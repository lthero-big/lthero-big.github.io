<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>【Algorithm-BackTracking】回溯法 | lthero</title><meta name="keywords" content="算法"><meta name="author" content="lthero"><meta name="copyright" content="lthero"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="批处理作业调度 来源：https:&#x2F;&#x2F;www.xin3721.com&#x2F;Articlenet&#x2F;3096.html  问题描述　　给定n个作业的集合J&#x3D;（J1，J2，… ，Jn）。每一个作业Ji都有两项任务分别在2台机器上完成。每个作业必须先有机器1处理，然后再由机器2处理。作业Ji需要机器j的处理时间为tji。对于一个确定的作业调度，设Fji是作业i在机器j上完成处理时间。则所有作业在机器">
<meta property="og:type" content="article">
<meta property="og:title" content="【Algorithm-BackTracking】回溯法">
<meta property="og:url" content="https://blog.lthero.cn/2022/06/11/Algorithm-BackTracking/index.html">
<meta property="og:site_name" content="lthero">
<meta property="og:description" content="批处理作业调度 来源：https:&#x2F;&#x2F;www.xin3721.com&#x2F;Articlenet&#x2F;3096.html  问题描述　　给定n个作业的集合J&#x3D;（J1，J2，… ，Jn）。每一个作业Ji都有两项任务分别在2台机器上完成。每个作业必须先有机器1处理，然后再由机器2处理。作业Ji需要机器j的处理时间为tji。对于一个确定的作业调度，设Fji是作业i在机器j上完成处理时间。则所有作业在机器">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.lthero.cn/webPic/background/3zexv9.jpg">
<meta property="article:published_time" content="2022-06-11T07:36:35.000Z">
<meta property="article:modified_time" content="2023-03-27T06:45:49.005Z">
<meta property="article:author" content="lthero">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.lthero.cn/webPic/background/3zexv9.jpg"><link rel="shortcut icon" href="https://cdn.lthero.cn/webPic/logo/lthero_logo.png"><link rel="canonical" href="https://blog.lthero.cn/2022/06/11/Algorithm-BackTracking/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="iNo3p5pDMQW3QRCjgVQ_A-4vbPCQipgCC1evSSmk8p8"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/5.13.0/css/all.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://ltherocn2.oss-cn-beijing.aliyuncs.com/cdn/css/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":90,"position":"top","messagePrev":"这篇文章距离他上一次更新已经过去了……我算算啊……好像是","messageNext":"天吧，不知道是否还有效啊!"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【Algorithm-BackTracking】回溯法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-27 14:45:49'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/mycss/lthero-css.css"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="lthero" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/webPic/logo/lthero_avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">129</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">60</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">51</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.lthero.cn/webPic/background/3zexv9.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">lthero</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【Algorithm-BackTracking】回溯法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-06-11T07:36:35.000Z" title="发表于 2022-06-11 15:36:35">2022-06-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-27T06:45:49.005Z" title="更新于 2023-03-27 14:45:49">2023-03-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/">回溯算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>29分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="【Algorithm-BackTracking】回溯法"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="批处理作业调度"><a href="#批处理作业调度" class="headerlink" title="批处理作业调度"></a>批处理作业调度</h1><blockquote>
<p>来源：<a target="_blank" rel="noopener" href="https://www.xin3721.com/Articlenet/3096.html">https://www.xin3721.com/Articlenet/3096.html</a></p>
</blockquote>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　给定n个作业的集合J&#x3D;（J1，J2，… ，Jn）。每一个作业Ji都有两项任务分别在2台机器上完成。每个作业必须先有机器1处理，然后再由机器2处理。作业Ji需要机器j的处理时间为tji。对于一个确定的作业调度，设Fji是作业i在机器j上完成处理时间。则所有作业在机器2上完成处理时间和f&#x3D;F2i，称为该作业调度的<strong>完成时间和</strong>。</p>
<h2 id="简单描述"><a href="#简单描述" class="headerlink" title="简单描述"></a>简单描述</h2><p>　　对于给定的n个作业，指定最佳作业调度方案，使其完成时间和达到<strong>最小</strong>。</p>
<h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><table>
<thead>
<tr>
<th>tji</th>
<th>机器1</th>
<th>机器2</th>
</tr>
</thead>
<tbody><tr>
<td>作业1</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>作业2</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>作业3</td>
<td>2</td>
<td>3</td>
</tr>
</tbody></table>
<p>　　</p>
<p>　　这3个作业的调度方案共有6种（即3个作业的全排列），分别是123,132,213,231,312,321，它们所相应的完成时间和分别是19,18,20,21,19,19。显而易见，最佳调度方案是132，其完成时间和为18。</p>
<h2 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h2><p>　　从n个作业中找出有<strong>最小完成时间和</strong>的作业调度，所以批处理作业调度问题的<strong>解空间是一棵排列树</strong>。按照回溯法搜索排列树的算法框架，设开始时x&#x3D;[1,2, … , n]是所给的n个作业，则相应的排列树由x[1:n]的所有排列构成。</p>
<p>　　类Flowshop的数据成员记录解空间的结点信息，以便减少传给Backtrack的参数。二维数组M是输入作业的处理时间，bestf记录当前最小完成时间和，bestx记录相应的当前最佳作业调度。</p>
<p>　　在递归函数Backtrack中，</p>
<p>　　　　当i&gt;n时，算法搜索至叶子结点，得到一个新的作业调度方案。此时算法适时更新当前最优值和相应的当前最佳调度。</p>
<p>　　　　当i&lt;n时，当前扩展结点位于排列树的第（i-1）层，此时算法选择下一个要安排的作业，以深度优先方式递归的对相应的子树进行搜索，对不满足上界约束的结点，则剪去相应的子树。</p>
<h2 id="算法描述："><a href="#算法描述：" class="headerlink" title="算法描述："></a>算法描述：</h2><p>注：1、区分作业i和当前第i个正在执行的作业</p>
<p>　　　　　　给x赋初值，即其中一种排列，如x&#x3D;[1,3,2]；M[x[j]][i]代表当前作业调度x排列中的第j个作业在第i台机器上的处理时间；如M[x[2]][1]就意味着作业3在机器1上的处理时间。</p>
<p>　　2、bestf的初值</p>
<p>　　　　　　此问题是得到最佳作业调度方案以便使其完成时间和达到最小，所以当前最优值bestf应该赋值为较大的一个值。如9999</p>
<p>　　3、f1、f2的定义与计算</p>
<p>　　　　　　假定当前作业调度排列为：x&#x3D;[1,2,3]；f1[i]即第i个作业在机器1上的处理时间，f2[j]即第j个作业在机器2上的处理时间；则：</p>
<p>　　　　　　<strong>f1[<strong>1</strong>]&#x3D;M[1][1] , f2[1]&#x3D;f1[1]+M[1][2]</strong></p>
<p>　　　　　　f1[2]&#x3D;f1[1]+M[2][1] , f2[2]&#x3D;MAX(f2[1],f1[2])+M[2][2]　&#x2F;&#x2F;f2[2]不光要等作业2自己在机器1上的处理时间，还要等作业1在机器2上的处理时间，选其大者。</p>
<p>　　　　　　f1[3]&#x3D;f1[2]+M[3][1] , f2[3]&#x3D;MAX(f2[2],f1[3])+M[3][2]</p>
<ul>
<li><strong>f1</strong>只有当前值有用，可以覆盖赋值，所以定义为int型变量即可，减少空间消耗；</li>
<li>f2需要记录<strong>每个作业的处理时间</strong>，所以定义为int *型，以便计算得完成时间和。</li>
</ul>
<p>　　4、f2[0]的初值</p>
<p>　　　　　　f2[i]的计算都是基于上一个作业f2[i-1]进行的，所以要记得给f2平[0]赋值为0。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Flowshop</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="title">Flow</span><span class="params">(<span class="type">int</span> * *,<span class="type">int</span>,<span class="type">int</span>[])</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Backtrack</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line">    <span class="type">int</span> * * M,　　　　　　<span class="comment">//各作业所需的处理时间，根据上面的例子就是4*3的矩阵————M[j][i]代表第j个作业在第i台机器上的处理时间</span></span><br><span class="line"></span><br><span class="line">        * x,　　　　　　　<span class="comment">//当前作业调度————其中一种排列顺序</span></span><br><span class="line">        * bestx,　　　　 <span class="comment">//当前最优作业调度</span></span><br><span class="line"></span><br><span class="line">        * f2,　　　　　　 <span class="comment">//机器2完成处理时间————记录每个作业在机器2上的完成时间</span></span><br><span class="line">        f1,　　　　　　　　<span class="comment">//机器1完成处理时间————定义int型，减少空间消耗（因为只有当前的f1有用，所以可以覆盖赋值）</span></span><br><span class="line">        f,　　　　　　　　<span class="comment">//完成时间和</span></span><br><span class="line"></span><br><span class="line">        bestf,　　　　　　<span class="comment">//当前最优值</span></span><br><span class="line"></span><br><span class="line">        n;　　　　　　　　<span class="comment">//作业树</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Flowshop::Backtrack</span><span class="params">(<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            bestx[j] = x[j];</span><br><span class="line">        <span class="keyword">if</span>(bestf&gt;f)</span><br><span class="line">        	bestf = f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//排列树中j从i开始————控制分支数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=t;j&lt;=n;j++)　　</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//“假设”：在第1台机器上的完成处理时间————着重关注M矩阵的行标（代表当前执行的作业，是动态变化的）</span></span><br><span class="line">            f1+=M[x[j]][t];　　</span><br><span class="line">            <span class="comment">//“假设”：在机器2上的完成处理时间，f2[0]初值赋为0</span></span><br><span class="line">            <span class="comment">////f2[t]不光要等作业t自己在机器1上的处理时间，还要等作业t-1在机器2上的处理时间，选其大者。</span></span><br><span class="line">            f2[t]=((f2[t<span class="number">-1</span>]&gt;f1)?f2[t<span class="number">-1</span>]:f1)+M[x[j]][<span class="number">2</span>];　　</span><br><span class="line">            <span class="comment">//“假设”：总的完成时间和</span></span><br><span class="line">            f+=f2[t];　　</span><br><span class="line">            <span class="comment">//进入下一个任务</span></span><br><span class="line">            <span class="keyword">if</span>(f&lt;bestf)　　</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">Swap</span>(x[t],x[j]);</span><br><span class="line">                <span class="comment">//“递归”</span></span><br><span class="line">                <span class="built_in">Backtrack</span>(t+<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">Swap</span>(x[t],x[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//“回溯消除”：改变机器完成时间计数————递归返回时间</span></span><br><span class="line">            f1 -= M[x[j]][<span class="number">1</span>];　　</span><br><span class="line">            f -= f2[t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Flow</span><span class="params">(<span class="type">int</span> * * M,<span class="type">int</span> n,<span class="type">int</span> bestx[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ub = INT_AMX;</span><br><span class="line">    Flowshop X;</span><br><span class="line">    X.x = <span class="keyword">new</span> <span class="type">int</span> [n+<span class="number">1</span>];</span><br><span class="line">    X.f2 = <span class="keyword">new</span> <span class="type">int</span> [n+<span class="number">1</span>];</span><br><span class="line">    X.M = M;</span><br><span class="line">    X.n = n;</span><br><span class="line">    X.bestf = ub;</span><br><span class="line">    X.bestx = bestx;</span><br><span class="line">    X.f1 = <span class="number">0</span>;</span><br><span class="line">    X.f = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        X.f2[i] = <span class="number">0</span>;</span><br><span class="line">        X.x[i] i;</span><br><span class="line">    &#125;</span><br><span class="line">    X.<span class="built_in">Backtrack</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">delete</span> [] X x;</span><br><span class="line">    <span class="keyword">delete</span> [] X f2;</span><br><span class="line">    <span class="keyword">return</span> X.bestf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>​    </p>
<h1 id="工作分配问题"><a href="#工作分配问题" class="headerlink" title="工作分配问题"></a>工作分配问题</h1><blockquote>
<p>与批处理作业调度类似</p>
</blockquote>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>设有n件工作分配给n个人。将工作i分配给第j个人所需的费用为c(i,j) 。 设计一个算法，对于给定的工作费用，为每一个人都分配1件不同的工作，并使总费用达到最小。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h2><p>输入数据的第一行有1 个正整数n (1≤n≤20)。接下来的n行，每行n个数，表示给每个人的工作费用。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h2><p>将计算出的最小总费用输出到屏幕。</p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>3<br>10 2 3<br>2 3 4<br>3 4 5</p>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>最小费用</p>
<p>9</p>
<p>最优序列为【第1个任务给第二个人，第2个任务给第一个人；列表示任务，对应值表示人】</p>
<p>2 1 3</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 21</span></span><br><span class="line"><span class="type">int</span> cost[N][N];</span><br><span class="line"><span class="comment">//x是当前假定的工作安排序列</span></span><br><span class="line"><span class="type">int</span> x[N];</span><br><span class="line"><span class="comment">//cv是当前费用currentValue</span></span><br><span class="line"><span class="type">int</span> n,cv=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//bestv是最小费用(bestValue)</span></span><br><span class="line"><span class="type">int</span> bestv=INT_MAX;</span><br><span class="line"><span class="comment">//bestx是最好的工作安排序列</span></span><br><span class="line"><span class="type">int</span> bestx[<span class="number">100</span>];</span><br><span class="line"><span class="comment">//传入第t任务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t&gt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//只当当前费用cv确实小于bestv才变</span></span><br><span class="line">			<span class="keyword">if</span>(cv&lt;bestv)&#123;</span><br><span class="line">				bestv=cv;</span><br><span class="line">                <span class="comment">//更新最好的工作安排序列</span></span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">					bestx[i]=x[i];</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//对每个人遍历，指定任务为t</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=t;i&lt;=n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//【先判断再假设】类型</span></span><br><span class="line">                <span class="comment">//当前【任务t】分配到【序列x】的【第i个人】，并花费更小时【和装载问题当前cw+w[i]&lt;cap时很像】</span></span><br><span class="line">                <span class="keyword">if</span>(cv + cost[t][x[i]]&lt; bestv)&#123;</span><br><span class="line">                    <span class="comment">//“假设”</span></span><br><span class="line">                    cv+=cost[t][x[i]];</span><br><span class="line">                    <span class="comment">//交换【序列x】的次序，以产生不同序列</span></span><br><span class="line">                    <span class="built_in">swap</span>(x[t],x[i]);</span><br><span class="line">                    <span class="built_in">backtrack</span>(t+<span class="number">1</span>);</span><br><span class="line">                    <span class="comment">//“回溯时还原”</span></span><br><span class="line">                    <span class="built_in">swap</span>(x[t],x[i]);</span><br><span class="line">                    <span class="comment">//“回溯时还原”</span></span><br><span class="line">                    cv-= cost[t][x[i]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">while</span>(cin&gt;&gt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//第i项目给第j个人的花费</span></span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">					<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">							cin&gt;&gt;cost[i][j];</span><br><span class="line">            <span class="comment">//默认按第1个人被分配第1个工作</span></span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">					x[i]=i;</span><br><span class="line">			<span class="built_in">backtrack</span>(<span class="number">1</span>);</span><br><span class="line">			cout&lt;&lt;bestv&lt;&lt;endl;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">				cout&lt;&lt;bestx[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">			cout&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>​    </p>
<hr>
<h1 id="三角符号问题"><a href="#三角符号问题" class="headerlink" title="三角符号问题"></a>三角符号问题</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>给定第一行的符号（只有+，-）数目n，每行比上一行数目少一（形成一个倒三角），2个相同符号下面为“+”号，2个不同符号下面为“-”号，要求有多少种情况使得两种符号数目相同。<br>第一行为7的符号三角形之一：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20200508164042189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Rvcm9f,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我们发现<br><strong>由于只有两种符号，所以我们可简化为0、1形式</strong>，+号用1表示，-号用0表示<br>①总符号数为n(n+1)&#x2F;2,如果总数为奇数，那么一定不可能符号数相等<br>②当某一符号数大于总数的一半时，那么此情况不存在解</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> half;</span><br><span class="line"><span class="type">int</span> p[N][N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    输入：t，表示t个符号形成的三角规模</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> t)</span>&#123;</span><br><span class="line">	<span class="type">int</span> j,i;</span><br><span class="line">	<span class="keyword">if</span>(cnt&gt;half||t*(t+<span class="number">1</span>)/<span class="number">2</span>-cnt&gt;half) <span class="comment">//某种符号数量大于一半时退出，减枝</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(t&gt;=n)&#123;<span class="comment">//t大于n时，说明已经找到了一个(t-1)规模的+与-相同的子三角型</span></span><br><span class="line">		sum++;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125; </span><br><span class="line">    <span class="comment">//选择-/+两个符号【和下面的着色问题中m个颜色类似】</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//“假设”：只需改变第一行，下面行的符号是确定的。t会不断增加，p[0][1],p[0][2],p[0][3]…………</span></span><br><span class="line">		p[<span class="number">0</span>][t]=i; </span><br><span class="line">        <span class="comment">//“假设”：cnt可以看做：记录所有行的+号个数，+号用1表示，-号用0表示</span></span><br><span class="line">		cnt+=p[<span class="number">0</span>][t]; </span><br><span class="line">        <span class="comment">//“假设”：从第二行开始，向下形成三角型</span></span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=t;j++)&#123;</span><br><span class="line">            <span class="comment">//j行的第(t-j)符号是  第(j-1)层的(t-j)与第(j-1)层的(t-j+1)符号 【异或】结果</span></span><br><span class="line">            <span class="comment">//t-j说明是从这行的末尾【最后一列】开始向前</span></span><br><span class="line">			p[j][t-j]=p[j<span class="number">-1</span>][t-j]^p[j<span class="number">-1</span>][t-j+<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//cnt记录j行的第(t-j)符号</span></span><br><span class="line">			cnt+=p[j][t-j];</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//“递归”“搜索t+1树</span></span><br><span class="line">		backtrack(t+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//“回溯时清除”：上次的赋值</span></span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=t;j++)&#123;</span><br><span class="line">			cnt-=p[j][t-j];</span><br><span class="line">		&#125;</span><br><span class="line">		cnt-=p[<span class="number">0</span>][t];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//输入第一行个数</span></span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="type">int</span> total=n*(n+<span class="number">1</span>)/<span class="number">2</span>;<span class="comment">//总的符号数 </span></span><br><span class="line">	<span class="keyword">if</span>(total%<span class="number">2</span>==<span class="number">1</span>) </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    half=total/<span class="number">2</span>;<span class="comment">//除以2才是真正的一半； </span></span><br><span class="line">    backtrack(<span class="number">0</span>); </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>比如：t&#x3D;3时，<code>让p[0][3]=0;</code> </p>
<p>假如第一行为0 0 1 0</p>
<p>则j从1（第二行开始），并从t-j&#x3D;2，第三列开始开始</p>
<table>
<thead>
<tr>
<th>第一行</th>
<th>0</th>
<th>0</th>
<th>1</th>
<th><code>0</code> p[0][3]</th>
</tr>
</thead>
<tbody><tr>
<td>第二行</td>
<td></td>
<td></td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>第二行</td>
<td></td>
<td>1</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>第二行</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td></td>
</tr>
</tbody></table>
<p>j再变成2，并从t-j&#x3D;1，第二列开始……剩下的类似</p>
<p>最终产生</p>
<table>
<thead>
<tr>
<th>第1行</th>
<th>0</th>
<th>0 p[0][1]</th>
<th>1 p[0][2]</th>
<th><code>0</code> p[0][3]</th>
</tr>
</thead>
<tbody><tr>
<td>第2行</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>第3行</td>
<td>1</td>
<td>0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>第4行</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>此时，已经完成了t&#x3D;3的(实际上是4个,t从0开始)规模的三角型，再进入backtrack(t+1);</p>
<p>进入backtrack(t+1)后，如果n&#x3D;4，现在t&#x3D;4，已经完成了目标，sum+1并return</p>
<p>返回上个递归，并进行清除之前的赋值，并重新让<code>p[0][3]=1;</code> </p>
<table>
<thead>
<tr>
<th>第1行</th>
<th>0</th>
<th>0 p[0][1]</th>
<th>1 p[0][2]</th>
<th><code>1</code> p[0][3]</th>
</tr>
</thead>
<tbody><tr>
<td>第2行</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>第3行</td>
<td>1</td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>第4行</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>此时，已经完成了t&#x3D;3的规模的三角型，再进入backtrack(t+1);</p>
<p>同上面一样，如果n&#x3D;4，t&#x3D;4，也完成了目标，sum+1并return</p>
<p>​    </p>
<p>返回上个递归，并进行清除之前的赋值，发现p[0][3]已经选择过0和1，<code>for(i=0;i&lt;2;i++)</code>已经执行完成，则<code>整个backtrack(3)执行完成</code>。</p>
<p>则返回到backtrack(2)调用backtrack(3)的后面，清除之前的赋值，发现p[0][2]也已经选择过0和1，<code>for(i=0;i&lt;2;i++)</code>已经执行完成，则<code>整个backtrack(2)执行完成</code>。</p>
<p>则返回到backtrack(1)调用backtrack(2)的后面，清除之前的赋值，并让<code>p[0][1]=1 ;</code> 再调用backtrack(2)并继续运算</p>
<p>​    </p>
<p>​    </p>
<hr>
<h1 id="n皇后问题"><a href="#n皇后问题" class="headerlink" title="n皇后问题"></a>n皇后问题</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>N皇后的排列，每行一个不冲突；N&lt;&#x3D;13。</p>
<h2 id="输入要求"><a href="#输入要求" class="headerlink" title="输入要求"></a>输入要求</h2><p>一个数字N (6 &lt;&#x3D; N &lt;&#x3D; 13) 表示棋盘是N x N大小的。</p>
<h2 id="输出要求"><a href="#输出要求" class="headerlink" title="输出要求"></a>输出要求</h2><p>前三行为前三个解，每个解的两个数字之间用一个空格隔开。第四行只有一个数字，表示解的总数。</p>
<p>解的输出顺序为从上到下从左到右，小的优先输出</p>
<h2 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h2><p>6</p>
<h2 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h2><p>2 4 6 1 3 5</p>
<p>3 6 2 5 1 4</p>
<p>4 1 5 2 6 3</p>
<p>4</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>整体思路：从第一列开始逐行遍历，如果i行j列可以放，则queue[i][j]位置设置为1，并开始遍历下一(i+1)行。如果不可以放，则设置queue[i][j]为0，并对(j+1）列开始逐行遍历。直到遍历到第八行时，将结果输出。输出的思路是，如果queue[i][j]为1则说明此位置有皇后，输出对应的j列号。</p>
<p>判断queue[i][j]是否可以放皇后的思路：</p>
<p>如果0~i-1行j列有皇后则不能放；</p>
<p>如果queue[i][j]的左上角有皇后则不可以放；</p>
<p>如果queue[i][j]的右上角有皇后则不可以放；</p>
<p>其它情况则可以放。</p>
<p>isSafe</p>
<p>We must check <strong>upper left diagonal</strong> , <strong>upper right diagonal</strong> and <strong>the same col</strong> .Because we <strong>place queens row by row</strong>, we can’t check lower left diagonal because all rows below “the current placing row” are empty and don’t have any queens yet.</p>
<p>On the other hand, checking the upper left and upper right diagonals is important because there may be queens in those diagonals that can attack the new position. That’s why you should check the same column, upper left diagonal and upper right diagonal when determining if it’s safe to place a new queen on the chessboard.</p>
<p>solveNQUtil</p>
<p>(solve N Queens Utility)<br>If not all queens have been placed yet, then the function enters a loop that iterates over <strong>all columns</strong> in <strong>the current(the given row) row</strong>.<br>For each column, it checks if it’s safe to place a new queen there using isSafe function. If it’s safe, then it places a queen in that position (board[row][i] &#x3D; 1)and calls itself recursively for <strong>the next row</strong> (solveNQUtil(board,row+1)).After returning from the recursive call,it removes the queen from that position (board[row][i] &#x3D; 0) and continues with the next column.</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">TIPS:</span></span><br><span class="line"><span class="comment">We must check upper left diagonal , upper right diagonal and the same col</span></span><br><span class="line"><span class="comment">Because we place queens row by row, we can&#x27;t check lower left diagonal because </span></span><br><span class="line"><span class="comment">all rows below &quot;the current placing row&quot; are empty and don&#x27;t have any queens yet.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">On the other hand, checking the upper left and upper right diagonals is important </span></span><br><span class="line"><span class="comment">because there may be queens in those diagonals that can attack the new position. </span></span><br><span class="line"><span class="comment">That’s why you should check the same column, upper left diagonal and upper right diagonal </span></span><br><span class="line"><span class="comment">when determining if it’s safe to place a new queen on the chessboard.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isSafe</span><span class="params">(<span class="type">int</span> board[N][N],<span class="type">int</span> row,<span class="type">int</span> col)</span></span>&#123;</span><br><span class="line">    <span class="comment">//Chech if there is a queen in the same col</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(board[i][col]==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Chech if there is a queen in the upper left diagonal</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=row,j=col;i&gt;=<span class="number">0</span> &amp;&amp; j&gt;=<span class="number">0</span>;i--,j--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(board[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Check if there is a queen in the upper right diagonal</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=row,j=col;i&gt;=<span class="number">0</span>&amp;&amp; j&lt;N;i--,j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(board[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printBoard</span><span class="params">(<span class="type">int</span> board[N][N])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">            cout&lt;&lt;board[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">solveNQUtil(solve N Queens Utility)</span></span><br><span class="line"><span class="comment">If not all queens have been placed yet, </span></span><br><span class="line"><span class="comment">then the function enters a loop that iterates over all columns in the current row. </span></span><br><span class="line"><span class="comment">For each column, it checks if it’s safe to place a new queen there using isSafe function. </span></span><br><span class="line"><span class="comment">If it’s safe, then it places a queen in that position (board[row][i] = 1)</span></span><br><span class="line"><span class="comment">and calls itself recursively for the next row (solveNQUtil(board,row+1)).</span></span><br><span class="line"><span class="comment">After returning from the recursive call,</span></span><br><span class="line"><span class="comment">it removes the queen from that position (board[row][i] = 0) </span></span><br><span class="line"><span class="comment">and continues with the next column.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solveNQUtil</span><span class="params">(<span class="type">int</span> board[N][N], <span class="type">int</span> row)</span></span>&#123;</span><br><span class="line">    <span class="comment">//If all queens have been placed successfully, then prin the solution</span></span><br><span class="line">    <span class="keyword">if</span>(row==N)&#123;</span><br><span class="line">        <span class="built_in">printBoard</span>(board);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//This loop try to place a queen in each colum of the given row</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isSafe</span>(board,row,i))&#123;</span><br><span class="line">            board[row][i]=<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">solveNQUtil</span>(board,row+<span class="number">1</span>);</span><br><span class="line">            board[row][i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//place queens row by row</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solveNQ</span><span class="params">(<span class="type">int</span> board[N][N])</span></span>&#123;</span><br><span class="line">    <span class="built_in">solveNQUtil</span>(board,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> board[N][N]=&#123;&#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">solveNQ</span>(board);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    </p>
<p>​    </p>
<hr>
<h1 id="最大团问题"><a href="#最大团问题" class="headerlink" title="最大团问题"></a>最大团问题</h1><blockquote>
<p>和装载问题相似</p>
</blockquote>
<p>了解最大团问题（Maximum Clique Problem, MCP）之前需要明白几个概念。复习一下图论知识……</p>
<p><strong>完全图</strong>：如果无向图中的任何一对顶点之间都有一条边，这种无向图称为完全图。</p>
<p><strong>完全子图</strong>：给定无向图G&#x3D;(V,E)。如果U⊆V，且对任意u，v⊆U 有(u，v) ⊆ E，则称U 是G 的完全子图。</p>
<p><strong>团（最大完全子图）</strong>: U是G的团当且仅当U不包含在G 的更大的完全子图中</p>
<p><strong>最大团：</strong>G 的最大团是指G中所含顶点数最多的团。</p>
<p><strong>空子图：</strong>给定无向图G&#x3D;(V,E)。如果U⊆V，且对任意u，v⊆U 有(u，v) ∉ E，则称U 是G 的空子图。G的空子图U是G的独立集当且仅当U不包含在G的更大空子图中。</p>
<p><strong>独立集：</strong>对于给定无向图G&#x3D;(V,E)。如果顶点集合V<em>⊆V，若V</em>中任何两个顶点均不相邻，则称V*为G的点独立集，或简称独立集。</p>
<p><strong>最大独立集：</strong>G中所含顶点数最多的独立集。</p>
<p>例如：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic002.cnblogs.com/images/2012/414141/2012080811564561.png" alt="a"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic002.cnblogs.com/images/2012/414141/2012080811573184.png" alt="b"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic002.cnblogs.com/images/2012/414141/2012080811581275.png" alt="c"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic002.cnblogs.com/images/2012/414141/2012080811585080.png" alt="d"></p>
<p>图a是一个无向图，图b、c、d都是图a的团，且都是最大团。</p>
<p><strong>补图：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img2018.cnblogs.com/i-beta/1358881/201911/1358881-20191124191950200-922996941.png" alt="img"></p>
<p>图G的补图，通俗的来讲就是完全图Kn去除G的边集后得到的图Kn-G。在图论里面，一个图G的补图（complement）或者反面（inverse）是一个图有着跟G相同的点，而且这些点之间有边相连当且仅当在G里面他们没有边相连。</p>
<h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><p>5 7<br>1 2<br>1 4<br>1 5<br>2 5<br>2 3<br>3 5<br>4 5</p>
<h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><p>3<br>1 2 5</p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>首先<code>假设最大团为一个空团</code>，往其中加入一个顶点，然后依次考虑<code>未加入到团的每个顶点</code>，查看<code>该顶点加入团之后是否仍然构成一个团</code>？</p>
<ul>
<li>如果可以再构成团，考虑将该顶点<code>加入团</code>或者<code>舍弃</code>两种情况。</li>
<li>如果不能再构成团，<code>直接舍弃</code>，然后递归判断下一顶点。</li>
</ul>
<p>对于无连接或者直接舍弃两种情况，在递归前，可采用剪枝策略来避免无效搜索。</p>
<p>判断某个顶点加入团之后是否仍是一个团</p>
<ul>
<li>该顶点和团中所有的顶点是否<code>都有连接</code></li>
</ul>
<h2 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h2><p>程序中采用了一个比较简单的剪枝策略，即如果剩余<code>未考虑的顶点</code>数加上<code>团中顶点数</code>不大于<code>当前最优解的顶点数</code>，可停止继续深度搜索，</p>
<ul>
<li>因为<code>最优解需要尽可能的大</code>，<code>未考虑的顶点+目前团中顶点</code> 的总数 <code>不可能再超过</code> <strong>当前最优解的顶点数</strong>，无需再进入子树</li>
</ul>
<p>否则继续深度递归。</p>
<p>​    </p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxnum=<span class="number">101</span>;</span><br><span class="line"><span class="type">int</span> a[maxnum][maxnum];<span class="comment">//图的邻接矩阵</span></span><br><span class="line"><span class="type">int</span> x[maxnum]; <span class="comment">//当前解</span></span><br><span class="line"><span class="type">int</span> cn;<span class="comment">//当前团的顶点数</span></span><br><span class="line"><span class="type">int</span> bestn;<span class="comment">//当前的最优解</span></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//图G的顶点数</span></span><br><span class="line"><span class="type">int</span> e;<span class="comment">//图G的边数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isCapatable</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="comment">//当前要加入的结点为i</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;i; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//x[j]==1表示，节点j在团内,a[j][i]==0表示节点i与某个点i无连接</span></span><br><span class="line">        <span class="keyword">if</span>(x[j]&amp;&amp;a[j][i]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//表示i与当前团的所有点都有连接，i可以入团</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传入的i是节点个数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="comment">//到叶子节点</span></span><br><span class="line">    <span class="keyword">if</span>(i&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        bestn=cn;</span><br><span class="line">        cout&lt;&lt;bestn&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x[j])</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;j&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左子树</span></span><br><span class="line">    <span class="comment">//先判断节点i是否可以入团</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isCapatable</span>(i))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//“假设”：将节点i加入到团内</span></span><br><span class="line">        x[i]=<span class="number">1</span>;</span><br><span class="line">        cn++;</span><br><span class="line">        <span class="comment">//“递归”：</span></span><br><span class="line">        <span class="built_in">backtrack</span>(i+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//“回溯时清除”：回收假设</span></span><br><span class="line">        cn--;    </span><br><span class="line">        x[i]=<span class="number">0</span>;<span class="comment">//可以不写，因为进入右子树时还会写</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//右子树</span></span><br><span class="line">    <span class="comment">//右子树，对应“不入团”，本来无需判断，可以直接调用BackTrack(i + 1);</span></span><br><span class="line">    <span class="comment">//但这里做剪枝操作，当bestn&gt;=cn+n-i时，丢弃右子树。因为右子树的产生最大团的数量，不可能超过bestn了</span></span><br><span class="line">    <span class="comment">//cn是当前团数量，n-i是剩下的节点；只有当cn+n-i大于bestn时，说明还有足够多的候选顶点，才有希望找到更大的团</span></span><br><span class="line">    <span class="comment">//这里如果设置r=n-i，那么和下面的装载问题一样</span></span><br><span class="line">    <span class="keyword">if</span>(cn+n-i&gt;bestn)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//X[i]不入团，不用</span></span><br><span class="line">        <span class="comment">//x[i]=0;</span></span><br><span class="line">        <span class="built_in">backtrack</span>(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,u,v;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">memset</span>(x,<span class="number">0</span>,<span class="built_in">sizeof</span>(x));</span><br><span class="line">    <span class="comment">//n个点，e个边</span></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;e;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;e; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        a[u][v]=a[v][u]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cn=bestn=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">backtrack</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>​    </p>
<p>​    </p>
<hr>
<h1 id="图的m着色问题"><a href="#图的m着色问题" class="headerlink" title="图的m着色问题"></a>图的m着色问题</h1><blockquote>
<p>着色问题与<strong>最大团</strong>、<strong>n皇后</strong>问题的<code>判断-假设部分</code>相似</p>
</blockquote>
<h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>给定图G&#x3D;(V, E)，需要为图G的各顶点着色，是否有一种着色法使G中相邻的两个顶点有不同的颜色?</p>
<h2 id="输入要求-1"><a href="#输入要求-1" class="headerlink" title="输入要求"></a>输入要求</h2><p>第一行是顶点的个数n（2≤n≤8），颜色数m（1≤m≤n）。</p>
<p>接下来是顶点之间的连接关系：a b；表示a和b相邻。顶点从1开始计。</p>
<p>当a，b同时为0时表示输入结束。</p>
<h2 id="输出要求-1"><a href="#输出要求-1" class="headerlink" title="输出要求"></a>输出要求</h2><p>输出着色方案总数和最少颜色数。如果无可行方案，颜色数为0。</p>
<h2 id="输入：-1"><a href="#输入：-1" class="headerlink" title="输入："></a>输入：</h2><p>5 8 4<br>1 2<br>1 3<br>1 4<br>2 3<br>2 4<br>2 5<br>3 4<br>4 5</p>
<h2 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h2><p>48 4</p>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>colorOf[n] 存储 n个顶点的着色方案，可以选择的颜色为1 到 m</p>
<p>x&#x3D;1 对当前第x个顶点开始着色：</p>
<p>若x&gt;n 则已求得一个解，输出着色方案即可</p>
<p>否则，依次对顶点x着色1到m，假设给点x着色为i</p>
<ul>
<li>若点x与其它相邻点无颜色冲突，则继续为<code>下一顶点</code>着色；</li>
<li>若点x与其它相邻点有相同颜色，则返回假，<code>尝试下一颜色</code>。</li>
</ul>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n=<span class="number">0</span>,k=<span class="number">0</span>,m=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> ConnectOf[<span class="number">100</span>][<span class="number">100</span>],ColorOf[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isUsable</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; </span><br><span class="line">    <span class="comment">//点x与其它点i相连，并且使用相同颜色，则返回假</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>((ConnectOf[x][i]==<span class="number">1</span>)&amp;&amp;(ColorOf[i]==ColorOf[x]))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//返回假</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//否则真</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isUsable</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> j)</span> </span>&#123; </span><br><span class="line">    <span class="comment">//点x与其它点i相连，并且使用相同颜色，则返回假</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>((ConnectOf[x][i]==<span class="number">1</span>)&amp;&amp;(ColorOf[i]==j))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//返回假</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//否则真</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="comment">//他的情况不是能涂哪个节点，因为我们就是从第一个开始涂色的，而是有m个颜色可涂；</span></span><br><span class="line">    <span class="keyword">if</span>(x&gt;n)&#123;</span><br><span class="line">        sum++;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//每一个点有1~m种颜色可以涂【像前面三角符号问题，每个符号有+/-两种可选】</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123; </span><br><span class="line">            <span class="comment">//两种写法，对应的isUsable不同</span></span><br><span class="line">            <span class="comment">//先判断后假设，先判断第x个能否涂第i种颜色</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isUsable</span>(x,i)) &#123; </span><br><span class="line">                <span class="comment">//再假设将x这个点涂成i色</span></span><br><span class="line">                ColorOf[x]=i;</span><br><span class="line">                <span class="comment">//如果可以涂色，则继续搜索</span></span><br><span class="line">                <span class="built_in">search</span>(x+<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//回收假设，并尝试下一种颜色</span></span><br><span class="line">                ColorOf[x]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            //先假设再判断，先假设第x个涂第i种颜色</span></span><br><span class="line"><span class="comment">            ColorOf[x]=i;</span></span><br><span class="line"><span class="comment">            //再判断第x个能否涂第i种颜色，所以isUsable无需传入要涂的颜色i</span></span><br><span class="line"><span class="comment">            if(isUsable(x)) &#123; </span></span><br><span class="line"><span class="comment">                //如果可以涂色，则继续搜索</span></span><br><span class="line"><span class="comment">                search(x+1);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            //回收假设，并尝试下一种颜色</span></span><br><span class="line"><span class="comment">            ColorOf[x]=0;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(ConnectOf,<span class="number">100</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(ColorOf,<span class="number">100</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=k; i++) &#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="comment">//点x与点y相连</span></span><br><span class="line">        ConnectOf[x][y]=ConnectOf[y][x]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">search</span>(<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>​    </p>
<p>​    </p>
<hr>
<h1 id="装载问题"><a href="#装载问题" class="headerlink" title="装载问题"></a>装载问题</h1><h2 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h2><p>有n个集装箱要装上2艘载重量分别为c1和c2的轮船，其中集装箱i的重量为wi，且∑wi &lt;&#x3D; c1 + c2。</p>
<p>问是否有一个合理的装载方案,可将这n个集装箱装上这2艘轮船。如果有，找出一种装载方案。</p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>如果一个给定装载问题有解，则采用下面的策略可得到最优装载方案。<br>(1)首先将<code>第一艘轮船尽可能装满</code>；<br>(2)将剩余的集装箱装上第二艘轮船。</p>
<p>将第一艘轮船尽可能装满等价于选取全体集装箱的一个子集，使该子集中集装箱重量之和最接近c1。由此可知，装载问题等价于以下特殊的0-1背包问题:</p>
<p> max∑ wi * xi &amp;&amp; ∑ wi * xi &lt;&#x3D; c1, xi ∈ {0, 1}, 1 &lt;&#x3D; i &lt;&#x3D; n;</p>
<h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>用<strong>子集树</strong>表示解空间,则解为n元向量{x1, … ,xn }, xi∈{0, 1} 。</p>
<h2 id="约束条件"><a href="#约束条件" class="headerlink" title="约束条件"></a>约束条件</h2><p>当前搜索的层i &lt;&#x3D; n时，</p>
<p>当前扩展结点Z为子集树的内部结点，仅当满足cw+w[i] &lt;&#x3D; c时进入左子树，x[i]&#x3D;1;</p>
<p>当cw+w[i] &gt; c ，即<code>装不下</code>，在以结点Z为根的子树中所有结点都不满足约束条件，因而该子树中解都是不可行解，因而将在该子树删去。  </p>
<h2 id="剪枝-1"><a href="#剪枝-1" class="headerlink" title="剪枝"></a>剪枝</h2><p>由于是最优化问题, 可利用最优解性质进一步剪去不含最优解的子树:</p>
<p>设Z是解空间树第i层上的当前扩展结点。</p>
<p>设     bestw: 当前最优载重量,<br>       cw   : 当前扩展结点Z的载重量 ;<br>       r    : 剩余集装箱的重量;</p>
<p>在以Z为根的子树中任意叶结点所相应的载重量不超过cw + r。因此，当cw + r (限界函数) ≤ bestw时，可将Z的右子树剪去</p>
<ul>
<li>因为目标<code>bestw要尽可能的大</code>，如果发现cw+r，也就是这个<code>子树的最大重量</code>，已经<code>不可能再超过bestw</code>，就无需进入子树</li>
</ul>
<p>即：只有当 cw + r &gt; bestw 时，才搜索右子树，x[i]&#x3D;0;</p>
<h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n; <span class="comment">//集装箱数</span></span><br><span class="line"><span class="type">int</span> cw; <span class="comment">// 当前载重量, current weight</span></span><br><span class="line"><span class="type">int</span> bestw; <span class="comment">//最优载重重量</span></span><br><span class="line"><span class="type">int</span> r;  <span class="comment">//剩余集装箱重量</span></span><br><span class="line"><span class="type">int</span> c1; <span class="comment">//第一艘轮船的载重量</span></span><br><span class="line"><span class="type">int</span> c2; <span class="comment">//第二艘轮船的载重量</span></span><br><span class="line"><span class="type">int</span> x[<span class="number">100</span>]; <span class="comment">//当前解</span></span><br><span class="line"><span class="type">int</span> bestx[<span class="number">100</span>]; <span class="comment">//当前最优解</span></span><br><span class="line"><span class="type">int</span> w[<span class="number">100</span>]; <span class="comment">//集装箱重量数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OutPut</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> restweight = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span>(bestx[i] == <span class="number">0</span>)</span><br><span class="line">           restweight += w[i];</span><br><span class="line">    <span class="keyword">if</span>(restweight &gt; c2)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;不能装入\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;船1装入的货物为:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(bestx[i] == <span class="number">1</span>)</span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n船2装入的货物为:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(bestx[i] != <span class="number">1</span>)</span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, i);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传输的i，是集装箱个数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BackTrack</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cw &gt; bestw)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">                bestx[i] = x[i];</span><br><span class="line">            bestw = cw;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//“假设”：剩余重量减少</span></span><br><span class="line">    r -= w[i];</span><br><span class="line">    <span class="comment">//【和最大团问题很像，最大团“装”的条件是这个点与团内点都有连接】</span></span><br><span class="line">    <span class="comment">//【最大团问题中，w[i]为1】</span></span><br><span class="line">    <span class="comment">//左子树，对应“装”，但要先判断能否装得下【先判断，再假设的类型】</span></span><br><span class="line">    <span class="keyword">if</span>(cw + w[i] &lt;= c1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//“假设”：装</span></span><br><span class="line">        x[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//“假设”：装入的重量增加</span></span><br><span class="line">        cw += w[i];</span><br><span class="line">        <span class="comment">//讨论下个箱子</span></span><br><span class="line">        <span class="built_in">BackTrack</span>(i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//“回溯消除”：</span></span><br><span class="line">        cw -= w[i];</span><br><span class="line">        <span class="comment">//“回溯消除”：</span></span><br><span class="line">        x[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//右子树，对应“不装”本来无需判断，可以直接调用BackTrack(i + 1);</span></span><br><span class="line">    <span class="comment">//但这里加入了“剪枝”操作，当bestw&gt;=cw+r时，将右子树剪去，右子树无法超过bestw</span></span><br><span class="line">    <span class="comment">//只有cw+r&gt;bestw时才装入，r是剩下的总量【和最大团问题几乎一样】</span></span><br><span class="line">    <span class="keyword">if</span>(cw + r &gt; bestw) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//x[i] = 0;</span></span><br><span class="line">        <span class="built_in">BackTrack</span>(i + <span class="number">1</span>);</span><br><span class="line">    &#125;<span class="comment">//否则不进入子树</span></span><br><span class="line">    <span class="comment">//“回溯消除”</span></span><br><span class="line">    r += w[i];</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bestw = <span class="number">0</span>;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    cw = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        r += w[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InPut</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;c1, &amp;c2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">InPut</span>();</span><br><span class="line">    <span class="built_in">Initialize</span>();</span><br><span class="line">    <span class="built_in">BackTrack</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">OutPut</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="测试样例"><a href="#测试样例" class="headerlink" title="测试样例"></a>测试样例</h2><p>输入：</p>
<p>3</p>
<p>50 50</p>
<p>10 40 40</p>
<p>输出</p>
<p>船1装入的货物为: 1 2</p>
<p>船2装入的货物为: 3</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://blog.lthero.cn">lthero</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.lthero.cn/2022/06/11/Algorithm-BackTracking/">https://blog.lthero.cn/2022/06/11/Algorithm-BackTracking/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.lthero.cn" target="_blank">lthero</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/06/11/Movie-Meet-Joe-Black/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/webPic/background/wallhaven-3z8qjd.png" onerror="onerror=null;src='https://cdn.lthero.cn/webPic/background/wallhaven-rdekew.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【电影】-Meet Joe Black</div></div></a></div><div class="next-post pull-right"><a href="/2022/06/10/Algorithm-Gready/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/webPic/background/wallhaven-28wqwg.jpg" onerror="onerror=null;src='https://cdn.lthero.cn/webPic/background/wallhaven-rdekew.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【Algorithm-Gready】贪心算法</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/06/10/Algorithm-Gready/" title="【Algorithm-Gready】贪心算法"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/webPic/background/wallhaven-28wqwg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-10</div><div class="title">【Algorithm-Gready】贪心算法</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/webPic/logo/lthero_avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">lthero</div><div class="author-info__description">喜欢折腾|喜欢尝试各种炫酷玩意儿|      Hacking the world</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">129</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">60</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">51</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lthero-big"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/lthero-big" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:ltherowlh@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">感谢github托管|hexo--butterfly主题提供支持</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%B9%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6"><span class="toc-number">1.</span> <span class="toc-text">批处理作业调度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.2.</span> <span class="toc-text">简单描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">1.3.</span> <span class="toc-text">举例说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.4.</span> <span class="toc-text">算法设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0%EF%BC%9A"><span class="toc-number">1.5.</span> <span class="toc-text">算法描述：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">1.6.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%88%86%E9%85%8D%E9%97%AE%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">工作分配问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-number">2.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">输入格式:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">输出格式:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5"><span class="toc-number">2.4.</span> <span class="toc-text">输入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%87%BA"><span class="toc-number">2.5.</span> <span class="toc-text">输出</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E8%A7%92%E7%AC%A6%E5%8F%B7%E9%97%AE%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">三角符号问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-number">3.2.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="toc-number">3.3.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B"><span class="toc-number">3.4.</span> <span class="toc-text">举例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text">n皇后问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-1"><span class="toc-number">4.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%A6%81%E6%B1%82"><span class="toc-number">4.2.</span> <span class="toc-text">输入要求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E8%A6%81%E6%B1%82"><span class="toc-number">4.3.</span> <span class="toc-text">输出要求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%EF%BC%9A"><span class="toc-number">4.4.</span> <span class="toc-text">输入：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B%EF%BC%9A"><span class="toc-number">4.5.</span> <span class="toc-text">输出样例：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-number">4.6.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-2"><span class="toc-number">4.7.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%9B%A2%E9%97%AE%E9%A2%98"><span class="toc-number">5.</span> <span class="toc-text">最大团问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5-1"><span class="toc-number">5.1.</span> <span class="toc-text">输入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%87%BA-1"><span class="toc-number">5.2.</span> <span class="toc-text">输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-1"><span class="toc-number">5.3.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%AA%E6%9E%9D"><span class="toc-number">5.4.</span> <span class="toc-text">剪枝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-3"><span class="toc-number">5.5.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84m%E7%9D%80%E8%89%B2%E9%97%AE%E9%A2%98"><span class="toc-number">6.</span> <span class="toc-text">图的m着色问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-2"><span class="toc-number">6.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%A6%81%E6%B1%82-1"><span class="toc-number">6.2.</span> <span class="toc-text">输入要求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E8%A6%81%E6%B1%82-1"><span class="toc-number">6.3.</span> <span class="toc-text">输出要求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%EF%BC%9A-1"><span class="toc-number">6.4.</span> <span class="toc-text">输入：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B%EF%BC%9A-1"><span class="toc-number">6.5.</span> <span class="toc-text">输出样例：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-2"><span class="toc-number">6.6.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-4"><span class="toc-number">6.7.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A3%85%E8%BD%BD%E9%97%AE%E9%A2%98"><span class="toc-number">7.</span> <span class="toc-text">装载问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-1"><span class="toc-number">7.1.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-number">7.2.</span> <span class="toc-text">问题分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF"><span class="toc-number">7.3.</span> <span class="toc-text">算法思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6"><span class="toc-number">7.4.</span> <span class="toc-text">约束条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%AA%E6%9E%9D-1"><span class="toc-number">7.5.</span> <span class="toc-text">剪枝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-5"><span class="toc-number">7.6.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%A0%B7%E4%BE%8B"><span class="toc-number">7.7.</span> <span class="toc-text">测试样例</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/04/24/BayesTheorem/" title="BayesTheorem"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/webPic/background/wallhaven-3z8qjd.png" onerror="this.onerror=null;this.src='https://cdn.lthero.cn/webPic/background/wallhaven-rdekew.jpg'" alt="BayesTheorem"/></a><div class="content"><a class="title" href="/2023/04/24/BayesTheorem/" title="BayesTheorem">BayesTheorem</a><time datetime="2023-04-24T14:49:00.000Z" title="发表于 2023-04-24 22:49:00">2023-04-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/08/UnlockNetcloudMusic/" title="网易云解锁灰色歌曲"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/webPic/background/wasx.jpg" onerror="this.onerror=null;this.src='https://cdn.lthero.cn/webPic/background/wallhaven-rdekew.jpg'" alt="网易云解锁灰色歌曲"/></a><div class="content"><a class="title" href="/2023/04/08/UnlockNetcloudMusic/" title="网易云解锁灰色歌曲">网易云解锁灰色歌曲</a><time datetime="2023-04-08T09:37:14.000Z" title="发表于 2023-04-08 17:37:14">2023-04-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/29/AlgorithmPractice/" title="AlgorithmPractice"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/webPic/background/wallhaven-285e6x.png" onerror="this.onerror=null;this.src='https://cdn.lthero.cn/webPic/background/wallhaven-rdekew.jpg'" alt="AlgorithmPractice"/></a><div class="content"><a class="title" href="/2023/03/29/AlgorithmPractice/" title="AlgorithmPractice">AlgorithmPractice</a><time datetime="2023-03-29T11:27:59.000Z" title="发表于 2023-03-29 19:27:59">2023-03-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/12/CreateChatbotWithOpenai/" title="基于openAI创建自己的chatbot"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/webPic/background/wallhaven-wy2ewp.png" onerror="this.onerror=null;this.src='https://cdn.lthero.cn/webPic/background/wallhaven-rdekew.jpg'" alt="基于openAI创建自己的chatbot"/></a><div class="content"><a class="title" href="/2023/03/12/CreateChatbotWithOpenai/" title="基于openAI创建自己的chatbot">基于openAI创建自己的chatbot</a><time datetime="2023-03-12T02:07:22.000Z" title="发表于 2023-03-12 10:07:22">2023-03-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/01/Englishpod/" title="EnglishPod"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/webPic/background/rd3pjw.jpg" onerror="this.onerror=null;this.src='https://cdn.lthero.cn/webPic/background/wallhaven-rdekew.jpg'" alt="EnglishPod"/></a><div class="content"><a class="title" href="/2023/02/01/Englishpod/" title="EnglishPod">EnglishPod</a><time datetime="2023-02-01T06:19:13.000Z" title="发表于 2023-02-01 14:19:13">2023-02-01</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By lthero</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="framework-info"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">浙ICP备2021022809号-1</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://ltherocn2.oss-cn-beijing.aliyuncs.com/cdn/js/fancybox.umd.js"></script><script src="https://ltherocn2.oss-cn-beijing.aliyuncs.com/cdn/js/instantpage.min.js" type="module"></script><script src="https://ltherocn2.oss-cn-beijing.aliyuncs.com/cdn/js/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadWaline () {
  function insertCSS () {
    const link = document.createElement("link")
    link.rel = "stylesheet"
    link.href = "https://ltherocn2.oss-cn-beijing.aliyuncs.com/cdn/css/waline.css"
    document.head.appendChild(link)
  }

  function initWaline () {
    const waline = Waline.init(Object.assign({
      el: '#waline-wrap',
      serverURL: 'vercel-psi-seven.vercel.app',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: false,
    }, null))
  }

  if (typeof Waline === 'function') initWaline()
  else {
    insertCSS()
    getScript('https://ltherocn2.oss-cn-beijing.aliyuncs.com/cdn/js/waline.js').then(initWaline)
  }
}

if ('Waline' === 'Waline' || !true) {
  if (true) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script></div><script src="https://ltherocn2.oss-cn-beijing.aliyuncs.com/cdn/js/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>