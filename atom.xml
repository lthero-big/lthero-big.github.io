<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lthero</title>
  
  <subtitle>个人博客</subtitle>
  <link href="https://blog.lthero.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.lthero.cn/"/>
  <updated>2025-07-28T03:44:21.967Z</updated>
  <id>https://blog.lthero.cn/</id>
  
  <author>
    <name>lthero</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCodeCampsDay34动态规划part02</title>
    <link href="https://blog.lthero.cn/2025/07/28/LeetCodeCampsDay34/"/>
    <id>https://blog.lthero.cn/2025/07/28/LeetCodeCampsDay34/</id>
    <published>2025-07-28T03:43:53.000Z</published>
    <updated>2025-07-28T03:44:21.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday34动态规划part02">LeetCodeCampsDay34动态规划part02</h1><blockquote></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday34动态规划part02&quot;&gt;LeetCodeCampsDay34动态规划part02&lt;/h1&gt;
&lt;blockquote&gt;&lt;/blockquote&gt;
</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay32动态规划paro01</title>
    <link href="https://blog.lthero.cn/2025/07/26/LeetCodeCampsDay32/"/>
    <id>https://blog.lthero.cn/2025/07/26/LeetCodeCampsDay32/</id>
    <published>2025-07-26T07:02:31.000Z</published>
    <updated>2025-07-26T07:25:05.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday32动态规划paro01">LeetCodeCampsDay32动态规划paro01</h1><blockquote><p>动态规划基础</p></blockquote><h1 id="动态规划基础">动态规划基础</h1><h3 id="什么是动态规划">什么是动态规划</h3><p>在<a href="https://programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">关于贪心算法，你该了解这些！ (opens new window)</a>中我举了一个背包问题的例子。</p><p>例如：有N件物品和一个最多能背重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p>动态规划中dp[j]是由dp[j-weight[i]]推导出来的，然后取max(dp[j], dp[j - weight[i]] + value[i])。</p><p>但如果是贪心呢，每次拿物品选一个最大的或者最小的就完事了，和上一个状态没有关系。</p><p>所以贪心解决不了动态规划的问题。</p><p><strong>其实大家也不用死扣动规和贪心的理论区别，后面做做题目自然就知道了</strong>。</p><p>而且很多讲解动态规划的文章都会讲最优子结构啊和重叠子问题啊这些，这些东西都是教科书的上定义，晦涩难懂而且不实用。</p><p>大家知道动规是由前一个状态推导出来的，而贪心是局部直接选最优的，对于刷题来说就够用了。</p><h3 id="动态规划的解题步骤">动态规划的解题步骤</h3><ol><li>确定dp数组以及下标的含义</li><li>研究递推公式</li><li>dp数组如何初始化</li><li>研究遍历顺序（开始下标，结束下标）</li><li>举例推导dp数组</li></ol><p>注意，递推公式决定了如何初始化dp数组</p><h3 id="动态规划debug">动态规划debug</h3><p>打印dp数组！</p><p>打印dp数组！</p><p>打印dp数组！</p><p>按递推公式检查dp数组初始化是否正确、以及dp的结果哪儿出错了，<strong>要和模拟推导一致！</strong></p><p>出错可能：<code>递归公式、初始化、遍历顺序</code></p><h1 id="509-斐波那契数">509. 斐波那契数</h1><p><a href="https://leetcode.cn/problems/fibonacci-number/">https://leetcode.cn/problems/fibonacci-number/</a></p><p><strong>斐波那契数</strong> （通常用 <code>F(n)</code> 表示）形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) = 0，F(1) = 1</span><br><span class="line">F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</span><br></pre></td></tr></table></figure><p>给定 <code>n</code> ，请计算 <code>F(n)</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：1</span><br><span class="line">解释：F(2) = F(1) + F(0) = 1 + 0 = 1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：2</span><br><span class="line">解释：F(3) = F(2) + F(1) = 1 + 1 = 2</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4</span><br><span class="line">输出：3</span><br><span class="line">解释：F(4) = F(3) + F(2) = 2 + 1 = 3</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 30</code></li></ul><h2 id="动态规划思路">动态规划思路</h2><p>题目比较基础，并且已经给出了递归公式<code>F(n) = F(n - 1) + F(n - 2)</code></p><p>那么按动态规划的步骤来</p><ol><li>确定dp数组以及下标含义：dp下标为输入i, dp数组的值为对应的斐波那契数数字</li><li>递推公式题目已经给了</li><li>dp数组初始化：dp[0]和dp[1]题目已经给了,其它值需要动态添加（默认全为0）</li><li>遍历顺序：从下标2开始，一直到下标n（注意是下标n）而不是n-1</li><li>推导举例：dp[0]=0, dp[1]=1, dp[2] = dp[0] + dp[1] = 1, dp[3] = dp[1] + dp[2] = 2; dp[4] = dp[2] + dp[3] = 3…</li></ol><h2 id="动态规划代码">动态规划代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(N)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp.append(dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><h1 id="70-爬楼梯">70. 爬楼梯</h1><p><a href="https://leetcode.cn/problems/climbing-stairs/">https://leetcode.cn/problems/climbing-stairs/</a></p><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：有两种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶</span><br><span class="line">2. 2 阶</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：有三种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶 + 1 阶</span><br><span class="line">2. 1 阶 + 2 阶</span><br><span class="line">3. 2 阶 + 1 阶</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 45</code></li></ul><h2 id="动态规划思路">动态规划思路</h2><ol><li>dp数组以及下标含义：下标是第i阶；dp数组值为到达第i阶有dp[i]种方法</li><li>递推公式，对于第i阶来说，只有从第i-2或第i-1台阶爬上来，所以到第i阶的方法数dp[i] = dp[i - 1] + dp[i - 2]</li><li>dp初始化：dp[0]=1, dp[1]=2</li><li>dp遍历顺序：从i=2开始遍历，遍历到n-1，最终返回n-1</li><li>举例推导</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="number">1</span>, res=<span class="number">1</span></span><br><span class="line">n=<span class="number">2</span>, res=<span class="number">2</span></span><br><span class="line">n=<span class="number">3</span>(<span class="number">1</span>+n=<span class="number">2</span>, <span class="number">2</span>+n=<span class="number">1</span>), res = <span class="number">3</span></span><br><span class="line">n=<span class="number">4</span>(<span class="number">1</span>+n=<span class="number">3</span>, <span class="number">2</span>+n=<span class="number">2</span>), res = <span class="number">3</span> + <span class="number">2</span> = <span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="动态规划代码">动态规划代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(N)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"></span><br><span class="line">        dp = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">        <span class="comment"># 和FB那题目不同点是结束位置在i=n-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">            dp.append(dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>])</span><br><span class="line">        <span class="comment"># 同样返回i=n-1</span></span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h1 id="746-使用最小花费爬楼梯">746. 使用最小花费爬楼梯</h1><p><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">https://leetcode.cn/problems/min-cost-climbing-stairs/</a></p><p>给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p><p>你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯。</p><p>请你计算并返回达到楼梯顶部的最低花费。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：cost = [10,15,20]</span><br><span class="line">输出：15</span><br><span class="line">解释：你将从下标为 1 的台阶开始。</span><br><span class="line">- 支付 15 ，向上爬两个台阶，到达楼梯顶部。</span><br><span class="line">总花费为 15 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：cost = [1,100,1,1,1,100,1,1,100,1]</span><br><span class="line">输出：6</span><br><span class="line">解释：你将从下标为 0 的台阶开始。</span><br><span class="line">- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。</span><br><span class="line">- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。</span><br><span class="line">- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。</span><br><span class="line">- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。</span><br><span class="line">- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。</span><br><span class="line">- 支付 1 ，向上爬一个台阶，到达楼梯顶部。</span><br><span class="line">总花费为 6 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= cost.length &lt;= 1000</code></li><li><code>0 &lt;= cost[i] &lt;= 999</code></li></ul><h2 id="动态规划思路">动态规划思路</h2><ol><li>确定dp数组以及下标含义：下标指第i层，dp[i]指<strong>爬到第i层的最低成本</strong>，注意<strong>cost[i]是指从第i层出发爬到其它层的成本</strong></li><li>递推公式：和爬楼梯很像，想到达第i层只能靠第i-1或第i-2层爬上来，并且需要挑<strong>第i-1或第i-2层</strong>中最低成本的爬上来：dp[i] = min(cost[i-1] + dp[i-1], cost[i - 2] + dp[i - 2]); 注意cost[i-1] + dp[i-1]才是到达第i层的成本（包含了从i-1到i的成本，以及从最底层爬到第i-1层的成本</li><li>dp初始化：前两层dp[0]和dp[1]为0</li><li>遍历顺序：从i=2开始遍历，结束位置为i=n(n为数组长度)，返回dp[n]</li><li>举例</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">index= [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">cost = [<span class="number">1</span>,<span class="number">100</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">100</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">100</span>,<span class="number">1</span>]</span><br><span class="line">dp   = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>,<span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><h2 id="动态规划代码">动态规划代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minCostClimbingStairs</span>(<span class="params">self, cost: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># dp里装着最小爬到i层的最低成本</span></span><br><span class="line">        <span class="comment"># dp初始化前两个台阶都为0</span></span><br><span class="line">        dp = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">        <span class="comment"># </span></span><br><span class="line">        L = <span class="built_in">len</span>(cost)</span><br><span class="line">        <span class="comment"># 注意题目要求是到顶楼，也就是到第L+1个（明显是超过cost长度的）</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, L + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 需要判断cost[i - 1]和cost[i - 2]哪个更低</span></span><br><span class="line">            dp.append(<span class="built_in">min</span>(cost[i - <span class="number">1</span>] + dp[i - <span class="number">1</span>], cost[i - <span class="number">2</span>] + dp[i - <span class="number">2</span>]))</span><br><span class="line">        <span class="keyword">return</span> dp[L] </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday32动态规划paro01&quot;&gt;LeetCodeCampsDay32动态规划paro01&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;动态规划基础&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;动态规划基础&quot;&gt;动态规划基础&lt;/h1&gt;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay31贪心part05</title>
    <link href="https://blog.lthero.cn/2025/07/25/LeetCodeCampsDay31/"/>
    <id>https://blog.lthero.cn/2025/07/25/LeetCodeCampsDay31/</id>
    <published>2025-07-25T01:30:21.000Z</published>
    <updated>2025-07-25T07:41:21.667Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday31贪心part05">LeetCodeCampsDay31贪心part05</h1><blockquote><p>本题目有个和二叉树结合的，值得注意</p></blockquote><h1 id="56-合并区间">56. 合并区间</h1><p><a href="https://leetcode.cn/problems/merge-intervals/">https://leetcode.cn/problems/merge-intervals/</a></p><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出：[[1,6],[8,10],[15,18]]</span><br><span class="line">解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,4],[4,5]]</span><br><span class="line">输出：[[1,5]]</span><br><span class="line">解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= intervals.length &lt;= 104</code></li><li><code>intervals[i].length == 2</code></li><li><code>0 &lt;= starti &lt;= endi &lt;= 104</code></li></ul><h2 id="贪心思路">贪心思路</h2><p>和之前几个区间问题比较像，如果区间有重合就将区间合并；如果没有重合，则将上一个区间添加到res里</p><p>注意，合并区间时，需要改变区间i的左端点为i-1的左端点；而将i&amp;i-1的右端点变成i&amp;i-1右端点的最大值</p><h2 id="贪心代码">贪心代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 有重合就合并，没有重合则把上一个区间添加进结果</span></span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        intervals.sort(key = <span class="keyword">lambda</span> x: (x[<span class="number">0</span>], x[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">        L = <span class="built_in">len</span>(intervals)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L):</span><br><span class="line">            <span class="keyword">if</span> intervals[i][<span class="number">0</span>] &lt;= intervals[i - <span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">                intervals[i][<span class="number">0</span>] = intervals[i - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">                intervals[i][<span class="number">1</span>] = intervals[i - <span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(intervals[i][<span class="number">1</span>], intervals[i - <span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(intervals[i - <span class="number">1</span>])</span><br><span class="line">        res.append(intervals[-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>或者先将第一个区间添加到res里，然后每次只要比较res[-1]的右端点与intervals[i]的左端点就好，并且也只要更新res[-1]的右端点为两个区间右端点最大值</p><h2 id="贪心代码二">贪心代码二</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 有重合就合并，没有重合则把上一个区间添加进结果</span></span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        intervals.sort(key = <span class="keyword">lambda</span> x: (x[<span class="number">0</span>], x[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">        L = <span class="built_in">len</span>(intervals)</span><br><span class="line">        res.append(intervals[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L):</span><br><span class="line">            <span class="keyword">if</span> res[-<span class="number">1</span>][<span class="number">1</span>] &gt;= intervals[i][<span class="number">0</span>]:</span><br><span class="line">                res[-<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(res[-<span class="number">1</span>][<span class="number">1</span>], intervals[i][<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(intervals[i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="738-单调递增的数字">738. 单调递增的数字</h1><p><a href="https://leetcode.cn/problems/monotone-increasing-digits/">https://leetcode.cn/problems/monotone-increasing-digits/</a></p><p>当且仅当每个相邻位数上的数字 <code>x</code> 和 <code>y</code> 满足 <code>x &lt;= y</code> 时，我们称这个整数是<strong>单调递增</strong>的。</p><p>给定一个整数 <code>n</code> ，返回 <em>小于或等于 <code>n</code> 的最大数字，且数字呈 <strong>单调递增</strong></em> 。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 10</span><br><span class="line">输出: 9</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 1234</span><br><span class="line">输出: 1234</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 332</span><br><span class="line">输出: 299</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>0 &lt;= n &lt;= 109</code></li></ul><h2 id="贪心思路">贪心思路</h2><p>本题目先将数字变成字符串，方便逐个比较；</p><p>以98为例； 若n[i - 1] &gt; n[i] ，首先，令n[i - 1]设置为n[i - 1] - 1；并且将n[i]设置为9，会得到89</p><p>那么是从前向后遍历还是从后向前遍历？</p><p>如果是从前向后遍历，遇到strNum[i - 1] &gt; strNum[i]的情况，让strNum[i - 1]减一，但此时如果strNum[i - 1]减一了，可能又小于strNum[i - 2]。</p><p>比如332，如果从前向后遍历，先得到329，此时2又小于3不满足情况；如果从后向前遍历，先得到329，再得到299；就对了</p><p>注意，在实现的时候，还需要设置个for循环，将9后面的所有数字都设置为9</p><p>比如100，会输出090，而不是99，因为最后一个0和倒数第二个0时不会进入if，而第二个0和1会输出090；所以需要记录第一个9出现的位置，再将其后面所有数字都设置为9</p><h2 id="贪心代码">贪心代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">monotoneIncreasingDigits</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># </span></span><br><span class="line">        n_str = <span class="built_in">list</span>(<span class="built_in">str</span>(n))</span><br><span class="line">        L = <span class="built_in">len</span>(n_str)</span><br><span class="line">        <span class="keyword">if</span> L == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> n_str[i - <span class="number">1</span>] &gt; n_str[i]:</span><br><span class="line">                n_str[i - <span class="number">1</span>] = <span class="built_in">str</span>(<span class="built_in">int</span>(n_str[i - <span class="number">1</span>]) - <span class="number">1</span>)</span><br><span class="line">                <span class="comment"># 将修改位置后面的字符都设置为9</span></span><br><span class="line">                <span class="comment"># 比如100，会先变成090，（最后一个0和倒数第二个0时不会进入if）</span></span><br><span class="line">                <span class="comment"># 再用for循环将9后面所有数字变成9</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, L):</span><br><span class="line">                    n_str[j] = <span class="string">&quot;9&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(<span class="string">&quot;&quot;</span>.join(n_str))</span><br></pre></td></tr></table></figure><p>或者使用个flag记录设置9的起点位置，省得增加时间复杂度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">monotoneIncreasingDigits</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 从后向前遍历，以98为例； 若n[i - 1] &gt; n[i] ，将n[i]设置为9并且令n[i - 1]设置为n[i - 1] - 1</span></span><br><span class="line">        n_str = <span class="built_in">list</span>(<span class="built_in">str</span>(n))</span><br><span class="line">        L = <span class="built_in">len</span>(n_str)</span><br><span class="line">        <span class="keyword">if</span> L == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        flag = L</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> n_str[i - <span class="number">1</span>] &gt; n_str[i]:</span><br><span class="line">                n_str[i - <span class="number">1</span>] = <span class="built_in">str</span>(<span class="built_in">int</span>(n_str[i - <span class="number">1</span>]) - <span class="number">1</span>)</span><br><span class="line">                flag = i</span><br><span class="line">                <span class="comment"># 将修改位置后面的字符都设置为9</span></span><br><span class="line">                <span class="comment"># 比如100，会先变成090，（最后一个0和倒数第二个0时不会进入if）</span></span><br><span class="line">                <span class="comment"># 再用for循环将9后面所有数字变成9</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(flag, L):</span><br><span class="line">            n_str[j] = <span class="string">&quot;9&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(<span class="string">&quot;&quot;</span>.join(n_str))</span><br></pre></td></tr></table></figure><h1 id="968-监控二叉树">968. 监控二叉树</h1><p><a href="https://leetcode.cn/problems/binary-tree-cameras/">https://leetcode.cn/problems/binary-tree-cameras/</a></p><p>给定一个二叉树，我们在树的节点上安装摄像头。</p><p>节点上的每个摄影头都可以监视<strong>其父对象、自身及其直接子对象。</strong></p><p>计算监控树的所有节点所需的最小摄像头数量。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_01.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[0,0,null,0,0]</span><br><span class="line">输出：1</span><br><span class="line">解释：如图所示，一台摄像头足以监控所有节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_02.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[0,0,null,0,null,0,null,null,0]</span><br><span class="line">输出：2</span><br><span class="line">解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>给定树的节点数的范围是 <code>[1, 1000]</code>。</li><li>每个节点的值都是 0。</li></ol><h2 id="贪心思路">贪心思路</h2><p>这是很重要的一个线索，摄像头可以覆盖上中下三层，如果把摄像头放在叶子节点上，就浪费的一层的覆盖。</p><p>所以把摄像头放在叶子节点的父节点位置，才能充分利用摄像头的覆盖面积。</p><p>那么有同学可能问了，为什么不从头结点开始看起呢，为啥要从叶子节点看呢？</p><p>因为头结点放不放摄像头也就省下一个摄像头， 叶子节点放不放摄像头省下了的摄像头数量是指数阶别的。</p><p><strong>所以我们要从下往上看，局部最优：让叶子节点的父节点安摄像头，所用摄像头最少，整体最优：全部摄像头数量所用最少！</strong></p><p>局部最优推出全局最优，找不出反例，那么就按照贪心来！</p><p>此时，大体思路就是从低到上，先给叶子节点父节点放个摄像头，然后隔两个节点放一个摄像头，直至到二叉树头结点。</p><p>此时这道题目还有两个难点：</p><ol><li>二叉树的遍历</li><li>如何隔两个节点放一个摄像头</li></ol><p>一个摄影头可以监控3个节点，并且最好从叶子节点倒着向root节点进行遍历（即使用<strong>后序遍历的方法</strong>）</p><p>此时需要状态转移的公式，大家不要和动态的状态转移公式混到一起，本题状态转移没有择优的过程，就是单纯的状态转移！</p><p>来看看这个状态应该如何转移，先来看看每个节点可能有几种状态：</p><p>我们分别有三个数字来表示：</p><ul><li>0：该节点无覆盖</li><li>1：本节点有摄像头</li><li>2：本节点有覆盖</li></ul><p>大家应该找不出第四个节点的状态了。</p><p><strong>一些同学可能会想有没有第四种状态：本节点无摄像头，其实无摄像头就是 无覆盖 或者 有覆盖的状态，所以一共还是三个状态。</strong></p><p><strong>因为在遍历树的过程中，就会遇到空节点，那么问题来了，空节点究竟是哪一种状态呢？ 空节点表示无覆盖？ 表示有摄像头？还是有覆盖呢？</strong></p><p>回归本质，为了让摄像头数量最少，我们要尽量让叶子节点的父节点安装摄像头，这样才能摄像头的数量最少。</p><p>那么空节点不能是无覆盖的状态，这样叶子节点就要放摄像头了，空节点也不能是有摄像头的状态，这样叶子节点的父节点就没有必要放摄像头了，而是可以把摄像头放在叶子节点的爷爷节点上。</p><p><strong>所以空节点的状态只能是有覆盖，这样就可以在叶子节点的父节点放摄像头了</strong></p><p>接下来就是递推关系。</p><p>那么递归的终止条件应该是遇到了空节点，<strong>此时应该返回2（有覆盖）</strong>，原因上面已经解释过了。</p><p>主要有如下四类情况：</p><ul><li>情况1：左右节点都有覆盖</li></ul><p>左孩子有覆盖，右孩子有覆盖，那么此时中间节点应该就是无覆盖的状态了。</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20201229203710729.png" alt="img"></p><ul><li>情况2：左右节点至少有一个无覆盖的情况</li></ul><p>如果是以下情况，则中间节点（父节点）应该放摄像头：</p><ul><li>left == 0 &amp;&amp; right == 0 左右节点无覆盖</li><li>left == 1 &amp;&amp; right == 0 左节点有摄像头，右节点无覆盖</li><li>left == 0 &amp;&amp; right == 1 左节点有无覆盖，右节点摄像头</li><li>left == 0 &amp;&amp; right == 2 左节点无覆盖，右节点覆盖</li><li>left == 2 &amp;&amp; right == 0 左节点覆盖，右节点无覆盖</li></ul><p>这个不难理解，毕竟有一个孩子没有覆盖，父节点就应该放摄像头。</p><p>此时摄像头的数量要加一，并且return 1，代表中间节点放摄像头。</p><ul><li>情况3：左右节点至少有一个有摄像头</li></ul><p>如果是以下情况，其实就是 左右孩子节点有一个有摄像头了，那么其父节点就应该是2（覆盖的状态）</p><ul><li>left == 1 &amp;&amp; right == 2 左节点有摄像头，右节点有覆盖</li><li>left == 2 &amp;&amp; right == 1 左节点有覆盖，右节点有摄像头</li><li>left == 1 &amp;&amp; right == 1 左右节点都有摄像头</li></ul><ul><li>情况4：头结点没有覆盖</li></ul><p>以上都处理完了，递归结束之后，可能头结点 还有一个无覆盖的情况，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20201229203742446.png" alt="img"></p><p>最后，在main函数里，根据rootState判断是否需要再添加一个摄像头</p><h2 id="贪心代码">贪心代码</h2><ul><li>时间复杂度: O(n)，需要遍历二叉树上的每个节点</li><li>空间复杂度: O(n)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="comment"># 空节点应该是什么状态？默认把空节点当成被覆盖的状态</span></span><br><span class="line">            <span class="comment"># 目的是让叶子节点的父节点安装摄像头</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">        leftState = self.foo(node.left)</span><br><span class="line">        rightState = self.foo(node.right)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 左、右至少有一个是无覆盖</span></span><br><span class="line">        <span class="keyword">if</span> leftState == <span class="number">0</span> <span class="keyword">or</span> rightState == <span class="number">0</span>:</span><br><span class="line">            self.res += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="comment"># 右、右都是有覆盖</span></span><br><span class="line">        <span class="keyword">if</span> leftState == <span class="number">2</span> <span class="keyword">and</span> rightState == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 左、右至少有一个是有摄像头的</span></span><br><span class="line">        <span class="keyword">if</span> leftState == <span class="number">1</span> <span class="keyword">or</span> rightState == <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># 根节点被覆盖</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minCameraCover</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        self.root = root</span><br><span class="line">        rootState = self.foo(root)</span><br><span class="line">        <span class="comment"># 最后一个情况，root如果还没有被覆盖</span></span><br><span class="line">        <span class="keyword">if</span> rootState == <span class="number">0</span>:</span><br><span class="line">            self.res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday31贪心part05&quot;&gt;LeetCodeCampsDay31贪心part05&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;本题目有个和二叉树结合的，值得注意&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;56-合并区间&quot;&gt;56.</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay30贪心part04</title>
    <link href="https://blog.lthero.cn/2025/07/24/LeetCodeCampsDay30/"/>
    <id>https://blog.lthero.cn/2025/07/24/LeetCodeCampsDay30/</id>
    <published>2025-07-24T07:36:15.000Z</published>
    <updated>2025-07-24T09:14:11.061Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday30贪心part04">LeetCodeCampsDay30贪心part04</h1><blockquote><p>三个区间问题的题目，用贪心算法解决</p><p>本题需要用到python的lambda表示式</p><p>x.sort(key = lambda x: (x[0], x[1]))</p><p>表示对列表x进行排序，优先对x[0]从小到大排序，再按x[1]从小到大</p><p>如果需要先从大到小，再从小到大，<strong>可以先使用-x[0]</strong></p><p>x.sort(key = lambda x: (<strong>-x[0]</strong>, x[1]))</p></blockquote><h1 id="452-用最少数量的箭引爆气球">452. 用最少数量的箭引爆气球</h1><p><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/</a></p><p>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 <code>points</code> ，其中<code>points[i] = [xstart, xend]</code> 表示水平直径在 <code>xstart</code> 和 <code>xend</code>之间的气球。你不知道气球的确切 y 坐标。</p><p>一支弓箭可以沿着 x 轴从不同点 <strong>完全垂直</strong> 地射出。在坐标 <code>x</code> 处射出一支箭，若有一个气球的直径的开始和结束坐标为 <code>x``start</code>，<code>x``end</code>， 且满足  <code>xstart ≤ x ≤ x``end</code>，则该气球会被 <strong>引爆</strong> 。可以射出的弓箭的数量 <strong>没有限制</strong> 。 弓箭一旦被射出之后，可以无限地前进。</p><p>给你一个数组 <code>points</code> ，<em>返回引爆所有气球所必须射出的 <strong>最小</strong> 弓箭数</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[10,16],[2,8],[1,6],[7,12]]</span><br><span class="line">输出：2</span><br><span class="line">解释：气球可以用2支箭来爆破:</span><br><span class="line">-在x = 6处射出箭，击破气球[2,8]和[1,6]。</span><br><span class="line">-在x = 11处发射箭，击破气球[10,16]和[7,12]。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[1,2],[3,4],[5,6],[7,8]]</span><br><span class="line">输出：4</span><br><span class="line">解释：每个气球需要射出一支箭，总共需要4支箭。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[1,2],[2,3],[3,4],[4,5]]</span><br><span class="line">输出：2</span><br><span class="line">解释：气球可以用2支箭来爆破:</span><br><span class="line">- 在x = 2处发射箭，击破气球[1,2]和[2,3]。</span><br><span class="line">- 在x = 4处射出箭，击破气球[3,4]和[4,5]。</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= points.length &lt;= 105</code></li><li><code>points[i].length == 2</code></li><li><code>-231 &lt;= xstart &lt; xend &lt;= 231 - 1</code></li></ul><h2 id="贪心思路">贪心思路</h2><p>本题的最小结果，其实是“最多的重合区间个数”</p><ol><li>对于区间问题，我们先对区间的左端点进行排序（从小到大），如果左端点一样，再按右端点大小到大排序</li><li>随后，再按重复的区间进行讨论（只有两种情况，排序的结果会保证这一点）<ol><li>当前区间i左边界大于上一区间(i-1)右边界，即：两个区间无重合，则说明上一个区间i-1需要一个箭</li><li>当前区间i左边界小于等于上一区间i-1右边界，两个区间重合，此时，可以用一个箭射穿两个区间；并且需要更新这两个区间的右边界，让他俩的右边界变成他俩右边界的最小值<code>points[i - 1][1] = points[i][1] = min(points[i - 1][1], points[i][1])</code>；这样做的目的，是为了让下一个区间i+1把当前区间i当成&quot;i-1&quot;进行处理，即，当i-1和i重复了，是否能把i+1也带上一起射穿。</li></ol></li></ol><h2 id="贪心代码">贪心代码</h2><ul><li>时间复杂度：O(nlog n)，因为有一个快排</li><li>空间复杂度：O(n)，有一个快排，最差情况(倒序)时，需要n次递归调用。因此确实需要O(n)的栈空间</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMinArrowShots</span>(<span class="params">self, points: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 求最多的重合区间个数 = 最小结果</span></span><br><span class="line">        <span class="comment"># 先按左边界对这些区间进行从小到大排序，如果左端点一样，就按右端点从小到大</span></span><br><span class="line">        points.sort(key = <span class="keyword">lambda</span> x: (x[<span class="number">0</span>], x[<span class="number">1</span>]))</span><br><span class="line">        <span class="comment"># print(points)</span></span><br><span class="line">        <span class="comment"># 再按情况讨论</span></span><br><span class="line">        <span class="comment"># 1、p[i][0] &gt; p[i - 1][1]，当前区间左边界大于上一区间右边界，即：两个区间无重合</span></span><br><span class="line">        <span class="comment"># 2、p[i][0] &lt;= p[i - 1][1]，两个区间重合，此时，可以用一个箭射；并且需要更新这两个区间的右边界，让他俩的右边界变成他俩右边界的最小值</span></span><br><span class="line">        <span class="comment"># 循环，和下一个气球比较</span></span><br><span class="line">        L = <span class="built_in">len</span>(points)</span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L):</span><br><span class="line">            <span class="keyword">if</span> points[i][<span class="number">0</span>] &gt; points[i - <span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> points[i][<span class="number">0</span>] &lt;= points[i - <span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># 两个区间的右端点都更新成为两个区间右端点的最小值</span></span><br><span class="line">                points[i - <span class="number">1</span>][<span class="number">1</span>] = points[i][<span class="number">1</span>] = <span class="built_in">min</span>(points[i - <span class="number">1</span>][<span class="number">1</span>], points[i][<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="435-无重叠区间">435. 无重叠区间</h1><p><a href="https://leetcode.cn/problems/non-overlapping-intervals/">https://leetcode.cn/problems/non-overlapping-intervals/</a></p><p>给定一个区间的集合 <code>intervals</code> ，其中 <code>intervals[i] = [starti, endi]</code> 。返回 <em>需要移除区间的最小数量，使剩余区间互不重叠</em> 。</p><p><strong>注意</strong> 只在一点上接触的区间是 <strong>不重叠的</strong>。例如 <code>[1, 2]</code> 和 <code>[2, 3]</code> 是不重叠的。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: intervals = [[1,2],[2,3],[3,4],[1,3]]</span><br><span class="line">输出: 1</span><br><span class="line">解释: 移除 [1,3] 后，剩下的区间没有重叠。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: intervals = [ [1,2], [1,2], [1,2] ]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: intervals = [ [1,2], [2,3] ]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= intervals.length &lt;= 105</code></li><li><code>intervals[i].length == 2</code></li><li><code>-5 * 104 &lt;= starti &lt; endi &lt;= 5 * 104</code></li></ul><h2 id="贪心思路">贪心思路</h2><p>本题和上一题的思路很像，以及代码都非常像；本题是不需要处理不重叠区间的情况；</p><p>同样需要注意的一点是，<strong>将两个重叠区间的右边界，变成两个区间右端点的最小值</strong>，相当于融合成了一个区间，从而让下一个区间和这个新的右端点进行比较判断</p><h2 id="贪心代码">贪心代码</h2><ul><li>时间复杂度：O(nlog n) ，有一个快排</li><li>空间复杂度：O(n)，有一个快排，最差情况(倒序)时，需要n次递归调用。因此确实需要O(n)的栈空间</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eraseOverlapIntervals</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 本题目就是问有多少个重叠的区间</span></span><br><span class="line">        <span class="comment"># 让相邻的区间保持在一起</span></span><br><span class="line">        <span class="comment"># 先排序区间，再对区间判断</span></span><br><span class="line">        intervals.sort(key = <span class="keyword">lambda</span> x: (x[<span class="number">0</span>], x[<span class="number">1</span>]))</span><br><span class="line">        </span><br><span class="line">        L = <span class="built_in">len</span>(intervals)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L):</span><br><span class="line">          <span class="comment"># 如果两个区间重叠</span></span><br><span class="line">            <span class="keyword">if</span> intervals[i][<span class="number">0</span>] &lt; intervals[i - <span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 将两个区间的右边界，变成两个区间右端点的最小值</span></span><br><span class="line">                intervals[i - <span class="number">1</span>][<span class="number">1</span>] = intervals[i][<span class="number">1</span>] = <span class="built_in">min</span>(intervals[i - <span class="number">1</span>][<span class="number">1</span>], intervals[i][<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="763-划分字母区间">763. 划分字母区间</h1><p><a href="https://leetcode.cn/problems/partition-labels/">https://leetcode.cn/problems/partition-labels/</a></p><p>给你一个字符串 <code>s</code> 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。例如，字符串 <code>&quot;ababcc&quot;</code> 能够被分为 <code>[&quot;abab&quot;, &quot;cc&quot;]</code>，但类似 <code>[&quot;aba&quot;, &quot;bcc&quot;]</code> 或 <code>[&quot;ab&quot;, &quot;ab&quot;, &quot;cc&quot;]</code> 的划分是非法的。</p><p>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 <code>s</code> 。</p><p>返回一个表示每个字符串片段的长度的列表。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ababcbacadefegdehijhklij&quot;</span><br><span class="line">输出：[9,7,8]</span><br><span class="line">解释：</span><br><span class="line">划分结果为 &quot;ababcbaca&quot;、&quot;defegde&quot;、&quot;hijhklij&quot; 。</span><br><span class="line">每个字母最多出现在一个片段中。</span><br><span class="line">像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 这样的划分是错误的，因为划分的片段数较少。 </span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;eccbbbbdec&quot;</span><br><span class="line">输出：[10]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 500</code></li><li><code>s</code> 仅由小写英文字母组成</li></ul><h2 id="贪心思路">贪心思路</h2><h3 id="思路一：">思路一：</h3><p>同一字母最多出现在一个片段中，也暗示这是个区间问题和前面两个题目一样</p><p>可以对每个字母看成一个区间（最多有26个区间），记录每个字母的首、末区间位置；然后进行排序，再统计最大重合区间，区间有重合的就合并（按最大右端点合并），并统计合并后区间长度；如果不重叠，则边界就是答案</p><p>将区间按左边界从小到大排序，找到边界将区间划分成组，互不重叠。找到的边界就是答案。</p><h3 id="思路二：">思路二：</h3><p>思路2更灵活，对每个字母来说，使用hashtable，记录每个字母出现的最远位置的下标；（第一次遍历）</p><p>再遍历一次，不过这次使用个变量farest，记录当前hashtable里，最远位置的下标，当farest==i时，（比如i=8=farest），此时就达到了一个最长区间。</p><p><img src="https://file1.kamacoder.com/i/algo/20201222191924417.png" alt="img"></p><h2 id="贪心代码">贪心代码</h2><h3 id="思路一">思路一</h3><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)，使用的hash数组是固定大小</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partitionLabels</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 统计每个字符最后出现的位置，</span></span><br><span class="line">        <span class="comment"># 从头遍历，更新字符的最远出现下标，如果字符最远出现下标与当前下标相等，则找到了分割点</span></span><br><span class="line">        table = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        L = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">            table[<span class="built_in">ord</span>(s[i]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] = i</span><br><span class="line"></span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        farest = <span class="number">0</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">            farest = <span class="built_in">max</span>(farest,  table[<span class="built_in">ord</span>(s[i]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)])</span><br><span class="line">            <span class="keyword">if</span> i == farest:</span><br><span class="line">                res.append(i - start + <span class="number">1</span>)</span><br><span class="line">                start = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="思路二代码">思路二代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partitionLabels</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line"><span class="comment"># 先对s划分成多个区间</span></span><br><span class="line">        table = <span class="built_in">dict</span>()</span><br><span class="line">        L = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">not</span> <span class="keyword">in</span> table:</span><br><span class="line">                table[s[i]] = [i, i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 更新右端点</span></span><br><span class="line">                table[s[i]][-<span class="number">1</span>] = i</span><br><span class="line">        <span class="comment"># 得到区间后排序</span></span><br><span class="line">        s_list = <span class="built_in">list</span>(table.values())</span><br><span class="line">        s_list.sort(key = <span class="keyword">lambda</span> x: (x[<span class="number">0</span>], x[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">        L = <span class="built_in">len</span>(s_list)</span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        <span class="comment"># start用来记录新区间的起点位置，用来计算个数用</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 开始遍历并查找独立区间、合并重合区间</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L):</span><br><span class="line">            <span class="comment"># 当前区间右端点大于前区间左端点，说明有独立区间</span></span><br><span class="line">            <span class="keyword">if</span> s_list[i][<span class="number">0</span>] &gt; s_list[i - <span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">                res.append(s_list[i - <span class="number">1</span>][<span class="number">1</span>] - start + <span class="number">1</span>)</span><br><span class="line">                start = s_list[i - <span class="number">1</span>][<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">              <span class="comment"># 注意这里是将区间统一变成最大值</span></span><br><span class="line">                s_list[i][<span class="number">1</span>] = <span class="built_in">max</span>(s_list[i - <span class="number">1</span>][<span class="number">1</span>], s_list[i][<span class="number">1</span>])</span><br><span class="line">        res.append(s_list[-<span class="number">1</span>][<span class="number">1</span>] - start + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday30贪心part04&quot;&gt;LeetCodeCampsDay30贪心part04&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;三个区间问题的题目，用贪心算法解决&lt;/p&gt;
&lt;p&gt;本题需要用到python的lambda表示式&lt;/p&gt;
&lt;p&gt;x</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay29贪心part03</title>
    <link href="https://blog.lthero.cn/2025/07/24/LeetCodeCampsDay29/"/>
    <id>https://blog.lthero.cn/2025/07/24/LeetCodeCampsDay29/</id>
    <published>2025-07-24T02:49:36.000Z</published>
    <updated>2025-07-24T09:08:29.267Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday29贪心part03">LeetCodeCampsDay29贪心part03</h1><blockquote><p>有些题目有多个维度时，可以去去除一个维度（比如406）</p><p>而有些题目需要同时考虑左右相邻元素时，可以先从左向右、再从右向左遍历</p></blockquote><h1 id="134-加油站">134. 加油站</h1><p><a href="https://leetcode.cn/problems/gas-station/">https://leetcode.cn/problems/gas-station/</a></p><p>在一条环路上有 <code>n</code> 个加油站，其中第 <code>i</code> 个加油站有汽油 <code>gas[i]</code> 升。</p><p>你有一辆油箱容量无限的的汽车，从第 <code>i</code> 个加油站开往第 <code>i+1</code> 个加油站需要消耗汽油 <code>cost[i]</code> 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>给定两个整数数组 <code>gas</code> 和 <code>cost</code> ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 <code>-1</code> 。如果存在解，则 <strong>保证</strong> 它是 <strong>唯一</strong> 的。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油</span><br><span class="line">开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油</span><br><span class="line">开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油</span><br><span class="line">开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</span><br><span class="line">因此，3 可为起始索引。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: gas = [2,3,4], cost = [3,4,3]</span><br><span class="line">输出: -1</span><br><span class="line">解释:</span><br><span class="line">你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。</span><br><span class="line">我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油</span><br><span class="line">你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。</span><br><span class="line">因此，无论怎样，你都不可能绕环路行驶一周。</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>n == gas.length == cost.length</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>0 &lt;= gas[i], cost[i] &lt;= 104</code></li><li>输入保证答案唯一。</li></ul><table><thead><tr><th>Gas</th><th>2</th><th>5</th><th>2</th><th>3</th><th>5</th></tr></thead><tbody><tr><td>Cost</td><td>1</td><td>2</td><td>8</td><td>2</td><td>4</td></tr><tr><td>restGas</td><td>1</td><td>3</td><td>-6</td><td>1</td><td>1</td></tr><tr><td>Index</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td></tr></tbody></table><p>开始令下标从0开始，就累加计算当前restGas量，如果当前累加量小于0，比如到达第三号时，此时剩余-2，则说明无论是从1号还是2号出发，肯定都会无法走完全程的，所以将下标从3开始继续尝试。</p><h2 id="贪心思路">贪心思路</h2><p>本题目可以不用管所谓的循环的条件，只关心剩余gas量</p><p>先求出每站跑一遍能剩下的gas量(rest = gas - cost)，再直接以第一站开始遍历，将每站rest量添加到remain，如果到了第i站，remain出现负数，说明从i站之前所有站的出发，都无法完成目标；需要从第i+1站继续尝试，如果i+1站走到了终点，则说明i+1站可以作为起点；</p><p>这里有点儿难理解，为什么i+1站并没有走完所谓的全程（至少没有循环地走完全程），而只是从i+1走到L，就可以说明它可以作为起点；</p><blockquote><p>因为题目里保证，如果有答案，只唯一，所以这里贪心的思路是，<strong>删除所有不可能的点，剩下可能的一定是答案</strong></p></blockquote><p>总和是关键：如果整个环的总 rest 和 &gt;= 0，那么一定有一个唯一起点</p><p>先考虑整个数组的 total rest（即所有 rest[i] 的和）。</p><p>如果 total rest &lt; 0，意味着总油量不足以绕环一周，无论从哪里出发，都不可能成功。</p><p>如果 total rest &gt;= 0，问题保证了只有一个起点能成功。</p><p>这是因为环路的性质：油量是固定的，总供给 &gt;= 总消耗，所以只要找到那个“平衡点”，就能走完全程。</p><p>算法利用这一点：在遍历过程中，我们不是在真正模拟开车，而是在检查累积油量是否可持续。如果从某个起点开始，油量 remain 就负了，意味着这个起点不行，<strong>但我们知道其他起点中有一个是行的</strong></p><p>当我们重置起点到i+1并继续累积remain，实际上是在从i+1开始检查剩余路径是否可持续。同时，之前的失败已经帮我们&quot;过滤&quot;了无效起点</p><p>最终，遍历完整个数组后，如果总remain&gt;=0，说明从i+1开始的路径是可行的，因为总rest和&gt;=0，且我们已经排除了前面的无效点</p><p>用一个例子说明<br>假设我们有一个环形数组：<br>gas = [1, 2, 3, 4, 5]</p><p>cost = [3, 4, 5, 1, 2]</p><p>那么 rest = [1-3, 2-4, 3-5, 4-1, 5-2] = [-2, -2, -2, 3, 3]<br>现在，按算法遍历：<br>开始从索引 0，remain = 0</p><p>i=0: remain += -2 = -2 (负数！) → 起点无效，移到 i+1=1，重置 remain=0</p><p>i=1: remain += -2 = -2 (负数！) → 起点无效，移到 i+2=2，重置 remain=0</p><p>i=2: remain += -2 = -2 (负数！) → 起点无效，移到 i+3=3，重置 remain=0</p><p>i=3: remain += 3 = 3</p><p>i=4: remain += 3 = 6 (结束遍历)</p><p>总 remain = 6 &gt;= 0，所以起点是 3（i+1 从上一步的 i=2）。</p><p>为什么 i=3 可以直接作为起点？因为：</p><p>从 0、1、2 开始都失败了，证明它们不可行。 总 rest 和 = -2 + -2 + -2 + 3 + 3 = 0 (&gt;= 0)，<strong>所以一定有一个起点（这里是 3）</strong>。 我们不需要从 i=3 单独再走一遍全程，因为算法的最后累积 already 确认了它能覆盖整个环。</p><blockquote><p>另外，为什么找到了第一个可以走完剩下路的点i就是起点？或者说，第一个让remain一直保持大于0的点就是起点</p></blockquote><p>这好理解，哪怕有第二个点能让remain在i+1到L的路程一直大于0，那第一个点肯定更能满足在i到L的路程一直大于0(因为第一个点的rest要大于0，而且第二个点已经保持了后续的reamin大于0），那第一个点就必然是“唯一的答案”</p><h2 id="贪心代码">贪心代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canCompleteCircuit</span>(<span class="params">self, gas: <span class="type">List</span>[<span class="built_in">int</span>], cost: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># -2， -2， -2， 3， 3</span></span><br><span class="line">        L = <span class="built_in">len</span>(gas)</span><br><span class="line">        rest = [<span class="number">0</span>] * L</span><br><span class="line">        <span class="comment"># 先计算跑一天后剩下的gas</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">            rest[i] = gas[i] - cost[i]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">sum</span>(rest) &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 使用贪心算法，</span></span><br><span class="line">        startPoint = <span class="number">0</span></span><br><span class="line">        restGas = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">            restGas += rest[i]</span><br><span class="line">            <span class="comment"># 仅小于0时才说明i之前的位置不适合作为起始位置，从i+1开始尝试</span></span><br><span class="line">            <span class="keyword">if</span> restGas &lt; <span class="number">0</span>:</span><br><span class="line">                startPoint = i + <span class="number">1</span></span><br><span class="line">                restGas = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> startPoint</span><br></pre></td></tr></table></figure><h1 id="135-分发糖果">135. 分发糖果</h1><p><a href="https://leetcode.cn/problems/candy/">https://leetcode.cn/problems/candy/</a></p><p><code>n</code> 个孩子站成一排。给你一个整数数组 <code>ratings</code> 表示每个孩子的评分。</p><p>你需要按照以下要求，给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 <code>1</code> 个糖果。</li><li>相邻两个孩子评分更高的孩子会获得更多的糖果。</li></ul><p>请你给每个孩子分发糖果，计算并返回需要准备的 <strong>最少糖果数目</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：ratings = [1,0,2]</span><br><span class="line">输出：5</span><br><span class="line">解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：ratings = [1,2,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。</span><br><span class="line">     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == ratings.length</code></li><li><code>1 &lt;= n &lt;= 2 * 104</code></li><li><code>0 &lt;= ratings[i] &lt;= 2 * 104</code></li></ul><h2 id="贪心思路">贪心思路</h2><p>本题需要左、右都比较，但如果想一次遍历就比较左右两边是比较难的；所以可以遍历两次，一次从左向右比较，判断右边比左边高；一次从右向左比较，判断左边比右边高的情况</p><p>第一次遍历时，if ratings[i] &gt; ratings[i - 1]，则res[i] = res[i - 1] + 1</p><p>第二次遍历时，if ratings[i] &gt; ratings[i + 1]，需要注意，不能直接res[i] = res[i + 1] + 1，因为题目要求当前孩子需要比左、右孩子相对比，所以这里需要将res[i + 1] + 1（左边比右边高的情况）与res[i]（之前得到的，右边比左边高的情况进行比较），取最大值<code>res[i] = max(res[i], res[i + 1] + 1)</code></p><p>最后返回sumOfNums即可</p><h2 id="贪心代码">贪心代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">candy</span>(<span class="params">self, ratings: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        L = <span class="built_in">len</span>(ratings)</span><br><span class="line">        res = [<span class="number">1</span>] * L</span><br><span class="line">        <span class="comment"># 右边比左边高</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L):</span><br><span class="line">            <span class="keyword">if</span> ratings[i] &gt; ratings[i - <span class="number">1</span>]:</span><br><span class="line">                res[i] = res[i - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 左边从右边高（从后向前遍历）</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> ratings[i] &gt; ratings[i + <span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># 要取个值，保证res[i]要既比左边高，也比右边高</span></span><br><span class="line">                <span class="comment"># 这里的res[i]就是已经比左边高的值，而res[i+1]+1是比右边高的值，取最大值</span></span><br><span class="line">                res[i] = <span class="built_in">max</span>(res[i], res[i + <span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(res)</span><br></pre></td></tr></table></figure><h1 id="860-柠檬水找零">860. 柠檬水找零</h1><p><a href="https://leetcode.cn/problems/lemonade-change/">https://leetcode.cn/problems/lemonade-change/</a></p><p>在柠檬水摊上，每一杯柠檬水的售价为 <code>5</code> 美元。顾客排队购买你的产品，（按账单 <code>bills</code> 支付的顺序）一次购买一杯。</p><p>每位顾客只买一杯柠檬水，然后向你付 <code>5</code> 美元、<code>10</code> 美元或 <code>20</code> 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 <code>5</code> 美元。</p><p>注意，一开始你手头没有任何零钱。</p><p>给你一个整数数组 <code>bills</code> ，其中 <code>bills[i]</code> 是第 <code>i</code> 位顾客付的账。如果你能给每位顾客正确找零，返回 <code>true</code> ，否则返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：bills = [5,5,5,10,20]</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。</span><br><span class="line">第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。</span><br><span class="line">第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。</span><br><span class="line">由于所有客户都得到了正确的找零，所以我们输出 true。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：bills = [5,5,10,10,20]</span><br><span class="line">输出：false</span><br><span class="line">解释：</span><br><span class="line">前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。</span><br><span class="line">对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。</span><br><span class="line">对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。</span><br><span class="line">由于不是每位顾客都得到了正确的找零，所以答案是 false。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= bills.length &lt;= 105</code></li><li><code>bills[i]</code> 不是 <code>5</code> 就是 <code>10</code> 或是 <code>20</code></li></ul><h2 id="贪心思路">贪心思路</h2><p>本题只需要讨论找钱的几种情况，记数手里5元、10元的个数，并算欠用户多少钱，是否能还</p><ol><li>收到5元，直接收入；不找</li><li>收入10元，检测是否有5元，有则找；没有则False</li><li>收到20元，优先检测是否有一张10元一张5元，如果没有再检测是否有三张5元，有则找；没有则False</li></ol><h2 id="贪心代码">贪心代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lemonadeChange</span>(<span class="params">self, bills: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 记数手里5元、10元的个数，并算欠用户多少钱，是否能还</span></span><br><span class="line">        <span class="comment"># 5, 10</span></span><br><span class="line">        nums = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> bills:</span><br><span class="line">            index = i//<span class="number">5</span> - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> index == <span class="number">0</span>:</span><br><span class="line">                nums[index] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> index == <span class="number">1</span>:</span><br><span class="line">                nums[index] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> nums[<span class="number">0</span>] &gt; <span class="number">0</span>:</span><br><span class="line">                    nums[<span class="number">0</span>] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 20元，需要还1张10，1张5；或者三张5</span></span><br><span class="line">                <span class="comment"># 优先还10元的</span></span><br><span class="line">                <span class="keyword">if</span> nums[<span class="number">0</span>] <span class="keyword">and</span> nums[<span class="number">1</span>]:</span><br><span class="line">                    nums[<span class="number">0</span>] -= <span class="number">1</span></span><br><span class="line">                    nums[<span class="number">1</span>] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[<span class="number">0</span>] &gt;= <span class="number">3</span>:</span><br><span class="line">                    nums[<span class="number">0</span>] -= <span class="number">3</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">       </span><br></pre></td></tr></table></figure><h1 id="406-根据身高重建队列">406. 根据身高重建队列</h1><p><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/">https://leetcode.cn/problems/queue-reconstruction-by-height/</a></p><p>假设有打乱顺序的一群人站成一个队列，数组 <code>people</code> 表示队列中一些人的属性（不一定按顺序）。每个 <code>people[i] = [hi, ki]</code> 表示第 <code>i</code> 个人的身高为 <code>hi</code> ，前面 <strong>正好</strong> 有 <code>ki</code> 个身高大于或等于 <code>hi</code> 的人。</p><p>请你重新构造并返回输入数组 <code>people</code> 所表示的队列。返回的队列应该格式化为数组 <code>queue</code> ，其中 <code>queue[j] = [hj, kj]</code> 是队列中第 <code>j</code> 个人的属性（<code>queue[0]</code> 是排在队列前面的人）。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</span><br><span class="line">输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</span><br><span class="line">解释：</span><br><span class="line">编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。</span><br><span class="line">编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。</span><br><span class="line">编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。</span><br><span class="line">编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class="line">编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。</span><br><span class="line">编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class="line">因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]</span><br><span class="line">输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= people.length &lt;= 2000</code></li><li><code>0 &lt;= hi &lt;= 106</code></li><li><code>0 &lt;= ki &lt; people.length</code></li><li>题目数据确保队列可以被重建</li></ul><h2 id="贪心思路">贪心思路</h2><p>本题目有高度和顺序两个维度，同时处理起来很麻烦，所以先进行降维度；只处理高度</p><p>1、优先按h排序，从高到低，身高相同再按k从小到大；</p><p>比如</p><p>[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]</p><p>按身高先排序后会得到</p><p>[7,0],[7,1],[6,1],[5,0],[5,2],[4,4]</p><p>2、再按k进行排序，这里只要按k将元素插入在k位置即可</p><h2 id="贪心代码">贪心代码</h2><ul><li>时间复杂度：O(nlog n + n^2)</li><li>空间复杂度：O(n)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reconstructQueue</span>(<span class="params">self, people: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 1、优先按h排序，从高到低，身高相同再按k从小到大 </span></span><br><span class="line">        <span class="comment"># 这样保证，</span></span><br><span class="line">        <span class="comment"># 从而去除了身高的维度，下面去关注k</span></span><br><span class="line">        <span class="comment"># 2、根据k来调整具体顺序</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># lambda, 当-x[0](维度h)相同时，再根据x[1]（维度k)从小到大排序</span></span><br><span class="line">        people.sort(key = <span class="keyword">lambda</span> x: (- x[<span class="number">0</span>], x[<span class="number">1</span>]))</span><br><span class="line">        que = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 根据每个元素的第二个维度k，进行插入</span></span><br><span class="line">        <span class="comment"># 由于people已经排序好了，相同高度时，将k值小的排序前面</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> people:</span><br><span class="line">            que.insert(p[<span class="number">1</span>], p)</span><br><span class="line">        <span class="keyword">return</span> que</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday29贪心part03&quot;&gt;LeetCodeCampsDay29贪心part03&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;有些题目有多个维度时，可以去去除一个维度（比如406）&lt;/p&gt;
&lt;p&gt;而有些题目需要同时考虑左右相邻元素时，可以</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay28贪心part02</title>
    <link href="https://blog.lthero.cn/2025/07/22/LeetCodeCampsDay28/"/>
    <id>https://blog.lthero.cn/2025/07/22/LeetCodeCampsDay28/</id>
    <published>2025-07-22T07:26:52.000Z</published>
    <updated>2025-07-24T09:09:18.197Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday28贪心part02">LeetCodeCampsDay28贪心part02</h1><blockquote><p>覆盖范围的题目</p></blockquote><h1 id="122-买卖股票的最佳时机-ii">122. 买卖股票的最佳时机 II</h1><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/</a></p><p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p><p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p><p>返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [7,1,5,3,6,4]</span><br><span class="line">输出：7</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。</span><br><span class="line">随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3。</span><br><span class="line">最大总利润为 4 + 3 = 7 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [1,2,3,4,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。</span><br><span class="line">最大总利润为 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [7,6,4,3,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 3 * 104</code></li><li><code>0 &lt;= prices[i] &lt;= 104</code></li></ul><h2 id="贪心思路">贪心思路</h2><p>观察例子可以看到，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [1,2,3,4,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。</span><br></pre></td></tr></table></figure><p>虽然解释是第一天买，最后一天卖；但第一天买，第二天卖，第二天再买，第三天卖……最终也会得到同样的利润。因为<strong>把利润分解为每天为单位的维度，而不是从 1 天到第 5 天整体去考虑！</strong></p><p>所以，我们可以算出每天的利润表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prices = [7,1,5,3,6,4]</span><br><span class="line">DailyProfit = [-6， 4，-2，3，-2]</span><br></pre></td></tr></table></figure><p>只统计DailProfit里<strong>大于零的利润就好了</strong></p><p><img src="https://file1.kamacoder.com/i/algo/2020112917480858-20230310134659477.png" alt="img"></p><p>那？第一天怎么就没有利润呢，第一天到底算不算的困惑中。</p><p>第一天当然没有利润，至少要第二天才会有利润，所以利润的序列比股票序列少一天！</p><p>从图中可以发现，其实我们需要收集每天的正利润就可以，<strong>收集正利润的区间，就是股票买卖的区间，而我们只需要关注最终利润，不需要记录区间</strong>。</p><p>那么只收集正利润就是贪心所贪的地方！</p><p><strong>局部最优：收集每天的正利润，全局最优：求得最大利润</strong>。</p><h2 id="贪心代码">贪心代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># -6， 4，-2，3，-2</span></span><br><span class="line">        L = <span class="built_in">len</span>(prices)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L - <span class="number">1</span>):</span><br><span class="line">            profit = prices[i + <span class="number">1</span>] - prices[i]</span><br><span class="line">            <span class="keyword">if</span> profit &gt; <span class="number">0</span>:</span><br><span class="line">                res += profit</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="55-跳跃游戏">55. 跳跃游戏</h1><p><a href="https://leetcode.cn/problems/jump-game/">https://leetcode.cn/problems/jump-game/</a></p><p>给你一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标，如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,1,0,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>0 &lt;= nums[i] &lt;= 105</code></li></ul><h2 id="贪心思路">贪心思路</h2><p>本题其实跳几步无所谓，关键在于可跳的覆盖范围！</p><p><img src="https://file1.kamacoder.com/i/algo/20230203105634.png" alt="img"></p><h2 id="贪心代码">贪心代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">L = <span class="built_in">len</span>(nums)</span><br><span class="line">maxReach = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">    <span class="keyword">if</span> i &lt;= maxReach:</span><br><span class="line">        maxReach = <span class="built_in">max</span>(maxReach, i + nums[i])</span><br><span class="line">        <span class="keyword">if</span> maxReach &gt;= L - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="keyword">return</span> maxReach &gt;= L - <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="分治思路">分治思路</h2><p>数值：[2,3,1,1,4]</p><p>下标：[0,1,2,3,4]</p><p>从末尾向前检查，设置当前位置(cur)是最后一位，如果当前位置到i的距离（cur - i)小于等于nums[i]，说明当前位置可以被访问，最终判断cur是否回到了0</p><p>这种方法最好就是从终点走回到起点，逐渐将一个[2,3,1,1,4]的问题变成[2,3,1,1]-&gt;[2,3,1]-&gt;[2,3]-&gt;[2]</p><h2 id="分治代码">分治代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canJump</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 从末尾向前检查，设置当前位置是最后一位，</span></span><br><span class="line">        <span class="comment"># 如果当前位置到i的距离，小于等于nums[i]，说明当前位置可以被访问</span></span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        startPoint = L - <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] + i &gt;= startPoint:</span><br><span class="line">                startPoint = i</span><br><span class="line">        <span class="keyword">return</span> startPoint == <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="动态规划">动态规划</h2><p>设置个stepsAvailable，表示从当前位置能走的最大步数，一步步模拟，如果某个位置的nums[i]大于stepsAvailable，则更新stepsAvailable=nums[i]</p><h2 id="动态规划代码">动态规划代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">L = <span class="built_in">len</span>(nums)</span><br><span class="line">StepsAvailable = nums[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L):</span><br><span class="line">    <span class="keyword">if</span> StepsAvailable == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    StepsAvailable -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> nums[i] &gt; StepsAvailable:</span><br><span class="line">        StepsAvailable = nums[i]</span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h1 id="45-跳跃游戏-ii">45. 跳跃游戏 II</h1><p><a href="https://leetcode.cn/problems/jump-game-ii/">https://leetcode.cn/problems/jump-game-ii/</a></p><p>给定一个长度为 <code>n</code> 的 <strong>0 索引</strong>整数数组 <code>nums</code>。初始位置为 <code>nums[0]</code>。</p><p>每个元素 <code>nums[i]</code> 表示从索引 <code>i</code> 向后跳转的最大长度。换句话说，如果你在 <code>nums[i]</code> 处，你可以跳转到任意 <code>nums[i + j]</code> 处:</p><ul><li><code>0 &lt;= j &lt;= nums[i]</code></li><li><code>i + j &lt; n</code></li></ul><p>返回到达 <code>nums[n - 1]</code> 的最小跳跃次数。生成的测试用例可以到达 <code>nums[n - 1]</code>。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [2,3,1,1,4]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 2。</span><br><span class="line">     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [2,3,0,1,4]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li><li>题目保证可以到达 <code>nums[n-1]</code></li></ul><h2 id="贪心思路">贪心思路</h2><p>贪心的思路，局部最优：当前可移动距离尽可能多走，如果还没到终点，步数再加一。整体最优：一步尽可能多走，从而达到最少步数。</p><p>思路虽然是这样，但在写代码的时候还不能真的能跳多远就跳多远，那样就不知道下一步最远能跳到哪里了。</p><p><strong>所以真正解题的时候，要从覆盖范围出发，不管怎么跳，覆盖范围内一定是可以跳到的，以最小的步数增加覆盖范围，覆盖范围一旦覆盖了终点，得到的就是最少步数！</strong></p><p><strong>这里需要统计两个覆盖范围，当前这一步的最大覆盖和下一步最大覆盖</strong>。</p><p>如果移动下标达到了当前这一步的最大覆盖最远距离了，还没有到终点的话，那么就必须再走一步来增加覆盖范围，直到覆盖范围覆盖了终点。</p><p>我们每次在可跳范围内选择可以使得跳的更远的位置。</p><p>如下图，开始的位置是 2，可跳的范围是橙色的。然后因为 3 可以跳的更远，所以跳到 3 的位置。</p><p><img src="https://cdn.lthero.cn/post_images/course/MLc4a606188af249b911d06acb5e51b2f8a4589be68b02b900d32dfdd69a14d368-image.png" alt="img"></p><p>如下图，然后现在的位置就是 3 了，能跳的范围是橙色的，然后因为 4 可以跳的更远，所以下次跳到 4 的位置。</p><p><img src="https://cdn.lthero.cn/post_images/course/ML1c13a73f3ddd9c5badd83f818455c1ed16a251956473659ffcee6eb9a65ecdbf-image.png" alt="img"></p><p>在代码里，我们用 end 表示当前能跳的边界，对于上边第一个图的橙色 1，第二个图中就是橙色的 4，遍历数组的时候，到了边界，我们就重新更新新的边界。</p><h2 id="贪心代码">贪心代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">jump</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> L == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 当前能到达最远距离</span></span><br><span class="line">        end = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 下一步能到达最远距离</span></span><br><span class="line">        MaxReach = <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">          <span class="comment"># 找到能跳得最远的</span></span><br><span class="line">            MaxReach = <span class="built_in">max</span>(nums[i] + i, MaxReach)</span><br><span class="line">            <span class="comment"># 遇到边界，就更新边界，并且步数加一</span></span><br><span class="line">            <span class="keyword">if</span> i == end:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">                end = MaxReach</span><br><span class="line">                <span class="keyword">if</span> MaxReach &gt;= L - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="1005-k-次取反后最大化的数组和">1005. K 次取反后最大化的数组和</h1><p><a href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/">https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/</a></p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，按以下方法修改该数组：</p><ul><li>选择某个下标 <code>i</code> 并将 <code>nums[i]</code> 替换为 <code>-nums[i]</code> 。</li></ul><p>重复这个过程恰好 <code>k</code> 次。可以多次选择同一个下标 <code>i</code> 。</p><p>以这种方式修改数组后，返回数组 <strong>可能的最大和</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,2,3], k = 1</span><br><span class="line">输出：5</span><br><span class="line">解释：选择下标 1 ，nums 变为 [4,-2,3] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,-1,0,2], k = 3</span><br><span class="line">输出：6</span><br><span class="line">解释：选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,-3,-1,5,-4], k = 2</span><br><span class="line">输出：13</span><br><span class="line">解释：选择下标 (1, 4) ，nums 变为 [2,3,-1,5,4] 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-100 &lt;= nums[i] &lt;= 100</code></li><li><code>1 &lt;= k &lt;= 104</code></li></ul><h2 id="贪心思路">贪心思路</h2><p>先将nums排序，按绝对值排序，<strong>从大到小</strong></p><p>再对小于0的数字进行反转，每次消耗一次k</p><p>如果k有剩余，就对着最小的数进行反转剩下的k次（不过按奇偶划分下就行，偶数就不用反转，奇数就反转一次）</p><h2 id="贪心代码">贪心代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestSumAfterKNegations</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        </span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        nums.sort(key = <span class="keyword">lambda</span> x: <span class="built_in">abs</span>(x), reverse = <span class="literal">True</span>)</span><br><span class="line">        <span class="built_in">print</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">            <span class="keyword">if</span> k &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] &lt; <span class="number">0</span>:</span><br><span class="line">                nums[i] *= -<span class="number">1</span></span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> k % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            nums[-<span class="number">1</span>] *= -<span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(nums)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(nums)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday28贪心part02&quot;&gt;LeetCodeCampsDay28贪心part02&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;覆盖范围的题目&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;122-买卖股票的最佳时机-ii&quot;&gt;122.</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay27贪心part01</title>
    <link href="https://blog.lthero.cn/2025/07/21/LeetCodeCampsDay27/"/>
    <id>https://blog.lthero.cn/2025/07/21/LeetCodeCampsDay27/</id>
    <published>2025-07-21T08:51:43.000Z</published>
    <updated>2025-07-22T07:19:07.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday27贪心part01">LeetCodeCampsDay27贪心part01</h1><blockquote><p>贪心算法理论与一些基础题目</p></blockquote><h2 id="什么是贪心">什么是贪心</h2><p><strong>贪心的本质是选择每一阶段的局部最优，从而达到全局最优</strong>。</p><p>这么说有点抽象，来举一个例子：</p><p>例如，有一堆钞票，你可以拿走十张，如果想达到最大的金额，你要怎么拿？</p><p>指定每次拿最大的，最终结果就是拿走最大数额的钱。</p><p>每次拿最大的就是局部最优，最后拿走最大数额的钱就是推出全局最优。</p><p>再举一个例子如果是 有一堆盒子，你有一个背包体积为n，如何把背包尽可能装满，如果还每次选最大的盒子，就不行了。这时候就需要动态规划。动态规划的问题在下一个系列会详细讲解。</p><h3 id="贪心的例题">贪心的例题</h3><p>桌上有面值100，50，20，10，1的各种钞票各2张，如果只能拿5张，如何拿才能拿最多钱；</p><p>常识的思路肯定是<strong>优先拿最大的，然后次大的</strong>，先拿2张100，再2张50，一张20的；</p><h2 id="贪心的套路-什么时候用贪心">贪心的套路（什么时候用贪心）</h2><p>有没有什么套路可以一看就看出来是贪心。</p><p><strong>说实话贪心算法并没有固定的套路</strong>。</p><p>所以唯一的难点就是如何通过局部最优，推出整体最优。</p><p>那么如何能看出局部最优是否能推出整体最优呢？有没有什么固定策略或者套路呢？</p><p><strong>不好意思，也没有！</strong> 靠自己手动模拟，如果模拟可行，就可以试一试贪心策略，如果不可行，可能需要动态规划。</p><p>有同学问了如何验证可不可以用贪心算法呢？</p><p><strong>最好用的策略就是举反例，如果想不到反例，那么就试一试贪心吧</strong>。</p><p>可有有同学认为手动模拟，举例子得出的结论不靠谱，想要严格的数学证明。</p><p>一般数学证明有如下两种方法：</p><ul><li>数学归纳法</li><li>反证法</li></ul><p>看教课书上讲解贪心可以是一堆公式，估计大家连看都不想看，所以数学证明就不在我要讲解的范围内了，大家感兴趣可以自行查找资料。</p><p><strong>面试中基本不会让面试者现场证明贪心的合理性，代码写出来跑过测试用例即可，或者自己能自圆其说理由就行了</strong>。</p><p>举一个不太恰当的例子：我要用一下1+1 = 2，但我要先证明1+1 为什么等于2。严谨是严谨了，但没必要。</p><p>虽然这个例子很极端，但可以表达这么个意思：<strong>刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心</strong>。</p><p><strong>例如刚刚举的拿钞票的例子，就是模拟一下每次拿做大的，最后就能拿到最多的钱，这还要数学证明的话，其实就不在算法面试的范围内了，可以看看专业的数学书籍！</strong></p><p>所以这也是为什么很多同学通过（accept）了贪心的题目，但都不知道自己用了贪心算法，<strong>因为贪心有时候就是常识性的推导，所以会认为本应该就这么做！</strong></p><p><strong>那么刷题的时候什么时候真的需要数学推导呢？</strong></p><p>例如这道题目：<a href="https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html">链表：环找到了，那入口呢？ (opens new window)</a>，这道题不用数学推导一下，就找不出环的起始位置，想试一下就不知道怎么试，这种题目确实需要数学简单推导一下</p><h2 id="贪心一般解题步骤">贪心一般解题步骤</h2><p>贪心算法一般分为如下四步：</p><ul><li>将问题分解为若干个子问题</li><li>找出适合的贪心策略</li><li>求解每一个子问题的最优解</li><li>将局部最优解堆叠成全局最优解</li></ul><p>这个四步其实过于理论化了，我们平时在做贪心类的题目时，如果按照这四步去思考，真是有点“鸡肋”。</p><p>做题的时候，只要想清楚 局部最优 是什么，如果推导出全局最优，其实就够了。</p><h2 id="总结">总结</h2><p>本篇给出了什么是贪心以及大家关心的贪心算法固定套路。</p><p><strong>不好意思了，贪心没有套路，说白了就是常识性推导加上举反例</strong>。</p><p>最后给出贪心的一般解题步骤，大家可以发现这个解题步骤也是比较抽象的，不像是二叉树，回溯算法，给出了那么具体的解题套路和模板。</p><h1 id="455-分发饼干">455. 分发饼干</h1><p><a href="https://leetcode.cn/problems/assign-cookies/">https://leetcode.cn/problems/assign-cookies/</a></p><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 <code>i</code>，都有一个胃口值 <code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code> ，这个孩子会得到满足。你的目标是满足尽可能多的孩子，并输出这个最大数值。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: g = [1,2,3], s = [1,1]</span><br><span class="line">输出: 1</span><br><span class="line">解释: </span><br><span class="line">你有三个孩子和两块小饼干，3 个孩子的胃口值分别是：1,2,3。</span><br><span class="line">虽然你有两块小饼干，由于他们的尺寸都是 1，你只能让胃口值是 1 的孩子满足。</span><br><span class="line">所以你应该输出 1。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: g = [1,2], s = [1,2,3]</span><br><span class="line">输出: 2</span><br><span class="line">解释: </span><br><span class="line">你有两个孩子和三块小饼干，2 个孩子的胃口值分别是 1,2。</span><br><span class="line">你拥有的饼干数量和尺寸都足以让所有孩子满足。</span><br><span class="line">所以你应该输出 2。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= g.length &lt;= 3 * 104</code></li><li><code>0 &lt;= s.length &lt;= 3 * 104</code></li><li><code>1 &lt;= g[i], s[j] &lt;= 231 - 1</code></li></ul><p>**注意：**本题与 <a href="https://leetcode.cn/problems/maximum-matching-of-players-with-trainers/">2410. 运动员和训练师的最大匹配数</a> 题相同。</p><h2 id="贪心思路">贪心思路</h2><ol><li>本题的思路和拿钞票有点儿像？用尺寸最大的饼干优先满足胃口最大的孩子，如果胃口最大的无法满足，就去满足次大的……；</li><li>所以需要对孩子的胃口和饼干尺寸排序（从大到小）</li><li>具体做法<ol><li>可以用双指针，一个指向饼干，一个指向小孩；两者都各自从大到小遍历</li></ol></li></ol><p><img src="https://file1.kamacoder.com/i/algo/20230405225628.png" alt="img"></p><h2 id="贪心代码">贪心代码</h2><ul><li>时间复杂度O(N+M)</li><li>空间复杂度O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findContentChildren</span>(<span class="params">self, g: <span class="type">List</span>[<span class="built_in">int</span>], s: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 先对g和s排序，按s最大值对g最大值进行匹配</span></span><br><span class="line">        g = <span class="built_in">sorted</span>(g, reverse = <span class="literal">True</span>)</span><br><span class="line">        s = <span class="built_in">sorted</span>(s, reverse = <span class="literal">True</span>)</span><br><span class="line">        </span><br><span class="line">        indexOfg = <span class="number">0</span></span><br><span class="line">        indexOfs = <span class="number">0</span></span><br><span class="line">        LenOfg = <span class="built_in">len</span>(g)</span><br><span class="line">        Lenofs = <span class="built_in">len</span>(s)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> indexOfg &lt; LenOfg <span class="keyword">and</span> indexOfs &lt; Lenofs:</span><br><span class="line">            <span class="keyword">if</span> s[indexOfs] &gt;= g[indexOfg]:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">                indexOfs += <span class="number">1</span></span><br><span class="line">            indexOfg += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="53-最大子数组和">53. 最大子数组和</h1><p><a href="https://leetcode.cn/problems/maximum-subarray/">https://leetcode.cn/problems/maximum-subarray/</a></p><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong>是数组中的一个连续部分。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,4,-1,7,8]</span><br><span class="line">输出：23</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p>**进阶：**如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p><h2 id="贪心思路">贪心思路</h2><ol><li>当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。</li><li>从代码角度上来讲：遍历 nums，从头开始用 count 累积，如果 count 一旦加上 nums[i]变为负数，那么就应该从 nums[i+1]开始从 0 累积 count 了，因为已经变为负数的 count，只会拖累总和。</li></ol><p><img src="https://file1.kamacoder.com/i/algo/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.gif" alt="img"></p><h2 id="贪心代码">贪心代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># sumOfNums 如果小于等于0，就直接重置</span></span><br><span class="line">        maxOfsum = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">        sumOfNums = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            sumOfNums += i</span><br><span class="line">            <span class="keyword">if</span> maxOfsum &lt; sumOfNums:</span><br><span class="line">                maxOfsum = sumOfNums</span><br><span class="line">            <span class="keyword">if</span> sumOfNums &lt; <span class="number">0</span>:</span><br><span class="line">                sumOfNums = <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> maxOfsum</span><br></pre></td></tr></table></figure><h1 id="376-摆动序列">376. 摆动序列</h1><p><a href="https://leetcode.cn/problems/wiggle-subsequence/">https://leetcode.cn/problems/wiggle-subsequence/</a></p><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 **摆动序列 。**第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p><ul><li>例如， <code>[1, 7, 4, 9, 2, 5]</code> 是一个 <strong>摆动序列</strong> ，因为差值 <code>(6, -3, 5, -7, 3)</code> 是正负交替出现的。</li><li>相反，<code>[1, 4, 7, 2, 5]</code> 和 <code>[1, 7, 4, 5, 5]</code> 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</li></ul><p><strong>子序列</strong> 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p><p>给你一个整数数组 <code>nums</code> ，返回 <code>nums</code> 中作为 <strong>摆动序列</strong> 的 <strong>最长子序列的长度</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,7,4,9,2,5]</span><br><span class="line">输出：6</span><br><span class="line">解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,17,5,10,13,15,10,5,16,8]</span><br><span class="line">输出：7</span><br><span class="line">解释：这个序列包含几个长度为 7 摆动序列。</span><br><span class="line">其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,4,5,6,7,8,9]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li></ul><p>**进阶：**你能否用 <code>O(n)</code> 时间复杂度完成此题?</p><h2 id="贪心思路">贪心思路</h2><p><strong>局部最优：删除单调坡度上的节点（<strong>不包括单调坡度两端的节点</strong>），那么这个坡度就可以有两个局部峰值</strong>。</p><p>整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列。</p><p><img src="https://file1.kamacoder.com/i/algo/20201124174327597.png" alt="img"></p><p><strong>实际操作上，其实连删除的操作都不用做，因为题目要求的是最长摆动子序列的长度，所以只需要统计数组的峰值数量就可以了（相当于是删除单一坡度上的节点，然后统计长度）</strong></p><p><strong>这就是贪心所贪的地方，让峰值尽可能的保持峰值，然后删除单一坡度上的节点</strong></p><p>在计算是否有峰值的时候，大家知道遍历的下标 i ，计算 prediff（nums[i] - nums[i-1]） 和 curdiff（nums[i+1] - nums[i]），如果<code>prediff &lt; 0 &amp;&amp; curdiff &gt; 0</code> 或者 <code>prediff &gt; 0 &amp;&amp; curdiff &lt; 0</code> 此时就有波动就需要统计。</p><p>本题要考虑三种情况</p><ol><li>情况一：上下坡中有平坡</li><li>情况二：数组首尾两端</li><li>情况三：单调坡中有平坡</li></ol><p>情况一：上下坡中有平坡</p><p><img src="https://file1.kamacoder.com/i/algo/20230106170449.png" alt="img"></p><p>这种情况，答案是3</p><p>在图中，当 i 指向第一个 2 的时候，<code>prediff &gt; 0 &amp;&amp; curdiff = 0</code> ，当 i 指向最后一个 2 的时候 <code>prediff = 0 &amp;&amp; curdiff &lt; 0</code>。</p><p>如果我们采用，删左面三个 2 的规则，那么 当 <code>prediff = 0 &amp;&amp; curdiff &lt; 0</code> 也要记录一个峰值，因为他是把之前相同的元素都删掉留下的峰值。</p><p>所以我们记录峰值的条件应该是： <code>(preDiff &lt;= 0 &amp;&amp; curDiff &gt; 0) || (preDiff &gt;= 0 &amp;&amp; curDiff &lt; 0)</code>，为什么这里允许 prediff == 0 ，就是为了 上面我说的这种情况。</p><p><img src="https://file1.kamacoder.com/i/algo/20230106172613.png" alt="img"></p><p>情况二,数组首尾两端</p><p>题目中说了，如果只有两个不同的元素，那摆动序列也是 2。</p><p>例如序列[2,5]，如果靠统计差值来计算峰值个数就需要考虑数组最左面和最右面的特殊情况。</p><p>因为我们在计算 prediff（nums[i] - nums[i-1]） 和 curdiff（nums[i+1] - nums[i]）的时候，至少需要三个数字才能计算，而数组只有两个数字。</p><p>这里我们可以写死，就是 如果只有两个元素，且元素不同，那么结果为 2。</p><p>不写死的话，如何和我们的判断规则结合在一起呢？</p><p>可以假设，数组最前面还有一个数字，那这个数字应该是什么呢？</p><p>之前我们在 讨论 情况一：相同数字连续 的时候， prediff = 0 ，curdiff &lt; 0 或者 &gt;0 也记为波谷。</p><p>那么为了规则统一，针对序列[2,5]，可以假设为[2,2,5]，这样它就有坡度了即 preDiff = 0，如图：</p><p><img src="https://file1.kamacoder.com/i/algo/20201124174357612.png" alt="img"></p><p>针对以上情形，result 初始为 1（默认最右面有一个峰值），此时 curDiff &gt; 0 &amp;&amp; preDiff &lt;= 0，那么 result++（计算了左面的峰值），最后得到的 result 就是 2（峰值个数为 2 即摆动序列长度为 2）</p><p>情况三：单调坡度有平坡</p><p><img src="https://file1.kamacoder.com/i/algo/20230108171505.png" alt="img"></p><p>图中，我们可以看出，版本一的代码在三个地方记录峰值，但其实结果因为是 2，因为 单调中的平坡 不能算峰值（即摆动）。</p><p>之所以版本一会出问题，是因为我们实时更新了 prediff。</p><p>那么我们应该什么时候更新 prediff 呢？</p><p>我们只需要在 这个坡度 摆动变化的时候，更新 prediff 就行，这样 prediff 在 单调区间有平坡的时候 就不会发生变化，造成我们的误判。</p><h2 id="贪心代码">贪心代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wiggleMaxLength</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> L &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> L</span><br><span class="line">        </span><br><span class="line">        curDiff = <span class="number">0</span></span><br><span class="line">        preDiff = <span class="number">0</span></span><br><span class="line">        result = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L - <span class="number">1</span>):</span><br><span class="line">            curDiff = nums[i + <span class="number">1</span>] - nums[i]</span><br><span class="line">            <span class="keyword">if</span> preDiff &lt;= <span class="number">0</span> <span class="keyword">and</span> curDiff &gt; <span class="number">0</span> <span class="keyword">or</span> preDiff &gt;= <span class="number">0</span> <span class="keyword">and</span> curDiff &lt; <span class="number">0</span>:</span><br><span class="line">                result += <span class="number">1</span></span><br><span class="line">                preDiff = curDiff</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday27贪心part01&quot;&gt;LeetCodeCampsDay27贪心part01&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;贪心算法理论与一些基础题目&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;什么是贪心&quot;&gt;什么是贪心&lt;/h2</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>雅思出分(总分7.0/口语7.5)</title>
    <link href="https://blog.lthero.cn/2025/07/21/ExpOfIELTs/"/>
    <id>https://blog.lthero.cn/2025/07/21/ExpOfIELTs/</id>
    <published>2025-07-21T06:52:57.000Z</published>
    <updated>2025-07-21T11:07:39.432Z</updated>
    
    <content type="html"><![CDATA[<p>刚出分，很激动，没想到口语居然帮我提分了；</p><p>从4月开始自己准备，没报班，每天坚持做听力和阅读，可惜临考试的两周时间内没怎么刷这两个，写作本来想最后一个月专项冲刺，但事儿太多被耽误<br>了…</p><p>基础：裸考六级426分，平时有看英文影片的习惯，读研后经常阅读英文文献</p><h2 id="雅思复习经历">雅思复习经历</h2><p>下面按类总结下我的复习雅思经历</p><p>单词：断断续续背了一些，但都没坚持下来；（后悔）单词非常重要，听力哪怕听出来但不会写也不行！</p><p>听力：用的papa雅思，刷剑桥真题，从C9刷到C19，至少每个都刷了两遍；平时会看油管asmongold</p><p>阅读：也是papa雅思，刷真题，从C9到C18都刷了一遍；</p><p>写作：买了本simon的写作书，但咋说呢，记了一些模板但没法灵活应用；主要还是练少了…</p><p>口语：刚开始买个了语料库，按里面内容练习了半个多月，但记了忘，不会活用；直到…闲鱼买了口语老师的课，上了一课就知道我口语准备错方向了；之前死记硬背的口语语料不会灵活应用，跟着老师上了几节课，至少把口语回复的逻辑搞清楚了，感谢～口语就是得多说，并且不要背稿子～</p><h2 id="感受与教训">感受与教训</h2><ol><li>听力和阅读提分还是很快的，因为听力和阅读主要是“输入+处理”，对大家应该不成问题，多刷题多背单词就好；</li><li>写作和口语才是比较难的两个部分，因为它俩是“处理+输出”，需要掌握一些“基础模板句子/短语/用法”后，学会灵活应用这些基础，就像拼积木，用最基础的模块把你的想法灵活表达出来。<ol><li>写了什么或说了什么不是很重要，雅思到底是语言能力考查，而不是知识面的考察，如果你能把水煮白菜都描述得天花乱缀，你就掌握了其核心。</li><li>口语更像是聊天过程，不是很推荐硬记模板，你可以把模板的核心故事记下，然后剩下的东西靠自己编，因为说自己的真实经历会让自己更有自信、更连贯，而背出来的内容很明显能听出来。我对比过回答同一个问题，如果是纯背模板（完全一句不差）会让自己说话像背稿子，很虚假；如果是只记模板核心故事，将它内化为自己的“虚假经历”，在描述时也会更有生情并茂，像是个活人说话～</li></ol></li></ol><h3 id="关于单词">关于单词</h3><p>一定要背单词</p><p>雅思的单词分两类：简单（四级）词需要熟悉且会拼会用；难度（雅思词汇真经）需要看到认识就好</p><ol><li>雅思阅读单词难度比听力与口语要上一个台阶，听力和口语只要把四级词学得非常熟悉（比如会拼写，会用！不仅是会读而是看到词大概知道怎么造句），而雅思阅读的单词看到认识就行了。</li></ol><h3 id="刷题平台">刷题平台</h3><p>雅思哥/papa雅思等都不错，免费好用；写作推荐一些带ai自动判分的网站，比如https://engnovate.com/，虽然需要会员，但价格挺便宜的而且上面范文多，判分也比较准确，当然也可以打造个自己的chatbot专门给写作打分。</p><p><img src="https://cdn.lthero.cn/post_images/course/MLIELTs-2025.7.18%E6%88%90%E7%BB%A9.png" alt="IELTs-2025.7.18成绩"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;刚出分，很激动，没想到口语居然帮我提分了；&lt;/p&gt;
&lt;p&gt;从4月开始自己准备，没报班，每天坚持做听力和阅读，可惜临考试的两周时间内没怎么刷这两个，写作本来想最后一个月专项冲刺，但事儿太多被耽误&lt;br&gt;
了…&lt;/p&gt;
&lt;p&gt;基础：裸考六级426分，平时有看英文影片的习惯，读研</summary>
      
    
    
    
    <category term="IELTs" scheme="https://blog.lthero.cn/categories/IELTs/"/>
    
    
    <category term="IELTs" scheme="https://blog.lthero.cn/tags/IELTs/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay25回溯part04</title>
    <link href="https://blog.lthero.cn/2025/07/19/LeetCodeCampsDay25/"/>
    <id>https://blog.lthero.cn/2025/07/19/LeetCodeCampsDay25/</id>
    <published>2025-07-19T12:47:59.000Z</published>
    <updated>2025-07-20T13:59:59.099Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday25回溯part04">LeetCodeCampsDay25回溯part04</h1><blockquote><p>491是去重复的另一种情况，此时是不能将数组先排序再判断</p></blockquote><h1 id="491-非递减子序列">491. 非递减子序列</h1><p><a href="https://leetcode.cn/problems/non-decreasing-subsequences/">https://leetcode.cn/problems/non-decreasing-subsequences/</a></p><p>给你一个整数数组 <code>nums</code> ，找出并返回所有该数组中不同的递增子序列，递增子序列中 <strong>至少有两个元素</strong> 。你可以按 <strong>任意顺序</strong> 返回答案。</p><p>数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,6,7,7]</span><br><span class="line">输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,4,3,2,1]</span><br><span class="line">输出：[[4,4]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 15</code></li><li><code>-100 &lt;= nums[i] &lt;= 100</code></li></ul><h2 id="回溯思路">回溯思路</h2><p>本题目和<code>90. 子集II</code>有点像，但不同点是，<strong>本题不让排序</strong>，就没法使用nums[i] == nums[i - 1]来判断某个数字是否在本层被用过了，但记住，去重的核心思路是：当前数字num[i]是否在num[start: i]（不包含i）出现过，如果没出现过就可以用，否则continue，比如[7, 6, 7]，需要判断第二个7（即nums[i]，是否在nums[start: i]里）；</p><p>此外，还有个剪枝的条件，如果path的最后一个值比num[i]大，则可以跳过；</p><ol><li>输入输出：输入列表，开始下标；无返回值</li><li>终止条件：如果path长度大于2个就添加，无其它条件（单层逻辑必须保证此时是满足题目要求的）</li><li>单层逻辑：先去重，再剪枝掉path的最后一个值比num[i]大情况（可以不做，因为isLegal函数也会处理），随后，<strong>将当前数字添加到path并使用isLegal函数判断path是否合规</strong>，如果全规则再递归其子串；</li></ol><p><img src="https://file1.kamacoder.com/i/algo/20201124200229824.png" alt="img"></p><h2 id="回溯代码">回溯代码</h2><ul><li>时间复杂度O(N * 2^N)</li><li>空间复杂度O(N)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.res = <span class="built_in">list</span>()</span><br><span class="line">        self.path = <span class="built_in">list</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">islegal</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 需要保证nums[i + 1] &gt;= nums[i]</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], startIndex: <span class="built_in">int</span> = <span class="number">0</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.path) &gt; <span class="number">1</span>:</span><br><span class="line">            self.res.append(self.path[:])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># print(self.path)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 去重</span></span><br><span class="line">            <span class="comment"># 不能用nums[i] == nums[i - 1]来判断，因为能用这个去重的前提是有序的数组，而这题目是无序的</span></span><br><span class="line">            <span class="comment"># 但需要判断当前nums[i]是否在这层之前出现过</span></span><br><span class="line">            <span class="comment"># 比如[7, 6, 7]，需要判断第二个7（即nums[i]，是否在nums[start: i]里）</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> nums[startIndex: i] <span class="keyword">and</span> i &gt; startIndex:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 剪枝</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(self.path) &gt; <span class="number">1</span> <span class="keyword">and</span> self.path[-<span class="number">1</span>] &gt; nums[i]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># </span></span><br><span class="line">            self.path.append(nums[i])</span><br><span class="line">            <span class="comment"># print(self.path)        </span></span><br><span class="line">            <span class="keyword">if</span> self.islegal(self.path[:]):</span><br><span class="line">                self.foo(nums, i + <span class="number">1</span>)</span><br><span class="line">            self.path.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findSubsequences</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 本题似乎不能直接对nums排序，和子集II思路不同</span></span><br><span class="line">        <span class="comment"># 需要个子函数判断当前path里的是否合规</span></span><br><span class="line">        self.foo(nums)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure><h1 id="46-全排列">46. 全排列</h1><p><a href="https://leetcode.cn/problems/permutations/">https://leetcode.cn/problems/permutations/</a></p><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1]</span><br><span class="line">输出：[[0,1],[1,0]]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 6</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li></ul><h2 id="回溯思路">回溯思路</h2><p>画个二叉树的图后，可以发现，随着递归深度增加，for循环遍历的对象是未在path里的元素，所以需要有个used表来记录哪些元素被访问过；可以使用dict或者list实现</p><ol><li>输入输出：输入列表，无返回值</li><li>终止条件：当path长度等于nums长度则添加到res，如果path长度大于nums长度直接退出</li><li>单层逻辑：for循环遍历的对象是未在path里的元素，所以是for i in range(len(nums))；并且需要判断是否被访问过，只递归未访问过的元素</li></ol><h2 id="回溯代码">回溯代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.res = <span class="built_in">list</span>()</span><br><span class="line">        self.path = <span class="built_in">list</span>()</span><br><span class="line">        self.avoidIndex = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.path) == self.targetLen:</span><br><span class="line">            self.res.append(self.path[:])</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.path) &gt; self.targetLen:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> self.avoidIndex.get(nums[i], <span class="number">0</span>) != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 或者使用列表</span></span><br><span class="line">            <span class="comment"># if self.avoidIndex[i] != 0:</span></span><br><span class="line">            <span class="comment">#    continue</span></span><br><span class="line">            self.avoidIndex[nums[i]] = <span class="number">1</span></span><br><span class="line">            self.path.append(nums[i])</span><br><span class="line">            self.foo(nums)</span><br><span class="line">            self.path.pop()</span><br><span class="line">            self.avoidIndex[nums[i]] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        self.targetLen = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 全排列的树和组合类型的树不太一样，不需要使用startIndex，然而它for循环的被迭代对象是&quot;不在path里的所有元素&quot;</span></span><br><span class="line">        self.foo(nums)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure><h1 id="47-全排列-ii">47. 全排列 II</h1><p><a href="https://leetcode.cn/problems/permutations-ii/">https://leetcode.cn/problems/permutations-ii/</a></p><p>给定一个可包含重复数字的序列 <code>nums</code> ，<em><strong>按任意顺序</strong></em> 返回所有不重复的全排列。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 8</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li></ul><h2 id="回溯思路">回溯思路</h2><p>本题目和<code>47.全排列II</code>的不同点是“本题有可重复数字”，面对可重复数字，就需要去重复（比如先排序，再用nums[i]==nums[i-1]判断）；另一方面，本题也需要和一样，需要使用used数组来保证递归时只遍历“剩下”的子串（纵向条件）</p><ol><li>输入输出：输入列表，无直接返回值</li><li>终止条件：当path长度与nums长度相等即添加到res</li><li>单层逻辑：纵向上，只遍历剩余字符串；横向上，需要先去重复，再进行（标记当前数字被use-&gt;添加到path-&gt; 递归下一层 -&gt; 从path弹出回溯-&gt; 标记当前数字未被use)</li><li>这是去重复使用<code>if i &gt; 0 and nums[i] == nums[i - 1] and self.used[i - 1] == 0:                continue</code>，注意这里的<code>self.used[i - 1] == 0</code>，表示只有<strong>nums[i - 1]被用过了，而且nums[i]==nums[i-1]时，才能执行for单层逻辑</strong>，否则就跳过当前数字，因为当nums[i - 1]未被用过时，则nums[i - 1]就已经包含了nums[i]的情况（可以看下面的图）</li></ol><p><strong>还要强调的是去重一定要对元素进行排序，这样我们才方便通过相邻的节点来判断是否重复使用了</strong>。</p><p>我以示例中的 [1,1,2]为例 （为了方便举例，已经排序）抽象为一棵树，去重过程如图：</p><p><img src="https://file1.kamacoder.com/i/algo/20201124201331223.png" alt="img"></p><p><strong>一般来说：组合问题和排列问题是在树形结构的叶子节点上收集结果，而子集问题就是取树上所有节点的结果</strong>。</p><p>在<a href="https://programmercarl.com/0046.%E5%85%A8%E6%8E%92%E5%88%97.html">46.全排列 (opens new window)</a>中已经详细讲解了排列问题的写法，在<a href="https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html">40.组合总和II (opens new window)</a>、<a href="https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html">90.子集II (opens new window)</a>中详细讲解了去重的写法</p><h2 id="回溯代码">回溯代码</h2><ul><li>时间复杂度: O(n! * n)</li><li>空间复杂度: O(n)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.res = <span class="built_in">list</span>()</span><br><span class="line">        self.path = <span class="built_in">list</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.path) == self.targetLen:</span><br><span class="line">            self.res.append(self.path[:])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">          <span class="comment"># 这个used是保证递归时只遍历“剩下”的子串（纵向条件）</span></span><br><span class="line">            <span class="keyword">if</span> self.used[i] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 这个是保证去重复（横向条件），不能只用nums[i] == nums[i - 1]，否则例如输入：[1,1,2]，则不会有&quot;112&quot;这样的输出</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>] <span class="keyword">and</span> self.used[i - <span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 需要再添加个self.used[i - 1] == 0条件，即，只有num[i - 1]被用过了，而且num[i]==num[i-1]时，才能执行for单层逻辑</span></span><br><span class="line">            self.used[i] = <span class="number">1</span></span><br><span class="line">            self.path.append(nums[i])</span><br><span class="line">            self.foo(nums)</span><br><span class="line">            self.path.pop()</span><br><span class="line">            self.used[i] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permuteUnique</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 先对nums排序，再判断nums[i]是否等于nums[i-1]</span></span><br><span class="line">        nums = <span class="built_in">sorted</span>(nums)</span><br><span class="line">        self.targetLen = <span class="built_in">len</span>(nums)</span><br><span class="line">        self.used = [<span class="number">0</span>] * self.targetLen</span><br><span class="line">        self.foo(nums)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line">        </span><br></pre></td></tr></table></figure><h2 id="反思">反思</h2><p>大家发现，去重最为关键的代码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果改成 <code>used[i - 1] == true</code>， 也是正确的!</strong>，去重代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是为什么呢，就是上面我刚说的，如果要对**树层中前一位（横向）<strong>去重，就用<code>used[i - 1] == false</code>，如果要对</strong>树枝前一位（纵向）**去重用<code>used[i - 1] == true</code>。</p><p><strong>对于排列问题，树层上去重（横向）和树枝上去重（纵向），都是可以的，但是树层上去重效率更高！</strong></p><p>这么说是不是有点抽象？</p><p>来来来，我就用输入: [1,1,1] 来举一个例子。</p><p>树层上去重(used[i - 1] == false)的树形结构如下：</p><p><img src="https://file1.kamacoder.com/i/algo/20201124201406192.png" alt="47.全排列II2"></p><p>树枝上去重（used[i - 1] == true）的树型结构如下：</p><p><img src="https://file1.kamacoder.com/i/algo/20201124201431571.png" alt="47.全排列II3"></p><p>大家应该很清晰的看到，<strong>树层上对前一位（横向）去重非常彻底，效率很高</strong>，树枝上对前一位去（纵向）重虽然最后可以得到答案，<strong>但是做了很多无用搜索</strong>。</p><h1 id="51-n-皇后">51. N 皇后</h1><p><a href="https://leetcode.cn/problems/n-queens/">https://leetcode.cn/problems/n-queens/</a></p><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p><p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n 皇后问题</strong> 的解决方案。</p><p>每一种解法包含一个不同的 <strong>n 皇后问题</strong> 的棋子放置方案，该方案中 <code>'Q'</code> 和 <code>'.'</code> 分别代表了皇后和空位。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/queens.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4</span><br><span class="line">输出：[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]</span><br><span class="line">解释：如上图所示，4 皇后问题存在两个不同的解法。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[[&quot;Q&quot;]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 9</code></li></ul><h2 id="回溯思路">回溯思路</h2><blockquote><p>本方法特点：不创建初始棋盘，并且isValid函数也无需对整个棋盘进行遍历</p></blockquote><p>在做了前面的全排列与各种子集问题后，这题目反而不难，完全可以按下面的图，把代码写出来；横向遍历+纵向遍历，仍然使用path记录路径，此外，需要一个判别函数islegal()判断当前位置是否合规（在<code>491.非递减子序列</code>和<code>93. 复原 IP 地址</code> 也使用了islegal函数）</p><ol><li>输入输出：输入棋盘长度，无直接返回值</li><li>终止条件：当path长度与棋盘长度一致，返回结果</li><li>单层逻辑：横向遍历(for循环里)，先判断当前位置(depth, x)是否合规，其中depth指纵向深度下标，x指横向下标；如果合规，再将(depth, x)添加到path里，递归下一个深度，从path弹出回溯。（这里可以仅将x添加到path里，因为depth和x的下标是一样的）</li><li>islegal判断条件：<ol><li>函数功能：当前位置的<strong>上边列、左上角、右上角</strong>没有数字；</li><li>输入输出：输入位置(depth, x) ，输出bool</li><li>不像以往那种，先创建个棋盘，再对棋盘进行遍历；我们仅需要对path和当前位置进行判断即可，对path里的每个元素i遍历<ol><li>假设path记录的是坐标（[0,0], [1,2]），对于一个当前位置[2,0]</li><li>if i[1] == x， 说明当前列(x) 上边有元素，返回False</li><li>if depth - i[0] == x - i[1]，说明当前位置左上角有元素，返回False</li><li>if depth - i[0] == i[1] - x，说明当前位置右上角有元素，返回False</li></ol></li></ol></li></ol><p>判断函数甚至可以精简成这样（但这样就看不出来动机了）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isLegal</span>(<span class="params">self, depth, col</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> self.path:</span><br><span class="line">        <span class="keyword">if</span> i[<span class="number">1</span>] == col <span class="keyword">or</span> depth - i[<span class="number">0</span>] == <span class="built_in">abs</span>(col - i[<span class="number">1</span>]):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，本方法不需要对当前行的左边进行判断，<strong>因为进入当前行时，左边一定是不会有元素的</strong> 我们总是从上到下处理每一行（例如，从行 0 到行 N-1）。 当我们到达第 ⁠depth 行时，⁠self.path 中只包含之前行（0 到 depth-1）的皇后位置</p></blockquote><p><img src="https://file1.kamacoder.com/i/algo/20210130182532303.jpg" alt="img"></p><h2 id="回溯代码">回溯代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.res = <span class="built_in">list</span>()</span><br><span class="line">        self.path = <span class="built_in">list</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 当前path记录的是坐标（比如[0,0], [1,2]），传入的是位置[2,0]</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isLegal</span>(<span class="params">self, depth, col</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.path:</span><br><span class="line">        <span class="comment"># 同一行的左边列是否有皇后</span></span><br><span class="line">        <span class="comment"># 我们到达第 ⁠depth 行时，⁠self.path 中只包含之前行（0 到 depth-1）的皇后位置</span></span><br><span class="line">        <span class="comment"># 所以不用判断</span></span><br><span class="line">            <span class="comment"># if i[0] == depth:</span></span><br><span class="line">                <span class="comment"># return False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 同一列的上边行是否有皇后</span></span><br><span class="line">            <span class="keyword">if</span> i[<span class="number">1</span>] == col:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 若左上角有皇后</span></span><br><span class="line">            <span class="keyword">if</span> depth - i[<span class="number">0</span>] == col - i[<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 若右上角有皇后</span></span><br><span class="line">            <span class="keyword">if</span> depth - i[<span class="number">0</span>] == i[<span class="number">1</span>] - col:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">list2res</span>(<span class="params">self, path: <span class="type">List</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 创建个长度为len(path)的字符</span></span><br><span class="line">        board = <span class="built_in">list</span>()</span><br><span class="line">        L = <span class="built_in">len</span>(path)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> path:</span><br><span class="line">            board.append(<span class="string">&quot;.&quot;</span>*(i[<span class="number">1</span>]) + <span class="string">&quot;Q&quot;</span> + <span class="string">&quot;.&quot;</span>*(L - i[<span class="number">1</span>] - <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> board</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self, n: <span class="built_in">int</span>, depth: <span class="built_in">int</span> = <span class="number">0</span></span>):</span><br><span class="line">        <span class="comment"># 终止条件：深度depth等于n时即可退出</span></span><br><span class="line">        <span class="keyword">if</span> depth == n:</span><br><span class="line">            self.res.append(self.list2res(self.path[:]))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 横向遍历col</span></span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> self.isLegal(depth, col):</span><br><span class="line">                <span class="comment"># path其实可以用记录col，depth本身等于col下标</span></span><br><span class="line">                self.path.append([depth, col])</span><br><span class="line">                self.foo(n, depth + <span class="number">1</span>)</span><br><span class="line">                self.path.pop()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solveNQueens</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span><br><span class="line">        self.foo(n)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure><h2 id="回溯改进思路">回溯改进思路</h2><p>为了判断一个位置所在的列和两条斜线上是否已经有皇后，使用三个集合 columns、diagonals1 和 diagonals2 分别记录每一列以及两个方向的每条斜线上是否有皇后。</p><p>列的表示法很直观，一共有 N 列，每一列的下标范围从 0 到 N−1，使用列的下标即可明确表示每一列。</p><p>如何表示两个方向的斜线呢？对于每个方向的斜线，需要找到斜线上的每个位置的行下标与列下标之间的关系。</p><p>方向一的斜线为从左上到右下方向，同一条斜线上的每个位置满足行下标与列下标之差相等，例如 (0,0) 和 (3,3) 在同一条方向一的斜线上。因此使用行下标与列下标之差即可明确表示每一条方向一的斜线。</p><h2 id="回溯代码2">回溯代码2</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.res = <span class="built_in">list</span>()</span><br><span class="line">        self.path = <span class="built_in">list</span>()</span><br><span class="line">        self.cols = <span class="built_in">set</span>()</span><br><span class="line">        self.diag1 = <span class="built_in">set</span>()</span><br><span class="line">        self.diag2 = <span class="built_in">set</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 当前path记录的是坐标（比如-[0,0], [1,2]），对于一个节点[2,0]</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isLegal</span>(<span class="params">self, depth, x</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">in</span> self.cols:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> depth + x <span class="keyword">in</span> self.diag1:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> depth - x <span class="keyword">in</span> self.diag2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">list2res</span>(<span class="params">self, path: <span class="type">List</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 创建个长度为len(path)的字符串，对i in path，</span></span><br><span class="line">        board = <span class="built_in">list</span>()</span><br><span class="line">        L = <span class="built_in">len</span>(path)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> path:</span><br><span class="line">            board.append(<span class="string">&quot;.&quot;</span>*(i[<span class="number">1</span>]) + <span class="string">&quot;Q&quot;</span> + <span class="string">&quot;.&quot;</span>*(L - i[<span class="number">1</span>] - <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> board</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self, n: <span class="built_in">int</span>, depth: <span class="built_in">int</span> = <span class="number">0</span></span>):</span><br><span class="line">        <span class="comment"># 终止条件：深度y等于n时即可退出</span></span><br><span class="line">        <span class="keyword">if</span> depth == n:</span><br><span class="line">            self.res.append(self.list2res(self.path[:]))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 横向遍历x</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> self.isLegal(depth, x):</span><br><span class="line">                self.path.append([depth, x])</span><br><span class="line">                self.cols.add(x)</span><br><span class="line">                self.diag1.add(depth + x)</span><br><span class="line">                self.diag2.add(depth - x)</span><br><span class="line">                self.foo(n, depth + <span class="number">1</span>)</span><br><span class="line">                self.cols.remove(x)</span><br><span class="line">                self.diag1.remove(depth + x)</span><br><span class="line">                self.diag2.remove(depth - x)</span><br><span class="line">                self.path.pop()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solveNQueens</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span><br><span class="line">        self.foo(n)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure><h1 id="52-n-皇后-ii">52. N 皇后 II</h1><p><a href="https://leetcode.cn/problems/n-queens-ii/">https://leetcode.cn/problems/n-queens-ii/</a></p><p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n × n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 <code>n</code> ，返回 <strong>n 皇后问题</strong> 不同的解决方案的数量。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/queens.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4</span><br><span class="line">输出：2</span><br><span class="line">解释：如上图所示，4 皇后问题存在两个不同的解法。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 9</code></li></ul><h2 id="回溯代码">回溯代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">        self.path = <span class="built_in">list</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 当前path记录的是坐标（比如[0,0], [1,2]），传入的是位置[2,0]</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isLegal</span>(<span class="params">self, depth, col</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.path:</span><br><span class="line">            <span class="keyword">if</span> i[<span class="number">1</span>] == col <span class="keyword">or</span> depth - i[<span class="number">0</span>] == <span class="built_in">abs</span>(col - i[<span class="number">1</span>]):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self, n: <span class="built_in">int</span>, depth: <span class="built_in">int</span> = <span class="number">0</span></span>):</span><br><span class="line">        <span class="comment"># 终止条件：深度depth等于n时即可退出</span></span><br><span class="line">        <span class="keyword">if</span> depth == n:</span><br><span class="line">            self.res += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 横向遍历col</span></span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> self.isLegal(depth, col):</span><br><span class="line">                <span class="comment"># path其实可以用记录col，depth本身等于col下标</span></span><br><span class="line">                self.path.append([depth, col])</span><br><span class="line">                self.foo(n, depth + <span class="number">1</span>)</span><br><span class="line">                self.path.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">totalNQueens</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        self.foo(n)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure><h1 id="332-重新安排行程">332. 重新安排行程</h1><p><a href="https://leetcode.cn/problems/reconstruct-itinerary/">https://leetcode.cn/problems/reconstruct-itinerary/</a></p><p>给你一份航线列表 <code>tickets</code> ，其中 <code>tickets[i] = [fromi, toi]</code> 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。</p><p>所有这些机票都属于一个从 <code>JFK</code>（肯尼迪国际机场）出发的先生，所以该行程必须从 <code>JFK</code> 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。</p><ul><li>例如，行程 <code>[&quot;JFK&quot;, &quot;LGA&quot;]</code> 与 <code>[&quot;JFK&quot;, &quot;LGB&quot;]</code> 相比就更小，排序更靠前。</li></ul><p>假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/14/itinerary1-graph.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：tickets = [[&quot;MUC&quot;,&quot;LHR&quot;],[&quot;JFK&quot;,&quot;MUC&quot;],[&quot;SFO&quot;,&quot;SJC&quot;],[&quot;LHR&quot;,&quot;SFO&quot;]]</span><br><span class="line">输出：[&quot;JFK&quot;,&quot;MUC&quot;,&quot;LHR&quot;,&quot;SFO&quot;,&quot;SJC&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/14/itinerary2-graph.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：tickets = [[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]</span><br><span class="line">输出：[&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]</span><br><span class="line">解释：另一种有效的行程是 [&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;] ，但是它字典排序更大更靠后。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= tickets.length &lt;= 300</code></li><li><code>tickets[i].length == 2</code></li><li><code>fromi.length == 3</code></li><li><code>toi.length == 3</code></li><li><code>fromi</code> 和 <code>toi</code> 由大写英文字母组成</li><li><code>fromi != toi</code></li></ul><h2 id="回溯思路">回溯思路</h2><p>这个方法有点儿怪，题目要求从JFK出发并且绕完所有的机场，题目保证一定有解；所以只要从JFK出发，遍历它能到达的落地节点，再从落地节点出发，遍历落地节点的落地节点……比如，JFK-&gt;KUL，到达KUL则终点了，此时将KUL添加到res里；随后遍历JFK-&gt;NRT，NRT-&gt;JFK，又到了JFK，但此时JFK已经飞过了KUL和NRT（相当于没有从JFK的票了)，于是此时JFK(作为落地节点)被添加到res里；回到NRT，它也没有其它落地节点了，它被添加到res；最后回到JFK(作为初始的出发节点)也被添加到res里。</p><ol><li>回溯的输入输出：输入出发机场和现有的机票，无直接输出</li><li>终止条件：当前出发的机场没有机票时停止，此时将当前机场添加到res里</li><li>单层逻辑：遍历当前出发的机场所有机票，如果有票，先消耗这张票，递归（纵向遍历）这个票的终点机场；<strong>注意，这里没有回溯</strong>，即，不会把消耗的机票还原回去，试想下，如果还原回去，此时就会进入无尽的循环。</li></ol><p>![image-20250720211959981](/Users/lthero/Library/Application Support/typora-user-images/image-20250720211959981.png)</p><h2 id="回溯代码">回溯代码</h2><ul><li>时间复杂度O(nLogN)</li><li>空间复杂度O(N)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.res = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self, airport, targets</span>):</span><br><span class="line">        <span class="keyword">while</span> targets[airport]:</span><br><span class="line">            next_airport = targets[airport].pop()</span><br><span class="line">            self.foo(next_airport, targets)</span><br><span class="line">        <span class="comment"># 当前出发的机场没有机票时停止，此时将当前机场添加到res里</span></span><br><span class="line">        self.res.append(airport)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findItinerary</span>(<span class="params">self, tickets: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">        targets = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> ticket <span class="keyword">in</span> tickets:</span><br><span class="line">            targets[ticket[<span class="number">0</span>]].append(ticket[<span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> targets:</span><br><span class="line">            targets[key].sort(reverse = <span class="literal">True</span>)</span><br><span class="line">        </span><br><span class="line">        self.foo(<span class="string">&quot;JFK&quot;</span>, targets)</span><br><span class="line">        <span class="keyword">return</span> self.res[::-<span class="number">1</span>]</span><br><span class="line">        </span><br></pre></td></tr></table></figure><h1 id="37-解数独">37. 解数独</h1><p><a href="https://leetcode.cn/problems/sudoku-solver/">https://leetcode.cn/problems/sudoku-solver/</a></p><p>编写一个程序，通过填充空格来解决数独问题。</p><p>数独的解法需 <strong>遵循如下规则</strong>：</p><ol><li>数字 <code>1-9</code> 在每一行只能出现一次。</li><li>数字 <code>1-9</code> 在每一列只能出现一次。</li><li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。（请参考示例图）</li></ol><p>数独部分空格内已填入了数字，空白格用 <code>'.'</code> 表示。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]</span><br><span class="line">输出：[[&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;1&quot;,&quot;2&quot;],[&quot;6&quot;,&quot;7&quot;,&quot;2&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;8&quot;],[&quot;1&quot;,&quot;9&quot;,&quot;8&quot;,&quot;3&quot;,&quot;4&quot;,&quot;2&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;],[&quot;8&quot;,&quot;5&quot;,&quot;9&quot;,&quot;7&quot;,&quot;6&quot;,&quot;1&quot;,&quot;4&quot;,&quot;2&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;2&quot;,&quot;6&quot;,&quot;8&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;9&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;1&quot;,&quot;3&quot;,&quot;9&quot;,&quot;2&quot;,&quot;4&quot;,&quot;8&quot;,&quot;5&quot;,&quot;6&quot;],[&quot;9&quot;,&quot;6&quot;,&quot;1&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;2&quot;,&quot;8&quot;,&quot;4&quot;],[&quot;2&quot;,&quot;8&quot;,&quot;7&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;6&quot;,&quot;3&quot;,&quot;5&quot;],[&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;2&quot;,&quot;8&quot;,&quot;6&quot;,&quot;1&quot;,&quot;7&quot;,&quot;9&quot;]]</span><br><span class="line">解释：输入的数独如上图所示，唯一有效的解决方案如下所示：</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>board.length == 9</code></li><li><code>board[i].length == 9</code></li><li><code>board[i][j]</code> 是一位数字或者 <code>'.'</code></li><li>题目数据 <strong>保证</strong> 输入数独仅有一个解</li></ul><p>之前刷到的题目：<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77.组合（组合问题） (opens new window)</a>，<a href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">131.分割回文串（分割问题） (opens new window)</a>，<a href="https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html">78.子集（子集问题） (opens new window)</a>，<a href="https://programmercarl.com/0046.%E5%85%A8%E6%8E%92%E5%88%97.html">46.全排列（排列问题） (opens new window)</a>，以及<a href="https://programmercarl.com/0051.N%E7%9A%87%E5%90%8E.html">51.N皇后（N皇后问题） (opens new window)</a>，其实这些题目都是一维递归。</p><p><a href="https://programmercarl.com/0051.N%E7%9A%87%E5%90%8E.html">N皇后问题 (opens new window)</a>是因为每一行每一列只放一个皇后，只需要一层for循环遍历一行，递归来遍历列，然后一行一列确定皇后的唯一位置。</p><p>本题就不一样了，<strong>本题中棋盘的每一个位置都要放一个数字（而N皇后是一行只放一个皇后），并检查数字是否合法，解数独的树形结构要比N皇后更宽更深</strong>。</p><p><img src="https://file1.kamacoder.com/i/algo/2020111720451790-20230310131816104.png" alt="数独的树"></p><ol><li>输入输出：输入棋盘，输出bool，表示如果找到解就直接一路return，不用继续搜索了</li><li>终止条件：本题递归<strong>不用终止条件</strong>，解数独是要<strong>遍历整个树形结构寻找可能的叶子节点</strong>就立刻返回。</li><li>单层逻辑：横向遍历是对棋盘的高、宽进行二维遍历，此外还需要对数字(1~9)进行逐个横向遍历，仅只有当前位置上(row, col)填写数字i是合规的情况下，才能纵向遍历<ol><li>先判断当前位置是否数字，如果是则跳过</li><li>判断当前位置的数字i是否合规，如果合规，则将board的当前位置更新为这个数字i，再纵向遍历（递归），最后回溯将board当前位置更新为’.’</li></ol></li><li>判断当前位置的数字是否合规<ol><li>判断是否同行、同列、是否同一个小九宫格</li><li>注意小九宫格的判断方法，先求这个小九宫格里的行、列开始坐标，再此坐标上加三即可</li></ol></li></ol><h2 id="回溯代码">回溯代码</h2><p>下面代码会超时，但思路是正确的，超时的原因是九宫格判断，如果要遍历整个棋盘，会浪费大量时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">islegal</span>(<span class="params">self, row: <span class="built_in">int</span>, col: <span class="built_in">int</span>, num: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 判断同行</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.W):</span><br><span class="line">            <span class="keyword">if</span> self.board[row][i] == num:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 判断同列</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.H):</span><br><span class="line">            <span class="keyword">if</span> self.board[i][col] == num:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断九宫格内</span></span><br><span class="line">        <span class="comment"># 先得到num所在的九宫格</span></span><br><span class="line">        rowStart = (row // <span class="number">3</span>) * <span class="number">3</span></span><br><span class="line">        colStart = (col // <span class="number">3</span>) * <span class="number">3</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rowStart, rowStart + <span class="number">3</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(colStart, colStart + <span class="number">3</span>):</span><br><span class="line">                <span class="keyword">if</span> self.board[i][j] == num:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(self.H):</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(self.W):</span><br><span class="line">                <span class="keyword">if</span> self.board[row][col] != <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">                    <span class="keyword">if</span> self.islegal(row, col, <span class="built_in">str</span>(i)):</span><br><span class="line">                        self.board[row][col] = <span class="built_in">str</span>(i)</span><br><span class="line">                        <span class="keyword">if</span> self.foo():</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                        self.board[row][col] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solveSudoku</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.board = board</span><br><span class="line">        self.H = <span class="built_in">len</span>(self.board)</span><br><span class="line">        self.W = <span class="built_in">len</span>(self.board[<span class="number">0</span>])</span><br><span class="line">        self.foo()</span><br><span class="line">        <span class="keyword">return</span> self.board</span><br><span class="line">        </span><br></pre></td></tr></table></figure><p>不超时版本，用空间换时间，给每行每列每个小九宫格添加个used数组，并且！不要使用函数调用！否则一定会超时</p><p>The inline condition is directly part of the loop in your ⁠backtracking method. The Python interpreter can execute it without any extra indirection. In contrast, a method call introduces a “jump” to another part of the code, which can slow things down.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solveSudoku</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.row_used = [<span class="built_in">set</span>() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line">        self.col_used = [<span class="built_in">set</span>() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line">        self.box_used = [<span class="built_in">set</span>() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line">        self.board = board</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">                num = self.board[row][col]</span><br><span class="line">                <span class="keyword">if</span> num == <span class="string">&quot;.&quot;</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                self.row_used[row].add(num)</span><br><span class="line">                self.col_used[col].add(num)</span><br><span class="line">                self.box_used[(row // <span class="number">3</span>) * <span class="number">3</span> + col // <span class="number">3</span>].add(num)</span><br><span class="line">        self.backtracking(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">islegal</span>(<span class="params">self, row: <span class="built_in">int</span>, col: <span class="built_in">int</span>, num: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="keyword">return</span> (num <span class="keyword">not</span> <span class="keyword">in</span> self.row_used[row] <span class="keyword">and</span> num <span class="keyword">not</span> <span class="keyword">in</span> self.col_used[col] <span class="keyword">and</span> num <span class="keyword">not</span> <span class="keyword">in</span> self.box_used[(row // <span class="number">3</span>) * <span class="number">3</span> + col // <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self,</span></span><br><span class="line"><span class="params">        row: <span class="built_in">int</span>,</span></span><br><span class="line"><span class="params">        col: <span class="built_in">int</span>,</span></span><br><span class="line"><span class="params">    </span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> row == <span class="number">9</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        next_row, next_col = (row, col + <span class="number">1</span>) <span class="keyword">if</span> col &lt; <span class="number">8</span> <span class="keyword">else</span> (row + <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> self.board[row][col] != <span class="string">&quot;.&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> self.backtracking(</span><br><span class="line">                next_row, next_col</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">map</span>(<span class="built_in">str</span>, <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>)):</span><br><span class="line">          <span class="comment"># 不要使用函数调用，如果调用self.islegal(row, col, num)一定会超时</span></span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> self.row_used[row] <span class="keyword">and</span> num <span class="keyword">not</span> <span class="keyword">in</span> self.col_used[col] <span class="keyword">and</span> num <span class="keyword">not</span> <span class="keyword">in</span> self.box_used[(row // <span class="number">3</span>) * <span class="number">3</span> + col // <span class="number">3</span>]:</span><br><span class="line">                self.board[row][col] = num</span><br><span class="line">                self.row_used[row].add(num)</span><br><span class="line">                self.col_used[col].add(num)</span><br><span class="line">                self.box_used[(row // <span class="number">3</span>) * <span class="number">3</span> + col // <span class="number">3</span>].add(num)</span><br><span class="line">                <span class="keyword">if</span> self.backtracking(</span><br><span class="line">                    next_row, next_col</span><br><span class="line">                ):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                self.board[row][col] = <span class="string">&quot;.&quot;</span></span><br><span class="line">                self.row_used[row].remove(num)</span><br><span class="line">                self.col_used[col].remove(num)</span><br><span class="line">                self.box_used[(row // <span class="number">3</span>) * <span class="number">3</span> + col // <span class="number">3</span>].remove(num)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday25回溯part04&quot;&gt;LeetCodeCampsDay25回溯part04&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;491是去重复的另一种情况，此时是不能将数组先排序再判断&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;4</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay24回溯part03</title>
    <link href="https://blog.lthero.cn/2025/07/19/LeetCodeCampsDay24/"/>
    <id>https://blog.lthero.cn/2025/07/19/LeetCodeCampsDay24/</id>
    <published>2025-07-19T07:51:05.000Z</published>
    <updated>2025-07-19T12:11:18.313Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday24回溯part03">LeetCodeCampsDay24回溯part03</h1><blockquote><p>再次使用了去重复的技巧，其中78,90两题目像是77.组合的变体，都是每次向path添加一个元素的类型；</p><p>而93 复原ip以及131. 分割回文串都是每次向path添加多个元素的类型</p></blockquote><h1 id="93-复原-ip-地址">93. 复原 IP 地址</h1><p><a href="https://leetcode.cn/problems/restore-ip-addresses/">https://leetcode.cn/problems/restore-ip-addresses/</a></p><p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 <code>0</code> 到 <code>255</code> 之间组成，且不能含有前导 <code>0</code>），整数之间用 <code>'.'</code> 分隔。</p><ul><li>例如：<code>&quot;0.1.2.201&quot;</code> 和<code> &quot;192.168.1.1&quot;</code> 是 <strong>有效</strong> IP 地址，但是 <code>&quot;0.011.255.245&quot;</code>、<code>&quot;192.168.1.312&quot;</code> 和 <code>&quot;192.168@1.1&quot;</code> 是 <strong>无效</strong> IP 地址。</li></ul><p>给定一个只包含数字的字符串 <code>s</code> ，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP 地址</strong>，这些地址可以通过在 <code>s</code> 中插入 <code>'.'</code> 来形成。你 <strong>不能</strong> 重新排序或删除 <code>s</code> 中的任何数字。你可以按 <strong>任何</strong> 顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;25525511135&quot;</span><br><span class="line">输出：[&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;0000&quot;</span><br><span class="line">输出：[&quot;0.0.0.0&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;101023&quot;</span><br><span class="line">输出：[&quot;1.0.10.23&quot;,&quot;1.0.102.3&quot;,&quot;10.1.0.23&quot;,&quot;10.10.2.3&quot;,&quot;101.0.2.3&quot;]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 20</code></li><li><code>s</code> 仅由数字组成</li></ul><h2 id="回溯思路">回溯思路</h2><p>本题难度还是有的，但在做了<code>131.分割回文串</code> 后，会发现这两个题目思路是相似的</p><p>在131.里，需要先在for循环里判断 s[start, i+1]是否是回文串，如果是再添加到path里；而这题目也是如此，先判断s[start, i+1]是否是合规的数字（比如数字不大于255，如果0开头则必须只能有0，数字长度不大于4）；如果合规，再将数字添加到path里，再纵向搜索，再弹出以回溯；</p><ol><li>输入输出：输入字符串，以及startIndex, 和深度（因为ip最多四个整数，所以深度只有4，depth等于5时需要收割结果）</li><li>终止条件：当startIndex小于len(s)时，需要判断如果深度已经为4且len(s[startIndex:])大于3（即明显会有多余的数字不会被处理），直接返回，<strong>从而保证deepth==5时，一定是可以收割结果的</strong>；当startIndex不小于len(s)，且depth等于5，此时才将结果添加到res</li><li>单层逻辑：先判断s[start, i+1]是否是合规的数字，如果合规，再将数字添加到path里，再纵向搜索，再弹出以回溯；</li></ol><p>131.和本题都是每次将s[start: i+1]子串添加到path里，而最早做的<code>77.组合</code> 以及下面的<code>78.子集</code>每次只用添加一个元素s[i]到path里</p><p>另外，这里的深度，可以用len(self.path[:]) == 4 来判断，只要保证<strong>只有当self.path长度为4时才能收割结果。</strong></p><p><img src="https://file1.kamacoder.com/i/algo/20201123203735933.png" alt="img"></p><h2 id="回溯代码">回溯代码</h2><ul><li>时间复杂度: O(3^4)，IP地址最多包含4个数字，每个数字最多有3种可能的分割方式，则搜索树的最大深度为4，每个节点最多有3个子节点。</li><li>空间复杂度: O(n)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 本题目的递归深度为4</span></span><br><span class="line">    <span class="comment"># 横向遍历的条件，长度从1到3（闭区间）进行遍历（且不能0开始)，剩下的交给纵向</span></span><br><span class="line">    <span class="comment"># 纵向遍历的终止条件，如果最后一次剩下的数字大于3就返回，</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.res = <span class="built_in">list</span>()</span><br><span class="line">        self.path = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isLegal</span>(<span class="params">self, s</span>):</span><br><span class="line">        <span class="comment"># 如果开头数字是0，则单独划分，不用继续for循环了</span></span><br><span class="line">        LofS = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span> <span class="keyword">and</span> LofS &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 长度大于3，可以不加，传入时已经保证了长度不会大于3</span></span><br><span class="line">        <span class="keyword">if</span> LofS &gt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 大于255</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">int</span>(s) &gt; <span class="number">255</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">List2IPform</span>(<span class="params">self, s: <span class="type">List</span></span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;.&quot;</span>.join(s)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self, s: <span class="built_in">str</span>, startIndex: <span class="built_in">int</span> = <span class="number">0</span>, depth: <span class="built_in">int</span> = <span class="number">1</span></span>):</span><br><span class="line">        LofS = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="comment"># 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> startIndex &lt; LofS:</span><br><span class="line">          <span class="comment"># 如果最后一次剩下的数字大于3就返回，保证deepth==5时，一定是可以收割结果的</span></span><br><span class="line">            <span class="keyword">if</span> depth == <span class="number">4</span> <span class="keyword">and</span> <span class="built_in">len</span>(s[startIndex:]) &gt; <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> depth == <span class="number">5</span>:</span><br><span class="line">                self.res.append(self.List2IPform(self.path[:]))</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 横向遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, LofS):</span><br><span class="line">            <span class="comment"># 如果大于3个长度，直接断</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; startIndex + <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 检测startIndex到i的字符串是否合规</span></span><br><span class="line">            <span class="keyword">if</span> self.isLegal(s[startIndex: i + <span class="number">1</span>]):</span><br><span class="line">              <span class="comment"># 注意这里是一次添加了s[start: i+1]个元素进去</span></span><br><span class="line">                self.path.append(s[startIndex: i + <span class="number">1</span>])</span><br><span class="line">                <span class="comment"># 剩下的子串交给纵向遍历</span></span><br><span class="line">                self.foo(s, i + <span class="number">1</span>, depth + <span class="number">1</span>)</span><br><span class="line">                self.path.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">restoreIpAddresses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        self.foo(s)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure><h1 id="78-子集">78. 子集</h1><p><a href="https://leetcode.cn/problems/subsets/">https://leetcode.cn/problems/subsets/</a></p><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li></ul><h2 id="回溯思路">回溯思路</h2><ol><li>这题，需要把所有可能的子集都放在res里，本质上是遍历所有可能，在<code>77组合</code>里是求’k’个数的组合，那题目的终止条件（添加到res的条件）是len(path) == k，比如下图所示，只有当path里装了2个时，才将结果放在res；</li></ol><p><img src="https://file1.kamacoder.com/i/algo/20201123195223940.png" alt="77组合,k=2的图片"></p><p>而本题需要将所有遍历结果都装到res，所以它的终止条件（将结果放在res的条件）是空</p><p>所以本题的</p><ol><li>输入输出：输入列表和起点下标，无返回值</li><li>终止条件：无</li><li>单层逻辑：添加一个元素s[i]到path里，递归下一层，弹出s[i]以回溯</li></ol><p><img src="https://file1.kamacoder.com/i/algo/78.%E5%AD%90%E9%9B%86.png" alt="本题图片"></p><h2 id="回溯代码">回溯代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.res = <span class="built_in">list</span>()</span><br><span class="line">        self.path = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], startIndex: <span class="built_in">int</span> = <span class="number">0</span></span>):</span><br><span class="line">        <span class="comment"># 终止条件是空，所有的self.path都能直接丢进去</span></span><br><span class="line">        self.res.append(self.path[:])</span><br><span class="line">        <span class="comment"># 横向遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, LofNums):</span><br><span class="line">          <span class="comment"># 注意，这次只用一次添加一个元素进去</span></span><br><span class="line">            self.path.append(nums[i])</span><br><span class="line">            <span class="comment"># 纵向遍历</span></span><br><span class="line">            self.foo(nums, i + <span class="number">1</span>)</span><br><span class="line">            self.path.pop()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        self.foo(nums)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure><h1 id="90-子集-ii">90. 子集 II</h1><p><a href="https://leetcode.cn/problems/subsets-ii/">https://leetcode.cn/problems/subsets-ii/</a></p><p>给你一个整数数组 <code>nums</code> ，其中可能包含重复元素，请你返回该数组所有可能的 子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,2]</span><br><span class="line">输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li></ul><h2 id="回溯思路">回溯思路</h2><ol><li>这题目和<code>40.组合总和II</code>以及<code>78.子集</code>有点像，不同点是本题需要去重复（去重复的思路和<code>40.组合总和II</code>一样，不过我记得这种需要让nums[i]!=nums[i-1]的思路在之前的题目也遇到过）</li><li>本题和<code>78.子集</code>相比，只添加了这个去重复的约束条件，其它代码一样</li></ol><h2 id="回溯代码">回溯代码</h2><ul><li>时间复杂度: O(n * 2^n)</li><li>空间复杂度: O(n)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.res = <span class="built_in">list</span>()</span><br><span class="line">        self.path = <span class="built_in">list</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], startIndex: <span class="built_in">int</span> = <span class="number">0</span></span>):</span><br><span class="line">        self.res.append(self.path[:])</span><br><span class="line">        <span class="comment"># print(self.path)</span></span><br><span class="line">        LofNums = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, LofNums):</span><br><span class="line">            <span class="keyword">if</span> i &gt; startIndex <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            self.path.append(nums[i])</span><br><span class="line">            self.foo(nums, i + <span class="number">1</span>)</span><br><span class="line">            self.path.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsetsWithDup</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        nums = <span class="built_in">sorted</span>(nums)</span><br><span class="line">        self.foo(nums)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday24回溯part03&quot;&gt;LeetCodeCampsDay24回溯part03&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;再次使用了去重复的技巧，其中78,90两题目像是77.组合的变体，都是每次向path添加一个元素的类型；&lt;/p&gt;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay23回溯part02</title>
    <link href="https://blog.lthero.cn/2025/07/18/LeetCodeCampsDay23/"/>
    <id>https://blog.lthero.cn/2025/07/18/LeetCodeCampsDay23/</id>
    <published>2025-07-18T10:21:47.000Z</published>
    <updated>2025-07-19T12:12:29.397Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday23回溯part02">LeetCodeCampsDay23回溯part02</h1><blockquote><p>40.组合总和2使用了去重复的技巧，而131分割回文串是每次向path添加多个元素的类型</p><p>39.和40都是每次向path添加一个元素的类型；</p></blockquote><h1 id="39-组合总和">39. 组合总和</h1><p><a href="https://leetcode.cn/problems/combination-sum/">https://leetcode.cn/problems/combination-sum/</a></p><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。</p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates = [2,3,6,7], target = 7</span><br><span class="line">输出：[[2,2,3],[7]]</span><br><span class="line">解释：</span><br><span class="line">2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。</span><br><span class="line">7 也是一个候选， 7 = 7 。</span><br><span class="line">仅有这两种组合。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2,3,5], target = 8</span><br><span class="line">输出: [[2,2,2,2],[2,3,3],[3,5]]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2], target = 1</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= candidates.length &lt;= 30</code></li><li><code>2 &lt;= candidates[i] &lt;= 40</code></li><li><code>candidates</code> 的所有元素 <strong>互不相同</strong></li><li><code>1 &lt;= target &lt;= 40</code></li></ul><h2 id="回溯思路">回溯思路</h2><ol><li>和 <code>77组合</code> ，以及 <code>216.组合总和III</code> 很像，唯一区别是start位置，在77组合里，每层for循环里的下一个递归函数start为i+1，而这题目里下一个递归函数start为i即可；同样使用一个path记录路径，必要时计算path的和</li><li>输入一个候选列表，目标值，以及开始位置of候选列表</li><li>终止条件：sum of path如果大于target则终止；如果等于target则res添加path</li><li>单层逻辑：把当前值添加到path，递归下一轮（注意start需要包含当前值），再让path将当前值弹出</li></ol><p>如果，start值一直是0，会得到如[2,2,3],[3,2,2]这种重复的结果（注意题目要求不包含重复的组合）</p><p><img src="https://file1.kamacoder.com/i/algo/20201223170730367.png" alt="img"></p><h2 id="回溯代码">回溯代码</h2><ul><li>时间复杂度O(N * 2 ^ T)</li><li>空间复杂度O(T)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.res = <span class="built_in">list</span>()</span><br><span class="line">        self.path = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self, candidates: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span>, start: <span class="built_in">int</span> = <span class="number">0</span></span>):</span><br><span class="line">        sumOfPath = <span class="built_in">sum</span>(self.path)</span><br><span class="line">        <span class="keyword">if</span> sumOfPath &gt; target:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">elif</span> sumOfPath == target:</span><br><span class="line">            self.res.append(self.path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        L = <span class="built_in">len</span>(candidates)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, L):</span><br><span class="line">            self.path.append(candidates[i])</span><br><span class="line">            self.foo(candidates, target, i)</span><br><span class="line">            self.path.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum</span>(<span class="params">self, candidates: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        self.foo(candidates, target, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure><h1 id="40-组合总和-ii">40. 组合总和 II</h1><p><a href="https://leetcode.cn/problems/combination-sum-ii/">https://leetcode.cn/problems/combination-sum-ii/</a></p><p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。</p><p>**注意：**解集不能包含重复的组合。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">[1,1,6],</span><br><span class="line">[1,2,5],</span><br><span class="line">[1,7],</span><br><span class="line">[2,6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2,5,2,1,2], target = 5,</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">[1,2,2],</span><br><span class="line">[5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= candidates.length &lt;= 100</code></li><li><code>1 &lt;= candidates[i] &lt;= 50</code></li><li><code>1 &lt;= target &lt;= 30</code></li></ul><h2 id="回溯思路">回溯思路</h2><blockquote><p>本题目前一题目有点儿像，但不同点在于：本题要求不能有相同组合，第一想法是使用字典或set排队重复元素，但这样会导致超时（比如[1,1,1,1,…,1], target=30会发生超时）；<strong>所以需要在每层处理时就进行去重复</strong>，注意，<strong>下面的方法必须先对数组排序</strong></p></blockquote><ol><li>输入还是candidates和target，以及start节点；</li><li>终止条件：sumOfPath &gt; target则退出，等于target则添加到res；</li><li>单层逻辑：[剪枝]若sumOfPath + candidates[i]大于target则遍历下一个元素（或者直接return, 如果candiates已经排序过了），判断candidates[i - 1] == candidates[i]，目的是防止相同的元素再参与，<strong>注意只要使用continue即可</strong>，别使用return或break，因为后面还需要继续遍历</li></ol><p>下面这图的重点是：同一层如果有重复元素就不重复选取了，而不同层如果有重复元素是可以重复选的；比如[1,1,1,1,1,…,1]，target=30，对第一个1来说，后面的[1,1,1,1…,1]都可以选；而对第二个1来说</p><p><img src="https://file1.kamacoder.com/i/algo/20230310000954.png" alt="img"></p><p>我在图中将used的变化用橘黄色标注上，可以看出在candidates[i] == candidates[i - 1]相同的情况下：</p><ul><li>used[i - 1] == true，说明同一树枝candidates[i - 1]使用过</li><li>used[i - 1] == false，说明同一树层candidates[i - 1]使用过</li></ul><p>可能有的录友想，为什么 used[i - 1] == false 就是同一树层呢，因为同一树层，used[i - 1] == false 才能表示，当前取的 candidates[i] 是从 candidates[i - 1] 回溯而来的。</p><p>而 used[i - 1] == true，说明是进入下一层递归，去下一个数，所以是树枝上，如图所示：</p><p><img src="https://file1.kamacoder.com/i/algo/20221021163812.png" alt="img"></p><p>注意，下面的方法必须先对数组排序</p><p>注意，下面的方法必须先对数组排序</p><p>注意，下面的方法必须先对数组排序</p><p>相似的题目还有<code>90.子集II</code></p><h2 id="回溯代码">回溯代码</h2><ul><li>时间复杂度: O(n * 2^n)</li><li>空间复杂度: O(n)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.res = <span class="built_in">list</span>()</span><br><span class="line">        self.path = <span class="built_in">list</span>()</span><br><span class="line">        self.sumOfPath = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self, candidates, target, start: <span class="built_in">int</span> = <span class="number">0</span></span>):</span><br><span class="line">        <span class="keyword">if</span> self.sumOfPath &gt; target:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> self.sumOfPath == target:</span><br><span class="line">            self.res.append(self.path[:])</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        </span><br><span class="line">        L = <span class="built_in">len</span>(candidates)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, L):</span><br><span class="line">            <span class="keyword">if</span> self.sumOfPath + candidates[i] &gt; target:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"><span class="comment"># 要对同一树层使用过的元素进行跳过</span></span><br><span class="line">            <span class="keyword">if</span> candidates[i - <span class="number">1</span>] == candidates[i] <span class="keyword">and</span> i &gt; start:</span><br><span class="line">              <span class="comment"># 注意只要使用continue即可，别使用return或break，因为后面还需要继续遍历</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            self.sumOfPath += candidates[i]</span><br><span class="line">            self.path.append(candidates[i])</span><br><span class="line"><span class="comment"># 不带当前元素自身</span></span><br><span class="line">            self.foo(candidates, target, i + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            self.sumOfPath -= candidates[i]</span><br><span class="line">            self.path.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum2</span>(<span class="params">self, candidates: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        candidates = <span class="built_in">sorted</span>(candidates)</span><br><span class="line">        self.foo(candidates, target)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure><h1 id="131-分割回文串">131. 分割回文串</h1><p><a href="https://leetcode.cn/problems/palindrome-partitioning/">https://leetcode.cn/problems/palindrome-partitioning/</a></p><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些 子串，使每个子串都是 <strong>回文串</strong> 。返回 <code>s</code> 所有可能的分割方案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aab&quot;</span><br><span class="line">输出：[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;a&quot;</span><br><span class="line">输出：[[&quot;a&quot;]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 16</code></li><li><code>s</code> 仅由小写英文字母组成</li></ul><h2 id="回溯思路">回溯思路</h2><p>注意给的示例s=‘aab’的输出是[[“a”,“a”,“b”],[“aa”,“b”]]，可以看出来是先将’a’添加到path,再分别把’a’和’b’添加到path；每个次是先将’aa’添加到path，再将’b’添加到path；说明一点，横向上的startIndex是向右增加的，而纵向上，先处理’a’，再处理’a’的子串’ab’</p><p>本题里仍使用回溯算法，其中，横向遍历（for循环）需要判断s[start:i+1]这段子串是否是回文的，比如第一次for循环执行：‘a’, ‘aa’, ‘aab’，<strong>如果’a’是回文的</strong>，才对后面的’ab’进行递归，去处理子段；</p><p><img src="https://file1.kamacoder.com/i/algo/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg" alt="img"></p><h2 id="回溯代码">回溯代码</h2><ul><li>时间复杂度: O(n * 2^n)</li><li>空间复杂度: O(n^2)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 和kmp无关</span></span><br><span class="line">    <span class="comment"># path记录路径，res记录结果</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.res = <span class="built_in">list</span>()</span><br><span class="line">        self.path = <span class="built_in">list</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isP</span>(<span class="params">self, s: <span class="built_in">str</span>, start: <span class="built_in">int</span> = <span class="number">0</span>, end: <span class="built_in">int</span> = <span class="number">0</span></span>):</span><br><span class="line">        leftPoint = start</span><br><span class="line">        rightPoint = end</span><br><span class="line">        <span class="keyword">while</span> leftPoint &lt; rightPoint:</span><br><span class="line">            <span class="keyword">if</span> s[leftPoint] != s[rightPoint]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            leftPoint += <span class="number">1</span></span><br><span class="line">            rightPoint -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self, s: <span class="built_in">str</span>, start: <span class="built_in">int</span> = <span class="number">0</span></span>):</span><br><span class="line">        LofPath = <span class="built_in">len</span>(self.path)</span><br><span class="line">        LofS = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">if</span> start &gt;= LofS:</span><br><span class="line">            self.res.append(self.path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, LofS):</span><br><span class="line">            <span class="comment"># 如果是回文，才将这段子串添加到path里，再去递归它的剩下子串</span></span><br><span class="line">            <span class="keyword">if</span> self.isP(s, start, i):</span><br><span class="line">                self.path.append(s[start: i + <span class="number">1</span>])</span><br><span class="line">                self.foo(s, i + <span class="number">1</span>)</span><br><span class="line">                self.path.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span><br><span class="line">        self.foo(s)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday23回溯part02&quot;&gt;LeetCodeCampsDay23回溯part02&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;40.组合总和2使用了去重复的技巧，而131分割回文串是每次向path添加多个元素的类型&lt;/p&gt;
&lt;p&gt;39.和</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay22回溯part01</title>
    <link href="https://blog.lthero.cn/2025/07/17/LeetCodeCampsDay22/"/>
    <id>https://blog.lthero.cn/2025/07/17/LeetCodeCampsDay22/</id>
    <published>2025-07-17T13:14:31.000Z</published>
    <updated>2025-07-17T14:47:49.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday22回溯part01">LeetCodeCampsDay22回溯part01</h1><blockquote><p>包含回溯基础内容，虽然和递归还有点儿像的哦</p></blockquote><h2 id="理论基础">理论基础</h2><h3 id="什么是回溯法">什么是回溯法</h3><p>回溯法也可以叫做回溯搜索法，它是一种搜索的方式。</p><p>在二叉树系列中，我们已经不止一次，提到了回溯，例如<a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E9%80%92%E5%BD%92%E5%B8%A6%E7%9D%80%E5%9B%9E%E6%BA%AF.html">二叉树：以为使用了递归，其实还隐藏着回溯 (opens new window)</a>。</p><p>回溯是递归的副产品，只要有递归就会有回溯。</p><p><strong>所以以下讲解中，回溯函数也就是递归函数，指的都是一个函数</strong></p><p>在递归中必有回溯，只是之前都没有用到回溯的操作</p><hr><h3 id="回溯法的效率">回溯法的效率</h3><p>回溯法的性能如何呢，这里要和大家说清楚了，<strong>虽然回溯法很难，很不好理解，但是回溯法并不是什么高效的算法</strong>。</p><p><strong>因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案</strong>，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。</p><p>那么既然回溯法并不高效为什么还要用它呢？</p><p>因为没得选，一些问题能暴力搜出来就不错了，撑死了再剪枝一下，还没有更高效的解法。</p><p>此时大家应该好奇了，都什么问题，这么牛逼，只能暴力搜索</p><h3 id="如何理解回溯法">如何理解回溯法</h3><p><strong>回溯法解决的问题都可以抽象为树形结构</strong>，是的，我指的是所有回溯法的问题都可以<strong>抽象为树形结构</strong>！</p><p>因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度就构成了树的深度</strong>。</p><p>递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。</p><p>这块可能初学者还不太理解，后面的回溯算法解决的所有题目中，我都会强调这一点并画图举相应的例子，现在有一个印象就行。</p><h3 id="回溯模板">回溯模板</h3><ol><li>确定回溯的输入与输出值（是否有返回值）</li><li>终止条件（必有）</li><li>单层逻辑，在回溯里的单层逻辑往往需要使用for循环（横向遍历），这里的横向遍历是指单层逻辑需要处理的事儿</li></ol><p>回溯函数代码</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void backtracking(参数)</span><br></pre></td></tr></table></figure><p>终止条件代码</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (终止条件) &#123;</span><br><span class="line">    存放结果;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单层逻辑代码</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">    处理节点;</span><br><span class="line">    backtracking(路径，选择列表); // 递归</span><br><span class="line">    回溯，撤销处理结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如下面的例子里，<strong>递归是用来纵向遍历，而for遍历是单层逻辑里的横向遍历</strong>（注意回溯本身就是暴力搜索，或者说本身就是一堆for循环的变体）</p><p>for循环就是遍历子集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次</p><p><img src="https://file1.kamacoder.com/i/algo/20210130173631174.png" alt="img"></p><h1 id="77-组合">77. 组合</h1><p><a href="https://leetcode.cn/problems/combinations/">https://leetcode.cn/problems/combinations/</a></p><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4, k = 2</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1, k = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li><li><code>1 &lt;= k &lt;= n</code></li></ul><h2 id="回溯思路">回溯思路</h2><p>输入：n = 100, k = 3 那么就三层for循环，代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> n = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> u = j + <span class="number">1</span>; u &lt;= n; n++) &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; u &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但如果n=100, k = 50，此时需要写50个for循环吗？大可不必，使用回溯即可替代这么多for循环操作</p><p>将这个问题抽象出来，把它使用树进行展开，每个问题解构成子问题，则(1,2,3,4)的一个子树为(2,3,4)，(3,4), (4), ()；而所谓得到k集合，就是将取出来的数添加到path中；有点儿像<code>257. 二叉树的所有路径</code>；</p><blockquote><p>注意点一：如果子树里也是(1,2,3,4), (1,2,3,4), (1,2,3,4), (1,2,3,4)则得到的全排列，但题目里要求的是组合，比如(1,2)和(2,1)被认为一个组合，且组合里的数字只能使用一次</p></blockquote><p><img src="https://file1.kamacoder.com/i/algo/20201123195223940.png" alt="img"></p><h2 id="回溯代码">回溯代码</h2><ul><li>时间复杂度O(C(n,k)*k)</li><li>空间复杂度O(C(n,k)*k)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.res = <span class="built_in">list</span>()</span><br><span class="line">        self.path = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span>, start = <span class="number">1</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.path) == k:</span><br><span class="line">            <span class="comment"># 注意这里不能只用append(self.path),必须使用self.path[:],否则最终输出的self.res为空</span></span><br><span class="line">            <span class="comment"># 如果直接使用 ⁠self.path，你实际上是在向 ⁠self.res 中添加一个对 ⁠self.path 列表的引用</span></span><br><span class="line">            <span class="comment"># 而不是列表的副本。这会导致后续对 ⁠self.path 的修改影响到已经添加到 ⁠self.res 中的元素，从而导致结果错误。</span></span><br><span class="line">            self.res.append(self.path[:])</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, n + <span class="number">1</span>):</span><br><span class="line">            self.path.append(i)</span><br><span class="line">            self.foo(n, k, i + <span class="number">1</span>)</span><br><span class="line">            self.path.pop()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combine</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        self.foo(n, k, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure><h2 id="剪枝操作">剪枝操作</h2><p>添加一个判断，如果k大于<code>n - i + 1 + len(self.path)</code> ，说明后面的组合数量不可能满足k个，直接剪掉</p><p><img src="https://file1.kamacoder.com/i/algo/20210130194335207-20230310134409532.png" alt="img"></p><h2 id="包含剪枝的代码">包含剪枝的代码</h2><ul><li>时间复杂度O(C(n, k) * k)</li><li>空间复杂度O(C(n, k)* k + k)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.res = <span class="built_in">list</span>()</span><br><span class="line">        self.path = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span>, start = <span class="number">1</span></span>):</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.path) == k:</span><br><span class="line">            <span class="comment"># 注意这里不能只用append(self.path),必须使用self.path[:],否则最终输出的self.res为空</span></span><br><span class="line">            <span class="comment"># 如果直接使用 ⁠self.path，你实际上是在向 ⁠self.res 中添加一个对 ⁠self.path 列表的引用</span></span><br><span class="line">            <span class="comment"># 而不是列表的副本。这会导致后续对 ⁠self.path 的修改影响到已经添加到 ⁠self.res 中的元素，从而导致结果错误。</span></span><br><span class="line">            self.res.append(self.path[:])</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, n + <span class="number">1</span>):</span><br><span class="line">       <span class="comment"># 剪枝操作</span></span><br><span class="line">            <span class="keyword">if</span> k &gt; n - i + <span class="number">1</span> + <span class="built_in">len</span>(self.path):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            self.path.append(i)</span><br><span class="line">            self.foo(n, k, i + <span class="number">1</span>)</span><br><span class="line">            self.path.pop()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combine</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        self.foo(n, k, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure><h1 id="216-组合总和-iii">216. 组合总和 III</h1><p><a href="https://leetcode.cn/problems/combination-sum-iii/">https://leetcode.cn/problems/combination-sum-iii/</a></p><p>找出所有相加之和为 <code>n</code> 的 <code>k</code> 个数的组合，且满足下列条件：</p><ul><li>只使用数字1到9</li><li>每个数字 <strong>最多使用一次</strong></li></ul><p>返回 <em>所有可能的有效组合的列表</em> 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: k = 3, n = 7</span><br><span class="line">输出: [[1,2,4]]</span><br><span class="line">解释:</span><br><span class="line">1 + 2 + 4 = 7</span><br><span class="line">没有其他符合的组合了。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: k = 3, n = 9</span><br><span class="line">输出: [[1,2,6], [1,3,5], [2,3,4]]</span><br><span class="line">解释:</span><br><span class="line">1 + 2 + 6 = 9</span><br><span class="line">1 + 3 + 5 = 9</span><br><span class="line">2 + 3 + 4 = 9</span><br><span class="line">没有其他符合的组合了。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: k = 4, n = 1</span><br><span class="line">输出: []</span><br><span class="line">解释: 不存在有效的组合。</span><br><span class="line">在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 &gt; 1，没有有效的组合。</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>2 &lt;= k &lt;= 9</code></li><li><code>1 &lt;= n &lt;= 60</code></li></ul><h2 id="回溯代码">回溯代码</h2><ul><li>时间复杂度O(C(9,k)*k)</li><li>空间复杂度O(C(9,k)*k + k)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.res = <span class="built_in">list</span>()</span><br><span class="line">        self.path = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self, k: <span class="built_in">int</span>, n: <span class="built_in">int</span>, end = <span class="number">9</span>, start = <span class="number">1</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.path) == k:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(self.path[:]) == n:</span><br><span class="line">                self.res.append(self.path[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(self.path) &gt; k:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, end + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 剪枝一，按个数剪枝</span></span><br><span class="line">            <span class="keyword">if</span> k &gt; n - i + <span class="number">1</span> + <span class="built_in">len</span>(self.path):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 剪枝二，按path的和判断，如果已经大于n，则必须不成立</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(self.path[:]) &gt; n:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            self.path.append(i)</span><br><span class="line">            self.foo(k, n, end, i + <span class="number">1</span>)</span><br><span class="line">            self.path.pop()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum3</span>(<span class="params">self, k: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 使用递归，思路和组合1有点儿像，但这次需要将所有的数字仍放在path中</span></span><br><span class="line">        <span class="comment"># 判断sum of path是否等于n，如果等于n则添加到res</span></span><br><span class="line">        self.foo(k, n)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure><h1 id="17-电话号码的字母组合">17. 电话号码的字母组合</h1><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">https://leetcode.cn/problems/letter-combinations-of-a-phone-number/</a></p><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://pic.leetcode.cn/1752723054-mfIHZs-image.png" alt="img"></p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;&quot;</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;2&quot;</span><br><span class="line">输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= digits.length &lt;= 4</code></li><li><code>digits[i]</code> 是范围 <code>['2', '9']</code> 的一个数字。</li></ul><h2 id="回溯思路">回溯思路</h2><p>先构建个<code>alphaB = [&quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;]</code></p><p>比如digits=“623”，则</p><ol><li>与前面两个相似，纵向的遍历是6-&gt;2-&gt;3；而第一层是mno，第二层是&quot;abc&quot;, “abc”, “abc”，第三层是九个&quot;def&quot;</li><li>回溯输入digits以及在digits开始的下标，无返回值</li><li>终止条件：如果start大于等于len(digits)说明已经遍历完了，此时若self.path不为空，则添加到self.res里</li><li>单层逻辑：先从alphaB取出当前digits[start]对应数字的字母表，对逐个字母遍历并添加到path里，再递归到下一个digit，最终再path弹出之前添加的字母<ol><li>比如6-&gt;‘mno’，对’mno’进行遍历；将m添加到path里，然后递归到digits[start+1]，即2-&gt;‘abc’，再对’abc’遍历，将a添加到path里，此时path长度等于digits长度，将’ma’添加到res并退出；此时回溯，path弹出’a’，再将b添加到path里，重复……</li></ol></li></ol><p><img src="https://file1.kamacoder.com/i/algo/20201123200304469.png" alt="img"></p><h2 id="回溯代码">回溯代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.alphaB = [<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>]</span><br><span class="line">        self.path = <span class="built_in">list</span>()</span><br><span class="line">        self.res = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self, digits, start</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(digits) <span class="keyword">or</span> start &gt;= <span class="built_in">len</span>(digits):</span><br><span class="line">            res = <span class="string">&quot;&quot;</span>.join(self.path[:])</span><br><span class="line">            <span class="keyword">if</span> res != <span class="string">&quot;&quot;</span>:</span><br><span class="line">                self.res.append(res)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.alphaB[<span class="built_in">int</span>(digits[start])]:</span><br><span class="line">            self.path.append(i)</span><br><span class="line">            self.foo(digits, start + <span class="number">1</span>)</span><br><span class="line">            self.path.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">letterCombinations</span>(<span class="params">self, digits: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="comment"># 递归</span></span><br><span class="line">        self.foo(digits, <span class="number">0</span>)        </span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday22回溯part01&quot;&gt;LeetCodeCampsDay22回溯part01&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;包含回溯基础内容，虽然和递归还有点儿像的哦&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;理论基础&quot;&gt;理论</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay21</title>
    <link href="https://blog.lthero.cn/2025/07/15/LeetCodeCampsDay21/"/>
    <id>https://blog.lthero.cn/2025/07/15/LeetCodeCampsDay21/</id>
    <published>2025-07-15T12:29:00.000Z</published>
    <updated>2025-07-15T13:01:28.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday21二叉树part08">LeetCodeCampsDay21二叉树part08</h1><blockquote><p>平衡二叉树的构造；修剪二叉树（难度甚至比删除二叉树的节点要简单一些）</p></blockquote><h1 id="669-修剪二叉搜索树">669. 修剪二叉搜索树</h1><p><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/">https://leetcode.cn/problems/trim-a-binary-search-tree/</a></p><p>给你二叉搜索树的根节点 <code>root</code> ，同时给定最小边界<code>low</code> 和最大边界 <code>high</code>。通过修剪二叉搜索树，使得所有节点的值在<code>[low, high]</code>中。修剪树 <strong>不应该</strong> 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 <strong>唯一的答案</strong> 。</p><p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/09/trim1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,0,2], low = 1, high = 2</span><br><span class="line">输出：[1,null,2]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/09/trim2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3</span><br><span class="line">输出：[3,2,null,1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数在范围 <code>[1, 104]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 104</code></li><li>树中每个节点的值都是 <strong>唯一</strong> 的</li><li>题目数据保证输入是一棵有效的二叉搜索树</li><li><code>0 &lt;= low &lt;= high &lt;= 104</code></li></ul><h2 id="递归思路">递归思路</h2><ol><li>使用递归，带返回值，返回的是修剪后的子树节点；</li><li>输入节点/low以及high，输出是修剪后的子树节点；</li><li>终止条件，如果输入节点为空就返回</li><li>单层逻辑：修剪的规则是，如果node.val&lt;low，则node需要被删除，并且node.right会被当成node返回给node的父节点（并且node.left肯定都小于low，都被修剪了）；如果node.val&gt; high,，则node需要被删除，并且node.left会被当成node返回给node的父节点（并且node.right都大于high，都被修剪了）</li></ol><h2 id="递归代码">递归代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(H)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self, node, low, high</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="comment"># 使用递归，带返回值，返回的是修剪后的子树节点</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> node.val &lt; low:</span><br><span class="line">            <span class="comment"># 若node.val小于low，说明node是需要被删除的，但node.right可能不会被删除</span></span><br><span class="line">            <span class="comment"># 这里直接返回了node.right，说明node已经被修剪了</span></span><br><span class="line">            <span class="keyword">return</span> self.foo(node.right, low, high)</span><br><span class="line">        <span class="keyword">if</span> node.val &gt; high:</span><br><span class="line">            <span class="keyword">return</span> self.foo(node.left, low, high)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 这里是将修剪好的子树上传上来</span></span><br><span class="line">        node.left = self.foo(node.left, low, high)</span><br><span class="line">        node.right = self.foo(node.right, low, high)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trimBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], low: <span class="built_in">int</span>, high: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="comment"># 使用递归完成</span></span><br><span class="line">        <span class="keyword">return</span> self.foo(root, low, high)</span><br></pre></td></tr></table></figure><h1 id="108-将有序数组转换为二叉搜索树">108. 将有序数组转换为二叉搜索树</h1><p><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/</a></p><p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 平衡 二叉搜索树。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-10,-3,0,5,9]</span><br><span class="line">输出：[0,-3,9,-10,null,5]</span><br><span class="line">解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3]</span><br><span class="line">输出：[3,1]</span><br><span class="line">解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 按 <strong>严格递增</strong> 顺序排列</li></ul><h2 id="递归思路">递归思路</h2><ol><li>使用递归，带返回值，输出排序后的子树节点</li><li>输入num(list)，输出这个nums的树</li><li>终止条件num为空</li><li>单层逻辑：先找到这个nums里的medium值（就是len(nums)//2），如果len为偶数，选择哪个都可以；以这个medium为root，然后递归地构造root的左、右子树；这个方法与之前构造最大子树（<a href="https://leetcode.cn/problems/maximum-binary-tree/">654. 最大二叉树</a>）有点像。</li></ol><h2 id="递归代码">递归代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(H)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 找到中间位置的节点当成root，再以中间节点划分左、右区间进行递归地建树</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        midIndex = L // <span class="number">2</span></span><br><span class="line">        root = TreeNode(nums[midIndex])</span><br><span class="line">        root.left = self.foo(nums[:midIndex])</span><br><span class="line">        root.right = self.foo(nums[midIndex + <span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedArrayToBST</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="comment"># 递归</span></span><br><span class="line">        <span class="keyword">return</span> self.foo(nums)</span><br></pre></td></tr></table></figure><h1 id="538-把二叉搜索树转换为累加树">538. 把二叉搜索树转换为累加树</h1><p><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">https://leetcode.cn/problems/convert-bst-to-greater-tree/</a></p><p>给出二叉 <strong>搜索</strong> 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 <code>node</code> 的新值等于原树中大于或等于 <code>node.val</code> 的值之和。</p><p>提醒一下，二叉搜索树满足下列约束条件：</p><ul><li>节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</li><li>节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</li><li>左右子树也必须是二叉搜索树。</li></ul><p>**注意：**本题和 1038: <a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a> 相同</p><p><strong>示例 1：</strong></p><p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/tree.png" alt="img"></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]</span><br><span class="line">输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [0,null,1]</span><br><span class="line">输出：[1,null,1]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,0,2]</span><br><span class="line">输出：[3,3,2]</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,2,4,1]</span><br><span class="line">输出：[7,9,4,10]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中的节点数介于 <code>0</code> 和 <code>104</code> 之间。</li><li>每个节点的值介于 <code>-104</code> 和 <code>104</code> 之间。</li><li>树中的所有值 <strong>互不相同</strong> 。</li><li>给定的树为二叉搜索树。</li></ul><h2 id="递归思路">递归思路</h2><p>因为本题为BST，它本身就有了顺序，可以先做一次反中序遍历，再将中间节点更新为node.val += pre.val，其中pre.val就是反中序遍历中较大的节点的累加值</p><ol><li>使用不带返回值的递归</li><li>输入node节点，无输出</li><li>终止条件，当前节点为空，直接返回</li><li>单层逻辑：使用反中序遍历，对中间节点进行更新，更新成node.val = node.val + pre.val</li></ol><h2 id="递归代码">递归代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(H)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.pre = TreeNode(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self,  node</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            self.foo(node.right)</span><br><span class="line">        node.val += self.pre.val</span><br><span class="line">        self.pre = node</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            self.foo(node.left)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">convertBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="comment"># 思路1 把中序遍历，逐个累加，需要有个pre节点</span></span><br><span class="line">        </span><br><span class="line">        self.foo(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">        </span><br></pre></td></tr></table></figure><h2 id="迭代思路">迭代思路</h2><ol><li>使用反中序遍历，先一路干到最右节点（把一路上的节点都添加到stack中），再逐个弹出，弹出的顺序就是（右、中、左）即完成反中序遍历；对中间节点进行操作，修改它的值为node.val += pre.val（注意，从python机制上来说，使用+=是原地赋值而使用val = val + pre会新增空间）</li></ol><h2 id="迭代代码">迭代代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(H)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">convertBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">    <span class="comment"># 思路1 把中序遍历，逐个累加，需要有个pre节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># self.foo(root)</span></span><br><span class="line">    <span class="comment"># return root</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用栈+迭代实现反中序遍历</span></span><br><span class="line">    stack = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    cur = root</span><br><span class="line">    pre = TreeNode(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">while</span> stack <span class="keyword">or</span> cur:</span><br><span class="line">        <span class="keyword">if</span> cur:</span><br><span class="line">            stack.append(cur)</span><br><span class="line">            <span class="comment"># 先干到最右节点</span></span><br><span class="line">            cur = cur.right</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 最右节点</span></span><br><span class="line">            cur = stack.pop()</span><br><span class="line">            <span class="comment"># 中节点</span></span><br><span class="line">            cur.val += pre.val</span><br><span class="line">            pre = cur</span><br><span class="line">            <span class="comment"># 左节点</span></span><br><span class="line">            cur = cur.left</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday21二叉树part08&quot;&gt;LeetCodeCampsDay21二叉树part08&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;平衡二叉树的构造；修剪二叉树（难度甚至比删除二叉树的节点要简单一些）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay20二叉树part07</title>
    <link href="https://blog.lthero.cn/2025/07/14/LeetCodeCampsDay20/"/>
    <id>https://blog.lthero.cn/2025/07/14/LeetCodeCampsDay20/</id>
    <published>2025-07-14T14:50:36.000Z</published>
    <updated>2025-07-15T13:01:18.313Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday20二叉树part07">LeetCodeCampsDay20二叉树part07</h1><blockquote></blockquote><h1 id="235-二叉搜索树的最近公共祖先">235. 二叉搜索树的最近公共祖先</h1><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/</a></p><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p>例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" alt="img"></p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4</span><br><span class="line">输出: 2</span><br><span class="line">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li></ul><h2 id="递归思路">递归思路</h2><ol><li>本题是BST，可以利用它的特性；如果node大于q.val且大于p.val，则需要向左遍历，在左子树中找公共祖先节点；如果node小于q.val且小于p.val，需要向右遍历，在右子树中找公共祖先节点；否则，直接返回node, node一定为p和q的公共祖先节点</li></ol><h2 id="递归代码">递归代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(H)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self, node, p, q</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> node == q <span class="keyword">or</span> node == p <span class="keyword">or</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> node.val &gt; p.val <span class="keyword">and</span> node.val &gt; q.val:</span><br><span class="line">            <span class="comment"># 应该向左子树搜索, 返回左子树的公共节点</span></span><br><span class="line">            leftNode = self.foo(node.left, p, q)</span><br><span class="line">            <span class="comment"># 找到了公共节点就返回</span></span><br><span class="line">            <span class="keyword">if</span> leftNode:</span><br><span class="line">                <span class="keyword">return</span> leftNode</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> node.val &lt; p.val <span class="keyword">and</span> node.val &lt; q.val:</span><br><span class="line">            rightNode = self.foo(node.right, p, q)</span><br><span class="line">            <span class="keyword">if</span> rightNode:</span><br><span class="line">                <span class="keyword">return</span> rightNode</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> self.foo(root, p, q)</span><br></pre></td></tr></table></figure><h2 id="迭代思路">迭代思路</h2><ol><li>因为BST已经排序好了，所以不需要借用栈就能自行搜索，迭代的代码反而更简单，如果同时将node与p&amp;q的值对比，如果相等就返回node；否则就继续搜索</li><li>这与在BST中搜索target的代码几乎一样<a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findTarget</span>(<span class="params">self, node: TreeNode, val: <span class="built_in">int</span></span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> node.val &gt; val:</span><br><span class="line">            leftNode = self.findTarget(node.left, val)</span><br><span class="line">            <span class="keyword">if</span> leftNode:</span><br><span class="line">                <span class="keyword">return</span> leftNode</span><br><span class="line">        <span class="keyword">elif</span> node.val &lt; val:</span><br><span class="line">            rightNode = self.findTarget(node.right, val)</span><br><span class="line">            <span class="keyword">if</span> rightNode:</span><br><span class="line">                <span class="keyword">return</span> rightNode</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">searchBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="comment"># BST特点是可以使用类似二分查找，若val小于当前值就在左子树找；否则在右子树找</span></span><br><span class="line">        <span class="comment"># return self.findTarget(root, val)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># BST的迭代</span></span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> root.val == val:</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">            <span class="keyword">elif</span> root.val &lt; val:</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root = root.left</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="迭代代码">迭代代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">    <span class="comment"># return self.foo(root, p, q)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    node = root</span><br><span class="line">    <span class="keyword">while</span> node:</span><br><span class="line">        <span class="keyword">if</span> node.val &gt; q.val <span class="keyword">and</span> node.val &gt; p.val:</span><br><span class="line">            <span class="comment"># 向左遍历</span></span><br><span class="line">            node = node.left</span><br><span class="line">        <span class="keyword">elif</span> node.val &lt; q.val <span class="keyword">and</span> node.val &lt; p.val:</span><br><span class="line">            <span class="comment"># 向右子树遍历</span></span><br><span class="line">            node = node.right</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 否则node.val一定等于q&amp;p</span></span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h1 id="701-二叉搜索树中的插入操作">701. 二叉搜索树中的插入操作</h1><p><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">https://leetcode.cn/problems/insert-into-a-binary-search-tree/</a></p><p>给定二叉搜索树（BST）的根节点 <code>root</code> 和要插入树中的值 <code>value</code> ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 <strong>保证</strong> ，新值和原始二叉搜索树中的任意节点值都不同。</p><p><strong>注意</strong>，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 <strong>任意有效的结果</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3], val = 5</span><br><span class="line">输出：[4,2,7,1,3,5]</span><br><span class="line">解释：另一个满足题目要求可以通过的树是：</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [40,20,60,10,30,50,70], val = 25</span><br><span class="line">输出：[40,20,60,10,30,50,70,null,null,25]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5</span><br><span class="line">输出：[4,2,7,1,3,5]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中的节点数将在 <code>[0, 104]</code>的范围内。</li><li><code>-108 &lt;= Node.val &lt;= 108</code></li><li>所有值 <code>Node.val</code> 是 <strong>独一无二</strong> 的。</li><li><code>-108 &lt;= val &lt;= 108</code></li><li><strong>保证</strong> <code>val</code> 在原始BST中不存在。</li></ul><h2 id="递归思路">递归思路</h2><ol><li><p>需要考虑递归是否需要带输出，如果带输出，输出需要是更新后的输入节点；如果不带输出，如何将更新后的节点表示出来</p></li><li><p>输入输出：输入节点与targetval， 输出插好的子树节点node</p></li><li><p>终止条件：如果遇到空节点，这个空节点就必然是targetVal应该在的地方（因为后面的单层逻辑必须保证这个条件）</p></li><li><p>单层逻辑：node.val与val判断，如果node.val大于val，则在node.left继续搜索，且node.left = foo(node.left, val)；否则就在node.right搜索，注意这里的foo返回值是node.left或node.right已经将val插好后的新节点</p></li></ol><h2 id="递归代码">递归代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(H)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self, node, val</span>):</span><br><span class="line">        <span class="comment"># 返回可以嵌入的节点, 并且直接将这个val放在新节点返回</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(val)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> node.val &lt; val:</span><br><span class="line">            node.right = self.foo(node.right, val)</span><br><span class="line">        <span class="keyword">if</span> node.val &gt; val:</span><br><span class="line">            node.left = self.foo(node.left, val)</span><br><span class="line">        <span class="keyword">return</span> node </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insertIntoBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="comment"># 递归算法</span></span><br><span class="line">        <span class="keyword">return</span> self.foo(root, val)</span><br></pre></td></tr></table></figure><h2 id="迭代代码">迭代代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(H)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insertIntoBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">    <span class="comment"># 迭代算法</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> TreeNode(val)</span><br><span class="line">    partent = root</span><br><span class="line">    cur = root</span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        partent = cur</span><br><span class="line">        <span class="comment"># 二叉搜索</span></span><br><span class="line">        <span class="keyword">if</span> cur.val &gt; val:</span><br><span class="line">            cur = cur.left</span><br><span class="line">        <span class="keyword">elif</span> cur.val &lt; val:</span><br><span class="line">            cur = cur.right</span><br><span class="line">    <span class="comment"># 直到找到了合适位置</span></span><br><span class="line">    <span class="keyword">if</span> partent.val &gt; val:</span><br><span class="line">        partent.left = TreeNode(val)</span><br><span class="line">    <span class="keyword">elif</span> partent.val &lt; val:</span><br><span class="line">        partent.right = TreeNode(val)</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h1 id="450-删除二叉搜索树中的节点">450. 删除二叉搜索树中的节点</h1><p><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">https://leetcode.cn/problems/delete-node-in-a-bst/</a></p><p>给定一个二叉搜索树的根节点 <strong>root</strong> 和一个值 <strong>key</strong>，删除二叉搜索树中的 <strong>key</strong> 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><ol><li>首先找到需要删除的节点；</li><li>如果找到了，删除它。</li></ol><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,3,6,2,4,null,7], key = 3</span><br><span class="line">输出：[5,4,6,2,null,null,7]</span><br><span class="line">解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。</span><br><span class="line">一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。</span><br><span class="line">另一个正确答案是 [5,2,6,null,4,null,7]。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [5,3,6,2,4,null,7], key = 0</span><br><span class="line">输出: [5,3,6,2,4,null,7]</span><br><span class="line">解释: 二叉树不包含值为 0 的节点</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [], key = 0</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li>节点数的范围 <code>[0, 104]</code>.</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li>节点值唯一</li><li><code>root</code> 是合法的二叉搜索树</li><li><code>-105 &lt;= key &lt;= 105</code></li></ul><p><strong>进阶：</strong> 要求算法时间复杂度为 O(h)，h 为树的高度。</p><h2 id="递归思路">递归思路</h2><p>下面的方法节点位置发生了变化，当然还有种思路是直接在被删除节点的右子树里找到最小值，替换当前节点值即可，从而可以不改变位置</p><ol><li>使用带返回值的递归方法，返回的内容是已经将节点删除后的节点</li><li>输入值node与key，输出是将key删除后的节点</li><li>终止条件：如果node为空则直接返回node；</li><li>单层逻辑：判断node.val与key的关系，直到找到node.val等于key，随后需要分四种情况<ol><li>node的左、右子树为空，可以放心删除，直接返回None</li><li>node的左子树为空，右子树不为空；直接返回右子树</li><li>node的左子树不空，右子树为空，直接返回左子树</li><li>node的左、右子树都不空，当时需要特殊处理；将node左子树的root，变成node的右子树的最小的节点的左子树（参考下图），此时可以用个cur节点和while搭配，一直向左找即可</li></ol></li></ol><p><img src="https://file1.kamacoder.com/i/algo/450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.gif" alt="img"></p><h2 id="递归代码">递归代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(H)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 使用递归完成，并且被删除的节点有5种情况</span></span><br><span class="line">    <span class="comment"># </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.parent = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self, node: TreeNode, key: <span class="built_in">int</span></span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        <span class="comment"># 如果node是要被删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> node.val == key:</span><br><span class="line">            <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> node.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">elif</span> node.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> node.right:</span><br><span class="line">                <span class="keyword">return</span> node.right</span><br><span class="line">            <span class="keyword">elif</span> node.left <span class="keyword">and</span> node.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> node.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment">#</span></span><br><span class="line">                cur = node.right</span><br><span class="line">                <span class="keyword">while</span> cur.left:</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                cur.left = node.left</span><br><span class="line">                node = node.right</span><br><span class="line">                <span class="keyword">return</span> node</span><br><span class="line">        <span class="keyword">if</span> node.val &lt; key:</span><br><span class="line">            node.right = self.foo(node.right, key)</span><br><span class="line">        <span class="keyword">if</span> node.val &gt; key:</span><br><span class="line">            node.left = self.foo(node.left, key)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteNode</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], key: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="comment"># 使用递归</span></span><br><span class="line">        <span class="keyword">return</span> self.foo(root, key)</span><br></pre></td></tr></table></figure><h2 id="迭代代码">迭代代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(H)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">deleteNode</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], key: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">    <span class="comment"># 使用迭代</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    parent = <span class="literal">None</span></span><br><span class="line">    node = root</span><br><span class="line">    <span class="keyword">while</span> node:</span><br><span class="line">        <span class="keyword">if</span> node.val == key:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        parent = node</span><br><span class="line">        <span class="keyword">if</span> node.val &gt; key:</span><br><span class="line">            node = node.left</span><br><span class="line">        <span class="keyword">elif</span> node.val &lt; key:</span><br><span class="line">            node = node.right</span><br><span class="line">    <span class="comment"># 如果只有头节点</span></span><br><span class="line">    <span class="keyword">if</span> parent <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> self.deleteOneNode(node)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> parent.left <span class="keyword">and</span> parent.left.val == key:</span><br><span class="line">        parent.left = self.deleteOneNode(parent.left)</span><br><span class="line">    <span class="keyword">if</span> parent.right <span class="keyword">and</span> parent.right.val == key:</span><br><span class="line">        parent.right = self.deleteOneNode(parent.right)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h1 id="删除普通二叉搜索树的节点">删除普通二叉搜索树的节点</h1><p>在450基础上进行扩展</p><p>这里我在介绍一种通用的删除，普通二叉树的删除方式（没有使用搜索树的特性，遍历整棵树），用交换值的操作来删除目标节点。</p><p>代码中目标节点（要删除的节点）被操作了两次：</p><p>删除的逻辑时，在要被删除的node的右子树里，找到右子树最小的值，替换到node的值就好了，<strong>节点位置不用发生变化</strong></p><ul><li>第一次是和目标节点的右子树最左面节点交换。</li><li>第二次直接被NULL覆盖了。</li></ul><h2 id="递归代码">递归代码</h2><ul><li>时间复杂度O(N2)</li><li>空间复杂度O(N2)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">self, node, key</span>) -&gt; TreeNode:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    <span class="keyword">if</span> node.val == key:</span><br><span class="line">        <span class="keyword">if</span> node.right <span class="keyword">is</span> <span class="literal">None</span>: <span class="comment">#这里第二次操作目标值：最终删除的作用</span></span><br><span class="line">            <span class="keyword">return</span> node.left</span><br><span class="line">        <span class="comment"># 找到右子树中最小的节点</span></span><br><span class="line">        cur = node.right</span><br><span class="line">        <span class="keyword">while</span> cur.left:</span><br><span class="line">            cur = cur.left</span><br><span class="line">        node.val, cur.val = cur.val, node.val <span class="comment"># 这里第一次操作目标值：交换目标值其右子树最左面节点。</span></span><br><span class="line">    node.left = self.bar(node.left, key)</span><br><span class="line">    node.right = self.bar(node.right, key)  <span class="comment"># 这里的node.right会再次与key相等，介时会被删除</span></span><br><span class="line">    <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday20二叉树part07&quot;&gt;LeetCodeCampsDay20二叉树part07&lt;/h1&gt;
&lt;blockquote&gt;&lt;/blockquote&gt;
&lt;h1 id=&quot;235-二叉搜索树的最近公共祖先&quot;&gt;235. 二叉搜索树的最近公共祖先&lt;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay18二叉树part06</title>
    <link href="https://blog.lthero.cn/2025/07/13/LeetCodeCampsDay18/"/>
    <id>https://blog.lthero.cn/2025/07/13/LeetCodeCampsDay18/</id>
    <published>2025-07-13T02:51:24.000Z</published>
    <updated>2025-07-14T14:51:19.627Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday18二叉树part06">LeetCodeCampsDay18二叉树part06</h1><blockquote><p>查找公共祖先节点</p></blockquote><h1 id="236-二叉树的最近公共祖先">236. 二叉树的最近公共祖先</h1><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/</a></p><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">输出：3</span><br><span class="line">解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">输出：5</span><br><span class="line">解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2], p = 1, q = 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[2, 105]</code> 内。</li><li><code>-109 &lt;= Node.val &lt;= 109</code></li><li>所有 <code>Node.val</code> <code>互不相同</code> 。</li><li><code>p != q</code></li><li><code>p</code> 和 <code>q</code> 均存在于给定的二叉树中。</li></ul><h2 id="递归思路">递归思路</h2><ol><li>输入输出：输入node, q, p； 输出公共节点</li><li>终止条件：当前节点为空返回None，当前节点为p或q则返回当前节点</li><li>单层逻辑：需要先搜索左、右子树中是否存在p&amp;q<ol><li>如果左、右子树有p&amp;q（即左、右子树不为None），则当前node为公共节点；</li><li>下一步是需要考虑，如何将公共节点传到最上层：这里需要解释下，假设[10,1,7,<strong>2,3</strong>]（其中2，3为p&amp;q），假设当前节点为10，对10来说，1（左子树）返回值是None（因为不存在p或q），而7（右子树）返回值为7（不为空），说明7就是q&amp;p的最近公共祖先；10只需要将7返回，即if leftNode and not rightNode: return leftNode</li></ol></li></ol><p><img src="https://cdn.lthero.cn/post_images/course/MLimage-20250713125002679.png" alt="image-20250713125002679"></p><h2 id="递归代码">递归代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self, node, p, q</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="comment"># 如果当前节点为空</span></span><br><span class="line">        <span class="comment"># 当前节点为p/q，告诉上层节点，发现了目标值；如果上层节点知道左、右子树都不为空，则上层节点就是公共节点</span></span><br><span class="line">        <span class="keyword">if</span> node == q <span class="keyword">or</span> node == p <span class="keyword">or</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 探索左子树是否有p/q</span></span><br><span class="line">        leftNode = self.foo(node.left, p, q)</span><br><span class="line">        <span class="comment"># 探索右子树是否有p/q</span></span><br><span class="line">        rightNode = self.foo(node.right, p, q)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果node节点知道左、右子树都不为空，则node节点就是公共节点</span></span><br><span class="line">        <span class="keyword">if</span> leftNode <span class="keyword">and</span> rightNode:</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 这一步是将已经为公共节点的node，继续向上返回，保证顶部会得到公共节点</span></span><br><span class="line">        <span class="comment"># 这里需要解释下，假设[10,1,7,p,q]，即对10来说，1（左子树）返回值是None，而7（右子树）返回值为7（不为空），说明7就是q&amp;p的最近公共祖先</span></span><br><span class="line">        <span class="comment"># 对10来说，直接返回7就行</span></span><br><span class="line">        <span class="keyword">if</span> leftNode <span class="keyword">and</span> <span class="keyword">not</span> rightNode:</span><br><span class="line">            <span class="keyword">return</span> leftNode</span><br><span class="line">        <span class="comment"># 同理</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> leftNode <span class="keyword">and</span> rightNode:</span><br><span class="line">            <span class="keyword">return</span> rightNode</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> self.foo(root, p, q)</span><br></pre></td></tr></table></figure><h1 id="530-二叉搜索树的最小绝对差">530. 二叉搜索树的最小绝对差</h1><p><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">https://leetcode.cn/problems/minimum-absolute-difference-in-bst/</a></p><p>给你一个二叉搜索树的根节点 <code>root</code> ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。</p><p>差值是一个正数，其数值等于两值之差的绝对值。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,6,1,3]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/05/bst2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,0,48,null,null,12,49]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目范围是 <code>[2, 104]</code></li><li><code>0 &lt;= Node.val &lt;= 105</code></li></ul><h2 id="迭代思路">迭代思路</h2><ol><li>本题和<code>98. 验证二叉搜索树</code> 很像，都可以靠中序遍历，并且判断相邻两位元素的值（差）来解决；这需要用到BST特性，即左节点小于等于root，root小于等于右节点</li></ol><h2 id="迭代代码">迭代代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMinimumDifference</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 使用中序遍历，记录相邻两位元素差值</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        stack = [[root, <span class="literal">False</span>]] <span class="keyword">if</span> root <span class="keyword">else</span> []</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        diff = <span class="literal">None</span></span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node, visited = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> visited:</span><br><span class="line">                <span class="keyword">if</span> pre:</span><br><span class="line">                    <span class="keyword">if</span> diff <span class="keyword">and</span> <span class="built_in">abs</span>(node.val - pre.val) &lt; diff:</span><br><span class="line">                        diff = <span class="built_in">abs</span>(node.val - pre.val)</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> diff:</span><br><span class="line">                        diff = <span class="built_in">abs</span>(node.val - pre.val)</span><br><span class="line">                pre = node</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    stack.append([node.right, <span class="literal">False</span>])</span><br><span class="line">                stack.append([node, <span class="literal">True</span>])</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    stack.append([node.left, <span class="literal">False</span>])</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> diff</span><br></pre></td></tr></table></figure><h1 id="501-二叉搜索树中的众数">501. 二叉搜索树中的众数</h1><p><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">https://leetcode.cn/problems/find-mode-in-binary-search-tree/</a></p><p>给你一个含重复值的二叉搜索树（BST）的根节点 <code>root</code> ，找出并返回 BST 中的所有 <a href="https://baike.baidu.com/item/%E4%BC%97%E6%95%B0/44796">众数</a>（即，出现频率最高的元素）。</p><p>如果树中有不止一个众数，可以按 <strong>任意顺序</strong> 返回。</p><p>假定 BST 满足如下定义：</p><ul><li>结点左子树中所含节点的值 <strong>小于等于</strong> 当前节点的值</li><li>结点右子树中所含节点的值 <strong>大于等于</strong> 当前节点的值</li><li>左子树和右子树都是二叉搜索树</li></ul><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/11/mode-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,null,2,2]</span><br><span class="line">输出：[2]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[1, 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li></ul><p>**进阶：**你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p><h2 id="迭代思路">迭代思路</h2><ol><li>用中序遍历，关键是在「中间节点的操作」，本题和<code>530二叉搜索树的最小绝对差 </code>以及<code>98. 验证二叉搜索树</code> 相似，需要引入pre节点，判断前后两个元素是否相等，如果相等则将count+1，如果不相等则重置count为1。随后判断count是否等于MaxFreq，如果是，则将元素添加到res里；如果count大于MaxFreq，则将res清空并且将元素添加到res里，并设置MaxFreq等于count</li><li>本题如果只有一个众数，那会相对简直一些，只要一直记录count最大的元素就好，也不用对res清空</li></ol><h2 id="迭代代码">迭代代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(H) – 主要是stack占用的</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.MostFreq = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMode</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 还是按中序遍历，出现频率最高的数可以放在res里，用一个</span></span><br><span class="line">        stack = <span class="built_in">list</span>()</span><br><span class="line">        node = root</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> node <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                stack.append(node)</span><br><span class="line">                node = node.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 左</span></span><br><span class="line">                node = stack.pop()</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 中</span></span><br><span class="line">                <span class="keyword">if</span> pre:</span><br><span class="line">                    <span class="keyword">if</span> pre.val == node.val:</span><br><span class="line">                        count += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        count = <span class="number">1</span></span><br><span class="line">                pre = node</span><br><span class="line">                <span class="keyword">if</span> count == self.MostFreq:</span><br><span class="line">                    res.append(node.val)</span><br><span class="line">                    </span><br><span class="line">                <span class="keyword">elif</span> count &gt; self.MostFreq:</span><br><span class="line">                    res.clear()</span><br><span class="line">                    res.append(node.val)</span><br><span class="line">                    self.MostFreq = count</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 右</span></span><br><span class="line">                node = node.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br></pre></td></tr></table></figure><h2 id="递归代码">递归代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(H) – 最好O(logN)最坏O(N)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">self, node</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    <span class="comment"># 左</span></span><br><span class="line">    self.traverse(node.left)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 中</span></span><br><span class="line">    <span class="keyword">if</span> self.pre:</span><br><span class="line">        <span class="keyword">if</span> self.pre.val == node.val:</span><br><span class="line">            self.count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.count = <span class="number">1</span></span><br><span class="line">    self.pre = node</span><br><span class="line">    <span class="keyword">if</span> self.count == self.MostFreq:</span><br><span class="line">        self.res.append(node.val)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">elif</span> self.count &gt; self.MostFreq:</span><br><span class="line">        self.res.clear()</span><br><span class="line">        self.res.append(node.val)</span><br><span class="line">        self.MostFreq = self.count</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 右</span></span><br><span class="line">    self.traverse(node.right)</span><br></pre></td></tr></table></figure><h2 id="思考">思考</h2><p>如果本题不是BST而是普通树，可以先做遍历（中/前/后/层序都行），再进行排序，排序时按频率将最高频率的添加到res里</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday18二叉树part06&quot;&gt;LeetCodeCampsDay18二叉树part06&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;查找公共祖先节点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;236-二叉树的最近公共祖先&quot;&gt;236</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay17二叉树part05</title>
    <link href="https://blog.lthero.cn/2025/07/11/LeetCodeCampsDay17/"/>
    <id>https://blog.lthero.cn/2025/07/11/LeetCodeCampsDay17/</id>
    <published>2025-07-11T10:57:14.000Z</published>
    <updated>2025-07-11T12:51:44.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday17二叉树part05">LeetCodeCampsDay17二叉树part05</h1><blockquote><p>包含二叉搜索树的判断与搜索；以及合并二叉树的应用，最大二叉树的创建</p></blockquote><h1 id="654-最大二叉树">654. 最大二叉树</h1><p><a href="https://leetcode.cn/problems/maximum-binary-tree/">https://leetcode.cn/problems/maximum-binary-tree/</a></p><p>给定一个不重复的整数数组 <code>nums</code> 。 <strong>最大二叉树</strong> 可以用下面的算法从 <code>nums</code> 递归地构建:</p><ol><li>创建一个根节点，其值为 <code>nums</code> 中的最大值。</li><li>递归地在最大值 <strong>左边</strong> 的 <strong>子数组前缀上</strong> 构建左子树。</li><li>递归地在最大值 <strong>右边</strong> 的 <strong>子数组后缀上</strong> 构建右子树。</li></ol><p>返回 <em><code>nums</code> 构建的</em> *<strong>最大二叉树*</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,1,6,0,5]</span><br><span class="line">输出：[6,3,5,null,2,0,null,null,1]</span><br><span class="line">解释：递归调用如下所示：</span><br><span class="line">- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。</span><br><span class="line">    - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。</span><br><span class="line">        - 空数组，无子节点。</span><br><span class="line">        - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。</span><br><span class="line">            - 空数组，无子节点。</span><br><span class="line">            - 只有一个元素，所以子节点是一个值为 1 的节点。</span><br><span class="line">    - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。</span><br><span class="line">        - 只有一个元素，所以子节点是一个值为 0 的节点。</span><br><span class="line">        - 空数组，无子节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/24/tree2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,1]</span><br><span class="line">输出：[3,null,2,null,1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li></ul><h2 id="递归思路">递归思路</h2><ol><li>使用递归解决：<ol><li>终止条件，<strong>当发现叶子节点时返回这个节点，即len(nums)==1就返回构造的节点</strong></li><li>输入输出：输入列表，输出根节点</li><li>单层逻辑：先找到列表中最大值，它为root节点，再以root为界限，<strong>找左、右子树（前提是有左、右子树）</strong>，需要加个对rootIndex的判断；对nums的划分有点儿像之前做的根据前/中序列构造二叉树</li></ol></li></ol><h2 id="递归代码">递归代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(H)—最坏情况O(N)最好O(logN)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.res = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">traversal</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 终止条件是：发现叶子节点就直接返回</span></span><br><span class="line">        <span class="keyword">if</span> L == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(nums[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 找最大值</span></span><br><span class="line">        maxIndex = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt;= nums[maxIndex]:</span><br><span class="line">                maxIndex = i</span><br><span class="line">        root = TreeNode(nums[maxIndex])</span><br><span class="line">        <span class="comment"># 注意，maxIndex至少要有左子树和右子树</span></span><br><span class="line">        <span class="keyword">if</span> maxIndex &gt; <span class="number">0</span>:</span><br><span class="line">            leftTree = self.traversal(nums[:maxIndex])</span><br><span class="line">            root.left = leftTree</span><br><span class="line">        <span class="keyword">if</span> maxIndex &lt; L - <span class="number">1</span>:</span><br><span class="line">            rightTree = self.traversal(nums[maxIndex + <span class="number">1</span>:])</span><br><span class="line">            root.right = rightTree</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">constructMaximumBinaryTree</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="comment"># 注意层序顺序返回结果</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        que = deque()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        root = self.traversal(nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h1 id="700-二叉搜索树中的搜索">700. 二叉搜索树中的搜索</h1><p><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">https://leetcode.cn/problems/search-in-a-binary-search-tree/</a></p><p>给定二叉搜索树（BST）的根节点 <code>root</code> 和一个整数值 <code>val</code>。</p><p>你需要在 BST 中找到节点值等于 <code>val</code> 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 <code>null</code> 。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/12/tree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3], val = 2</span><br><span class="line">输出：[2,1,3]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/12/tree2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3], val = 5</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数在 <code>[1, 5000]</code> 范围内</li><li><code>1 &lt;= Node.val &lt;= 107</code></li><li><code>root</code> 是二叉搜索树</li><li><code>1 &lt;= val &lt;= 107</code></li></ul><h2 id="递归思路">递归思路</h2><ol><li>BST树特点是可以使用类似二分查找，若val小于当前值就在当前node的左子树找；否则在右子树找</li><li>输入输出：输入node和val，输出节点</li><li>终止条件：当前node为空</li><li>单层逻辑：若val小于当前值就在当前node的左子树找；否则在右子树找，如果相等就返回node</li></ol><h2 id="递归代码">递归代码</h2><ul><li>时间复杂度O(h) – 最好O(logN)，最坏O(N)</li><li>空间复杂度O(h) – 最好O(logN)，最坏O(N)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findTarget</span>(<span class="params">self, node: TreeNode, val: <span class="built_in">int</span></span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> node.val &gt; val:</span><br><span class="line">            <span class="keyword">return</span> self.findTarget(node.left, val)</span><br><span class="line">        <span class="keyword">elif</span> node.val &lt; val:</span><br><span class="line">            <span class="keyword">return</span> self.findTarget(node.right, val)</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="comment"># BST特点是可以使用类似二分查找，若val小于当前值就在左子树找；否则在右子树找</span></span><br><span class="line">        <span class="keyword">return</span> self.findTarget(root, val)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="迭代思路">迭代思路</h2><p>一提到二叉树遍历的迭代法，可能立刻想起使用栈来模拟深度遍历，使用队列来模拟广度遍历。</p><p>对于二叉搜索树可就不一样了，因为二叉搜索树的特殊性，也就是节点的有序性，<code>可以不使用辅助栈或者队列就可以写出迭代法</code>。</p><p>对于一般二叉树，递归过程中还有回溯的过程，<strong>例如走一个左方向的分支走到头了，那么要调头，在走右分支</strong>。</p><p>而<strong>对于二叉搜索树，不需要回溯的过程，因为节点的有序性就帮我们确定了搜索的方向。</strong></p><p>例如要搜索元素为3的节点，<strong>我们不需要搜索其他节点，也不需要做回溯，查找的路径已经规划好了。</strong></p><p>中间节点如果大于3就向左走，如果小于3就向右走，如图：</p><p><img src="https://file1.kamacoder.com/i/algo/20200812190213280.png" alt="img"></p><h2 id="迭代代码">迭代代码</h2><ul><li>时间复杂度O(h) – 最好O(logN)，最坏O(N)</li><li>空间复杂度O(h) – 最好O(logN)，最坏O(N)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">searchBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="comment"># BST的迭代</span></span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> root.val == val:</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">            <span class="keyword">elif</span> root.val &lt; val:</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root = root.left</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h1 id="98-验证二叉搜索树">98. 验证二叉搜索树</h1><p><a href="https://leetcode.cn/problems/validate-binary-search-tree/">https://leetcode.cn/problems/validate-binary-search-tree/</a></p><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [2,1,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,1,4,null,null,3,6]</span><br><span class="line">输出：false</span><br><span class="line">解释：根节点的值是 5 ，但是右子节点的值是 4 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目范围在<code>[1, 104]</code> 内</li><li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li></ul><h2 id="中序迭代思路">中序迭代思路</h2><ol><li>先用中序遍历输出到个数组中，再看数组是否是单调的</li><li>验证是否单调就找个maxIndex，如果后一个值大于maxIndex就更新maxIndex并继续搜索；否则就直接return False</li></ol><h2 id="中序迭代代码">中序迭代代码</h2><ul><li>时间复杂度O(N^2) — 主要是后面验证是否单调递增浪费时间</li><li>空间复杂度O(N)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 按中序遍历，输出的应该是单调增长的</span></span><br><span class="line"></span><br><span class="line">        stack = [(root, <span class="literal">False</span>)] <span class="keyword">if</span> root <span class="keyword">else</span> []</span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node, visited = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> visited:</span><br><span class="line">                res.append(node.val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    stack.append([node.right, <span class="literal">False</span>])</span><br><span class="line">                stack.append([node, <span class="literal">True</span>])</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    stack.append([node.left, <span class="literal">False</span>])</span><br><span class="line">        <span class="comment">#print(res)</span></span><br><span class="line">        <span class="comment">#rturn all(x &lt; y for x, y in zip(res, res[1:]))                </span></span><br><span class="line">        maxIndex = <span class="number">0</span></span><br><span class="line">        L = <span class="built_in">len</span>(res)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L):</span><br><span class="line">            <span class="keyword">if</span> res[i] &gt; res[maxIndex]:</span><br><span class="line">                maxIndex = i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="中序迭代思路二">中序迭代思路二</h2><ol><li>添加一个pre节点，在每次对visited==True时进行pre与当前节点的判断，<code>如果pre大于或等于node，则一定有问题！</code></li><li>好处是不需要额外数组装结果，中序遍历过程中就能判断是否有问题</li></ol><p>没错的，使用pre大于或等于node进行判断就行，因为目前是中序输出，不管下面哪种情况，都可以用pre大于或等于node来判断出False</p><p><img src="https://cdn.lthero.cn/post_images/course/MLimage-20250711201453775.png" alt="image-20250711201453775"></p><h2 id="统一中序迭代代码二">统一中序迭代代码二</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isValidBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="comment"># 按中序遍历，输出的应该是单调增长的</span></span><br><span class="line"></span><br><span class="line">    stack = [(root, <span class="literal">False</span>)] <span class="keyword">if</span> root <span class="keyword">else</span> []</span><br><span class="line">    pre = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node, visited = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> visited:</span><br><span class="line">            <span class="keyword">if</span> pre <span class="keyword">and</span> pre.val &gt;= node.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            pre = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append([node.right, <span class="literal">False</span>])</span><br><span class="line">            stack.append([node, <span class="literal">True</span>])</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append([node.left, <span class="literal">False</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="普通中序迭代代码三">普通中序迭代代码三</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> stack = <span class="built_in">list</span>()</span><br><span class="line"> cur = root</span><br><span class="line"> pre = <span class="literal">None</span></span><br><span class="line"><span class="comment"># cur先一路干到最底层的左子树左叶子节点</span></span><br><span class="line"> <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">     <span class="keyword">if</span> cur:</span><br><span class="line">         stack.append(cur)</span><br><span class="line">         cur = cur.left</span><br><span class="line">     <span class="comment"># 到达最左节点后，开始处理栈顶节点</span></span><br><span class="line">     <span class="keyword">else</span>:</span><br><span class="line">       <span class="comment"># 最底层的左子树左叶子节点开始输出，append到</span></span><br><span class="line">         cur = stack.pop()</span><br><span class="line">         <span class="keyword">if</span> pre <span class="keyword">and</span> cur.val &lt;= pre.val:</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">         pre = cur</span><br><span class="line">         <span class="comment"># 取栈顶元素右节点</span></span><br><span class="line">         cur = cur.right</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h1 id="617-合并二叉树">617. 合并二叉树</h1><p><a href="https://leetcode.cn/problems/merge-two-binary-trees/">https://leetcode.cn/problems/merge-two-binary-trees/</a></p><p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p><strong>注意:</strong> 合并过程必须从两个树的根节点开始。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/05/merge.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]</span><br><span class="line">输出：[3,4,5,5,4,null,7]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root1 = [1], root2 = [1,2]</span><br><span class="line">输出：[2,2]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>两棵树中的节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-104 &lt;= Node.val &lt;= 104</code></li></ul><h2 id="递归思路">递归思路</h2><ol><li>本题和<a href="https://leetcode.cn/problems/symmetric-tree/">对称二叉树</a>有点儿像</li><li>终止条件：如果都空就返回None；哪个空就返回另一个；</li><li>输入输出：输入两个节点，输出合并后的节点</li><li>单层逻辑：只有都不空，才创建root节点并将两个节点相加，随后创建root的左、右子树</li></ol><p><img src="https://file1.kamacoder.com/i/algo/617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91.gif" alt="img"></p><h2 id="递归代码">递归代码</h2><ul><li>时间复杂度O(N+M)</li><li>空间复杂度O(H) 其中 H 是两个树中高度的最大值。主要由递归调用栈引起</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, node1, node2</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node1 <span class="keyword">and</span> node2:</span><br><span class="line">            <span class="keyword">return</span> node2</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> node2 <span class="keyword">and</span> node1:</span><br><span class="line">            <span class="keyword">return</span> node1</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> node1 <span class="keyword">and</span> <span class="keyword">not</span> node2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            root = TreeNode(node1.val + node2.val)</span><br><span class="line"></span><br><span class="line">        leftTree = self.buildTree(node1.left, node2.left)</span><br><span class="line">        rightTree = self.buildTree(node1.right, node2.right)</span><br><span class="line"></span><br><span class="line">        root.left = leftTree</span><br><span class="line">        root.right = rightTree</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTrees</span>(<span class="params">self, root1: <span class="type">Optional</span>[TreeNode], root2: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="comment"># 树长度不用相同，使用递归</span></span><br><span class="line">        <span class="keyword">return</span> self.buildTree(root1, root2)</span><br></pre></td></tr></table></figure><h2 id="迭代思路">迭代思路</h2><ol><li>使用层序，和<a href="https://leetcode.cn/problems/symmetric-tree/">对称二叉树</a>有点儿像，每次处理两个节点；每次添加两个节点进去，弹出两个节点出来</li><li>但本题可以直接拿其中一个root当成结果，比如root1</li><li>每次判断时，如果只有当node1和node2的左子树都不为空，才添加到que；否则如果node1.left为空，则让node1.left等于node2.left（这里隐藏了一条代码，如果node2.left为空，则让node1.left等于node1.left，即不变）；对node1和node2的右子树同样这样操作</li><li>最终返回root1即可</li></ol><h2 id="迭代代码">迭代代码</h2><ul><li>时间复杂度O(N+M)</li><li>空间复杂度O(H) 其中 H 是两个树中高度的最大值。主要由递归调用栈引起</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mergeTrees</span>(<span class="params">self, root1: <span class="type">Optional</span>[TreeNode], root2: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">    <span class="comment"># 迭代版，使用层序</span></span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">    que = deque()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root1:</span><br><span class="line">        <span class="keyword">return</span> root2</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root2:</span><br><span class="line">        <span class="keyword">return</span> root1</span><br><span class="line">    que.append(root1)</span><br><span class="line">    que.append(root2)</span><br><span class="line">    <span class="keyword">while</span> que:</span><br><span class="line">        L = <span class="built_in">len</span>(que)</span><br><span class="line">        node1 = que.popleft()</span><br><span class="line">        node2 = que.popleft()</span><br><span class="line"></span><br><span class="line">        node1.val += node2.val</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> node1.left <span class="keyword">and</span> node2.left:</span><br><span class="line">            que.append(node1.left)</span><br><span class="line">            que.append(node2.left)</span><br><span class="line">        <span class="keyword">if</span> node1.right <span class="keyword">and</span> node2.right:</span><br><span class="line">            que.append(node1.right)</span><br><span class="line">            que.append(node2.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node1.left <span class="keyword">and</span> node2.left:</span><br><span class="line">            node1.left = node2.left</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node1.right <span class="keyword">and</span> node2.right:</span><br><span class="line">            node1.right = node2.right</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="103-二叉树的锯齿形层序遍历">103. 二叉树的锯齿形层序遍历</h1><p><a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/</a></p><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>锯齿形层序遍历</strong> 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：[[3],[20,9],[15,7]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h2 id="层序迭代思路">层序迭代思路</h2><ol><li>按层序遍历即可，先把每层元素全添加到level，再按奇偶反转level内部,再添加到res</li></ol><h2 id="层序迭代代码">层序迭代代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(H)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">zigzagLevelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 先全添加到level，再按奇偶反转level内部,再添加到res</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        que = deque()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        que.append(root)</span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        countLevel = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            L = <span class="built_in">len</span>(que)</span><br><span class="line">            level = <span class="built_in">list</span>()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">                node = que.popleft()</span><br><span class="line">                level.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    que.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    que.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> countLevel % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                level = level[::-<span class="number">1</span>]</span><br><span class="line">            res.append(level)</span><br><span class="line">            countLevel += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday17二叉树part05&quot;&gt;LeetCodeCampsDay17二叉树part05&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;包含二叉搜索树的判断与搜索；以及合并二叉树的应用，最大二叉树的创建&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>从AutoRegression到Diffusion</title>
    <link href="https://blog.lthero.cn/2025/07/10/AutoRegressionToDiffusion/"/>
    <id>https://blog.lthero.cn/2025/07/10/AutoRegressionToDiffusion/</id>
    <published>2025-07-10T15:44:54.000Z</published>
    <updated>2025-07-10T16:11:04.448Z</updated>
    
    <content type="html"><![CDATA[<h1 id="why-does-diffusion-work-better-than-auto-regression">Why Does Diffusion Work Better than Auto-Regression?</h1><blockquote><p><a href="https://www.youtube.com/watch?v=zc5NTeJbk-k">https://www.youtube.com/watch?v=zc5NTeJbk-k</a></p><p>原标题是为什么Diffusion比AutoRegression效果好？</p><p>刷到个有意思的视频，没什么公式与理论，但很通彻地讲了AutoRegression到Diffusion的过渡，Diffusion不是一蹿而就的，终究也是AutoRegression成就了它；</p></blockquote><h2 id="最早期">最早期</h2><p>假设我们有labels（实际图片），有个网络，我们关心输入，反正让网络训练就行了；最终效果是让网络学到从输入到labels的映射</p><p><img src="https://cdn.lthero.cn/post_images/course/MLimage-20250710234829391.png" alt="image-20250710234829391"></p><p>但问题是，网络最终得到是所有训练集的一个平均值图片；因为所有labels的平均值也可以是个meaningful的label</p><p><img src="https://cdn.lthero.cn/post_images/course/MLimage-20250710235012110.png" alt="image-20250710235012110"></p><h2 id="早期">早期</h2><p>那，我们退一万步，让一个网络只预测一个位置的像素；比如网络–编号768，只预测第768位置上的像素；</p><p>网络可能会将整个图像学习，得输出一个像素</p><p><img src="https://cdn.lthero.cn/post_images/course/MLimage-20250710235157236.png" alt="image-20250710235157236"></p><p>那更进一步，让输入是缺少两个像素，然后让网络–编号767训练并输出倒数第二个位置的像素，再把补齐后的像素给网络768预测最后一位置的像素</p><p><img src="https://cdn.lthero.cn/post_images/course/MLimage-20250710235357625.png" alt="image-20250710235357625"></p><p>那，再进768步；训练768个网络，每个网络就预测一个像素，网络–编号1预测了第一个像素后交给网络–编号2……</p><p><img src="https://cdn.lthero.cn/post_images/course/MLimage-20250710235533536.png" alt="image-20250710235533536"></p><p>这听起来似乎是pleassible的，但现实上，如果每个网络都直接输出这个网络的最高概率像素值，<strong>最终，不管运行多少次，得到的图片会是完全一样的</strong>；这个问题也很好解决，每次添加一些扰动，每次选择不同概率的值，从而增加多样性</p><p><img src="https://cdn.lthero.cn/post_images/course/MLimage-20250710235802260.png" alt="image-20250710235802260"></p><p>而且，这样的网络有什么好处呢？它是自监督的，不需要人类给图片打标签，网络可以根据已有的像素推算下一个像素</p><p>小结下，如果让网络同时预测一堆像素，最终会产生一堆比较合理的结果，网络会输出一个平均值</p><p><img src="https://cdn.lthero.cn/post_images/course/MLimage-20250711000026049.png" alt="image-20250711000026049"></p><p>但如果只让网络一次预测一个像素，效果就会比较好</p><p><img src="https://cdn.lthero.cn/post_images/course/MLimage-20250711000125217.png" alt="image-20250711000125217"></p><p>那，为什么会这样呢？----因为这些像素是“有相关性”的</p><p>比如，如果这些像素本身就是无关的，这些像素对下一个像素的预测本身也帮不上什么忙，从而，模型就不需要知道（或者查看）之前的像素是什么（知道了也没用）</p><p><img src="https://cdn.lthero.cn/post_images/course/MLimage-20250711000224312.png" alt="image-20250711000224312"></p><p>所以，现在的理想目标是，让网络学会“不依赖原像素”预测新像素；</p><p>那么，在选择数据集时，就不一定将连续的像素块儿扣下来，而是应该随机选择一些像素块儿让网络去预测</p><p><img src="https://cdn.lthero.cn/post_images/course/MLimage-20250711000453635.png" alt="连续相似的像素块"></p><p>并且，最好让这些被扣下来的像素块尽量分散（in a random order）</p><p><img src="https://cdn.lthero.cn/post_images/course/MLimage-20250711000608747.png" alt="image-20250711000608747"></p><p>目前呢，是将像素完全扣下来，直接变成黑色；</p><p>不过，我们可以不这样做，而是让像素逐渐丢失信息，比如，加点儿噪声？</p><p><img src="https://cdn.lthero.cn/post_images/course/MLimage-20250711000754578.png" alt="image-20250711000754578"></p><p>虽然我们不知道原图是什么了，但我们知道加了什么噪声</p><p>看，逐渐添加了很多噪声，<strong>让图像失去了信息，并且让像素相互独立</strong></p><p><img src="https://cdn.lthero.cn/post_images/course/MLimage-20250711000900198.png" alt="image-20250711000900198"></p><h2 id="最终">最终</h2><p>于是，按上面的方法，似乎就让Diffusion的出现变得合理了</p><p><img src="https://cdn.lthero.cn/post_images/course/MLimage-20250711001022827.png" alt="image-20250711001022827"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;why-does-diffusion-work-better-than-auto-regression&quot;&gt;Why Does Diffusion Work Better than Auto-Regression?&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a hr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Transformer-03-LayerNorm</title>
    <link href="https://blog.lthero.cn/2025/07/10/Transformer-03-LayerNorm/"/>
    <id>https://blog.lthero.cn/2025/07/10/Transformer-03-LayerNorm/</id>
    <published>2025-07-10T15:15:21.000Z</published>
    <updated>2025-07-10T15:22:09.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="transformer学习笔记三：为什么transformer要用layernorm-batch-normalization-layer-normalization">Transformer学习笔记三：为什么Transformer要用LayerNorm/Batch Normalization &amp; Layer Normalization</h1><p>参考：<a href="https://zhuanlan.zhihu.com/p/456863215%E4%BB%A5%E5%8F%8A%E7%A7%81%E6%9C%89%E8%B5%84%E6%96%99">https://zhuanlan.zhihu.com/p/456863215以及私有资料</a></p><p>一般来说，BatchNorm适用于CV，LayerNorm适用于NLP。关键是要看需要保留什么信息，举个例子</p><p>NLP中，[‘搜推yyds’，LLM大法好’，‘CV永不为奴’]三句话做normalization，</p><p>其中，样本数量(N)为3，而每个字看作图像里的一个通道，</p><p>假设一个词是一个token，BatchNorm效果是[‘搜’，L’，‘C’]，[‘推’，‘L’，‘V’]…做归一化；LayerNorm是三句话分别各自归一化；</p><p>前者归一到同一分布后变无法保留一个句子里的分布信息了（比如·搜推yyds用Batch Norm后就变了），而LayerNorm可以成功保留上下文分布信息</p><p>CV中BatchNorm是对图像的不同channel（比如对N个样本的R通道）各自进行归一化(如下图，batch Norm，本身CV任务不需要channel之间的信息交互，归一化后仅保留各channel的分布信息作后续判断即可</p><p>![image-20250710231823710](/Users/lthero/Library/Application Support/typora-user-images/image-20250710231823710.png)</p><p>而NLP中的layerNorm是对每个样本的所有通道做归一化</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;transformer学习笔记三：为什么transformer要用layernorm-batch-normalization-layer-normalization&quot;&gt;Transformer学习笔记三：为什么Transformer要用LayerNorm/Batch</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay16</title>
    <link href="https://blog.lthero.cn/2025/07/10/LeetCodeCampsDay16/"/>
    <id>https://blog.lthero.cn/2025/07/10/LeetCodeCampsDay16/</id>
    <published>2025-07-10T11:13:28.000Z</published>
    <updated>2025-07-11T11:18:11.220Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday16">LeetCodeCampsDay16</h1><blockquote><p>记录下，今儿三个题目一次过；</p><p>其中<strong>路径总和问题</strong>和之前<strong>求二叉树的所有路径相似</strong></p><p>找树左下角的值可以用层序解决</p><p><strong>从中序与后序遍历序列构造二叉树</strong> 可以用递归方法，找到<strong>输入输出；终止条件；单层逻辑</strong>就能解决</p></blockquote><h1 id="找树左下角的值">找树左下角的值</h1><p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">https://leetcode.cn/problems/find-bottom-left-tree-value/</a></p><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的 <strong>最底层 最左边</strong> 节点的值。</p><p>假设二叉树中至少有一个节点。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/14/tree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [2,1,3]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,null,5,6,null,null,7]</span><br><span class="line">输出: 7</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li>二叉树的节点个数的范围是 <code>[1,104]</code></li><li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li></ul><h2 id="层序迭代思路">层序迭代思路</h2><ol><li>使用迭代–层序的方法, 令res存储每层第一个元素，遍历到最后一层结束，再返回res即可</li></ol><h2 id="层序迭代代码">层序迭代代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(W)—二叉树最大宽度（也即二叉树每层最大长度）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findBottomLeftValue</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 使用迭代--层序的方法, 令res存储每层第一个元素，遍历到最后一层结束，再返回res即可</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        que = deque()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        que.append(root)</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            L = <span class="built_in">len</span>(que)</span><br><span class="line">            level = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">                node = que.popleft()</span><br><span class="line">                <span class="keyword">if</span> i ==<span class="number">0</span>:</span><br><span class="line">                    level = node.val</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    que.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    que.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> level</span><br></pre></td></tr></table></figure><h1 id="112-路径总和">112. 路径总和</h1><p><a href="https://leetcode.cn/problems/path-sum/">https://leetcode.cn/problems/path-sum/</a></p><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22</span><br><span class="line">输出：true</span><br><span class="line">解释：等于目标和的根节点到叶节点路径如上图所示。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3], targetSum = 5</span><br><span class="line">输出：false</span><br><span class="line">解释：树中存在两条根节点到叶子节点的路径：</span><br><span class="line">(1 --&gt; 2): 和为 3</span><br><span class="line">(1 --&gt; 3): 和为 4</span><br><span class="line">不存在 sum = 5 的根节点到叶子节点的路径。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [], targetSum = 0</span><br><span class="line">输出：false</span><br><span class="line">解释：由于树是空的，所以不存在根节点到叶子节点的路径。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[0, 5000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li><li><code>-1000 &lt;= targetSum &lt;= 1000</code></li></ul><h2 id="后序迭代思路">后序迭代思路</h2><ol><li>这题目和“<strong>二叉树所有路径</strong>”(day15)相似，只是将保存路径变成<code>保存路径上所有元素的和</code>；遇到叶子节点时，判断这和是否与target相等即可</li><li>本题同样对前/中/后，甚至逆向的前/中/后顺序不敏感，所有顺序都能通过</li><li>下面代码使用后序</li></ol><h2 id="后序迭代代码">后序迭代代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(H)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 使用后序遍历+栈？</span></span><br><span class="line">        stack = <span class="built_in">list</span>()</span><br><span class="line">        path = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        stack.append(root)</span><br><span class="line">        path.append(root.val)</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            pathNode = path.pop()</span><br><span class="line">            <span class="comment"># 终止条件，遇到叶子节点了</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                <span class="keyword">if</span> pathNode == targetSum:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">                path.append(pathNode + node.right.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">                path.append(pathNode + node.left.val)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="递归思路">递归思路</h2><ol><li>输入输出：输入节点和targetSum，这里的targetSum每次都需要变小; 输出True/False</li><li>终止条件：不能是判断node是否为空，因为它说明不了什么；需要判断是否为叶子节点，并且判断targetSum是否为零，为零则返回True；如果叶子节点且targetSum不为零，返回False</li><li>单层逻辑，判断左、右子树是否已经存在了满足target的路径，存在就返回True</li></ol><h2 id="递归代码">递归代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(N)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self, node: TreeNode, targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 终止条件不能是判断node是否为空，因为它说明不了什么</span></span><br><span class="line">        <span class="comment"># 需要判断是否为叶子节点，并且判断targetSum是否为零</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right <span class="keyword">and</span> <span class="number">0</span> == targetSum:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 如果叶子节点且targetSum不为零，返回False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            <span class="comment"># 每一次都需要判断是否它的左子树已经找到了targetSum为零的情况</span></span><br><span class="line">            <span class="keyword">if</span> self.foo(node.left, targetSum - node.left.val):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            <span class="comment"># 每一次都需要判断是否它的右子树已经找到了targetSum为零的情况</span></span><br><span class="line">            <span class="keyword">if</span> self.foo(node.right, targetSum - node.right.val):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># </span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.foo(root, targetSum)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="113-路径总和-ii">113. 路径总和 II</h1><p><a href="https://leetcode.cn/problems/path-sum-ii/">https://leetcode.cn/problems/path-sum-ii/</a></p><p>给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22</span><br><span class="line">输出：[[5,4,11,2],[5,8,4,5]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3], targetSum = 5</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2], targetSum = 0</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点总数在范围 <code>[0, 5000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li><li><code>-1000 &lt;= targetSum &lt;= 1000</code></li></ul><h2 id="思路">思路</h2><ol><li>和之前做的差不多，但注意，这里是将<code>pathNode + [node.right.val]</code> 传进去path里，所以对pathNode本身没有修改，如果直接修改pathNode，会把所有路径的值都添加进去，就不对了</li></ol><h2 id="迭代代码">迭代代码</h2><ul><li>时间复杂度O(N^2)</li><li>空间复杂度O(N^2)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        stack = <span class="built_in">list</span>()</span><br><span class="line">        path = <span class="built_in">list</span>()</span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack.append(root)</span><br><span class="line">        path.append([root.val])</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            <span class="comment"># print(path)</span></span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="comment"># 先把节点从path中弹出</span></span><br><span class="line">            pathNode = path.pop()</span><br><span class="line">            <span class="comment"># 为了实现中、前、后，入栈需要使用中、后、前</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">sum</span>(pathNode) == targetSum:</span><br><span class="line">                    res.append(pathNode)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">                <span class="comment"># 注意，这里是将pathNode + [node.right.val]传进去，所以对pathNode本身没有修改</span></span><br><span class="line">                <span class="comment"># 如果直接修改pathNode，会把所有路径的值都添加进去，就不对了</span></span><br><span class="line">                path.append(pathNode + [node.right.val])</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">                path.append(pathNode + [node.left.val])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="递归代码">递归代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(N)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.res = <span class="built_in">list</span>()</span><br><span class="line">        self.path = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self, node: TreeNode, targetSum: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="comment"># 终止条件不能是判断node是否为空，因为它说明不了什么</span></span><br><span class="line">        <span class="comment"># 需要判断是否为叶子节点，并且判断targetSum是否为零</span></span><br><span class="line">        <span class="comment"># print(self.res, self.path)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right <span class="keyword">and</span> targetSum == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(self.res, self.path, )</span><br><span class="line">            self.res.append(self.path[:])</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果叶子节点且targetSum不为零，返回False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            <span class="comment"># 每一次都需要判断是否它的左子树已经找到了targetSum为零的情况</span></span><br><span class="line">            self.path.append(node.left.val)</span><br><span class="line">            self.foo(node.left, targetSum - node.left.val)</span><br><span class="line">            self.path.pop()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            <span class="comment"># 每一次都需要判断是否它的右子树已经找到了targetSum为零的情况</span></span><br><span class="line">            self.path.append(node.right.val)</span><br><span class="line">            self.foo(node.right, targetSum - node.right.val)</span><br><span class="line">            self.path.pop()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        self.res.clear()</span><br><span class="line">        self.path.clear()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> self.res</span><br><span class="line">        self.path.append(root.val)</span><br><span class="line">        self.foo(root, targetSum - root.val)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure><h1 id="106-从中序与后序遍历序列构造二叉树">106. 从中序与后序遍历序列构造二叉树</h1><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/</a></p><p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗 <em>二叉树</em> 。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]</span><br><span class="line">输出：[3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：inorder = [-1], postorder = [-1]</span><br><span class="line">输出：[-1]</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= inorder.length &lt;= 3000</code></li><li><code>postorder.length == inorder.length</code></li><li><code>-3000 &lt;= inorder[i], postorder[i] &lt;= 3000</code></li><li><code>inorder</code> 和 <code>postorder</code> 都由 <strong>不同</strong> 的值组成</li><li><code>postorder</code> 中每一个值都在 <code>inorder</code> 中</li><li><code>inorder</code> <strong>保证</strong>是树的中序遍历</li><li><code>postorder</code> <strong>保证</strong>是树的后序遍历</li></ul><h2 id="递归思路">递归思路</h2><ol><li>用两个指针，一个指针指向inorder首，一个指向postorder末尾</li><li>使用while循环，当left.val == right.val时<ol><li>右子树</li><li>left的下标也是右子树的postorder的开始下标</li><li>right - 1的下标是右子树postorder的结束下标（注意python里列表的右是开区间，所以写postorder[left: right]即可）</li><li>left + 1 是inorder中右子树开始下标，并且后面全是右子树</li><li>左子树</li><li>left 是inorder中左子树结束下标，并且前面全是左子树</li><li>left 是postorder中左子树结束下标，并且前面全是左子树</li></ol></li></ol><p>把左子树想成一大块儿；右子树想成一大块儿，就好理解了</p><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>in</td><td><code>左子树</code></td><td><code>左子树</code></td><td>3</td><td><strong>右子树</strong></td><td><strong>右子树</strong></td><td><strong>右子树</strong></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Post</td><td><code>左子树</code></td><td><code>左子树</code></td><td><strong>右子树</strong></td><td><strong>右子树</strong></td><td><strong>右子树</strong></td><td>3</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>left</td><td></td><td></td><td>Right</td></tr></tbody></table><p>这是对于3的两个子树的区间位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">leftTree = self.foo(inorder[:left], postorder[:left])</span><br><span class="line">rightTree = self.foo(inorder[left + <span class="number">1</span>:], postorder[left: right])</span><br></pre></td></tr></table></figure><h2 id="递归代码">递归代码</h2><ul><li>时间复杂度O(N^2)—最好情况O(NlogN)</li><li>空间复杂度O(N^2)</li><li>可以将while找root替换成index函数，即<code>left = inorder.index(postorder[right])</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self, inorder: <span class="type">List</span>[<span class="built_in">int</span>], postorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(inorder) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(postorder) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> inorder[left] != postorder[right]:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        leftTree = self.foo(inorder[:left], postorder[:left])</span><br><span class="line">        rightTree = self.foo(inorder[left + <span class="number">1</span>:], postorder[left: right])</span><br><span class="line"></span><br><span class="line">        node = TreeNode(inorder[left])</span><br><span class="line">        node.left = leftTree</span><br><span class="line">        node.right = rightTree</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, inorder: <span class="type">List</span>[<span class="built_in">int</span>], postorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="keyword">return</span> self.foo(inorder, postorder)</span><br></pre></td></tr></table></figure><h1 id="105-从前序与中序遍历序列构造二叉树">105. 从前序与中序遍历序列构造二叉树</h1><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]</span><br><span class="line">输出: [3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: preorder = [-1], inorder = [-1]</span><br><span class="line">输出: [-1]</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= preorder.length &lt;= 3000</code></li><li><code>inorder.length == preorder.length</code></li><li><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li><li><code>preorder</code> 和 <code>inorder</code> 均 <strong>无重复</strong> 元素</li><li><code>inorder</code> 均出现在 <code>preorder</code></li><li><code>preorder</code> <strong>保证</strong> 为二叉树的前序遍历序列</li><li><code>inorder</code> <strong>保证</strong> 为二叉树的中序遍历序列</li></ul><h2 id="代码">代码</h2><ul><li>时间复杂度O(N)—最好情况O(logN)</li><li>空间复杂度O(N)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], inorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(preorder) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = inorder.index(preorder[left])</span><br><span class="line"></span><br><span class="line">        leftTree = self.foo(preorder[left + <span class="number">1</span>: right + <span class="number">1</span>], inorder[:right])</span><br><span class="line">        rightTree = self.foo(preorder[right + <span class="number">1</span>:], inorder[right + <span class="number">1</span>:])</span><br><span class="line">        root = TreeNode(preorder[left])</span><br><span class="line">        root.left = leftTree</span><br><span class="line">        root.right = rightTree</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], inorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">return</span> self.foo(preorder, inorder)</span><br></pre></td></tr></table></figure><h1 id="889-根据前序和后序遍历构造二叉树">889. 根据前序和后序遍历构造二叉树</h1><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/</a></p><p>给定两个整数数组，<code>preorder</code> 和 <code>postorder</code> ，其中 <code>preorder</code> 是一个具有 <strong>无重复</strong> 值的二叉树的前序遍历，<code>postorder</code> 是同一棵树的后序遍历，重构并返回二叉树。</p><p>如果存在多个答案，您可以返回其中 <strong>任何</strong> 一个。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/07/24/lc-prepost.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]</span><br><span class="line">输出：[1,2,3,4,5,6,7]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: preorder = [1], postorder = [1]</span><br><span class="line">输出: [1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= preorder.length &lt;= 30</code></li><li><code>1 &lt;= preorder[i] &lt;= preorder.length</code></li><li><code>preorder</code> 中所有值都 <strong>不同</strong></li><li><code>postorder.length == preorder.length</code></li><li><code>1 &lt;= postorder[i] &lt;= postorder.length</code></li><li><code>postorder</code> 中所有值都 <strong>不同</strong></li><li>保证 <code>preorder</code> 和 <code>postorder</code> 是同一棵二叉树的前序遍历和后序遍历</li></ul><h2 id="递归思路">递归思路</h2><ol><li>和中充&amp;后序构造/前序&amp;中序构造不太一样，只知道前序和后序，需要更精确地知道左、右子树的区间；</li><li>除了需要知道当前root节点rootIndexPost以外，还需要知道左（或者右）的root节点rootIndexLeftTreeInPost的位置，这样才能判断左（或右）子树的区间</li><li>输入输出：输入为前&amp;后序列，输出为子树</li><li>终止条件：序列为空则返回None表示空节点，序列长度为1则返回这个叶子节点</li><li>单层逻辑：找到root（preorder的第一个就是），再以当前root为中心，找到它的左、右子树区间；使用递归找左、右子树，按拼接到root上就好；难度在于找到左、右树区间范围</li></ol><h2 id="递归代码">递归代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, preorder, postorder </span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(preorder)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(preorder) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># </span></span><br><span class="line">        rootIndexPost = <span class="built_in">len</span>(postorder)</span><br><span class="line">        rootIndexLeftTreeInPost = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> postorder[rootIndexLeftTreeInPost] != preorder[<span class="number">1</span>]:</span><br><span class="line">            rootIndexLeftTreeInPost += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        leftTree = self.buildTree(preorder[<span class="number">1</span>: <span class="number">1</span> + rootIndexLeftTreeInPost + <span class="number">1</span>], postorder[: rootIndexLeftTreeInPost + <span class="number">1</span>])</span><br><span class="line">        rightTree = self.buildTree(preorder[<span class="number">1</span> + rootIndexLeftTreeInPost + <span class="number">1</span>: ], postorder[rootIndexLeftTreeInPost + <span class="number">1</span>: -<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        root = TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line">        root.left = leftTree</span><br><span class="line">        root.right = rightTree</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">constructFromPrePost</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], postorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">return</span> self.buildTree(preorder, postorder)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday16&quot;&gt;LeetCodeCampsDay16&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;记录下，今儿三个题目一次过；&lt;/p&gt;
&lt;p&gt;其中&lt;strong&gt;路径总和问题&lt;/strong&gt;和之前&lt;strong&gt;求二叉树的所有路径相似&lt;/s</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay15二叉树part03</title>
    <link href="https://blog.lthero.cn/2025/07/09/LeetCodeCampsDay15/"/>
    <id>https://blog.lthero.cn/2025/07/09/LeetCodeCampsDay15/</id>
    <published>2025-07-09T06:12:49.000Z</published>
    <updated>2025-07-10T10:40:48.171Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday15二叉树part03">LeetCodeCampsDay15二叉树part03</h1><blockquote><p>涉及树的高度/深度求解，以及平衡二叉树的判断，完全二叉树求节点个数；</p><p>根节点到任意节点的路径/深度求解</p></blockquote><h1 id="平衡二叉树">平衡二叉树</h1><p><a href="https://leetcode.cn/problems/balanced-binary-tree/">https://leetcode.cn/problems/balanced-binary-tree/</a></p><p>给定一个二叉树，判断它是否是 平衡二叉树</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,2,3,3,null,null,4,4]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中的节点数在范围 <code>[0, 5000]</code> 内</li><li><code>-104 &lt;= Node.val &lt;= 104</code></li></ul><h2 id="后序递归思路">后序递归思路</h2><p>这里强调一波概念：</p><ul><li>二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。</li><li>二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。</li></ul><p>但leetcode中强调的深度和高度很明显是按照节点来计算的，如图：</p><p><img src="https://file1.kamacoder.com/i/algo/20210203155515650.png" alt="img"></p><p>如何判断一个树是不是平衡二叉树？—<strong>判断它的左树和右树的高度是否差大于1</strong></p><p>使用<strong>递归+后序</strong>遍历方法</p><ol><li>输入节点；输出高度（或者-1，表示高度差已经大于1了）</li><li>终止条件：节点为空返回0</li><li>单层逻辑：分别求左、右子树的高度，判断两者高度差，如果大于1则返回-1；否则返回1+max(左,右)</li></ol><p>顺便提一下，在day14写过“求最大深度”，当时也使用后序递归算法；当时仅需要每个节点找到子树的深度，再加一即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">leftDeepth = self.traverse(node.left)</span><br><span class="line">rightDeepth = self.traverse(node.right)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>(leftDeepth, rightDeepth) + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>而现在需要求每个节点的子树高度，是同样的代码，因为求最大深度，即**“根节点的高度就是二叉树的最大深度”**</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">leftHeight = self.getHeight(node.left)</span><br><span class="line">rightHeight = self.getHeight(node.right)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(leftHeight, rightHeight)</span><br></pre></td></tr></table></figure><p>但需要添加几个约束条件，比如求了leftH和righH后判断两者是否为-1，如果是，直接提前退出；以及判断两者高度差是否大于1</p><h2 id="后序递归代码">后序递归代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(H)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getHeight</span>(<span class="params">self, node</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 分别求左、右子树的高度，如果高度差大于1，则返回-1</span></span><br><span class="line">        leftHeight = self.getHeight(node.left)</span><br><span class="line">        <span class="keyword">if</span> leftHeight == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        rightHeight = self.getHeight(node.right)</span><br><span class="line">        <span class="keyword">if</span> rightHeight == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(leftHeight, rightHeight)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isBalanced</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 本题目尝试用递归法</span></span><br><span class="line">        res = self.getHeight(root)</span><br><span class="line">        <span class="keyword">if</span> res != -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h1 id="257-二叉树的所有路径">257. 二叉树的所有路径</h1><p><a href="https://leetcode.cn/problems/binary-tree-paths/">https://leetcode.cn/problems/binary-tree-paths/</a></p><p>给你一个二叉树的根节点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3,null,5]</span><br><span class="line">输出：[&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：[&quot;1&quot;]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[1, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h2 id="思路">思路</h2><p>已知前序遍历是长这样的</p><p><img src="https://file1.kamacoder.com/i/algo/20210204151702443.png" alt="img"></p><p>还是按递归的方式写个前序，但终止条件有点儿不同，以往是判断node为空就直接返回，但这题目需要<strong>判断“如果当前节点为叶子节点”，就将根到节点的路径保存</strong>。所以，还需要有个path列表来记录路径，同时还需要个res列表记录所有从根节点到叶子节点的路径</p><p>于是，</p><ol><li>递归的输入：node, path, res；输出就是res（用引用的方式输出就好）</li><li>终止条件：当前节点无孩子节点，则将当前的path添加到res里</li><li>单层逻辑：依然使用前序遍历，但需要添加判断条件，仅当left/right不为空时才能执行递归；而且递归后，需要将当前节点从path中弹出去<ol><li>比如[1,2,3,null,5],当找到了path=[1,2,5]后，如果不把[2,5]弹出，下次path会记录成[1,2,5,3]而不是正确答案[1,3]</li></ol></li></ol><p>本题使用递归写简单直接一点儿，用迭代也可以完成</p><h2 id="递归代码">递归代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(H)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preOrder</span>(<span class="params">self, node: TreeNode, path: <span class="built_in">list</span>, res: <span class="built_in">list</span></span>):</span><br><span class="line">        <span class="comment"># 操作, 必须放最前面（在终止条件前面）</span></span><br><span class="line">        path.append(node.val)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">            <span class="comment"># res里已经记录了[1,2,5]，需要将它转成1-&gt;2-&gt;5</span></span><br><span class="line">            s = <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(path) - <span class="number">1</span>):</span><br><span class="line">                s += (<span class="built_in">str</span>(path[i]) + <span class="string">&quot;-&gt;&quot;</span>)</span><br><span class="line">            s += <span class="built_in">str</span>(path[-<span class="number">1</span>])</span><br><span class="line">            res.append(s)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历</span></span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            self.preOrder(node.left, path, res)</span><br><span class="line">            <span class="comment"># 回溯只会发生在，当前节点的子节点都被遍历完了</span></span><br><span class="line">            <span class="comment"># 假设现在子节点已经被遍历完，需要进行回溯</span></span><br><span class="line">            path.pop()</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            self.preOrder(node.right, path, res)</span><br><span class="line">            <span class="comment"># 回溯</span></span><br><span class="line">            path.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">binaryTreePaths</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="comment"># 先用递归实现个前序遍历</span></span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        path = <span class="built_in">list</span>()</span><br><span class="line">        self.preOrder(root, path, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="迭代代码">迭代代码</h2><p>迭代的过程更简单一点儿</p><ul><li>时间复杂度O(N)</li><li>空间复杂度O(H)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  stack = <span class="built_in">list</span>()</span><br><span class="line">  path = <span class="built_in">list</span>()</span><br><span class="line">  res = <span class="built_in">list</span>()</span><br><span class="line">  stack.append(root)</span><br><span class="line">  path.append(<span class="built_in">str</span>(root.val))</span><br><span class="line">  <span class="keyword">while</span> stack:</span><br><span class="line">      node = stack.pop()</span><br><span class="line"><span class="comment"># 先把节点从path中弹出</span></span><br><span class="line">      pathNode = path.pop()</span><br><span class="line">      <span class="comment"># 为了实现中、前、后，入栈需要使用中、后、前</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">          res.append(pathNode)</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> node.right:</span><br><span class="line">          stack.append(node.right)</span><br><span class="line">          <span class="comment"># </span></span><br><span class="line">          path.append(pathNode + <span class="string">&quot;-&gt;&quot;</span> + <span class="built_in">str</span>(node.right.val))</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> node.left:</span><br><span class="line">          stack.append(node.left)</span><br><span class="line">          path.append(pathNode + <span class="string">&quot;-&gt;&quot;</span> + <span class="built_in">str</span>(node.left.val))</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="思考">思考</h2><p>day14以及day15中都有求二叉树的高度的题目（实现起来不难），并且有一个求最大深度的题目（但当时是直接用“根节点的高度“），但它规避了求某个节点所在深度的问题</p><p>深度的定义：<strong>指从根节点到该节点的最长简单路径边的长度</strong></p><p>比如[3,9,20,7]，其中7所在深度为3，对应的路径为[3,20,7]长度也为3</p><p>那么问题可以变成如何求根节点到任意节点的路径，思路可以和本题很像，这题目的终止条件是“遇到叶子节点”才把路径添加到res；而可以扩展成，遇到“target节点”就把路径添加到res</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">binaryTreePaths</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], target: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        stack = <span class="built_in">list</span>()</span><br><span class="line">        path = <span class="built_in">list</span>()</span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        stack.append(root)</span><br><span class="line">        path.append(<span class="built_in">str</span>(root.val))</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            pathNode = path.pop()</span><br><span class="line">            <span class="comment"># 为了实现中、前、后，入栈需要使用中、后、前</span></span><br><span class="line">            <span class="comment"># 这里使用val数值判断，当然可以通过地址判断，从而唯一对应target</span></span><br><span class="line">            <span class="comment"># if node.val == target.val:</span></span><br><span class="line">            <span class="comment">#     res.append(pathNode)</span></span><br><span class="line">            <span class="comment"># 可以使用地址进行唯一的对应</span></span><br><span class="line">            <span class="keyword">if</span> node == target:</span><br><span class="line">                res.append(pathNode)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">                path.append(pathNode + <span class="string">&quot;-&gt;&quot;</span> + <span class="built_in">str</span>(node.right.val))</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">                path.append(pathNode + <span class="string">&quot;-&gt;&quot;</span> + <span class="built_in">str</span>(node.left.val))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">root = TreeNode(<span class="number">1</span>)</span><br><span class="line">root.left = TreeNode(<span class="number">2</span>)</span><br><span class="line">root.right = TreeNode(<span class="number">3</span>)</span><br><span class="line">target = TreeNode(<span class="number">5</span>)</span><br><span class="line">root.left.left = target</span><br><span class="line"><span class="built_in">print</span>(so.binaryTreePaths(root, target))</span><br></pre></td></tr></table></figure><p>输入root为[1,2,3,null,5]，target为[5]</p><p>输出[‘1-&gt;2-&gt;5’]，从而得知5的深度为3</p><h1 id="404-左叶子之和">404. 左叶子之和</h1><p><a href="https://leetcode.cn/problems/sum-of-left-leaves/">https://leetcode.cn/problems/sum-of-left-leaves/</a></p><p>给定二叉树的根节点 <code>root</code> ，返回所有左叶子之和。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/04/08/leftsum-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [3,9,20,null,null,15,7] </span><br><span class="line">输出: 24 </span><br><span class="line">解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [1]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li>节点数在 <code>[1, 1000]</code> 范围内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h2 id="递归思路">递归思路</h2><p>这题目要求是求“左子树之和”，如图所示；</p><p><img src="https://file1.kamacoder.com/i/algo/20220902165805.png" alt="img"></p><p>可以使用递归的后序遍历</p><ol><li>终止条件：if not node: return 0</li><li>输入输出：输入为node，输出为int，表示当前节点的左叶子之和</li><li>单层递归逻辑：求左子树的左叶子和、右子树的左叶子之和，再将两者相加，得到了当前节点的左叶子之和（这也是使用后序遍历的原因）</li></ol><p>但有个不同点，如何判断当前节点是父节点的左叶子；</p><p>可以当父节点是当前节点时，判断node.left.left和node.left.right是否为空，判断当前的左子节点是否为空，<strong>如果其左子节点是叶子，则当前节点的左子树之和就是node.left.val</strong></p><h2 id="递归代码">递归代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(H)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postOrder</span>(<span class="params">self, node: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 终止条件</span></span><br><span class="line">        <span class="comment"># 如果当前节点为空，则返回0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 终止条件二，找到了叶子节点，返回零，因为它的左右子树为空(Optional，不写这个终止条件也行，无非是多递归一层)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 需要在当前节点，判断，它的左子节点是否为空，如果不为空，则判断它左子节点是否为叶子节点</span></span><br><span class="line">        <span class="comment"># 左子树</span></span><br><span class="line">        sumOfLeft = self.postOrder(node.left)</span><br><span class="line">        <span class="comment"># 左子树的特殊情况，即“左叶子节点”，此时才能将 sumOfLeft 设置为 node.left.val</span></span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left.left <span class="keyword">and</span> <span class="keyword">not</span> node.left.right:</span><br><span class="line">                sumOfLeft = node.left.val</span><br><span class="line">        <span class="comment"># 右</span></span><br><span class="line">        sumOfRight = self.postOrder(node.right)</span><br><span class="line">        <span class="comment"># 中，求合</span></span><br><span class="line">        <span class="keyword">return</span> sumOfLeft + sumOfRight</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumOfLeftLeaves</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 使用后序遍历，目标是从收集左子树和右子树的“左叶子之和”，再将总和相加</span></span><br><span class="line">        <span class="keyword">return</span> self.postOrder(root)</span><br></pre></td></tr></table></figure><h2 id="迭代思路">迭代思路</h2><ol><li>仍然使用后序遍历，注意入栈时，先中、再右、最后左，这样才能让出栈时的顺序为“左、右、中”</li><li>迭代的过程看着更简单一点儿</li><li>使用前序/中序也可以完成任务，而且这题目对实际顺序不敏感</li><li>比如入栈顺序为[中，右，左]、[中，左，右]、[左，中，右]、[右，中，左]、[左，右，中]、[右，左，中]都可以</li></ol><h2 id="迭代代码">迭代代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(H),最坏O(N)，最好O(logN)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sumOfLeftLeaves</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="comment"># 使用后序遍历（迭代）</span></span><br><span class="line">    stack = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    stack.append(root)</span><br><span class="line">    sumLeftLeaves = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.left.left <span class="keyword">and</span> <span class="keyword">not</span> node.left.right:</span><br><span class="line">            sumLeftLeaves += node.left.val</span><br><span class="line">        <span class="comment"># 注意使用栈时的入栈顺序，先right再left</span></span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            stack.append(node.right)</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            stack.append(node.left)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sumLeftLeaves</span><br></pre></td></tr></table></figure><p>这题目使用前序也可以，如果使用栈+迭代，最好从while的底层向上读代码来理解实际的输出顺序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sumOfLeftLeaves</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    stack = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    stack.append(root)</span><br><span class="line">    sumLeftLeaves = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">      <span class="comment"># 前序，后入先出</span></span><br><span class="line">        node = stack.pop()</span><br><span class="line">        <span class="comment"># 保持&quot;右，左，中“入栈，才能得到“中左右”的效果</span></span><br><span class="line">        <span class="comment"># 处理右</span></span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            stack.append(node.right)</span><br><span class="line">        <span class="comment"># 处理左</span></span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            stack.append(node.left)</span><br><span class="line">        <span class="comment"># 处理中</span></span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.left.left <span class="keyword">and</span> <span class="keyword">not</span> node.left.right:</span><br><span class="line">            sumLeftLeaves += node.left.val</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sumLeftLeaves</span><br></pre></td></tr></table></figure><h1 id="222-完全二叉树的节点个数">222. 完全二叉树的节点个数</h1><p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">https://leetcode.cn/problems/count-complete-tree-nodes/</a></p><p>给你一棵 <strong>完全二叉树</strong> 的根节点 <code>root</code> ，求出该树的节点个数。</p><p><a href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin">完全二叉树</a> 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 <code>h</code> 层（从第 0 层开始），则该层包含 <code>1~ 2h</code> 个节点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/14/complete.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3,4,5,6]</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目范围是<code>[0, 5 * 104]</code></li><li><code>0 &lt;= Node.val &lt;= 5 * 104</code></li><li>题目数据保证输入的树是 <strong>完全二叉树</strong></li></ul><p>**进阶：**遍历树来统计节点是一种时间复杂度为 <code>O(n)</code> 的简单解决方案。你可以设计一个更快的算法吗？</p><h2 id="普通树处理思路">普通树处理思路</h2><ol><li>不管它是什么树，直接用前/中/后/层序遍历处理（递归）就行</li><li>递归输入：节点，输出：子树的节点个数</li><li>终止条件：节点为空返回0</li><li>单层逻辑：求左、右子树节点个数，再计算总和并加一</li></ol><h2 id="普通树的递归代码">普通树的递归代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(H) – 最坏O(N)，最好O(logN)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 使用递归求解, 尝试后序</span></span><br><span class="line">    <span class="comment"># 返回子树的节点个数, 如果当前普通树处理，时间复杂度为O(N)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postOrder</span>(<span class="params">self, node: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        countOfLeft = self.postOrder(node.left)</span><br><span class="line">        countOfRight = self.postOrder(node.right)</span><br><span class="line">        <span class="keyword">return</span> countOfLeft + countOfRight + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countNodes</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.postOrder(root)</span><br></pre></td></tr></table></figure><h2 id="普通树的迭代代码">普通树的迭代代码</h2><p>使用前序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">countNodes</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="comment"># 使用栈+迭代实现</span></span><br><span class="line">    stack = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    stack.append(root)</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            stack.append(node.right)</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            stack.append(node.left)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p>使用层序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">countNodes</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:      </span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">      que = deque()</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">      que.append(root)</span><br><span class="line">      count = <span class="number">0</span></span><br><span class="line">      <span class="keyword">while</span> que:</span><br><span class="line">          node = que.popleft()</span><br><span class="line">          count += <span class="number">1</span></span><br><span class="line">          <span class="keyword">if</span> node.right:</span><br><span class="line">              que.append(node.right)</span><br><span class="line">          <span class="keyword">if</span> node.left:</span><br><span class="line">              que.append(node.left)</span><br><span class="line">          </span><br><span class="line">      <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h2 id="完成二叉树思路">完成二叉树思路</h2><p>在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^(h-1)  个节点。</p><p><img src="https://file1.kamacoder.com/i/algo/20200920221638903-20230310123444151.png" alt="img"></p><p>完全二叉树只有两种情况，情况一：就是满二叉树，情况二：最后一层叶子节点没有满。</p><p>对于情况一，可以直接用 2^树深度 - 1 来计算，注意这里根节点深度为1。</p><p>对于情况二，分别递归左孩子，和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后依然可以按照情况1来计算。</p><p>完全二叉树（一）如图：</p><p><img src="https://file1.kamacoder.com/i/algo/20201124092543662.png" alt="img"></p><p>完全二叉树（二）如图：</p><p><img src="https://file1.kamacoder.com/i/algo/20201124092634138.png" alt="img"></p><p>可以看出如果整个树不是满二叉树，就递归其左右孩子，直到遇到满二叉树为止，用公式计算这个子树（满二叉树）的节点数量。</p><p>这里关键在于<strong>如何去判断一个左子树或者右子树是不是满二叉树呢？</strong> —如果<strong>递归向左遍历的深度等于递归向右遍历的深度</strong>，那说明就是满二叉树</p><p>顺便提一句，如何判断一个树是否为平衡二叉树？----判断左、右子树的高度差，如果高度差大于1则不是</p><p><img src="https://file1.kamacoder.com/i/algo/20220829163554.png" alt="img"></p><p>下面这图中“向右遍历的深度为2”指的是，令rightNode = node.right，并且循环rightNode = rightNode.right并count+=1，一路向右，如果出现了“非满二叉树”就出出现深度为2，否则深度一定为3；就像左边一样</p><blockquote><p>通过<strong>leftNode一路向左，rightNode一路向右</strong>，来判断子树的深度是否一样，是否是满二叉树</p><p>之所以能用<strong>leftNode一路向左，rightNode一路向右</strong>，也是利用了完全二叉树的性质</p></blockquote><p><img src="https://file1.kamacoder.com/i/algo/20220829163709.png" alt="img"></p><h2 id="完全二叉树代码">完全二叉树代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countNum</span>(<span class="params">self, node: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        leftNode = node.left</span><br><span class="line">        rightNode = node.right</span><br><span class="line">        <span class="comment"># 求左、右子树的深度</span></span><br><span class="line">        leftDepth = <span class="number">0</span></span><br><span class="line">        rightDepth = <span class="number">0</span></span><br><span class="line">        <span class="comment"># leftNode一路向左</span></span><br><span class="line">        <span class="keyword">while</span> leftNode:</span><br><span class="line">            leftNode = leftNode.left</span><br><span class="line">            leftDepth += <span class="number">1</span></span><br><span class="line">        <span class="comment"># rightNode一路向右</span></span><br><span class="line">        <span class="keyword">while</span> rightNode:</span><br><span class="line">            rightNode = rightNode.right</span><br><span class="line">            rightDepth += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 满二叉树</span></span><br><span class="line">        <span class="keyword">if</span> leftDepth == rightDepth:</span><br><span class="line">            <span class="comment"># 直接返回总数2^D - 1</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="number">2</span> &lt;&lt; leftDepth) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 单层逻辑</span></span><br><span class="line">        leftNum = self.countNum(node.left)</span><br><span class="line">        rightNum = self.countNum(node.right)</span><br><span class="line">        <span class="keyword">return</span> leftNum + rightNum + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">countNodes</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 完全二叉树统计</span></span><br><span class="line">        <span class="keyword">return</span> self.countNum(root)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday15二叉树part03&quot;&gt;LeetCodeCampsDay15二叉树part03&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;涉及树的高度/深度求解，以及平衡二叉树的判断，完全二叉树求节点个数；&lt;/p&gt;
&lt;p&gt;根节点到任意节点的路径/</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
    <category term="二叉树" scheme="https://blog.lthero.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
</feed>
