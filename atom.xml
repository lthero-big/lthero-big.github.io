<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lthero</title>
  
  <subtitle>个人博客</subtitle>
  <link href="https://blog.lthero.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.lthero.cn/"/>
  <updated>2025-07-07T15:35:45.099Z</updated>
  <id>https://blog.lthero.cn/</id>
  
  <author>
    <name>lthero</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCodeCampsDay13</title>
    <link href="https://blog.lthero.cn/2025/07/07/LeetCodeCampsDay13/"/>
    <id>https://blog.lthero.cn/2025/07/07/LeetCodeCampsDay13/</id>
    <published>2025-07-07T04:15:53.000Z</published>
    <updated>2025-07-07T15:35:45.099Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树的递归遍历">二叉树的递归遍历</h1><p>二叉树的递归遍历，或者说“所有的递归”都离不开三个因素</p><ol><li>确定递归函数的input与output(参数与返回值)</li><li>终止条件</li><li>单层递归的逻辑</li></ol><p>以中序遍历为例</p><ol><li><p>确定递归函数的参数与返回值：</p><ol><li>需要有“当前节点”，其次，需要将中序遍历的结果放在res数组中;可以不返回</li><li><code>def traversal(cur: TreeNode, res: List): ..... return</code></li></ol></li><li><p>终止条件</p><ol><li>当“当前节点”为空时，则终止</li><li><code>if not cur: return</code></li></ol></li><li><p>单层递归的逻辑</p><ol><li><p>先将&quot;cur.val&quot;添加到res中，再递归遍历&quot;cur.left&quot;，最终递归遍历&quot;cur.right&quot;</p></li><li><pre><code class="language-python">res.append(cur.val)    // 中traversal(cur.left, res);  // 左traversal(cur.right, res); // 右<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 144. 二叉树的前序遍历</span><br><span class="line"></span><br><span class="line">https://leetcode.cn/problems/binary-tree-preorder-traversal/</span><br><span class="line"></span><br><span class="line">给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**示例 1：**</span><br><span class="line"></span><br><span class="line">**输入：**root = [1,null,2,3]</span><br><span class="line"></span><br><span class="line">**输出：**[1,2,3]</span><br><span class="line"></span><br><span class="line">**解释：**</span><br><span class="line"></span><br><span class="line">![img](https://assets.leetcode.com/uploads/2024/08/29/screenshot-2024-08-29-202743.png)</span><br><span class="line"></span><br><span class="line">**示例 2：**</span><br><span class="line"></span><br><span class="line">**输入：**root = [1,2,3,4,5,null,8,null,null,6,7,9]</span><br><span class="line"></span><br><span class="line">**输出：**[1,2,4,5,6,7,3,8,9]</span><br><span class="line"></span><br><span class="line">**解释：**</span><br><span class="line"></span><br><span class="line">![img](https://assets.leetcode.com/uploads/2024/08/29/tree_2.png)</span><br><span class="line"></span><br><span class="line">**示例 3：**</span><br><span class="line"></span><br><span class="line">**输入：**root = []</span><br><span class="line"></span><br><span class="line">**输出：**[]</span><br><span class="line"></span><br><span class="line">**示例 4：**</span><br><span class="line"></span><br><span class="line">**输入：**root = [1]</span><br><span class="line"></span><br><span class="line">**输出：**[1]</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">**提示：**</span><br><span class="line"></span><br><span class="line">- 树中节点数目在范围 `[0, 100]` 内</span><br><span class="line">- `-100 &lt;= Node.val &lt;= 100`</span><br><span class="line"></span><br><span class="line">**进阶：**递归算法很简单，你可以通过迭代算法完成吗？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 递归思路</span><br><span class="line"></span><br><span class="line">1. 确定递归函数的输入&amp;输出；确定终止条件；确定单层递归的逻辑</span><br><span class="line">2. 前序遍历，先记录cur.val，再分别递归左、右子树</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 递归代码</span><br><span class="line"></span><br><span class="line">* 时间复杂度O(N)</span><br><span class="line">* 空间复杂度O(1)</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="line">#         self.val = val</span><br><span class="line">#         self.left = left</span><br><span class="line">#         self.right = right</span><br><span class="line">class Solution:</span><br><span class="line">    # preorder</span><br><span class="line">    def traversal(self, cur: TreeNode, res: List):</span><br><span class="line">        if not cur:</span><br><span class="line">            return</span><br><span class="line">        res.append(cur.val)</span><br><span class="line">        self.traversal(cur.left, res)</span><br><span class="line">        self.traversal(cur.right, res)</span><br><span class="line"></span><br><span class="line">    def preorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:</span><br><span class="line">        res = []</span><br><span class="line">        self.traversal(root, res)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure></code></pre></li></ol></li></ol><h2 id="迭代思路">迭代思路</h2><ol><li>取：中间节点</li><li>处理：将中间节点元素放进result数组中</li><li>访问：遍历子节点</li></ol><p><img src="https://file1.kamacoder.com/i/algo/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89.gif" alt="img"></p><h2 id="迭代代码">迭代代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="comment"># 迭代实现</span></span><br><span class="line">    stack = <span class="built_in">list</span>()</span><br><span class="line">    res = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    stack.append(root)</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        <span class="comment"># 取中间节点</span></span><br><span class="line">        node = stack.pop()</span><br><span class="line">        <span class="comment"># 处理：将元素放在res</span></span><br><span class="line">        res.append(node.val)</span><br><span class="line">        <span class="comment"># 访问：遍历子节点</span></span><br><span class="line">        <span class="keyword">if</span> node.right: <span class="comment"># 加入右节点</span></span><br><span class="line">            stack.append(node.right)</span><br><span class="line">        <span class="keyword">if</span> node.left: <span class="comment"># 加入左节点</span></span><br><span class="line">            stack.append(node.left)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="统一迭代代码">统一迭代代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># preorder</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">traversal</span>(<span class="params">self, cur: TreeNode, res: <span class="type">List</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        res.append(cur.val)</span><br><span class="line">        self.traversal(cur.left, res)</span><br><span class="line">        self.traversal(cur.right, res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        stack = [(root, <span class="literal">False</span>)] <span class="keyword">if</span> root <span class="keyword">else</span> []</span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node, visit_status = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> visit_status:</span><br><span class="line">                res.append(node.val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 按前序遍历，“中左右”，但这里是栈，所以应该是“右左中”；不过，我决定在最后使用反转大法</span></span><br><span class="line">                <span class="comment"># 所以这里还是按“中左右”进行入栈</span></span><br><span class="line">                stack.append((node, <span class="literal">True</span>))</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    stack.append((node.left, <span class="literal">False</span>))</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    stack.append((node.right, <span class="literal">False</span>))</span><br><span class="line">                </span><br><span class="line">        </span><br><span class="line">        res = res[::-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">            </span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="145-二叉树的后序遍历">145. 二叉树的后序遍历</h1><p><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">https://leetcode.cn/problems/binary-tree-postorder-traversal/</a></p><p>给你一棵二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>后序遍历</strong> 。</p><p><strong>示例 1：</strong></p><p>**输入：**root = [1,null,2,3]</p><p><strong>输出：</strong>[3,2,1]</p><p><strong>解释：</strong></p><p><img src="https://assets.leetcode.com/uploads/2024/08/29/screenshot-2024-08-29-202743.png" alt="img"></p><p><strong>示例 2：</strong></p><p>**输入：**root = [1,2,3,4,5,null,8,null,null,6,7,9]</p><p><strong>输出：</strong>[4,6,7,5,2,9,8,3,1]</p><p><strong>解释：</strong></p><p><img src="https://assets.leetcode.com/uploads/2024/08/29/tree_2.png" alt="img"></p><p><strong>示例 3：</strong></p><p>**输入：**root = []</p><p><strong>输出：</strong>[]</p><p><strong>示例 4：</strong></p><p>**输入：**root = [1]</p><p><strong>输出：</strong>[1]</p><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p>**进阶：**递归算法很简单，你可以通过迭代算法完成吗？</p><h2 id="递归代码">递归代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">traversal</span>(<span class="params">self, cur: TreeNode, res: <span class="type">List</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.traversal(cur.left, res) <span class="comment"># 左</span></span><br><span class="line">        self.traversal(cur.right, res) <span class="comment"># 右</span></span><br><span class="line">        res.append(cur.val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        self.traversal(root, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="迭代思路">迭代思路</h2><ol><li>前序遍历是&quot;中左右&quot;，将它换成&quot;中右左&quot;，再将res反转就得到了&quot;左右中&quot;（多少是带了技巧的）</li></ol><p><img src="https://file1.kamacoder.com/i/algo/20200808200338924.png" alt="img"></p><h2 id="迭代代码">迭代代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(N)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="comment"># 迭代遍历</span></span><br><span class="line">    stack = <span class="built_in">list</span>()</span><br><span class="line">    res = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    stack.append(root)</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        res.append(node.val)</span><br><span class="line">        <span class="comment"># 将前序遍历的顺序更换</span></span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            stack.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            stack.append(node.right)</span><br><span class="line">    <span class="comment"># 最后将结果反转</span></span><br><span class="line">    res = res[::-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">        </span><br></pre></td></tr></table></figure><h2 id="统一迭代代码">统一迭代代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 统一迭代遍历</span></span><br><span class="line">    <span class="comment"># stack使用bool对每个节点进行标记，False表示没访问过，True则访问过</span></span><br><span class="line">    stack = [(root, <span class="literal">False</span>)] <span class="keyword">if</span> root <span class="keyword">else</span> []</span><br><span class="line">    res = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node, visit_statue = stack.pop()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果节点已经visited，</span></span><br><span class="line">        <span class="keyword">if</span> visit_statue:</span><br><span class="line">            res.append(node.val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 没有访问过这节点，则按后序遍历方式&quot;左右中“”</span></span><br><span class="line">            <span class="comment"># 当然也可以使用反转大法，这里就按“左右中”的方式入栈，最后需要将res反转</span></span><br><span class="line">            <span class="keyword">if</span> node.left: <span class="comment"># 左子节点</span></span><br><span class="line">                stack.append((node.left, <span class="literal">False</span>)) </span><br><span class="line">            <span class="keyword">if</span> node.right: <span class="comment"># 右子节点</span></span><br><span class="line">                stack.append((node.right, <span class="literal">False</span>))</span><br><span class="line">            <span class="comment"># 中间节点，注意标记为True</span></span><br><span class="line">            stack.append((node, <span class="literal">True</span>))</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">    res = res[::-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="二叉树的中序遍历">二叉树的中序遍历</h1><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">https://leetcode.cn/problems/binary-tree-inorder-traversal/</a></p><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,null,2,3]</span><br><span class="line">输出：[1,3,2]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><h2 id="递归代码">递归代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">traversal</span>(<span class="params">self, cur: TreeNode, res: <span class="type">List</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.traversal(cur.left, res) <span class="comment"># 左</span></span><br><span class="line">        res.append(cur.val)</span><br><span class="line">        self.traversal(cur.right, res) <span class="comment"># 右</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        self.traversal(root, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="迭代思路">迭代思路</h2><p>1.中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了<strong>处理顺序和访问顺序是不一致的。</strong></p><p>那么<strong>在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</strong></p><p><img src="https://file1.kamacoder.com/i/algo/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89.gif" alt="img"></p><h2 id="迭代代码">迭代代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="comment"># res = list()</span></span><br><span class="line">    <span class="comment"># self.traversal(root, res)</span></span><br><span class="line">    <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 迭代</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    res = <span class="built_in">list</span>()</span><br><span class="line">    stack = <span class="built_in">list</span>()</span><br><span class="line">    cur = root</span><br><span class="line">    <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">        <span class="comment"># 先一路干到最底层的左子树节点</span></span><br><span class="line">        <span class="keyword">if</span> cur:</span><br><span class="line">            stack.append(cur)</span><br><span class="line">            cur = cur.left</span><br><span class="line">        <span class="comment"># 到达最左节点后，开始处理栈顶节点</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = stack.pop()</span><br><span class="line">            res.append(cur.val)</span><br><span class="line">            <span class="comment"># 取栈顶元素右节点</span></span><br><span class="line">            cur = cur.right</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="统一迭代代码">统一迭代代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="comment"># 统一迭代</span></span><br><span class="line">    stack = [(root, <span class="literal">False</span>)] <span class="keyword">if</span> root <span class="keyword">else</span> []</span><br><span class="line">    res = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node, visit_status = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> visit_status:</span><br><span class="line">            res.append(node.val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 按中序遍历，“左中右”，但这里是栈，所以应该是“右中左”；不过，我决定在最后使用反转大法</span></span><br><span class="line">            <span class="comment"># 所以这里还是按“左中右”进行入栈</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append((node.left, <span class="literal">False</span>))</span><br><span class="line">            stack.append((node, <span class="literal">True</span>))</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append((node.right, <span class="literal">False</span>))</span><br><span class="line">            </span><br><span class="line">    <span class="comment"># 上面为了方便理解，使用left, mid, right的方式进行入栈，最后需要进行反转结果</span></span><br><span class="line">    res = res[::-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="二叉树的迭代遍历">二叉树的迭代遍历</h1><p>除了使用递归的方式实现二叉树的遍历，还可以使用“迭代的方法”</p><p>递归的本质是：<strong>每一次递归调用，都会把函数的局部变量</strong>，参数值和返回地址等信息压入调用栈中，等递归返回的时候，<strong>从栈顶弹出上一次递归的各项参数</strong></p><p>前序遍历（迭代实现）</p><p>前序遍历输出“中，左，右”，所以需要先将“中间”节点放在栈中，然后弹出，并将右孩子入栈，再加入左孩子（因为后入先出，左孩子得先出，所以得后入）</p><p><img src="https://file1.kamacoder.com/i/algo/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89.gif" alt="img"></p><h1 id="二叉树的统一迭代">二叉树的统一迭代</h1><p><strong>加一个 <code>boolean</code> 值跟随每个节点，<code>false</code> (默认值) 表示需要为该节点和它的左右儿子安排在栈中的位次，<code>true</code> 表示该节点的位次之前已经安排过了，可以收割节点了。</strong></p><p>这种方法可以叫做<code>boolean 标记法</code>， 这种方法更容易理解，在面试中更容易写出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># stack的初始化</span></span><br><span class="line"><span class="comment"># 其中的False表示这个节点没有访问过，需要给这个节点以及它的左、右两个节点安排位置</span></span><br><span class="line">stack = [(root, <span class="literal">False</span>)] <span class="keyword">if</span> root <span class="keyword">else</span> []</span><br><span class="line">res = <span class="built_in">list</span>()</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="keyword">while</span> stack:</span><br><span class="line">  <span class="comment"># 弹出一个节点进行visit状态的判断</span></span><br><span class="line">    node, visit_status = stack.pop()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果已经visited过，说明可以收割了，将node结果放在res里</span></span><br><span class="line">    <span class="keyword">if</span> visit_status:</span><br><span class="line">      res.append(node.val)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="comment"># 下面就是按“既定顺序”添加到stack中即可</span></span><br><span class="line">      <span class="comment"># 比如前序就是“中左右”</span></span><br><span class="line">      stack.append((node, <span class="literal">True</span>))</span><br><span class="line">      <span class="keyword">if</span> node.left:</span><br><span class="line">        stack.append((node.left, <span class="literal">False</span>))</span><br><span class="line">      <span class="keyword">if</span> node.right:</span><br><span class="line">        stack.append((node.right, <span class="literal">False</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于res是个栈，而上面添加到栈的顺序是按“既定顺序”添加的，而实际输出需要进行反转(因为栈是先入后出)</span></span><br><span class="line">res = res[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二叉树的递归遍历&quot;&gt;二叉树的递归遍历&lt;/h1&gt;
&lt;p&gt;二叉树的递归遍历，或者说“所有的递归”都离不开三个因素&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;确定递归函数的input与output(参数与返回值)&lt;/li&gt;
&lt;li&gt;终止条件&lt;/li&gt;
&lt;li&gt;单层递归的逻辑&lt;/li&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay11</title>
    <link href="https://blog.lthero.cn/2025/07/06/LeetCodeCampsDay11/"/>
    <id>https://blog.lthero.cn/2025/07/06/LeetCodeCampsDay11/</id>
    <published>2025-07-06T14:37:48.000Z</published>
    <updated>2025-07-06T16:01:41.864Z</updated>
    
    <content type="html"><![CDATA[<h1 id="150-逆波兰表达式求值">150. 逆波兰表达式求值</h1><p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">https://leetcode.cn/problems/evaluate-reverse-polish-notation/</a></p><p>给你一个字符串数组 <code>tokens</code> ，表示一个根据 <a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437">逆波兰表示法</a> 表示的算术表达式。</p><p>请你计算该表达式。返回一个表示表达式值的整数。</p><p><strong>注意：</strong></p><ul><li>有效的算符为 <code>'+'</code>、<code>'-'</code>、<code>'*'</code> 和 <code>'/'</code> 。</li><li>每个操作数（运算对象）都可以是一个整数或者另一个表达式。</li><li>两个整数之间的除法总是 <strong>向零截断</strong> 。</li><li>表达式中不含除零运算。</li><li>输入是一个根据逆波兰表示法表示的算术表达式。</li><li>答案及所有中间计算结果可以用 <strong>32 位</strong> 整数表示。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]</span><br><span class="line">输出：9</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]</span><br><span class="line">输出：6</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]</span><br><span class="line">输出：22</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：</span><br><span class="line">  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / (12 * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / -132)) + 17) + 5</span><br><span class="line">= ((10 * 0) + 17) + 5</span><br><span class="line">= (0 + 17) + 5</span><br><span class="line">= 17 + 5</span><br><span class="line">= 22</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= tokens.length &lt;= 104</code></li><li><code>tokens[i]</code> 是一个算符（<code>&quot;+&quot;</code>、<code>&quot;-&quot;</code>、<code>&quot;*&quot;</code> 或 <code>&quot;/&quot;</code>），或是在范围 <code>[-200, 200]</code> 内的一个整数</li></ul><p><strong>逆波兰表达式：</strong></p><p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p><ul><li>平常使用的算式则是一种中缀表达式，如 <code>( 1 + 2 ) * ( 3 + 4 )</code> 。</li><li>该算式的逆波兰表达式写法为 <code>( ( 1 2 + ) ( 3 4 + ) * )</code> 。</li></ul><p>逆波兰表达式主要有以下两个优点：</p><ul><li>去掉括号后表达式无歧义，上式即便写成 <code>1 2 + 3 4 + * </code>也可以依据次序计算出正确结果。</li><li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</li></ul><h2 id="思路">思路</h2><p>其实逆波兰表达式相当于是二叉树中的后序遍历</p><ol><li>使用个栈实现，遇到数字就进栈，遇到符号则弹出两个数字进行计算，将计算结果再入栈</li><li>本题中每一个子表达式要得出一个结果，然后拿这个结果再进行运算，那么这岂不就是一个相邻字符串消除的过程，和<a href="https://programmercarl.com/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.html">1047.删除字符串中的所有相邻重复项 (opens new window)</a>中的对对碰游戏是不是就非常像了</li></ol><p><img src="https://file1.kamacoder.com/i/algo/150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.gif" alt="img"></p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">evalRPN</span>(<span class="params">self, tokens: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 使用个栈实现，遇到数字就进栈，遇到符号则弹出两个数字进行计算，将计算结果再入栈</span></span><br><span class="line">        <span class="comment"># python可用list实现</span></span><br><span class="line">        curStack = <span class="built_in">list</span>()</span><br><span class="line">        symbolList = [<span class="string">&#x27;+&#x27;</span>, <span class="string">&quot;-&quot;</span>, <span class="string">&quot;*&quot;</span>, <span class="string">&quot;/&quot;</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> tokens:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> symbolList:</span><br><span class="line">                curStack.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(curStack) &gt;= <span class="number">2</span>:</span><br><span class="line">                    num2 = <span class="built_in">int</span>(curStack.pop())</span><br><span class="line">                    num1 = <span class="built_in">int</span>(curStack.pop())</span><br><span class="line">                    <span class="keyword">if</span> i == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                        res = num1 + num2</span><br><span class="line">                    <span class="keyword">elif</span> i == <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                        res = num1 - num2</span><br><span class="line">                    <span class="keyword">elif</span> i == <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                        res = num1 * num2</span><br><span class="line">                    <span class="keyword">elif</span> i == <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                        res = num1 / num2</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">                    curStack.append(res)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(curStack.pop())              </span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="单调队列">单调队列</h1><blockquote><p>维护一个只能单调增加/减少的队列，队列的front值一定是最大/最小值</p></blockquote><p><img src="https://file1.kamacoder.com/i/algo/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.gif" alt="img"></p><p>对于窗口里的元素{2, 3, 5, 1 ,4}，单调队列里只维护{5, 4} 就够了，保持单调队列里单调递减，此时队列出口元素就是窗口里最大元素。</p><p>设计单调队列的时候，pop，和push操作要保持如下规则：</p><ol><li>pop(value)：如果窗口移除的元素value等于单调队列的front元素，那么队列弹出元素，否则不用任何操作（滑动窗口在右移时需要用到pop，此时只能pop出最大/小值，<strong>因为非“最大/最小”值都已经不在这个队列里的</strong>）</li><li>push(value)：如果push的元素value大于tail元素的数值，那么就将队列tail的元素弹出，直到push元素的数值小于等于队列tail元素的数值为止；保证如果value是最大/最小值，则value一定会在front</li></ol><p>保持如上规则，每次窗口移动的时候，只要问que.front()就可以返回当前窗口的最大值。</p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myQueue</span>():</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,</span>):</span><br><span class="line">            self.que = deque()</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, value</span>):</span><br><span class="line">            <span class="built_in">print</span>(self.que)</span><br><span class="line">            <span class="comment"># 若value大于que的tail值，需要不断tail值弹出，保证如果value是最大/最小值，则value一定会在front</span></span><br><span class="line">            <span class="keyword">while</span> self.que <span class="keyword">and</span> value &gt; self.que[-<span class="number">1</span>]:</span><br><span class="line">                self.que.pop()</span><br><span class="line">            self.que.append(value)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self, value</span>):</span><br><span class="line">            <span class="built_in">print</span>(self.que)</span><br><span class="line">            <span class="comment"># 判断value是否等于front值，如果相等则弹出</span></span><br><span class="line">            <span class="keyword">if</span> self.que <span class="keyword">and</span> value == self.que[<span class="number">0</span>]:</span><br><span class="line">                self.que.popleft()</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">front</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="comment"># 返回队列前端(即最大值)</span></span><br><span class="line">            <span class="keyword">return</span> self.que[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h1 id="239-滑动窗口最大值">239. 滑动窗口最大值</h1><p><a href="https://leetcode.cn/problems/sliding-window-maximum/">https://leetcode.cn/problems/sliding-window-maximum/</a></p><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p><p>返回 <em>滑动窗口中的最大值</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1], k = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>1 &lt;= k &lt;= nums.length</code></li></ul><h2 id="思路">思路</h2><ol><li>需要使用单调队列</li><li></li></ol><p>以题目示例为例，输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3，动画如下：</p><p><img src="https://file1.kamacoder.com/i/algo/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-2.gif" alt="img"></p><h2 id="代码">代码</h2><ul><li>时间复杂度O(n) — nums 中的每个元素最多也就被 push_back 和 pop_back 各一次，没有任何多余操作，所以整体的复杂度还是 O(n)</li><li>空间复杂度O(k)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myQueue</span>():</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,</span>):</span><br><span class="line">            self.que = deque()</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, value</span>):</span><br><span class="line">            <span class="built_in">print</span>(self.que)</span><br><span class="line">            <span class="comment"># 若value大于que的tail值，需要不断tail值弹出，保证如果value是最大/最小值，则value一定会在front</span></span><br><span class="line">            <span class="keyword">while</span> self.que <span class="keyword">and</span> value &gt; self.que[-<span class="number">1</span>]:</span><br><span class="line">                self.que.pop()</span><br><span class="line">            self.que.append(value)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self, value</span>):</span><br><span class="line">            <span class="built_in">print</span>(self.que)</span><br><span class="line">            <span class="comment"># 判断value是否等于front值，如果相等则弹出</span></span><br><span class="line">            <span class="keyword">if</span> self.que <span class="keyword">and</span> value == self.que[<span class="number">0</span>]:</span><br><span class="line">                self.que.popleft()</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">front</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="comment"># 返回队列前端(即最大值)</span></span><br><span class="line">            <span class="keyword">return</span> self.que[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        que = myQueue()</span><br><span class="line">        results = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            que.push(nums[i])</span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        results.append(que.front())</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, L):</span><br><span class="line">            que.pop(nums[i - k])</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;que.pop: <span class="subst">&#123;nums[i - k]&#125;</span>&quot;</span>)</span><br><span class="line">            que.push(nums[i])</span><br><span class="line">            results.append(que.front())</span><br><span class="line">        <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><h1 id="347-前-k-个高频元素">347. 前 K 个高频元素</h1><p><a href="https://leetcode.cn/problems/top-k-frequent-elements/">https://leetcode.cn/problems/top-k-frequent-elements/</a></p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">输出: [1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1], k = 1</span><br><span class="line">输出: [1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>k</code> 的取值范围是 <code>[1, 数组中不相同的元素的个数]</code></li><li>题目数据保证答案唯一，换句话说，数组中前 <code>k</code> 个高频元素的集合是唯一的</li></ul><p>**进阶：**你所设计算法的时间复杂度 <strong>必须</strong> 优于 <code>O(n log n)</code> ，其中 <code>n</code> 是数组大小。</p><h2 id="思路">思路</h2><ol><li>要统计元素出现频率、对频率排序、找出前K个高频元素</li><li>其中，<strong>统计频率</strong>-----可以使用map完成；</li><li>对<strong>频率排序</strong>----则需要使用“优先级队列”：<strong>一个披着队列外衣的堆</strong>，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列；而且优先级队列内部元素是<strong>自动依照元素的权值排列</strong></li></ol><p><strong>堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。</strong> 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。所以大家经常说的大顶堆（堆头是最大元素），小顶堆（堆头是最小元素）</p><p>题目要求<strong>前 K 个高频元素—决定使用大顶堆还是小顶堆</strong>（因为需要将不需要的数据pop出去），如果使用大顶堆，定义一个大小为k的大顶堆，在每次移动更新大顶堆的时候，每次弹出都把最大的元素弹出去了，那么怎么保留下来前K个高频元素呢。</p><p>而且使用大顶堆就要把所有元素都进行排序，那能不能只排序k个元素呢？</p><p><strong>所以我们要用小顶堆，因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素。</strong></p><h2 id="代码">代码</h2><ul><li>时间复杂度O(nlogk)</li><li>空间复杂度O(k)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">topKFrequent</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        map_ = &#123;&#125;</span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">            map_[nums[i]] = map_.get(nums[i], <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        pri_que = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> key, freq <span class="keyword">in</span> map_.items():</span><br><span class="line">            <span class="comment"># 将(freq, key)添加到pri_que，并且按freq从小到大排序，形成个小顶堆</span></span><br><span class="line">            heapq.heappush(pri_que, (freq, key))</span><br><span class="line">            <span class="comment"># 超出k个则自动弹出，保证仅有k个高频元素在小顶堆中</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(pri_que) &gt; k:</span><br><span class="line">                heapq.heappop(pri_que)</span><br><span class="line">        <span class="built_in">print</span>(pri_que)</span><br><span class="line">        </span><br><span class="line">        results = [<span class="number">0</span>] * k</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            results[i] = heapq.heappop(pri_que)[<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;150-逆波兰表达式求值&quot;&gt;150. 逆波兰表达式求值&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/evaluate-reverse-polish-notation/&quot;&gt;https://leetcode.cn/pro</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay10</title>
    <link href="https://blog.lthero.cn/2025/07/04/LeetCodeCampsDay10/"/>
    <id>https://blog.lthero.cn/2025/07/04/LeetCodeCampsDay10/</id>
    <published>2025-07-04T13:59:27.000Z</published>
    <updated>2025-07-04T15:27:19.349Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday10">LeetCodeCampsDay10</h1><blockquote><p>使用队列实现栈；</p><p>使用栈实现队列；</p><p>以及两个关于栈的题目</p></blockquote><h1 id="232-用栈实现队列">232. 用栈实现队列</h1><p><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">https://leetcode.cn/problems/implement-queue-using-stacks/</a></p><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p><p>实现 <code>MyQueue</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li><li><code>int pop()</code> 从队列的开头移除并返回元素</li><li><code>int peek()</code> 返回队列开头的元素</li><li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li></ul><p><strong>说明：</strong></p><ul><li>你 <strong>只能</strong> 使用标准的栈操作 —— 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li><li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;]</span><br><span class="line">[[], [1], [2], [], [], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, 1, 1, false]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyQueue myQueue = new MyQueue();</span><br><span class="line">myQueue.push(1); // queue is: [1]</span><br><span class="line">myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)</span><br><span class="line">myQueue.peek(); // return 1</span><br><span class="line">myQueue.pop(); // return 1, queue is [2]</span><br><span class="line">myQueue.empty(); // return false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= x &lt;= 9</code></li><li>最多调用 <code>100</code> 次 <code>push</code>、<code>pop</code>、<code>peek</code> 和 <code>empty</code></li><li>假设所有操作都是有效的 （例如，一个空的队列不会调用 <code>pop</code> 或者 <code>peek</code> 操作）</li></ul><p><strong>进阶：</strong></p><ul><li>你能否实现每个操作均摊时间复杂度为 <code>O(1)</code> 的队列？换句话说，执行 <code>n</code> 个操作的总时间复杂度为 <code>O(n)</code> ，即使其中一个操作可能花费较长时间。</li></ul><h2 id="思路">思路</h2><ol><li>维护两个列表list，其中一个用于入栈(stack_in)，一个出栈(stack_out)</li><li>push函数，直接入栈到stack_in</li><li>empty函数，只要stack_out或stack_in不为空即可</li><li>pop函数，先判断是否为“empyt”；<ol><li>其次，如果stack_out中有数字，就出栈这个数；</li><li>stack_out为空的时候，将stack_in全部转移到stack_out，再弹出一个数（比如下面动画弹出“1”和“3”时，明显是将stack_in的所有数据都移到了stack_out中）</li></ol></li></ol><p>下面动画模拟以下队列的执行过程：</p><p>执行语句：<br>queue.push(1);<br>queue.push(2);<br>queue.pop(); <strong>注意此时的输出栈的操作</strong> ,输出1<br>queue.push(3);<br>queue.push(4);<br>queue.pop(); # 输出2<br>queue.pop();<strong>注意此时的输出栈的操作</strong> 输出3<br>queue.pop(); # 输出4<br>queue.empty();</p><p><img src="https://file1.kamacoder.com/i/algo/232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%89%88%E6%9C%AC2.gif" alt="img"></p><h2 id="代码">代码</h2><ul><li>时间复杂度O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.stack_in = []</span><br><span class="line">        self.stack_out = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.stack_in.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> self.empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 如果stack_out中有数据，直接从stack_out中弹出这个 </span></span><br><span class="line">        <span class="keyword">if</span> self.stack_out:</span><br><span class="line">            <span class="keyword">return</span> self.stack_out.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">          <span class="comment"># 先将stack_in的全部转移到stack_out中</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.stack_in)):</span><br><span class="line">                self.stack_out.append(self.stack_in.pop())</span><br><span class="line">            <span class="comment"># 再从stack_out中弹出一个</span></span><br><span class="line">            <span class="keyword">return</span> self.stack_out.pop()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = self.pop()</span><br><span class="line">        self.stack_out.append(ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> (self.stack_in <span class="keyword">or</span> self.stack_out)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyQueue()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.peek()</span></span><br><span class="line"><span class="comment"># param_4 = obj.empty()</span></span><br></pre></td></tr></table></figure><h1 id="225-用队列实现栈">225. 用队列实现栈</h1><p><a href="https://leetcode.cn/problems/implement-stack-using-queues/">https://leetcode.cn/problems/implement-stack-using-queues/</a></p><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code>push</code>、<code>top</code>、<code>pop</code> 和 <code>empty</code>）。</p><p>实现 <code>MyStack</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 压入栈顶。</li><li><code>int pop()</code> 移除并返回栈顶元素。</li><li><code>int top()</code> 返回栈顶元素。</li><li><code>boolean empty()</code> 如果栈是空的，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul><p><strong>注意：</strong></p><ul><li>你只能使用队列的标准操作 —— 也就是 <code>push to back</code>、<code>peek/pop from front</code>、<code>size</code> 和 <code>is empty</code> 这些操作。</li><li>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MyStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;top&quot;, &quot;pop&quot;, &quot;empty&quot;]</span><br><span class="line">[[], [1], [2], [], [], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, 2, 2, false]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyStack myStack = new MyStack();</span><br><span class="line">myStack.push(1);</span><br><span class="line">myStack.push(2);</span><br><span class="line">myStack.top(); // 返回 2</span><br><span class="line">myStack.pop(); // 返回 2</span><br><span class="line">myStack.empty(); // 返回 False</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= x &lt;= 9</code></li><li>最多调用<code>100</code> 次 <code>push</code>、<code>pop</code>、<code>top</code> 和 <code>empty</code></li><li>每次调用 <code>pop</code> 和 <code>top</code> 都保证栈不为空</li></ul><p>**进阶：**你能否仅用一个队列来实现栈。</p><h2 id="思路">思路</h2><ol><li>使用两个队列实现栈，一个输入队列que_in，一个输出队列que_backup</li><li>push函数，直接用que_in加入；</li><li>empty函数，如果queue_in不为空即可</li><li>pop函数，先判断是否为空；<ol><li>先将L-1个数字转移到que_backup，再将que_backup与que_in交换，再将最后一个数字弹出</li></ol></li><li>top函数，调用pop函数，再将数据添加回que_in即可</li></ol><p>模拟的队列执行语句如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">queue.<span class="built_in">push</span>(<span class="number">1</span>);        </span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">2</span>);        </span><br><span class="line">queue.<span class="built_in">pop</span>();   <span class="comment">// 注意弹出的操作       </span></span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">3</span>);        </span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">4</span>);       </span><br><span class="line">queue.<span class="built_in">pop</span>();  <span class="comment">// 注意弹出的操作    </span></span><br><span class="line">queue.<span class="built_in">pop</span>();    </span><br><span class="line">queue.<span class="built_in">pop</span>();    </span><br><span class="line">queue.<span class="built_in">empty</span>();    </span><br></pre></td></tr></table></figure><p><img src="https://file1.kamacoder.com/i/algo/225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.gif" alt="img"></p><h2 id="代码">代码</h2><ul><li>时间复杂度O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>:</span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.queue_in = deque()</span><br><span class="line">        self.queue_out = deque()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.queue_in.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> self.empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 由于queue是FIFO，比如stack中有[1-&gt;3-&gt;4   如果想弹出4，</span></span><br><span class="line">        <span class="comment"># 此时队列A中  4-&gt;3-&gt;1，需要将3-&gt;1这两个数字转移到另一个队列B，再将4弹出去</span></span><br><span class="line">        <span class="comment"># 这里是len(self.queue_in) - 1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.queue_in) - <span class="number">1</span>):</span><br><span class="line">            self.queue_out.append(self.queue_in.popleft())</span><br><span class="line">        <span class="comment"># 然后进行两个队列的交换，因为只有一个数据在queue_in中，其余都在queue_out</span></span><br><span class="line">        self.queue_in, self.queue_out = self.queue_out, self.queue_in</span><br><span class="line">        <span class="keyword">return</span> self.queue_out.popleft()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 调用self.pop，将pop出来的数字再加回到self.queue_in里</span></span><br><span class="line">        ans = self.pop()</span><br><span class="line">        self.queue_in.append(ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.queue_in</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.empty()</span></span><br></pre></td></tr></table></figure><h2 id="思路二-仅用一个队列">思路二(仅用一个队列)</h2><ol><li>上述使用的que_backup可以省略掉，将数据反复加入到queue_in即可了</li></ol><h2 id="代码">代码</h2><ul><li>时间复杂度O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>:</span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.queue_in = deque()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.queue_in.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> self.empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 由于queue是FIFO，比如stack中有[1-&gt;3-&gt;4   如果想弹出4，</span></span><br><span class="line">        <span class="comment"># 此时队列A中  4-&gt;3-&gt;1，需要将3-&gt;1这两个数字转移到另一个队列B，再将4弹出去</span></span><br><span class="line">        <span class="comment"># 这里是len(self.queue_in) - 1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.queue_in) - <span class="number">1</span>):</span><br><span class="line">          <span class="comment"># 重新添加回去</span></span><br><span class="line">            self.queue_in.append(self.queue_in.popleft())</span><br><span class="line">        <span class="keyword">return</span> self.queue_in.popleft()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 调用self.pop，将pop出来的数字再加回到self.queue_in里</span></span><br><span class="line">        ans = self.pop()</span><br><span class="line">        self.queue_in.append(ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.queue_in</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.empty()</span></span><br></pre></td></tr></table></figure><h1 id="20-有效的括号">20. 有效的括号</h1><p><a href="https://leetcode.cn/problems/valid-parentheses/">https://leetcode.cn/problems/valid-parentheses/</a></p><p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'&#123;'</code>，<code>'&#125;'</code>，<code>'['</code>，<code>']'</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><p><strong>示例 1：</strong></p><p>**输入：**s = “()”</p><p>**输出：**true</p><p><strong>示例 2：</strong></p><p>**输入：**s = “()[]{}”</p><p>**输出：**true</p><p><strong>示例 3：</strong></p><p>**输入：**s = “(]”</p><p>**输出：**false</p><p><strong>示例 4：</strong></p><p>**输入：**s = “([])”</p><p>**输出：**true</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅由括号 <code>'()[]&#123;&#125;'</code> 组成</li></ul><h2 id="思路">思路</h2><ol><li>使用栈解决<ol><li>如果是左括号就入栈</li><li>如果是右括号就出栈（且栈不空）并判断是否是对应的左括号（使用下标判断）</li><li>否则就直接返回False，比如s=’]’</li></ol></li><li>最后再判断栈是否还有剩余，比如s=’[’</li></ol><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 如果是左括号就入栈，如果是右括号就出栈</span></span><br><span class="line">        leftList = [<span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>, <span class="string">&#x27;[&#x27;</span>]</span><br><span class="line">        rightList = [<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;]&#x27;</span>]</span><br><span class="line"></span><br><span class="line">        stack = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> leftList:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">elif</span> i <span class="keyword">in</span> rightList <span class="keyword">and</span> <span class="built_in">len</span>(stack) != <span class="number">0</span>:</span><br><span class="line">                l = stack.pop()</span><br><span class="line">                <span class="keyword">if</span> leftList.index(l) != rightList.index(i):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(stack) != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h1 id="1047-删除字符串中的所有相邻重复项">1047. 删除字符串中的所有相邻重复项</h1><p><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/</a></p><p>给出由小写字母组成的字符串 <code>s</code>，<strong>重复项删除操作</strong>会选择两个相邻且相同的字母，并删除它们。</p><p>在 <code>s</code> 上反复执行重复项删除操作，直到无法继续删除。</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;abbaca&quot;</span><br><span class="line">输出：&quot;ca&quot;</span><br><span class="line">解释：</span><br><span class="line">例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= s.length &lt;= 105</code></li><li><code>s</code> 仅由小写英文字母组成</li></ol><h2 id="思路">思路</h2><ol><li>使用栈可以解决，用栈的top函数，可惜python的列表只有pop没有top；不过可以将弹出的重新添加回去</li><li>如果栈不空，就弹出最后元素并与s[i]判断<ol><li>如果相等就不执行操作了（因为已经弹出了）</li><li>如果不相等，则需要将弹出的元素添加回去，并且再将s[i]入栈</li></ol></li><li>如果栈为空，默认添加s[i]入栈</li></ol><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 使用栈的top()，可惜python的列表只有pop没有top</span></span><br><span class="line">        <span class="comment"># </span></span><br><span class="line">        stack = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">          <span class="comment"># 如果栈不空，就弹出并判断</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(stack):</span><br><span class="line">              <span class="comment"># 默认弹出来并进行判断</span></span><br><span class="line">                l = stack.pop()</span><br><span class="line">                <span class="keyword">if</span> l != i:</span><br><span class="line">                    <span class="comment"># 如果l不等于i，再添加回去</span></span><br><span class="line">                    stack.append(l)</span><br><span class="line">                    stack.append(i)</span><br><span class="line">            <span class="comment"># 栈空就默认添加</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(stack)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday10&quot;&gt;LeetCodeCampsDay10&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;使用队列实现栈；&lt;/p&gt;
&lt;p&gt;使用栈实现队列；&lt;/p&gt;
&lt;p&gt;以及两个关于栈的题目&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;232</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay9</title>
    <link href="https://blog.lthero.cn/2025/07/03/LeetCodeCampsDay9/"/>
    <id>https://blog.lthero.cn/2025/07/03/LeetCodeCampsDay9/</id>
    <published>2025-07-03T08:10:02.000Z</published>
    <updated>2025-07-03T13:04:59.403Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday9">LeetCodeCampsDay9</h1><blockquote><p>字符串反转</p></blockquote><h1 id="151-反转字符串中的单词">151. 反转字符串中的单词</h1><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">https://leetcode.cn/problems/reverse-words-in-a-string/</a></p><p>给你一个字符串 <code>s</code> ，请你反转字符串中 <strong>单词</strong> 的顺序。</p><p><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code> 中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p><p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串。</p><p>**注意：**输入字符串 <code>s</code>中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;the sky is blue&quot;</span><br><span class="line">输出：&quot;blue is sky the&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;  hello world  &quot;</span><br><span class="line">输出：&quot;world hello&quot;</span><br><span class="line">解释：反转后的字符串中不能存在前导空格和尾随空格。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;a good   example&quot;</span><br><span class="line">输出：&quot;example good a&quot;</span><br><span class="line">解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 包含英文大小写字母、数字和空格 <code>' '</code></li><li><code>s</code> 中 <strong>至少存在一个</strong> 单词</li></ul><p>**进阶：**如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 <code>O(1)</code> 额外空间复杂度的 <strong>原地</strong> 解法</p><h2 id="思路">思路</h2><ol><li>先去年多余的空格，可以使用快慢指针思路，当快指针遇到字符时，先给slow添加个空格，当作每两个单词之间的空格（当然slow不能为0）；再同时推进slow与fast，将fast指向的单词转移到slow的位置</li><li>再将整体反转</li><li>最后，将每个单词反转for i in range(L + 1):  if i == L or s[i] == &quot; &quot;: 这里需要注意跳出的条件，因为有时最后一个词也需要反转，但最后一个词后面是没有空格的，所以需要将i的范围从0到L都遍历一遍，并且遇到i==L时，再做一次反转（特殊情况）</li></ol><h2 id="代码">代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseClip</span>(<span class="params">self, s:<span class="built_in">list</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        L = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L//<span class="number">2</span>):</span><br><span class="line">            s[i], s[L - i -<span class="number">1</span>] = s[L - i - <span class="number">1</span>], s[i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeSpace</span>(<span class="params">self, s: <span class="built_in">list</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        L = <span class="built_in">len</span>(s)</span><br><span class="line">        slow = <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; L:</span><br><span class="line">            <span class="keyword">if</span> s[i] != <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> slow != <span class="number">0</span>:</span><br><span class="line">                    s[slow] = <span class="string">&quot; &quot;</span></span><br><span class="line">                    slow += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> i &lt; L <span class="keyword">and</span> s[i] != <span class="string">&quot; &quot;</span>:</span><br><span class="line">                    s[slow] = s[i]</span><br><span class="line">                    slow += <span class="number">1</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[:slow]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseWords</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        s = <span class="built_in">list</span>(s)</span><br><span class="line">        <span class="comment"># 先删除空格</span></span><br><span class="line">        s = self.removeSpace(s)</span><br><span class="line">        <span class="comment"># 先反转整体，再局部反转</span></span><br><span class="line">        s = self.reverseClip(s)</span><br><span class="line">        L = <span class="built_in">len</span>(s)</span><br><span class="line">        leftIndex = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i == L <span class="keyword">or</span> s[i] == <span class="string">&quot; &quot;</span>:</span><br><span class="line">                s[leftIndex: i] = self.reverseClip(s[leftIndex: i])</span><br><span class="line">                leftIndex = i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(s)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="右旋字符串-第八期模拟笔试">右旋字符串（第八期模拟笔试）</h1><p><strong>题目描述</strong></p><p>字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。</p><p>例如，对于输入字符串 “abcdefg” 和整数 2，函数应该将其转换为 “fgabcde”。</p><p><strong>输入描述</strong></p><p>输入共包含两行，第一行为一个正整数 k，代表右旋转的位数。第二行为字符串 s，代表需要旋转的字符串。</p><p><strong>输出描述</strong></p><p>输出共一行，为进行了右旋转操作后的字符串。</p><p><strong>输入示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">abcdefg</span><br></pre></td></tr></table></figure><p><strong>输出示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fgabcde</span><br></pre></td></tr></table></figure><p><strong>提示信息</strong></p><p>数据范围：<br>1 &lt;= k &lt; 10000,<br>1 &lt;= s.length &lt; 10000;</p><h2 id="思路">思路</h2><ol><li>将整体反转</li><li>再将前k个反转，以及剩下的L-k个反转</li></ol><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseClip</span>(<span class="params">self, s: <span class="built_in">list</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        L = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L//<span class="number">2</span>):</span><br><span class="line">            s[i], s[L - i - <span class="number">1</span>] = s[L - i - <span class="number">1</span>], s[i]</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseR</span>(<span class="params">self, k: <span class="built_in">int</span>, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        s = <span class="built_in">list</span>(s)</span><br><span class="line">        s = self.reverseClip(s)</span><br><span class="line">        s[<span class="number">0</span>:k] = self.reverseClip(s[<span class="number">0</span>:k])</span><br><span class="line">        s[k:] = self.reverseClip(s[k:])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(s)</span><br><span class="line"></span><br><span class="line">k = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line">solu = solution()</span><br><span class="line">res = solu.reverseR(k, s)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><h1 id="kmp算法">KMP算法</h1><blockquote><p>核心是求“子串的最长相等前后缀”</p><p>比如&quot;aabaaf&quot;，对f来说，它的子串（即aabaa）的最长相等前后缀是&quot;aa&quot;</p><p>前缀不包含最后一个尾字母，后缀不包含首字母</p><p>kmp学了忘，忘记再学，哎，之前都没理解深刻，这次发现了一个很有意思的两个重点</p><ol><li><strong>left指针是个重点</strong>，它是“已经匹配上的前缀的长度”，而且它不是单调变化的</li><li>kmp每次将前n个字符与后n个字符进行匹配，并且n逐个减一地再进行循环匹配，完美解决了“最长前后缀”的匹配问题</li></ol></blockquote><h2 id="kmp思路">KMP思路</h2><ol><li>KMP的核心思路是找“子串的最长相等前后缀”（所谓的前缀表，即，prefix或next数组）</li><li>比如<strong>aa</strong>b<strong>aa</strong>的最长相等前后缀是&quot;aa&quot;，aabaaf的最长相等前后缀是&quot;&quot;，<strong>a</strong>abaaf<strong>a</strong>的最长相等前后缀是&quot;a&quot;</li><li>可以使用双指针思路来找&quot;最长相等前后缀&quot;</li><li>将数组一分为二，比如aa|baaf，其中aa为前缀子串；baaf为后缀子串</li><li>left指针：指向<strong>已匹配上的前缀的长度</strong>，left是非单向的，它初始化为0-&gt;1-&gt;0-&gt;1-&gt;2-&gt;1，只有当s[left]==s[right]时才递增；否则就会下降</li><li>right指针：指向后缀最后一个位置, right是单向递增的，它只会从1-&gt;2-&gt;3…-&gt;n</li></ol><table><thead><tr><th>下标</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td>串</td><td>a</td><td>a</td><td>b</td><td>a</td><td>a</td><td>b</td><td>f</td></tr><tr><td>前缀表(next数组)</td><td>0</td><td>1</td><td>0</td><td>1</td><td>2</td><td>3</td><td>0</td></tr></tbody></table><h3 id="举例求-aabaa-的next数组">举例求&quot;aabaa&quot;的next数组</h3><p>初始化left=0;next数组全为0；right=1</p><table><thead><tr><th>下标</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>串</td><td>a</td><td>a</td><td>b</td><td>a</td><td>a</td></tr><tr><td>前缀表(next数组)</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>变量位置</td><td>left</td><td>right</td><td></td><td></td><td></td></tr></tbody></table><p>s[left]==s[right]，说明找到了一对最长前后缀&quot;aa&quot;</p><p>left更新：left=left+1即下标1（此时需要指向right的位置），left维护的是0~1这个子串里最长前缀的下标</p><p>并更新next数组，next[right]=left，更新了下标1位置的next数组，说明<strong>长度为1的前缀</strong>与**‘a’(1)匹配**</p><table><thead><tr><th>下标</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>串</td><td>a</td><td>a</td><td>b</td><td>a</td><td>a</td></tr><tr><td>前缀表(next数组)</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>变量位置</td><td></td><td>left</td><td>right</td><td></td><td></td></tr></tbody></table><p><strong>While…</strong></p><ul><li>s[left]!=s[right](s[1]!=s[2])，说明’aa’是无法与’b’匹配的</li><li>Left更新left = next[left-1],即left=0</li><li>然后s[left]再与s[right]判断，此时s[left]!=s[right]，再想更新left = next[left-1]，但此时left已经为0，无法更新，因为越界了，所以需要添加个判断条件left&gt;0时才能更新left（这一步是在一个while执行的）</li></ul><p><strong>If…</strong></p><ul><li>s[left]!=s[right](s[0]!=s[2])，说明’a’无法与’b’匹配</li></ul><p>next[right] = left；更新了下标2位置的next数组，说明<strong>长度为0的前缀</strong>与**'b’匹配**</p><p>最后，right更新，指向下标3</p><table><thead><tr><th>下标</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>串</td><td>a</td><td>a</td><td>b</td><td>a</td><td>a</td></tr><tr><td>前缀表(next数组)</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>变量位置</td><td>left</td><td></td><td></td><td>right</td><td></td></tr></tbody></table><p><strong>While…</strong></p><ul><li>s[left]==s[right](s[0]==s[3])，说明’a’(0)是与’a’(3)匹配的，退出while</li></ul><p><strong>If…</strong></p><ul><li>s[left]==s[right](s[0]==s[3])，说明’a’(0)是与’a’(3)匹配的</li><li>left += 1,  # left = 1</li></ul><p>next[right] = left；更新了下标3位置的next数组，说明<strong>长度为1的前缀</strong>与**‘a’(3)匹配**</p><p>最后，right更新，指向下标4</p><table><thead><tr><th>下标</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>串</td><td>a</td><td>a</td><td>b</td><td>a</td><td>a</td></tr><tr><td>前缀表(next数组)</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td>变量位置</td><td></td><td>left</td><td></td><td></td><td>right</td></tr></tbody></table><p><strong>While…</strong></p><ul><li>s[left]==s[right](s[1]==s[4])，说明’aa’(0,1)是与’aa’(3,4)匹配的，退出while</li></ul><p><strong>If…</strong></p><ul><li>s[left]==s[right](s[1]==s[4])，说明’aa’(0,1)是与’aa’(3,4)匹配的</li><li>left += 1, # left = 2</li></ul><p>next[right] = left；更新了下标4位置的next数组，说明<strong>长度为2的前缀</strong>与**‘aa’(3,4)匹配**</p><p>最后，right更新，指向下标5</p><table><thead><tr><th>下标</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>串</td><td>a</td><td>a</td><td>b</td><td>a</td><td>a</td><td>f</td></tr><tr><td>前缀表(next数组)</td><td>0</td><td>1</td><td>0</td><td>1</td><td>2</td><td>0</td></tr><tr><td>变量位置</td><td></td><td></td><td>left</td><td></td><td></td><td>right</td></tr></tbody></table><p><strong>While…</strong></p><blockquote><p>注意，这里虽然只比较了s[left]!=s[right](s[2]!=s[5])，但它实际比较的是**‘aab’(0,1,2)是与’aaf’(3,4,5)不匹配的**，因为**‘aa’(0,1)是与’aa’(3,4)匹配是已知的信息**，只有将s[2]与s[5]判断，就能直接知道这s(0~2)与s(3~5)是否一样了</p></blockquote><ul><li>s[left]!=s[right](s[2]!=s[5])，说明’aab’(0,1,2)是与’aaf’(3,4,5)不匹配的，于是退而求其次</li><li>left = next[left - 1] # left = 1</li><li>s[left]==s[right](s[1]==s[5])，说明’aa’(0,1)是与’af’(4,5)不匹配的，于是退而求其次</li><li>left = next[left - 1] # left = 0</li><li>s[left]==s[right](s[0]==s[5])，说明’a’(0)是与’f’(5)不匹配的，没得退了，此时left=0</li></ul><p><strong>If…</strong></p><ul><li>s[left]!=s[right](s[0]==s[5])，说明’a’(0)是与’f’(5)不匹配的，if不操作</li></ul><p>next[right] = left；更新了下标4位置的next数组，说明<strong>长度为0的前缀</strong>与**‘f’(5)匹配**</p><p>最后，right更新，指向下标6</p><table><thead><tr><th>下标</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td>串</td><td>a</td><td>a</td><td>b</td><td>a</td><td>a</td><td>f</td><td>a</td></tr><tr><td>前缀表(next数组)</td><td>0</td><td>1</td><td>0</td><td>1</td><td>2</td><td>0</td><td>0</td></tr><tr><td>变量位置</td><td>left</td><td></td><td></td><td></td><td></td><td></td><td>right</td></tr></tbody></table><p><img src="https://file1.kamacoder.com/i/algo/KMP%E7%B2%BE%E8%AE%B22.gif" alt="img"></p><blockquote><p>KMP一个很神奇的一点是，它每次将前n个字符与后n个字符进行匹配，并且n逐个减一地再进行循环匹配，比如</p></blockquote><p><strong>’aab’(0,1,2)是与’aaf’(3,4,5)不匹配的</strong></p><p>然后会比较</p><p><strong>’aa’(0,1)是与’af’(4,5)不匹配的</strong>，</p><p>然后再比较</p><p><strong>’a’(0)是与’f’(5)不匹配的</strong></p><p>很完美地完成了“最长前后缀”问题</p><h3 id="怎么理解left指针是已匹配上的前缀的长度呢">怎么理解left指针是已匹配上的前缀的长度呢</h3><p>left代表当前子串 <code>s[0...right]</code> 的“最长相等前后缀”的长度。</p><p>left同时也是指向“最长前缀”的下一个字符的下标。</p><ul><li>当 <code>left</code> 为 0 时，我们比较 <code>s[0]</code> 和 <code>s[right]</code>。</li><li>当 <code>left</code> 为 1 时，意味着前缀 <code>s[0]</code> 已经匹配上了，我们接下来要比较 <code>s[1]</code> 和 <code>s[right]</code>。</li><li>当 <code>left</code> 为 <code>k</code> 时，意味着前缀 <code>s[0...k-1]</code> 已经匹配上了，我们接下来要比较 <code>s[k]</code> 和 <code>s[right]</code>。</li></ul><h2 id="kmp代码">KMP代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getNext</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        <span class="comment"># 函数返回s的最大相等前缀的数值结果表</span></span><br><span class="line">        L = <span class="built_in">len</span>(s)</span><br><span class="line">        nextArry = [<span class="number">0</span>] * L</span><br><span class="line">        left = <span class="number">0</span> <span class="comment"># “已匹配上的前缀的长度”（很关键的一句话，如果能解理就能明白KMP算法了）</span></span><br><span class="line">        nextIndex = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L):</span><br><span class="line">            <span class="comment"># 这里有个假设，next表是已经打造好的东西（或者是一边打造一边就要用）</span></span><br><span class="line">            <span class="comment"># 当s[left] != s[right]，让right向前搜索，令right = next[right - 1];</span></span><br><span class="line">            <span class="comment"># 很关键的思想，有点儿递归的意思</span></span><br><span class="line">            <span class="keyword">while</span> s[left] != s[right] <span class="keyword">and</span> left &gt; <span class="number">0</span>:</span><br><span class="line">                left = nextArry[left]</span><br><span class="line">            <span class="comment"># 当s[left]等于s[right]说明找到了一组相等的前后缀</span></span><br><span class="line">            <span class="keyword">if</span> s[left] == s[right]:</span><br><span class="line">                <span class="comment"># 前缀指针向后移动</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 更新next数组，这里的right即是next的下标，也是后缀的下标</span></span><br><span class="line">            <span class="comment"># 当然可以将nextIndex与right分开；这样更明确一点儿</span></span><br><span class="line">            nextArry[nextIndex] = left</span><br><span class="line">            nextIndex += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nextArry</span><br></pre></td></tr></table></figure><h1 id="28-找出字符串中第一个匹配项的下标">28. 找出字符串中第一个匹配项的下标</h1><p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/</a></p><p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串的第一个匹配项的下标（下标从 0 开始）。如果 <code>needle</code> 不是 <code>haystack</code> 的一部分，则返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：haystack = &quot;sadbutsad&quot;, needle = &quot;sad&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：&quot;sad&quot; 在下标 0 和 6 处匹配。</span><br><span class="line">第一个匹配项的下标是 0 ，所以返回 0 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：haystack = &quot;leetcode&quot;, needle = &quot;leeto&quot;</span><br><span class="line">输出：-1</span><br><span class="line">解释：&quot;leeto&quot; 没有在 &quot;leetcode&quot; 中出现，所以返回 -1 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= haystack.length, needle.length &lt;= 104</code></li><li><code>haystack</code> 和 <code>needle</code> 仅由小写英文字符组成</li></ul><h2 id="思路">思路</h2><ol><li>先求next数组；再进行匹配，不过求next数组的代码和匹配字符串时的代码是一样的</li></ol><h2 id="代码">代码</h2><ul><li>时间复杂度O(N+M), 其中N为haystack长度，M是needle长度</li><li>空间复杂度O(M)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getNext</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        <span class="comment"># 函数返回s的最大相等前缀的数值结果表</span></span><br><span class="line">        L = <span class="built_in">len</span>(s)</span><br><span class="line">        nextArry = [<span class="number">0</span>] * L</span><br><span class="line">        left = <span class="number">0</span> <span class="comment"># “当前子串中的最长前缀的下标”（很关键的一句话，如果能解理就能明白KMP算法了）</span></span><br><span class="line">        nextIndex = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L):</span><br><span class="line">            <span class="comment"># 这里有个假设，next表是已经打造好的东西（或者是一边打造一边就要用）</span></span><br><span class="line">            <span class="comment"># 当s[left] != s[right]，让right向前搜索，令right = next[right - 1];</span></span><br><span class="line">            <span class="comment"># 很关键的思想，有点儿递归的意思</span></span><br><span class="line">            <span class="keyword">while</span> s[left] != s[right] <span class="keyword">and</span> left &gt; <span class="number">0</span>:</span><br><span class="line">                left = nextArry[left - <span class="number">1</span>]</span><br><span class="line">            <span class="comment"># 当s[left]等于s[right]说明找到了一组相等的前后缀</span></span><br><span class="line">            <span class="keyword">if</span> s[left] == s[right]:</span><br><span class="line">                <span class="comment"># 前缀指针向后移动</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 更新next数组，这里的right即是next的下标，也是后缀的下标</span></span><br><span class="line">            <span class="comment"># 当然可以将nextIndex与right分开；这样更明确一点儿</span></span><br><span class="line">            nextArry[right] = left</span><br><span class="line">            <span class="comment"># nextIndex += 1</span></span><br><span class="line">        <span class="keyword">return</span> nextArry</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">strStr</span>(<span class="params">self, haystack: <span class="built_in">str</span>, needle: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nextArry = self.getNext(needle)</span><br><span class="line">        L = <span class="built_in">len</span>(needle)</span><br><span class="line">        L_hay = <span class="built_in">len</span>(haystack)</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>( L_hay):</span><br><span class="line">            <span class="keyword">while</span> left &gt; <span class="number">0</span> <span class="keyword">and</span> haystack[i] != needle[left]:</span><br><span class="line">                left = nextArry[left - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> needle[left] == haystack[i]:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 唯独需要在这儿判断是否到了needle的尾部</span></span><br><span class="line">            <span class="keyword">if</span> left == L:</span><br><span class="line">                <span class="keyword">return</span> i - L + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="459-重复的子字符串">459. 重复的子字符串</h1><p><a href="https://leetcode.cn/problems/repeated-substring-pattern/">https://leetcode.cn/problems/repeated-substring-pattern/</a></p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abab&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 可由子串 &quot;ab&quot; 重复两次构成。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;aba&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcabcabc&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 可由子串 &quot;abc&quot; 重复四次构成。 (或子串 &quot;abcabc&quot; 重复两次构成。)</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 由小写英文字母组成</li></ul><h2 id="代码">代码</h2><ul><li>时间复杂度(N)</li><li>空间复杂度(N)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getNext</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        L = <span class="built_in">len</span>(s)</span><br><span class="line">        nextArray = [<span class="number">0</span>] * L</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L):</span><br><span class="line">            <span class="keyword">while</span> s[left]!=s[right] <span class="keyword">and</span> left &gt; <span class="number">0</span>:</span><br><span class="line">                left = nextArray[left - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> s[left]==s[right]:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            nextArray[right] = left</span><br><span class="line">        <span class="keyword">return</span> nextArray</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">repeatedSubstringPattern</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        L = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">if</span> L == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        nextArray = self.getNext(s)</span><br><span class="line">        <span class="keyword">if</span> nextArray[-<span class="number">1</span>]!=<span class="number">0</span> <span class="keyword">and</span> L % (L - nextArray[-<span class="number">1</span>]) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday9&quot;&gt;LeetCodeCampsDay9&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;字符串反转&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;151-反转字符串中的单词&quot;&gt;151. 反转字符串中的单词&lt;/h1&gt;
&lt;p&gt;&lt;a h</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay8</title>
    <link href="https://blog.lthero.cn/2025/07/02/LeetCodeCampsDay8/"/>
    <id>https://blog.lthero.cn/2025/07/02/LeetCodeCampsDay8/</id>
    <published>2025-07-02T08:32:11.000Z</published>
    <updated>2025-07-02T10:17:17.309Z</updated>
    
    <content type="html"><![CDATA[<h1 id="344-反转字符串">344. 反转字符串</h1><p><a href="https://leetcode.cn/problems/reverse-string/">https://leetcode.cn/problems/reverse-string/</a></p><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>s</code> 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>修改输入数组**、使用 O(1) 的额外空间解决这一问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]</span><br><span class="line">输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 105</code></li><li><code>s[i]</code> 都是 <a href="https://baike.baidu.com/item/ASCII">ASCII</a> 码表中的可打印字符</li></ul><h2 id="思路零">思路零</h2><ol><li>使用python内置库函数，可以了解下</li></ol><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseString</span>(<span class="params">self, s: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># method1</span></span><br><span class="line">s[::] = s[::-<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># method2</span></span><br><span class="line">        <span class="comment"># s[::] = reversed(s)</span></span><br></pre></td></tr></table></figure><h2 id="思路一双指针">思路一双指针</h2><ol><li>使用双指针，一个从头开始一个从尾部开始，逐个交换即可</li></ol><h2 id="代码">代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseString</span>(<span class="params">self, s: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        L = <span class="built_in">len</span>(s)</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = L - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            s[left], s[right] = s[right], s[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="思路二用range">思路二用range</h2><ol><li>因为while每次都要判断条件，增加了时间复杂度，可以使用range(0, L//2)</li></ol><h2 id="代码">代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseString</span>(<span class="params">self, s: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        L = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L//<span class="number">2</span>):</span><br><span class="line">            s[i], s[L - i - <span class="number">1</span>] = s[L - i -<span class="number">1</span>], s[i]</span><br></pre></td></tr></table></figure><h2 id="思路三用栈">思路三用栈</h2><ol><li>将数据入栈，再逐个弹出；缺点是需要两个循环</li></ol><h2 id="代码">代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseString</span>(<span class="params">self, s: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        L = <span class="built_in">len</span>(s)</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">            s[i] = stack.pop()</span><br></pre></td></tr></table></figure><h1 id="541-反转字符串-ii">541. 反转字符串 II</h1><p><a href="https://leetcode.cn/problems/reverse-string-ii/">https://leetcode.cn/problems/reverse-string-ii/</a></p><p>给定一个字符串 <code>s</code> 和一个整数 <code>k</code>，从字符串开头算起，每计数至 <code>2k</code> 个字符，就反转这 <code>2k</code> 字符中的前 <code>k</code> 个字符。</p><ul><li>如果剩余字符少于 <code>k</code> 个，则将剩余字符全部反转。</li><li>如果剩余字符小于 <code>2k</code> 但大于或等于 <code>k</code> 个，则反转前 <code>k</code> 个字符，其余字符保持原样。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">输出：&quot;bacdfeg&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abcd&quot;, k = 2</span><br><span class="line">输出：&quot;bacd&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅由小写英文组成</li><li><code>1 &lt;= k &lt;= 104</code></li></ul><h2 id="思路">思路</h2><ol><li>输入是字符串，必须经过处理转成列表；字符串无法被直接修改</li><li>使用反转字符串的思路，写个完全反转的辅助函数</li><li>主思路，使用两个指针，每次按2k的长度对s进行滑动（所谓滑动窗口）<ol><li>对窗口内的子段进行长度判断，如果长度大于等于k，则只反转前k个；否则反转窗口内所有内容</li></ol></li><li>更新left与right；其中left = right；而right = left + 2 * k;</li></ol><h2 id="代码">代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseStrClip</span>(<span class="params">self, s:<span class="built_in">list</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        L = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L//<span class="number">2</span>):</span><br><span class="line">            s[i], s[L - i - <span class="number">1</span>] = s[L - i -<span class="number">1</span>], s[i]</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseStr</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">      <span class="comment"># 字符串无法被修改，必须转成list</span></span><br><span class="line">        s = <span class="built_in">list</span>(s)</span><br><span class="line">        left = right = <span class="number">0</span></span><br><span class="line">        L = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="comment"># 退出条件是left到底</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;  L:</span><br><span class="line">            left = right</span><br><span class="line">            right = left + <span class="number">2</span> * k</span><br><span class="line">            <span class="keyword">if</span> right - left &gt;= k:</span><br><span class="line">                s[left: left+k] = self.reverseStrClip(s[left: left+k])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">              <span class="comment"># 因为剩下所有的内容已经小于k了，全部反转即可</span></span><br><span class="line">              s[left:] = self.reverseStrClip(s[left:])</span><br><span class="line">                <span class="comment">#s[left: right] = self.reverseStrClip(s[left: right])</span></span><br><span class="line">        <span class="comment"># 转回字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(s)</span><br></pre></td></tr></table></figure><p>改进，同样的，推荐使用range而不是while，可以提高速度</p><p>Range(0, L, 2 * k)，即将i作为left，而right每次手动计算下即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseStrClip</span>(<span class="params">self, s:<span class="built_in">list</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        L = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L//<span class="number">2</span>):</span><br><span class="line">            s[i], s[L - i - <span class="number">1</span>] = s[L - i -<span class="number">1</span>], s[i]</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseStr</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 设置好开始结束区间</span></span><br><span class="line">        <span class="comment"># 一共两个条件</span></span><br><span class="line">        s = <span class="built_in">list</span>(s)</span><br><span class="line">        left = right = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 退出条件是left到底</span></span><br><span class="line">        L = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, L , <span class="number">2</span> * k):</span><br><span class="line">            <span class="keyword">if</span> i + k &lt;= L:</span><br><span class="line">                s[i: i + k] = self.reverseStrClip(s[i: i + k])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">              <span class="comment"># 剩下内容个数小于k，全部反转</span></span><br><span class="line">              <span class="comment"># s[i:] = self.reverseStrClip(s[i:]) 也是可以的</span></span><br><span class="line">                s[i: i + <span class="number">2</span> * k] = self.reverseStrClip(s[i: i + <span class="number">2</span> * k])</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(s)</span><br></pre></td></tr></table></figure><h2 id="思路二-python列表特性语法糖">思路二(Python列表特性语法糖)</h2><blockquote><p>Python列表特性语法糖</p></blockquote><ol><li>更直接一点儿，都不用进行条件判断，<strong>直接对每次2k内的前k个元素进行反转即可</strong>（不用管它长度是大于k还是小于k，直接按k个进行切片）</li><li>这里利用了<strong>python的一个列表性质</strong>：s[start:end]，哪怕end越出了实际长度，python只会把它当成s[start:-1]，也就是把start后所有内容返回，而不会报错；<ul><li>比如s = [‘a’, ‘b’] 且k = 4，如果i = 0时，s[0 + 4]会是[‘a’, ‘b’]</li></ul></li><li>利用这种性质，可以直接<code>s[i: i + k] = self.reverseStrClip(s[i: i + k])</code> ，而不用进行长度的判断；这也算是语法糖了，这种东西最好不要用，不然容易解释不清楚，还以为这样的算法是正确的，但没想到是语言在兜底</li></ol><h2 id="代码">代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(N)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseStr</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">L = <span class="built_in">len</span>(s)</span><br><span class="line">        s = <span class="built_in">list</span>(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, L, <span class="number">2</span> * k):</span><br><span class="line">          <span class="comment"># </span></span><br><span class="line">            s[i: i + k] = s[i: i + k][::-<span class="number">1</span>]</span><br><span class="line">            <span class="comment"># 或者用自己写的函数也行</span></span><br><span class="line">            <span class="comment"># s[i: i + k] = self.reverseStrClip(s[i: i + k])</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(s)</span><br></pre></td></tr></table></figure><h1 id="54-替换数字">54.替换数字</h1><p><a href="https://kamacoder.com/problempage.php?pid=1064">https://kamacoder.com/problempage.php?pid=1064</a></p><p><strong>题目描述</strong></p><p>给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。 例如，对于输入字符串 “a1b2c3”，函数应该将其转换为 “anumberbnumbercnumber”。</p><p><strong>输入描述</strong></p><p>输入一个字符串 s,s 仅包含小写字母和数字字符。</p><p><strong>输出描述</strong></p><p>打印一个新的字符串，其中每个数字字符都被替换为了number</p><p><strong>输入示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a1b2c3</span><br></pre></td></tr></table></figure><p><strong>输出示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anumberbnumbercnumber</span><br></pre></td></tr></table></figure><p><strong>提示信息</strong></p><p>数据范围：<br>1 &lt;= s.length &lt; 10000。</p><h2 id="思路">思路</h2><ol><li>偷懒思路：字符串转成列表，再判断是否为数字，是则替换</li><li>可以使用ord()来找ascii码，比较通用；或者使用python库函数s.isdigit()</li></ol><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">s:<span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    s = <span class="built_in">list</span>(s)</span><br><span class="line">    L = <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">ord</span>(<span class="string">&#x27;9&#x27;</span>) &gt;= <span class="built_in">ord</span>(s[i]) &gt;= <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>):</span><br><span class="line">            s[i] = <span class="string">&quot;number&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(s)</span><br><span class="line"></span><br><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line"><span class="built_in">print</span>(foo(s))</span><br></pre></td></tr></table></figure><h2 id="思路二-纯算法">思路二(纯算法)</h2><ol><li>如果需要正常写，需要进行 <code>数组扩展</code> 以及 <code>数组填充</code>（倒序填充）</li><li>先统计原数组内的digital个数，再创建个新数组res，容量为<strong>len(s) + countDig * 5</strong></li><li>随后，使用双指针，同时对s与res从后向前遍历，如果遇到s[indexOld]是digital则将res[indexNew-5: indexNew+1]=&quot;number&quot;直接赋值即可，或者逐个赋值；如果不是digital，直接将s[indexOld]复制到res[indexNew]即可</li></ol><p><img src="https://file1.kamacoder.com/i/algo/20231030173058.png" alt="img"></p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        L = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="comment"># 统计str中digital个数</span></span><br><span class="line">        countDigital = <span class="built_in">sum</span>(<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> s <span class="keyword">if</span> i.isdigit())</span><br><span class="line">        <span class="comment"># 创建新结果数组, 等于原数组长度 + countDigital * 5</span></span><br><span class="line">        res = [<span class="string">&#x27;&#x27;</span>] * (countDigital * <span class="number">5</span> + L)</span><br><span class="line">        <span class="comment"># 从后向前对res进行填充</span></span><br><span class="line">        newIndex = <span class="built_in">len</span>(res) - <span class="number">1</span></span><br><span class="line">        oldIndex = L - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> oldIndex &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> s[oldIndex].isdigit():</span><br><span class="line">                res[newIndex - <span class="number">5</span>: newIndex + <span class="number">1</span>] = <span class="string">&quot;number&quot;</span></span><br><span class="line">                newIndex -= <span class="number">6</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res[newIndex] = s[oldIndex]</span><br><span class="line">                newIndex -= <span class="number">1</span></span><br><span class="line">            oldIndex -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(res)</span><br><span class="line"></span><br><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line">solu = solution()</span><br><span class="line"><span class="built_in">print</span>(solu.foo(s))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;344-反转字符串&quot;&gt;344. 反转字符串&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/reverse-string/&quot;&gt;https://leetcode.cn/problems/reverse-string/&lt;/a</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay7</title>
    <link href="https://blog.lthero.cn/2025/06/30/LeetCodeCampsDay7/"/>
    <id>https://blog.lthero.cn/2025/06/30/LeetCodeCampsDay7/</id>
    <published>2025-06-30T13:49:11.000Z</published>
    <updated>2025-07-02T09:51:31.821Z</updated>
    
    <content type="html"><![CDATA[<h1 id="383-赎金信">383. 赎金信</h1><p><a href="https://leetcode.cn/problems/ransom-note/">https://leetcode.cn/problems/ransom-note/</a></p><p>给你两个字符串：<code>ransomNote</code> 和 <code>magazine</code> ，判断 <code>ransomNote</code> 能不能由 <code>magazine</code> 里面的字符构成。</p><p>如果可以，返回 <code>true</code> ；否则返回 <code>false</code> 。</p><p><code>magazine</code> 中的每个字符只能在 <code>ransomNote</code> 中使用一次。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：ransomNote = &quot;a&quot;, magazine = &quot;b&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：ransomNote = &quot;aa&quot;, magazine = &quot;ab&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：ransomNote = &quot;aa&quot;, magazine = &quot;aab&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= ransomNote.length, magazine.length &lt;= 105</code></li><li><code>ransomNote</code> 和 <code>magazine</code> 由小写英文字母组成</li></ul><h2 id="思路">思路</h2><ol><li>把这题目当成生成者，消费者问题：ransomNote是消费者，它需要消费指定数量的指定字符；matezine是生产者</li><li><strong>ransomNote 长度要少于等于 magazine</strong>, 因为magazine中字符只能使用一次</li><li>需要用到hash table</li></ol><h3 id="与242-区别">与242.区别</h3><p>在242. 有效的字母异位词中，可以同步遍历的原因是<strong>两者相互为生产者与消费者</strong>；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 仅当长度相等时，同步推进，减少一次遍历次数</span></span><br><span class="line"><span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">zip</span>(s,t):</span><br><span class="line">    nums[<span class="built_in">ord</span>(i) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">    nums[<span class="built_in">ord</span>(j) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] -= <span class="number">1</span></span><br></pre></td></tr></table></figure><p>本题特殊性是，<strong>magazine需要cover掉ransomNote用的字符</strong>，所以必须先遍历ransomNote，<strong>了解ransomNote的需求</strong>；</p><p>再遍历magazine，如果某个字符需求数量大于0，再将需求减一；<strong>否则没必要操作</strong>：</p><p>比如ransomNote = “aa”, magazine = “aab”，虽然’b’在magazine中，但table[‘b’-‘a’]=0，没必要进行操作的</p><h2 id="代码">代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canConstruct</span>(<span class="params">self, ransomNote: <span class="built_in">str</span>, magazine: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 本题特殊性是，magazine需要cover掉ransomNote用的字符</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(ransomNote) &gt; <span class="built_in">len</span>(magazine):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        table = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 消费者需要的量</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> ransomNote:</span><br><span class="line">            table[<span class="built_in">ord</span>(i) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 生产者有的量</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> magazine:</span><br><span class="line">            <span class="comment"># 如果消费者有这个字符的需求，才减少，不然没必须操作</span></span><br><span class="line">            <span class="keyword">if</span> table[<span class="built_in">ord</span>(i) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] &gt; <span class="number">0</span>:</span><br><span class="line">                table[<span class="built_in">ord</span>(i) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 直接求和，只有等于零时才满足要求</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">sum</span>(table)!= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 或者逐个遍历也是一样的</span></span><br><span class="line">        <span class="comment"># for i in table:</span></span><br><span class="line">        <span class="comment">#     if i != 0:</span></span><br><span class="line">        <span class="comment">#         return False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure><h1 id="15-三数之和">15. 三数之和</h1><blockquote><p>对于<a href="https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html">15.三数之和 (opens new window)</a>双指针法就是将原本暴力O(n^3)的解法，降为O(n^2)的解法，四数之和的双指针解法就是将原本暴力O(n^4)的解法，降为O(n^3)的解法。</p></blockquote><p><a href="https://leetcode.cn/problems/3sum/">https://leetcode.cn/problems/3sum/</a></p><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p><p>**注意：**答案中不可以包含重复的三元组。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br><span class="line">解释：</span><br><span class="line">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。</span><br><span class="line">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。</span><br><span class="line">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。</span><br><span class="line">不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span><br><span class="line">注意，输出的顺序和三元组的顺序并不重要。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,1]</span><br><span class="line">输出：[]</span><br><span class="line">解释：唯一可能的三元组和不为 0 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,0,0]</span><br><span class="line">输出：[[0,0,0]]</span><br><span class="line">解释：唯一可能的三元组和为 0 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 3000</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul><h2 id="思路">思路</h2><ol><li>这题目和1. 两数之和很像，但本题target固定为0</li><li>这题目用hash table会变得复杂，使用双指针更简单</li><li>从左向右遍历，先固定一个数,如num[0]，则num[1:]可以看成一个“两数之和”的问题，并且target变成0-num[0]</li><li></li></ol><h2 id="代码">代码</h2><ul><li>时间复杂度O(N^2)</li><li>空间复杂度O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 这题目和1. 两数之和很像，但本题target固定为0</span></span><br><span class="line">        <span class="comment"># 这题目用hash table会变得复杂，使用双指针更简单</span></span><br><span class="line">        <span class="comment"># 从左向右遍历，先固定一个数,如num[0]，则num[1:]可以看成一个“两数之和”的问题，并且target变成0-num[0]</span></span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">            <span class="keyword">if</span> nums[index] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            <span class="comment"># 对于nums[index]来说, 跳过相同的数字</span></span><br><span class="line">            <span class="keyword">if</span> index &gt; <span class="number">0</span> <span class="keyword">and</span> nums[index] == nums[index - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            left = index + <span class="number">1</span></span><br><span class="line">            right = L - <span class="number">1</span></span><br><span class="line">            currentTarget = - nums[index]</span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                <span class="comment"># 计算双指针的和</span></span><br><span class="line">                currentSum = nums[left] + nums[right]</span><br><span class="line">                <span class="keyword">if</span> currentSum == currentTarget:</span><br><span class="line">                    res.append([nums[index], nums[left], nums[right]]) </span><br><span class="line">                    <span class="comment"># 需要去重复</span></span><br><span class="line">                    <span class="keyword">while</span> right &gt; left <span class="keyword">and</span> nums[right] == nums[right - <span class="number">1</span>]:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> right &gt; left <span class="keyword">and</span> nums[left] == nums[left + <span class="number">1</span>]:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 记得修改条件</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> currentSum &lt; currentTarget:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="思路二-字典">思路二(字典)</h2><ol><li>或者和之前一样，使用字典也能做</li><li>同样，对nums里每个num遍历，把剩下的nums看成双数相加等于target问题</li><li>创建个字典，用来记录剩下nums的其中一个值，并在剩下nums找另一个值；如果</li></ol><p><img src="https://file1.kamacoder.com/i/algo/20220711202638.png" alt="img"></p><h2 id="代码">代码</h2><ul><li>时间复杂度O(N^2)</li><li>空间复杂度O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">            <span class="keyword">if</span> nums[index] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            <span class="comment"># 对于nums[index]来说, 跳过相同的数字</span></span><br><span class="line">            <span class="keyword">if</span> index &gt; <span class="number">0</span> <span class="keyword">and</span> nums[index] == nums[index - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            table = <span class="built_in">dict</span>()</span><br><span class="line">            <span class="comment"># 更新target</span></span><br><span class="line">            target = <span class="number">0</span> - nums[index]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(index + <span class="number">1</span>, L):</span><br><span class="line">              <span class="comment"># 跳过重复的值</span></span><br><span class="line">                <span class="keyword">if</span> j &gt; index + <span class="number">2</span> <span class="keyword">and</span> nums[j] == nums[j - <span class="number">1</span>] == nums[j - <span class="number">2</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 后面的思路和1. 两数之和完全一样，判断某个值是否已经在table里了，如果在，说明它就是需要被找到的值</span></span><br><span class="line">                <span class="comment"># 否则就把它添加进去</span></span><br><span class="line">                <span class="keyword">if</span> nums[j] <span class="keyword">in</span> table:</span><br><span class="line">                    res.append([nums[index], nums[j], target - nums[j]])</span><br><span class="line">                    table.pop(nums[j])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    table[target - nums[j]] = j</span><br></pre></td></tr></table></figure><h1 id="18-四数之和">18. 四数之和</h1><p><a href="https://leetcode.cn/problems/4sum/">https://leetcode.cn/problems/4sum/</a></p><p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code> ，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p><ul><li><code>0 &lt;= a, b, c, d &lt; n</code></li><li><code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> <strong>互不相同</strong></li><li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li></ul><p>你可以按 <strong>任意顺序</strong> 返回答案 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,0,-1,0,-2,2], target = 0</span><br><span class="line">输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,2,2,2,2], target = 8</span><br><span class="line">输出：[[2,2,2,2]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 200</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li></ul><h2 id="思路">思路</h2><ol><li>和三数之和几乎一样，这题目可以扩展到N数之和</li><li>可以不提前退出，但必须“去重复”；否则[2,2,2,2,2]（输入），会输出[[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2]]</li><li>提前退出的条件<ol><li>条件1：if nums[i] &gt; target and nums[i] &gt; 0 and target &gt; 0:</li><li>条件2：if nums[i] + nums[j] &gt; target and target &gt; 0</li><li>满足其中一个即可退出</li></ol></li></ol><h2 id="代码">代码</h2><ul><li>时间复杂度O(N^3)</li><li>空间复杂度O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 和三数之和相似，但可以用两层for循环，将原本需要O(n^4)降为O(n^3)</span></span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">            <span class="comment"># 必须去重复，否则[2,2,2,2,2]（输入），会输出[[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2]]</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 提前退出[Optional]</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; target <span class="keyword">and</span> nums[i] &gt; <span class="number">0</span> <span class="keyword">and</span> target &gt; <span class="number">0</span>:</span><br><span class="line">              <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, L):</span><br><span class="line">                <span class="comment"># 必须去重复</span></span><br><span class="line">                <span class="keyword">if</span> j &gt; i + <span class="number">1</span> <span class="keyword">and</span> nums[j] == nums[j - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 提前退出[Optional]</span></span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[j] &gt; target <span class="keyword">and</span> target &gt; <span class="number">0</span></span><br><span class="line">                <span class="keyword">break</span> </span><br><span class="line">                  </span><br><span class="line">                <span class="comment"># 双指针</span></span><br><span class="line">                left = j + <span class="number">1</span></span><br><span class="line">                right = L - <span class="number">1</span></span><br><span class="line">                current_target = target - nums[i] - nums[j]</span><br><span class="line">                <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                    currentSum = nums[left] + nums[right]</span><br><span class="line">                    <span class="keyword">if</span> current_target == currentSum:</span><br><span class="line">                        res.append([nums[i], nums[j], nums[left], nums[right]])</span><br><span class="line">                        <span class="comment"># 同样是为了去重复</span></span><br><span class="line">                        <span class="keyword">while</span> right &gt; left <span class="keyword">and</span> nums[right] == nums[right - <span class="number">1</span>]:</span><br><span class="line">                            right -= <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> right &gt; left <span class="keyword">and</span> nums[left] == nums[left + <span class="number">1</span>]:</span><br><span class="line">                            left += <span class="number">1</span></span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> currentSum &lt; current_target:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="思路二-字典">思路二(字典)</h2><p>同样，这题目也可以用dict解决，我刚开始没有去重复，于是错误了</p><ul><li>时间复杂度O(N^3)</li><li>空间复杂度O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 和三数之和相似，但可以用两层for循环，将原本需要O(n^4)降为O(n^3)</span></span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">            <span class="comment"># 必须去重复，否则[2,2,2,2,2]（输入），会输出[[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2]]</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, L):</span><br><span class="line">                <span class="comment"># 必须去重复</span></span><br><span class="line">                <span class="keyword">if</span> j &gt; i + <span class="number">1</span> <span class="keyword">and</span> nums[j] == nums[j - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 用hash table试试</span></span><br><span class="line">                table = <span class="built_in">dict</span>()</span><br><span class="line">                current_target = target - nums[i] - nums[j]</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(j + <span class="number">1</span>, L):</span><br><span class="line">                    <span class="keyword">if</span> k &gt; j + <span class="number">3</span> <span class="keyword">and</span> nums[k] == nums[k - <span class="number">1</span>] == nums[k - <span class="number">2</span>] == nums[k - <span class="number">3</span>]:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> nums[k] <span class="keyword">in</span> table:</span><br><span class="line">                        res.append([nums[i], nums[j], nums[k], current_target - nums[k]])</span><br><span class="line">                        table.pop(nums[k])</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        table[current_target - nums[k]] = k</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                </span><br></pre></td></tr></table></figure><h1 id="454-四数相加-ii">454. 四数相加 II</h1><p><a href="https://leetcode.cn/problems/4sum-ii/">https://leetcode.cn/problems/4sum-ii/</a></p><p>给你四个整数数组 <code>nums1</code>、<code>nums2</code>、<code>nums3</code> 和 <code>nums4</code> ，数组长度都是 <code>n</code> ，请你计算有多少个元组 <code>(i, j, k, l)</code> 能满足：</p><ul><li><code>0 &lt;= i, j, k, l &lt; n</code></li><li><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">两个元组如下：</span><br><span class="line">1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0</span><br><span class="line">2. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums1.length</code></li><li><code>n == nums2.length</code></li><li><code>n == nums3.length</code></li><li><code>n == nums4.length</code></li><li><code>1 &lt;= n &lt;= 200</code></li><li><code>-228 &lt;= nums1[i], nums2[i], nums3[i], nums4[i] &lt;= 228</code></li></ul><h2 id="思路">思路</h2><ol><li>之前的三数之和、四数之和是在同一个数组查找，现在是四个不同的数组</li><li>用两个双层for循环，先算A, B的所有和，放在字典中；再算C, D所有排列组合可能的和，从字典中查找是否存在这样的键，如果存在就将这个键对应的值（即A,B的所有的和出现的次数</li></ol><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSumCount</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>], nums3: <span class="type">List</span>[<span class="built_in">int</span>], nums4: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 统计 a+b+c+d = 0 出现的次数</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="comment"># key放a和b两数之和，value 放a和b两数之和出现的次数</span></span><br><span class="line">        table = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="comment"># 先计算nums1, nums2的排列组合可能的和</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> nums2:</span><br><span class="line">                table[i + j] = table.get(i + j, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="comment"># </span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums3:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> nums4:</span><br><span class="line">                <span class="keyword">if</span> table.get(- i - j, <span class="number">0</span>):</span><br><span class="line">                    res += table[<span class="number">0</span> - i - j]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;383-赎金信&quot;&gt;383. 赎金信&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/ransom-note/&quot;&gt;https://leetcode.cn/problems/ransom-note/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay6</title>
    <link href="https://blog.lthero.cn/2025/06/30/LeetCodeCampsDay6/"/>
    <id>https://blog.lthero.cn/2025/06/30/LeetCodeCampsDay6/</id>
    <published>2025-06-30T06:37:28.000Z</published>
    <updated>2025-06-30T13:31:26.546Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday6">LeetCodeCampsDay6</h1><blockquote><p>以及几题目主要利用hash table的“唯一性”思想解决题目</p><p>关键词：哈希表；快慢指针；双指针；用set/dict/当成hash表；</p></blockquote><h1 id="242-有效的字母异位词">242. 有效的字母异位词</h1><p><a href="https://leetcode.cn/problems/valid-anagram/">https://leetcode.cn/problems/valid-anagram/</a></p><blockquote><p>给定两个字符串 <code>s</code> 和 <code>t</code> ，编写一个函数来判断 <code>t</code> 是否是 <code>s</code> 的 字母异位词。</p></blockquote><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;rat&quot;, t = &quot;car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= s.length, t.length &lt;= 5 * 104</code></li><li><code>s</code> 和 <code>t</code> 仅包含小写字母</li></ul><p><strong>进阶:</strong> 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p><h2 id="思路">思路</h2><ol><li>使用hash table可解决</li><li>开辟一块26个int型的数组即可，比如对于字符串s，&quot;a&quot;出现一次，则’a’ - ‘a’的下标（应该是0）对应的数据加一；而对于字符串t，就将反着“检查”，比如’n’出现一次，就要将’n’ - 'a’的下标对应的数据减一；</li><li>最后，判断是否有「非零」数，若存在则s与t不是字母异位词</li><li>可以通过判断s与t长度提前判断；</li></ol><p>如动画所示</p><p><img src="https://file1.kamacoder.com/i/algo/242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.gif" alt="img"></p><h2 id="代码">代码</h2><p>ord(.)用于获取字符的ascii码</p><ul><li>时间复杂度O(n)</li><li>空间复杂度O(1)，指仅用了26个int型（因为length &lt;= 5*10^4)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        nums = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        <span class="comment"># 如果两者长度不相等直接False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s)!= <span class="built_in">len</span>(t):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            nums[<span class="built_in">ord</span>(i) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> t:</span><br><span class="line">            nums[<span class="built_in">ord</span>(i) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>代码改进，可以使用zip减少一次遍历次数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        nums = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        <span class="comment"># 如果两者长度不相等直接False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s)!= <span class="built_in">len</span>(t):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 仅当长度相等时，同步推进，减少一次遍历次数</span></span><br><span class="line">        <span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">zip</span>(s,t):</span><br><span class="line">            nums[<span class="built_in">ord</span>(i) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">            nums[<span class="built_in">ord</span>(j) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h1 id="349-两个数组的交集">349. 两个数组的交集</h1><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">https://leetcode.cn/problems/intersection-of-two-arrays/</a></p><p>给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>它们的 交集</em> 。输出结果中的每个元素一定是 <strong>唯一</strong> 的。我们可以 <strong>不考虑输出结果的顺序</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">输出：[2]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span><br><span class="line">输出：[9,4]</span><br><span class="line">解释：[4,9] 也是可通过的</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li><li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li></ul><h2 id="思路">思路</h2><ol><li><p>如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费，此时就要使用另一种<strong>结构体set</strong></p></li><li><p>先将nums1转成unordered_set，再将nums2与这unordered_set比较，得到二次筛选后的unordered_set.</p></li><li><p>在python时使用dict字典即可，将nums1的数据添加到字典了（如果已经存在就不用添加了，也是变相地一种set）</p></li></ol><p>如动画所示</p><p><img src="https://file1.kamacoder.com/i/algo/20220707173513.png" alt="img"></p><h2 id="代码">代码</h2><p>python提供了集合set函数，可以直接使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intersection</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">set</span>(nums1) &amp; <span class="built_in">set</span>(nums2))</span><br></pre></td></tr></table></figure><p>手动实现，使用字典dict和列表list实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">intersection</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        dictSet = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">          <span class="comment"># 如果i 不在dictSet中，返回-1，并且添加到dictSet中，赋值为1（随便给）</span></span><br><span class="line">            <span class="comment"># get 方法内部也会进行哈希表查找，一次查询的平均时间复杂度也是 O(1)</span></span><br><span class="line">            <span class="comment"># 与if i in dictSet:一样</span></span><br><span class="line">            <span class="keyword">if</span> dictSet.get(i, -<span class="number">1</span>) == -<span class="number">1</span>:</span><br><span class="line">                dictSet[i] = <span class="number">1</span></span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums2:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> dictSet:</span><br><span class="line">                res.append(i)</span><br><span class="line">                <span class="comment"># 删除dictSet中的这个数据，防止被反复添加</span></span><br><span class="line">                <span class="keyword">del</span> dictSet[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">      </span><br><span class="line">        <span class="comment"># 或者将res设置为set，可以减少删除dictSet中数字的步骤</span></span><br><span class="line">        <span class="comment"># res = set()</span></span><br><span class="line">        <span class="comment"># for i in nums2:</span></span><br><span class="line">        <span class="comment">#     if dictSet.get(i, -1) != -1:</span></span><br><span class="line">        <span class="comment">#         res.add(i)</span></span><br><span class="line">        <span class="comment"># return list(res)</span></span><br></pre></td></tr></table></figure><p>当然也可以使用数组（list）实现，这题目限制范围是0&lt;=num&lt;=1000数据，可以开1001个位置的数据并按<code>242. 有效的字母异位词的思路</code>赋值再查询</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   dictSet = [<span class="number">0</span>] * <span class="number">1001</span></span><br><span class="line"><span class="comment"># 在nums1中的数据先在dictSet设置为1</span></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">       dictSet[i] = <span class="number">1</span></span><br><span class="line">   <span class="comment"># 在nums2中的数据，并且在dictSet设置为1的，再设置为2</span></span><br><span class="line">   <span class="comment"># 好处是如果dictSet中有重复的数据，不用被重复设置</span></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> nums2:</span><br><span class="line">       <span class="keyword">if</span> dictSet[i] == <span class="number">1</span>:</span><br><span class="line">           dictSet[i] = <span class="number">2</span></span><br><span class="line">   res = <span class="built_in">list</span>()</span><br><span class="line">   <span class="comment"># 最后输出dictSet中为2的，就是同时出现在两个nums的并且不重复的数据</span></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1001</span>):</span><br><span class="line">       <span class="keyword">if</span> dictSet[i] == <span class="number">2</span>:</span><br><span class="line">           res.append(i)</span><br><span class="line">   <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="pytorch版本">Pytorch版本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">intersection</span>(<span class="params">nums1: <span class="type">List</span>, nums2: <span class="type">List</span></span>)</span><br><span class="line"><span class="comment"># 转成tensor</span></span><br><span class="line">nums1_tensor = torch.tensor(nums1)</span><br><span class="line">  nums2_tensor = troch.tensor(nums2)</span><br><span class="line">    <span class="comment"># 使用unique（与set类似）</span></span><br><span class="line">    unique_nums1 = torch.unique(nums1_tensor)</span><br><span class="line">    <span class="comment"># isin返回一个bool张量，表示每个元素是否在nums2_tensor中</span></span><br><span class="line">    mask = torch.isin(unique_nums1, nums2_tensor)</span><br><span class="line">    <span class="comment"># 傅mask过滤得到交集元素。</span></span><br><span class="line">    intersection_tensor = unique_nums1[mask]</span><br><span class="line">    <span class="comment"># 转回list格式</span></span><br><span class="line">    <span class="keyword">return</span> intersection_tensor.tolist()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例测试</span></span><br><span class="line">nums1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>]</span><br><span class="line">nums2 = [<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line">result = intersection(nums1, nums2)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出: [2, 6]</span></span><br></pre></td></tr></table></figure><h1 id="202-快乐数">202. 快乐数</h1><p><a href="https://leetcode.cn/problems/happy-number/">https://leetcode.cn/problems/happy-number/</a></p><p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p><p><strong>「快乐数」</strong> 定义为：</p><ul><li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li><li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</li><li>如果这个过程 <strong>结果为</strong> 1，那么这个数就是快乐数。</li></ul><p>如果 <code>n</code> 是 <em>快乐数</em> 就返回 <code>true</code> ；不是，则返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 19</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">12 + 92 = 82</span><br><span class="line">82 + 22 = 68</span><br><span class="line">62 + 82 = 100</span><br><span class="line">12 + 02 + 02 = 1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 231 - 1</code></li></ul><h2 id="思路一">思路一</h2><ol><li>题目中说了会 <strong>无限循环</strong>，那么也就是说<strong>求和的过程中，sum会重复出现，这对解题很重要！</strong></li><li>可以使用Hash Table，如果sum在表中出现了则说明有循环，可以直接退出；否则就一直找，直到sum=1</li></ol><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 设置个set，如果未在set中即可添加进来，否则就出现循环了</span></span><br><span class="line">        table = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">while</span> n != <span class="number">1</span>:</span><br><span class="line">          <span class="comment"># python中将数字按位划分的最方便形式就是转成str后按数组对付</span></span><br><span class="line">            n_str = <span class="built_in">str</span>(n)</span><br><span class="line">            n = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> n_str:</span><br><span class="line">                n += <span class="built_in">int</span>(i)*<span class="built_in">int</span>(i)</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> table:</span><br><span class="line">                table.add(n)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>相似的思路，如果不在list中就添加进来，一直计算sum直到等于1停止</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 设置个set，如果未在set中即可添加进来，否则就出现循环了</span></span><br><span class="line">        table = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">while</span> n <span class="keyword">not</span> <span class="keyword">in</span> table:</span><br><span class="line">          table.append(n)</span><br><span class="line">          <span class="comment"># python中将数字按位划分的最方便形式就是转成str后按数组对付</span></span><br><span class="line">            n_str = <span class="built_in">str</span>(n)</span><br><span class="line">            n = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> n_str:</span><br><span class="line">                n += <span class="built_in">int</span>(i)*<span class="built_in">int</span>(i)</span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="思路二快慢指针">思路二快慢指针</h2><ol><li>这题目可以用快慢指针解决，如果出现了&quot;循环&quot;（sum会重复出现），其实就是“链表有环”的问题</li><li>慢指针每次走一步；快指针每次走两步。即慢指针每次计算sumN(slow)，快指针每次计算sumN(sumN(fast))</li><li>如果slow == fast则说明有环（有重复的sum）返回False</li><li>while跳出条件是sumN(fast)!=1，这和fast.next不为空即可[在有环链表题目中，while fast and fast.next则执行]</li></ol><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumN</span>(<span class="params">self, n:<span class="built_in">int</span></span>):</span><br><span class="line">        n_str = <span class="built_in">str</span>(n)</span><br><span class="line">        new_n = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> n_str:</span><br><span class="line">            new_n += <span class="built_in">int</span>(i)*<span class="built_in">int</span>(i)  </span><br><span class="line">        <span class="keyword">return</span> new_n</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumNByhand</span>(<span class="params">self, n:<span class="built_in">int</span></span>):</span><br><span class="line">        new_n = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            temp = n % <span class="number">10</span></span><br><span class="line">            new_n += temp ** <span class="number">2</span></span><br><span class="line">            n = n // <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> new_n</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        slow = n</span><br><span class="line">        fast = n</span><br><span class="line">        <span class="keyword">while</span> self.sumN(n) != <span class="number">1</span> <span class="keyword">and</span> self.sumN(self.sumN(fast)) != <span class="number">1</span>:</span><br><span class="line">            slow = self.sumN(slow)</span><br><span class="line">            fast = self.sumN(self.sumN(fast))</span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h1 id="1-两数之和">1. 两数之和</h1><p><a href="https://leetcode.cn/problems/two-sum/">https://leetcode.cn/problems/two-sum/</a></p><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li><li><strong>只会存在一个有效答案</strong></li></ul><p>**进阶：**你可以想出一个时间复杂度小于 <code>O(n2)</code> 的算法吗？</p><h2 id="思路">思路</h2><ol><li>使用hash map, 本题目可以使用dict，因为它已经假设每种输入只有一个答案</li><li>记录table[target - nums[i_1]] = i_1，如果target - nums[i_1] == nums[i_2]则说明target == nums[i_1] + nums[i_2]</li><li>如果nums[i_2]在table中，则找到了一个匹配的返回i_1和i_2</li></ol><p><img src="https://file1.kamacoder.com/i/algo/20220711202638.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20230220223536.png" alt="img"></p><h2 id="代码">代码</h2><p>如果使用双重循环的方式，时间复杂度O(N^2)，但空间复杂度可以到O(1)；所以本质还是空间换时间</p><ul><li>时间复杂度O(N)</li><li>空间复杂度O(N)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 使用个hash map，记录table[target - nums[i_1]] = i_1</span></span><br><span class="line">        <span class="comment"># 如果nums[i_2]在table中，则找到了一个匹配的返回i_1和i_2</span></span><br><span class="line">        table = <span class="built_in">dict</span>()</span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">          <span class="comment"># 如果当前元素在table内，说明已经找到匹配的了</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> table:</span><br><span class="line">                <span class="keyword">return</span> table[nums[i]], i</span><br><span class="line">            <span class="comment"># 否则，target-nums[i] 就是需要等的数字</span></span><br><span class="line">            table[target - nums[i]] = i</span><br><span class="line">        <span class="keyword">return</span> </span><br></pre></td></tr></table></figure><h2 id="思路二双指针">思路二双指针</h2><ol><li>可以使用双指针做，<strong>但前提是：数组是有序的(从小到大）</strong></li><li>left指针从左向右遍历；right指针从右向左遍历</li><li>每次计算left和right所指数字的和；并与target判断大小；如果current_sum大了，则right向左移动；小了则left向右移动；如果相等，有点儿的麻烦的是，需要将left和right在原nums的下标进行还原；</li><li>初次的还原使用nums.index(nums_sorted[left])，但会出现left_index == right_index的情况，因为题目规定不能使用同一个下标，所以需要将right_index进行调整，调整到nums[left_index+1:].index(nums_sorted[right]) + left_index + 1，也就是强行在nums[left_index+1:]里找right数字对应的下标（返回的是nums[left_index+1:]的下标值，即<code>相对下标</code>）所以需要再加上left_index+1成为<code>绝对下标</code></li></ol><h2 id="代码">代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(N)—因为占用了个空间存放排序后的数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># method2 双指针</span></span><br><span class="line">nums_sorted = <span class="built_in">sorted</span>(nums)</span><br><span class="line"></span><br><span class="line">left = <span class="number">0</span></span><br><span class="line">right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> left &lt; right:</span><br><span class="line">    current_sum = nums_sorted[left] + nums_sorted[right]</span><br><span class="line">    <span class="built_in">print</span>(current_sum)</span><br><span class="line">    <span class="keyword">if</span> current_sum == target:</span><br><span class="line">        <span class="comment"># 如果两个数字之和等于target就返回两个数的下标（原nums数组中的）</span></span><br><span class="line">        left_index = nums.index(nums_sorted[left])</span><br><span class="line">        right_index = nums.index(nums_sorted[right])</span><br><span class="line">        <span class="keyword">if</span> left_index == right_index:</span><br><span class="line">            right_index = nums[left_index+<span class="number">1</span>:].index(nums_sorted[right]) + left_index + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left_index, right_index</span><br><span class="line">    <span class="comment"># 否则left向右移动</span></span><br><span class="line">    <span class="keyword">elif</span> current_sum &lt; target:</span><br><span class="line">        left += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        right -= <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday6&quot;&gt;LeetCodeCampsDay6&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;以及几题目主要利用hash table的“唯一性”思想解决题目&lt;/p&gt;
&lt;p&gt;关键词：哈希表；快慢指针；双指针；用set/dict/当成hash表；</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay4</title>
    <link href="https://blog.lthero.cn/2025/06/28/LeetCodeCampsDay4/"/>
    <id>https://blog.lthero.cn/2025/06/28/LeetCodeCampsDay4/</id>
    <published>2025-06-28T03:16:53.000Z</published>
    <updated>2025-06-29T03:29:34.175Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday4">LeetCodeCampsDay4</h1><blockquote><p>大多修改/删除/添加操作需要使用dummy_head；仅查询的话，可以不用dummy_head</p><p>如果需要一遍扫描完成一些题目，需要借用额外的变量（时间换空间），比如多指针/快慢指针</p></blockquote><h1 id="24-两两交换链表中的节点">24. 两两交换链表中的节点</h1><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">https://leetcode.cn/problems/swap-nodes-in-pairs/</a></p><blockquote><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p></blockquote><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4]</span><br><span class="line">输出：[2,1,4,3]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 100</code></li></ul><h2 id="思路">思路</h2><h3 id="初始化">初始化</h3><ol><li>需要<strong>创建dummy_head</strong>，方便解题，尤其头节点和第二个节点的交换，有dummy_head后更方便</li><li>如果current is None或current.next is None直接返回；说明链表为空或仅一个节点</li><li>需要一个pre节点，一个current节点</li><li>比如：[[],[1],[2],[3]]<ol><li>令[]为dummy_head，且初始化为pre</li><li>令[1]为current节点</li><li>令[2]为tmp节点</li><li>令[3]为nextToGO节点（因为至少有两个节点，所以这里的[3]可能是None，不过没关系）</li></ol></li></ol><h3 id="循环体内">循环体内</h3><ol><li>初始化：tmp节点，指向current.next; 以及nextToGO节点，指向tmp.next</li></ol><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>[]-&gt;</td><td>1-&gt;</td><td>2-&gt;</td><td>3-&gt;</td><td>4-&gt;</td><td>None</td></tr><tr><td>pre</td><td>cur</td><td>tmp</td><td>nextToGO</td><td></td><td></td></tr></tbody></table><ol><li>开始swap： #和交换数字的思路比较像<ol><li>pre.next = tmp</li><li>current.next = nextToGO</li><li>tmp.next = current</li></ol></li></ol><p>此时的链表</p><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>[]-&gt;</td><td>2-&gt;</td><td>1-&gt;</td><td>3-&gt;</td><td>4-&gt;</td><td>None</td></tr><tr><td>pre</td><td>tmp</td><td>cur</td><td>nextToGO</td><td></td><td></td></tr></tbody></table><ol><li>更新pre和current<ol><li>pre = current</li><li>current = nextToGO</li></ol></li></ol><h2 id="代码">代码</h2><ul><li>时间复杂度 O(n)</li><li>空间复杂度 O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__printVal</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;node.val <span class="subst">&#123;node.val&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swapPairs</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy_head = ListNode(<span class="built_in">next</span> = head)</span><br><span class="line"></span><br><span class="line">        pre = dummy_head</span><br><span class="line">        current = dummy_head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># init</span></span><br><span class="line">        <span class="keyword">if</span> current <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> current.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> current <span class="keyword">and</span> current.<span class="built_in">next</span>:</span><br><span class="line">            temp = current.<span class="built_in">next</span></span><br><span class="line">            nextToGo = temp.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># swap</span></span><br><span class="line">            pre.<span class="built_in">next</span> = temp</span><br><span class="line">            current.<span class="built_in">next</span> = nextToGo</span><br><span class="line">            temp.<span class="built_in">next</span> = current</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># update</span></span><br><span class="line">            pre = current</span><br><span class="line">            current = nextToGo</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy_head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>如果不使用nextToGo也可以，但需要理解好几个节点的关系</p><h3 id="初始化">初始化</h3><ol><li>需要创建dummy_head，方便解题，尤其头节点和第二个节点的交换，有dummy_head后更方便</li><li>如果current is None或current.next is None直接返回；说明链表为空或仅一个节点</li><li>需要一个pre节点，一个current节点</li><li>比如：[[],[1],[2],[3]]<ol><li>令[]为dummy_head，且初始化为pre</li><li>令[1]为current节点</li><li>令[2]为tmp节点</li></ol></li></ol><h3 id="循环体内">循环体内</h3><ol><li>初始化：tmp节点，指向current.next</li></ol><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>[]-&gt;</td><td>1-&gt;</td><td>2-&gt;</td><td>3-&gt;</td><td>4-&gt;</td><td>None</td></tr><tr><td>pre</td><td>cur</td><td>tmp</td><td></td><td></td><td></td></tr></tbody></table><ol><li>开始swap： #和交换数字的思路比较像<ol><li>pre.next = tmp</li><li>current.next = tmp.next</li><li>tmp.next = current</li></ol></li></ol><p>此时的链表</p><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>[]-&gt;</td><td>2-&gt;</td><td>1-&gt;</td><td>3-&gt;</td><td>4-&gt;</td><td>None</td></tr><tr><td>pre</td><td>tmp</td><td>cur</td><td></td><td></td><td></td></tr></tbody></table><ol><li>更新pre和current<ol><li>pre = current</li><li>current = current.next</li></ol></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line">            temp = current.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># swap</span></span><br><span class="line">            pre.<span class="built_in">next</span> = temp</span><br><span class="line">            current.<span class="built_in">next</span> = temp.<span class="built_in">next</span></span><br><span class="line">            temp.<span class="built_in">next</span> = current</span><br><span class="line">            <span class="comment"># update</span></span><br><span class="line">            pre = current</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><h1 id="19-删除链表的倒数第-n-个结点">19. 删除链表的倒数第 N 个结点</h1><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">https://leetcode.cn/problems/remove-nth-node-from-end-of-list/</a></p><blockquote><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p></blockquote><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], n = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], n = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中结点的数目为 <code>sz</code></li><li><code>1 &lt;= sz &lt;= 30</code></li><li><code>0 &lt;= Node.val &lt;= 100</code></li><li><code>1 &lt;= n &lt;= sz</code></li></ul><p>进阶：你能尝试使用一趟扫描实现吗？</p><p>提示：Maintain two pointers and update one with a delay of n steps.</p><h2 id="思路">思路</h2><ol><li>使用dummy_head，方便解题</li><li>使用快慢指针，快指针比慢指针多走n+1步，因为需要让慢指针stops at 被删除节点的前一个节点;<strong>从而一次扫描即可实现</strong></li></ol><h2 id="代码">代码</h2><ul><li>时间复杂度 O(n)</li><li>空间复杂度 O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], n: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">      <span class="comment"># init a dummy head</span></span><br><span class="line">        dummy_head = ListNode(<span class="built_in">next</span> = head)</span><br><span class="line">        current = dummy_head</span><br><span class="line">        slow = dummy_head</span><br><span class="line"><span class="comment"># Move the current pointer forward by n+1 steps so that the slow pointer stops at the node immediately before the one that need to be deleted.</span></span><br><span class="line">        <span class="keyword">while</span> n+<span class="number">1</span> <span class="keyword">and</span> current:</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># </span></span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        slow.<span class="built_in">next</span> = slow.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy_head.<span class="built_in">next</span></span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      <span class="comment"># The following method is my dummy one.</span></span><br><span class="line">        <span class="comment"># count = 0</span></span><br><span class="line">        <span class="comment"># while current.next:</span></span><br><span class="line">        <span class="comment">#     current = current.next</span></span><br><span class="line">        <span class="comment">#     if count&lt; n:</span></span><br><span class="line">        <span class="comment">#         count += 1</span></span><br><span class="line">        <span class="comment">#         continue</span></span><br><span class="line">        <span class="comment">#     else:</span></span><br><span class="line">        <span class="comment">#         slow = slow.next</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment"># slow.next = slow.next.next</span></span><br><span class="line">        <span class="comment"># return dummy_head.next</span></span><br><span class="line">        </span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="面试题-02-07-链表相交">面试题 02.07. 链表相交</h1><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/</a></p><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 <code>null</code> 。</p><p>图示两个链表在节点 <code>c1</code> 开始相交**：**</p><p><img src="https://cdn.lthero.cn/post_images/course/ML160_statement.png" alt="img"></p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.lthero.cn/post_images/course/ML160_example_1.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Intersected at &#x27;8&#x27;</span><br><span class="line">解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。</span><br><span class="line">在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://cdn.lthero.cn/post_images/course/ML160_example_2.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</span><br><span class="line">输出：Intersected at &#x27;2&#x27;</span><br><span class="line">解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。</span><br><span class="line">在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="https://cdn.lthero.cn/post_images/course/ML160_example_3.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</span><br><span class="line">输出：null</span><br><span class="line">解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。</span><br><span class="line">由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">这两个链表不相交，因此返回 null 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>listA</code> 中节点数目为 <code>m</code></li><li><code>listB</code> 中节点数目为 <code>n</code></li><li><code>0 &lt;= m, n &lt;= 3 * 104</code></li><li><code>1 &lt;= Node.val &lt;= 105</code></li><li><code>0 &lt;= skipA &lt;= m</code></li><li><code>0 &lt;= skipB &lt;= n</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA + 1] == listB[skipB + 1]</code></li></ul><p>**进阶：**你能否设计一个时间复杂度 <code>O(n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p><h2 id="思路">思路</h2><ol><li>可以使用dummy_head，确实方便一点儿; 不过本题目没有插入/删除，可以不用dummy_head.</li><li>注意它是“指针相等”而不是数值相等；并且A和B如果相交，它们则一定是到某个节点后，是指向同一节点的，不要把它们当成两条完全独立的链表处理；</li><li>可以通过判断最后一个元素是否相等来初步筛选</li><li>如果两个链表长度相等，则可以同步地遍历，找到共同节点</li><li>如果两个链表长度不相等，可以让长的先遍历n步n = abs(L_A - L_B), where L_A is the length of A. 然后再按长度相等的方式处理</li></ol><h2 id="代码">代码</h2><ul><li>时间复杂度：O(L_A + L_B) [指A和B的总长度]</li><li>空间复杂度：O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        <span class="comment"># 如果A,B链表长度相同，则可以同步遍历</span></span><br><span class="line">        <span class="comment"># 如果A,B链表长度不同，则让长的先走n步, where n = abs(L_a - L_b)</span></span><br><span class="line">        L_A = <span class="number">0</span></span><br><span class="line">        L_B = <span class="number">0</span></span><br><span class="line">        <span class="comment"># dh指dummy_head</span></span><br><span class="line">        dhA = ListNode(<span class="built_in">next</span> = headA)</span><br><span class="line">        endA = dhA</span><br><span class="line">        <span class="keyword">while</span> endA.<span class="built_in">next</span>:</span><br><span class="line">            endA = endA.<span class="built_in">next</span></span><br><span class="line">            L_A += <span class="number">1</span></span><br><span class="line">        dhB = ListNode(<span class="built_in">next</span> = headB)</span><br><span class="line">        endB = dhB</span><br><span class="line">        <span class="keyword">while</span> endB.<span class="built_in">next</span>:</span><br><span class="line">            endB = endB.<span class="built_in">next</span></span><br><span class="line">            L_B += <span class="number">1</span></span><br><span class="line">        <span class="comment"># If the last elements are not equal return NULL</span></span><br><span class="line">        <span class="keyword">if</span> endA != endB <span class="keyword">or</span> L_A == <span class="number">0</span> <span class="keyword">or</span> L_B == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">        curA = dhA</span><br><span class="line">        curB = dhB</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Adjust the Make sure they start at same step.</span></span><br><span class="line">        gap = <span class="built_in">abs</span>(L_B - L_A)</span><br><span class="line">        <span class="keyword">if</span> L_A &lt; L_B:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(gap):</span><br><span class="line">                curB = curB.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">elif</span> L_A &gt; L_B:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(gap):</span><br><span class="line">                curA = curA.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> curA.<span class="built_in">next</span>:</span><br><span class="line">            curA = curA.<span class="built_in">next</span></span><br><span class="line">            curB = curB.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> curA == curB:</span><br><span class="line">                <span class="keyword">return</span> curA</span><br><span class="line">        <span class="keyword">return</span> </span><br></pre></td></tr></table></figure><h1 id="142-环形链表-ii">142. 环形链表 II</h1><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">https://leetcode.cn/problems/linked-list-cycle-ii/</a></p><blockquote><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p></blockquote><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p><strong>不允许修改</strong> 链表。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.lthero.cn/post_images/course/MLcircularlinkedlist.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://cdn.lthero.cn/post_images/course/MLcircularlinkedlist_test2.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：返回索引为 0 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="https://cdn.lthero.cn/post_images/course/MLcircularlinkedlist_test3.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：返回 null</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li></ul><p>**进阶：**你是否可以使用 <code>O(1)</code> 空间解决此题？</p><h2 id="快慢指针思路">快慢指针思路</h2><ol><li>这题不用dummy_head</li><li>本题有两个任务：<ol><li>是否有环</li><li>如果有环，怎么找到环的入口</li></ol></li></ol><h3 id="是否有环">是否有环</h3><p>如果使用快慢指针的方式，快指针每次走两步，慢指针每次走一步，如果有环，一定能相遇</p><p><img src="https://cdn.lthero.cn/post_images/course/ML141.%25E7%258E%25AF%25E5%25BD%25A2%25E9%2593%25BE%25E8%25A1%25A8-20250628155706375.gif" alt="img"></p><h3 id="如何找环的入口">如何找环的入口</h3><ul><li>令头节点到入口节点的距离为x(个节点)。</li><li>环形<strong>入口节点</strong> 到 fast指针与slow指针<strong>相遇节点</strong> 节点数为y。</li><li>从<strong>相遇节点</strong> 再到<strong>环形入口节点节点数为 z</strong>。</li></ul><p>如图所示：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20220925103433-20250628155649033.png" alt="img"></p><p>那么相遇时：</p><ul><li>slow指针走过的节点数为: <code>x + y</code></li><li>fast指针走过的节点数：<code>x + y + n (y + z)</code>，n为fast指针在环内走了n圈才遇到slow指针，（y+z）为 一圈内节点的个数A。</li></ul><p>因为fast指针是一步走两个节点，slow指针一步走一个节点， 所以 fast指针走过的节点数 = slow指针走过的节点数 * 2 ：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo stretchy="false">)</mo><mo>∗</mo><mn>2</mn><mo>=</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo>+</mo><mi>n</mi><mo stretchy="false">(</mo><mi>y</mi><mo>+</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x + y) * 2 = x + y + n (y + z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span></span></p><p>两边消掉一个（x+y）: <code>x + y = n (y + z)</code></p><blockquote><p>因为要找环形的入口，则需要求的元素是<code>x</code>，因为x表示：the <strong>distance</strong> between <strong>头节点</strong> and <strong>入口节点</strong>。即<code>x = n (y + z) - y</code></p></blockquote><p>再从n(y+z)中提出一个 （y+z）来，整理公式之后为如下公式：<code>x = (n - 1) (y + z) + z</code> 注意这里n一定是大于等于1的，因为 fast指针至少要多走一圈才能相遇slow指针。</p><p>这个公式说明什么呢？</p><p>先拿<strong>n为1</strong>的情况来举例，意味着fast指针在环形里转了一圈之后，就遇到了 slow指针了。</p><p>当 n为1的时候，公式就化解为 <code>x = z</code>，</p><p>这就意味着，从<strong>头结点</strong>出发<strong>一个指针</strong>，从<strong>相遇节点</strong>也出发<strong>一个指针</strong>，这两个指针每次都只走一个节点， 那么当这<strong>两个指针相遇</strong>的时候就是 <strong>环形入口的节点</strong>。</p><p>也就是在相遇节点处，定义一个指针index1，在头结点处定一个指针index2（也可以让slow继续走，并且让fast每次只走一步）</p><p>让index1和index2同时移动，每次移动一个节点， 那么他们相遇的地方就是 环形入口的节点。</p><p>动画如下：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML142.%25E7%258E%25AF%25E5%25BD%25A2%25E9%2593%25BE%25E8%25A1%25A8II%25EF%25BC%2588%25E6%25B1%2582%25E5%2585%25A5%25E5%258F%25A3%25EF%25BC%2589.gif" alt="img"></p><p>那么 n如果大于1是什么情况呢，就是<strong>fast指针在环形转n圈之后才遇到 slow指针</strong>。</p><p>其实这种情况和n为1的时候 效果是一样的，一样可以通过这个方法找到 环形的入口节点，只不过，index1 指针在环里 多转了(n-1)圈，然后再遇到index2，相遇点依然是环形的入口节点。</p><h2 id="代码">代码</h2><ul><li>时间复杂度 O(N) --slow走完一遍即可（slow不用在环内转圈）/60ms</li><li>空间复杂度 O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detectCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="comment"># 快慢指针，如果有环，快指针必能遇到慢指针</span></span><br><span class="line">        fast = head</span><br><span class="line">        slow = head</span><br><span class="line"><span class="comment"># 注意退出条件，只控制fast即可了</span></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 如果快慢指针相遇，说明有环，当前位置是相遇点；下一任务是找入口</span></span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                <span class="comment"># 让slow从头开始，而fast仍在相遇点；fast和slow都是每次走一步</span></span><br><span class="line">                slow = head</span><br><span class="line">                <span class="keyword">while</span> slow != fast:</span><br><span class="line">                    fast = fast.<span class="built_in">next</span></span><br><span class="line">                    slow = slow.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> slow</span><br><span class="line">        <span class="keyword">return</span> </span><br></pre></td></tr></table></figure><h2 id="普通思路">普通思路</h2><p>创建一个visited_list，将遍历过的节点都添加进去，如果新的节点已经存在于visited_list说明它就是“入口节点”</p><h2 id="代码">代码</h2><ul><li>时间复杂度 O(N)—844ms</li><li>空间复杂度 O(N)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detectCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line"><span class="comment"># 普通解法，记录所有节点</span></span><br><span class="line">        visitedList = []</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur <span class="keyword">in</span> visitedList:</span><br><span class="line">                <span class="keyword">return</span> cur</span><br><span class="line">            visitedList.append(cur)</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday4&quot;&gt;LeetCodeCampsDay4&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;大多修改/删除/添加操作需要使用dummy_head；仅查询的话，可以不用dummy_head&lt;/p&gt;
&lt;p&gt;如果需要一遍扫描完成一些题目，需要借用</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay3</title>
    <link href="https://blog.lthero.cn/2025/06/26/LeetCodeCampsDay3/"/>
    <id>https://blog.lthero.cn/2025/06/26/LeetCodeCampsDay3/</id>
    <published>2025-06-26T13:54:25.000Z</published>
    <updated>2025-06-27T16:47:39.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday3">LeetCodeCampsDay3</h1><blockquote><p>主要与链表相关</p><p>记住：<strong>一般涉及到 增删改操作，用虚拟头结点dummy_head都会方便很多， 如果只能查的话，用不用虚拟头结点都差不多。</strong></p></blockquote><h2 id="链表理论基础">链表理论基础</h2><p>建议：了解一下链表基础，以及链表和数组的区别</p><p>文章链接：<a href="https://programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">https://programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html</a></p><h1 id="203-移除链表元素">203. 移除链表元素</h1><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">https://leetcode.cn/problems/remove-linked-list-elements/</a></p><blockquote><p>一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p></blockquote><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,6,3,4,5,6], val = 6</span><br><span class="line">输出：[1,2,3,4,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [], val = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [7,7,7,7], val = 7</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>列表中的节点数目在范围 <code>[0, 104]</code> 内</li><li><code>1 &lt;= Node.val &lt;= 50</code></li><li><code>0 &lt;= val &lt;= 50</code></li></ul><h2 id="思路">思路</h2><ol><li>head是输入链表，是不动的；需要一个遍历的指针，可以使用index = head创建；</li><li>不断判断index.next的值是否等于val（因为，如果index.next.val等于val，可以通过操作，让index.next被删除）</li><li>最后判断下，如果head.val等于val，需要将head=head.next ；以免出现val=1, 但head返回是[1，2]的情况</li></ol><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElements</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        index = head</span><br><span class="line">        <span class="keyword">while</span> index.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> val == index.<span class="built_in">next</span>.val:</span><br><span class="line">                index.<span class="built_in">next</span> = index.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                index = index.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> head.val == val:</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h2 id="思路二">思路二</h2><p>思路一有个缺点，需要单独写一段逻辑处理头结点的情况，可以设置一个虚拟头部dummy_head，其中dummy_head.next=head；从而原链表的所有节点都可以统一处理</p><p><img src="https://file1.kamacoder.com/i/algo/20210316095619221.png" alt="img"></p><h2 id="代码二">代码二</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElements</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummpy_head = ListNode(<span class="built_in">next</span> = head)</span><br><span class="line"><span class="comment"># 同样需要index作为当前指针</span></span><br><span class="line">        index = dummpy_head</span><br><span class="line">        <span class="keyword">while</span> index.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> val == index.<span class="built_in">next</span>.val:</span><br><span class="line">                index.<span class="built_in">next</span> = index.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                index = index.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummpy_head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><h1 id="206-反转链表">206. 反转链表</h1><p><a href="https://leetcode.cn/problems/reverse-linked-list/">https://leetcode.cn/problems/reverse-linked-list/</a></p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：[2,1]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 5000]</code></li><li><code>-5000 &lt;= Node.val &lt;= 5000</code></li></ul><p>进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p><h2 id="思路一">思路一</h2><p>至少需要三个辅助节点，pre, current, current_next(temp)</p><ol><li>先记录current.next到temp</li><li>不断将current.next设置为pre</li><li>pre转成current；current转成temp</li></ol><p><img src="https://file1.kamacoder.com/i/algo/206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.gif" alt="img"></p><h2 id="代码一">代码一</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:        </span><br><span class="line">        current = head</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> current <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            temp = current.<span class="built_in">next</span></span><br><span class="line">            current.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = current</span><br><span class="line">            current = temp</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure><h2 id="思路二-递归">思路二（递归）</h2><p>退出条件：如果head为空/head.next为空，则直接返回haed，因为它已经反转了</p><p>让递归函数输入head.next(即剩下链表)，返回结果为new_head；new_head会先变成原head链表最后一个元素，如[1,2,3,4,5]则new_head为5，且整个递归过程new_head一直为5</p><p>foo([1,2,3,4,5])</p><p>foo([1,foo([2,3,4,5])])</p><p>foo([1,foo([2,foo([3,4,5])])])</p><p>foo([1,foo([2,foo([3,foo([4,5])])])])</p><p>foo([1,foo([2,foo([3,foo([4,foo([5])])])])])</p><p>逐个分析下</p><ul><li>foo([5])返回head，并且成为new_head</li><li>对于foo([4,foo([5])])，new_head = 5；head.next.next = head 意为将4.next.next（原来为5）设置为4，即5.next = 4；且head.next = None，即4.next = None；这里把4当成反转后的最后一个节点</li><li>对于foo([3,foo([4,foo([5])])])，new_head = 5; head.next.next = head意为将3.next.next(原为4)设置为3，即4.next = 3且head.next = None，即3.next = None；这里把3当成反转后的最后一个节点</li><li>对于foo([2,foo([3,foo([4,foo([5])])])])，new_head = 5; head.ext.next = head意为将2.next.next(原为3)设置为2，即3.next = 2且head.next = None，即2.next = None；这里把2当成反转后的最后一个节点</li><li>对于foo([1,foo([2,foo([3,foo([4,foo([5])])])])])，new_head = 5; head.ext.next = head意为将1.next.next(原为2)设置为1，即2.next = 1且head.next = None，即1.next = None；这里把1当成反转后的最后一个节点</li></ul><p>从而完成递归的反转链表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">head: <span class="type">Optional</span>[ListNode]</span>):</span><br><span class="line">            <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> head</span><br><span class="line">            <span class="comment"># new_head会先变成原head链表最后一个元素</span></span><br><span class="line">            <span class="comment"># [1,2,3,4,5]则new_head为5，且一直为5</span></span><br><span class="line">            new_head = foo(head.<span class="built_in">next</span>)</span><br><span class="line">            <span class="comment"># 反转两个节点</span></span><br><span class="line">            head.<span class="built_in">next</span>.<span class="built_in">next</span> = head</span><br><span class="line">            <span class="comment"># 反转后的最后一个节点的next设置为None</span></span><br><span class="line">            head.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> new_head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> foo(head)</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，其中n是链表节点数，每个节点被访问一次</p><p>空间复杂度O(N)，递归调用栈的空间，最坏的情况下，stack深度为n</p><h1 id="707-设计链表">707. 设计链表</h1><p><a href="https://leetcode.cn/problems/design-linked-list/">https://leetcode.cn/problems/design-linked-list/</a></p><p>你可以选择使用单链表或者双链表，设计并实现自己的链表。</p><p>单链表中的节点应该具备两个属性：<code>val</code> 和 <code>next</code> 。<code>val</code> 是当前节点的值，<code>next</code> 是指向下一个节点的指针/引用。</p><p>如果是双向链表，则还需要属性 <code>prev</code> 以指示链表中的上一个节点。假设链表中的所有节点下标从 <strong>0</strong> 开始。</p><p>实现 <code>MyLinkedList</code> 类：</p><ul><li><code>MyLinkedList()</code> 初始化 <code>MyLinkedList</code> 对象。</li><li><code>int get(int index)</code> 获取链表中下标为 <code>index</code> 的节点的值。如果下标无效，则返回 <code>-1</code> 。</li><li><code>void addAtHead(int val)</code> 将一个值为 <code>val</code> 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。</li><li><code>void addAtTail(int val)</code> 将一个值为 <code>val</code> 的节点追加到链表中作为链表的最后一个元素。</li><li><code>void addAtIndex(int index, int val)</code> 将一个值为 <code>val</code> 的节点插入到链表中下标为 <code>index</code> 的节点之前。如果 <code>index</code> 等于链表的长度，那么该节点会被追加到链表的末尾。如果 <code>index</code> 比长度更大，该节点将 <strong>不会插入</strong> 到链表中。</li><li><code>void deleteAtIndex(int index)</code> 如果下标有效，则删除链表中下标为 <code>index</code> 的节点。</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;MyLinkedList&quot;, &quot;addAtHead&quot;, &quot;addAtTail&quot;, &quot;addAtIndex&quot;, &quot;get&quot;, &quot;deleteAtIndex&quot;, &quot;get&quot;]</span><br><span class="line">[[], [1], [3], [1, 2], [1], [1], [1]]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, null, 2, null, 3]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">MyLinkedList myLinkedList = new MyLinkedList();</span><br><span class="line">myLinkedList.addAtHead(1);</span><br><span class="line">myLinkedList.addAtTail(3);</span><br><span class="line">myLinkedList.addAtIndex(1, 2);    // 链表变为 1-&gt;2-&gt;3</span><br><span class="line">myLinkedList.get(1);              // 返回 2</span><br><span class="line">myLinkedList.deleteAtIndex(1);    // 现在，链表变为 1-&gt;3</span><br><span class="line">myLinkedList.get(1);              // 返回 3</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= index, val &lt;= 1000</code></li><li>请不要使用内置的 LinkedList 库。</li><li>调用 <code>get</code>、<code>addAtHead</code>、<code>addAtTail</code>、<code>addAtIndex</code> 和 <code>deleteAtIndex</code> 的次数不超过 <code>2000</code> 。</li></ul><h2 id="思路">思路</h2><ol><li>先确定使用单链表，包含head和L(表示节点个数)</li><li>addAtHead设置借用<strong>203.移除链表元素</strong>里dummy_head思想即可</li><li>addAtIndex才是核心需要设置的东西<ol><li>如果index为0，addAtIndex直接调用addAtHead；</li><li>如果index &gt; self.L or index &lt; 0 直接返回</li><li>如果index有效，寻找<code>index</code>前一节点current，令current.next = newNode</li></ol></li><li>addAtTail直接调用addAtIndex就行，传入self.L,val</li><li>deleteAtIndex难度不大<ol><li>Index == 0，直接跳过head即可</li><li>Index &gt;= self.L 直接返回</li><li>Index有效时，找到index前一节点current，令current.next = current.next.next</li></ol></li></ol><p>另外，定义个函数__getIndexPreNode，用来找到index的前一个节点；因为有至少三个函数需要调用到它</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__getIndexPreNode</span>(<span class="params">self, node, index</span>):</span><br><span class="line">        current = node</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index - <span class="number">1</span>):</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> current</span><br></pre></td></tr></table></figure><p>__printList用来打印当前链表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__printList</span>(<span class="params">self, node</span>):</span><br><span class="line">        caller_name = inspect.stack()[<span class="number">1</span>].function</span><br><span class="line">        current = self.head</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;caller_name: <span class="subst">&#123;caller_name&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">while</span> current.<span class="built_in">next</span>:</span><br><span class="line">            <span class="built_in">print</span>(current.val, end = <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;, self.L <span class="subst">&#123;self.L&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,val = <span class="number">0</span>, <span class="built_in">next</span> = <span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.head = ListNode()</span><br><span class="line">        self.L = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getIndexPreNode</span>(<span class="params">self, node, index</span>):</span><br><span class="line">        current = node</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index - <span class="number">1</span>):</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> current</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__printList</span>(<span class="params">self, node</span>):</span><br><span class="line">        caller_name = inspect.stack()[<span class="number">1</span>].function</span><br><span class="line">        current = self.head</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;caller_name: <span class="subst">&#123;caller_name&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">while</span> current.<span class="built_in">next</span>:</span><br><span class="line">            <span class="built_in">print</span>(current.val, end = <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;, self.L <span class="subst">&#123;self.L&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, index: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> index &gt;= self.L <span class="keyword">or</span> index &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> index == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.head.val</span><br><span class="line"></span><br><span class="line">        current = self.__getIndexPreNode(self.head, index)</span><br><span class="line">        <span class="comment"># self.__printList(self.head)</span></span><br><span class="line">        <span class="keyword">return</span> current.<span class="built_in">next</span>.val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addAtHead</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        dummy_head = ListNode(val = val, <span class="built_in">next</span> = self.head)</span><br><span class="line">        self.head = dummy_head</span><br><span class="line">        self.L += <span class="number">1</span></span><br><span class="line">        <span class="comment"># self.__printList(self.head)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addAtTail</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.addAtIndex(self.L, val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addAtIndex</span>(<span class="params">self, index: <span class="built_in">int</span>, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> index &gt; self.L <span class="keyword">or</span> index &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> index ==<span class="number">0</span> :</span><br><span class="line">            <span class="keyword">return</span> self.addAtHead(val)</span><br><span class="line">        </span><br><span class="line">        current = self.__getIndexPreNode(self.head, index)</span><br><span class="line">        newNode = ListNode(val, current.<span class="built_in">next</span>)</span><br><span class="line">        current.<span class="built_in">next</span> = newNode</span><br><span class="line">        self.L += <span class="number">1</span></span><br><span class="line">        <span class="comment"># self.__printList(self.head)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteAtIndex</span>(<span class="params">self, index: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> index &gt;= self.L <span class="keyword">or</span> index &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">if</span> index == <span class="number">0</span>:</span><br><span class="line">            self.head = self.head.<span class="built_in">next</span></span><br><span class="line">            self.L -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        current = self.__getIndexPreNode(self.head, index)</span><br><span class="line">        current.<span class="built_in">next</span> = current.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        self.L -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># self.__printList(self.head)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyLinkedList()</span></span><br><span class="line"><span class="comment"># param_1 = obj.get(index)</span></span><br><span class="line"><span class="comment"># obj.addAtHead(val)</span></span><br><span class="line"><span class="comment"># obj.addAtTail(val)</span></span><br><span class="line"><span class="comment"># obj.addAtIndex(index,val)</span></span><br><span class="line"><span class="comment"># obj.deleteAtIndex(index)</span></span><br></pre></td></tr></table></figure><h2 id="改进版">改进版</h2><ol><li>其它思路不变，规定将head作为“dummy_head”</li><li>新增__getIndexNode函数，指获得Index对应节点</li><li>优点：<strong>代码更统一了，减少了需要额外讨论index==0以及index==self.L的情况</strong>！！所以，有dummy_head非常方便</li><li>因为head是dummy_head，所以__getIndexNode(index)得到的就是index的pre节点，和原版作用是一样的</li><li>所以get函数中需要传入head.next而不是head</li></ol><blockquote><p>一般涉及到 增删改操作，用虚拟头结点dummy_head都会方便很多， 如果只能查的话，用不用虚拟头结点都差不多。</p></blockquote><h2 id="代码二">代码二</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,val = <span class="number">0</span>, <span class="built_in">next</span> = <span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.head = ListNode()</span><br><span class="line">        self.L = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getIndexNode</span>(<span class="params">self, node, index</span>):</span><br><span class="line">        current = node</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index):</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> current</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, index: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> index &gt;= self.L <span class="keyword">or</span> index &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"><span class="comment"># 注意，这里传入head.next而不是head</span></span><br><span class="line">        current = self.__getIndexNode(self.head.<span class="built_in">next</span>, index)</span><br><span class="line">        <span class="keyword">return</span> current.val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addAtHead</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.head.<span class="built_in">next</span> = ListNode(val = val, <span class="built_in">next</span> = self.head.<span class="built_in">next</span>)</span><br><span class="line">        self.L += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addAtTail</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.addAtIndex(self.L, val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addAtIndex</span>(<span class="params">self, index: <span class="built_in">int</span>, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> index &gt; self.L <span class="keyword">or</span> index &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        current = self.__getIndexNode(self.head, index)</span><br><span class="line">        current.<span class="built_in">next</span> =  ListNode(val, current.<span class="built_in">next</span>)</span><br><span class="line">        self.L += <span class="number">1</span></span><br><span class="line">        <span class="comment"># self.__printList(self.head)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteAtIndex</span>(<span class="params">self, index: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> index &gt;= self.L <span class="keyword">or</span> index &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">        current = self.__getIndexNode(self.head, index)</span><br><span class="line">        current.<span class="built_in">next</span> = current.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        self.L -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># self.__printList(self.head)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyLinkedList()</span></span><br><span class="line"><span class="comment"># param_1 = obj.get(index)</span></span><br><span class="line"><span class="comment"># obj.addAtHead(val)</span></span><br><span class="line"><span class="comment"># obj.addAtTail(val)</span></span><br><span class="line"><span class="comment"># obj.addAtIndex(index,val)</span></span><br><span class="line"><span class="comment"># obj.deleteAtIndex(index)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday3&quot;&gt;LeetCodeCampsDay3&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;主要与链表相关&lt;/p&gt;
&lt;p&gt;记住：&lt;strong&gt;一般涉及到 增删改操作，用虚拟头结点dummy_head都会方便很多， 如果只能查的话，用不用虚</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>IELTsSpeaking</title>
    <link href="https://blog.lthero.cn/2025/06/26/IELTsSpeaking/"/>
    <id>https://blog.lthero.cn/2025/06/26/IELTsSpeaking/</id>
    <published>2025-06-26T12:32:09.000Z</published>
    <updated>2025-07-06T14:54:21.960Z</updated>
    
    <content type="html"><![CDATA[<h1 id="改变世界的发明">改变世界的发明</h1><h2 id="part-2">Part 2</h2><blockquote><p>Describe an invention that has changed the world in a positive way</p></blockquote><p>You should say:</p><p>•        <strong>what</strong> it is</p><p>•        Basically, AI brings many benefits</p><p>•        <strong>how</strong> it influences people of different ages</p><p>•        <strong>explain</strong> how it changed people’s lives = how you felt about it</p><h3 id="大纲">大纲</h3><p>•        <strong>what</strong> it is</p><p>•        AI is a new invention that was just released several years ago</p><p>•        For example, there are many AI applications like DeepSeek and ChatGPT</p><p>•        Personally, I use it everyday</p><p>•        <strong>what</strong> benefits it has brought</p><p>•        Basically, AI brings many benefits</p><p>•        Firstly, it reduces the cost of generating content</p><p>•        Secondly, it can improve our efficiency at work</p><p>•        <strong>how</strong> it influences people of different ages</p><p>•        Overall, all kinds of people can be benefited by AI</p><p>•        For the kids, AI help them calculate the math equations and correct their errors</p><p>•        For the elderly, it allows them to seek for useful information they need</p><p>•        <strong>explain</strong> how it changed people’s lives = how you felt about it</p><p>AI is a new invention that was just released several years ago which changed the world significantly. For example, there are many AI applications like DeepSeek and ChatGPT.</p><p>Firstly, it significantly reduces the cost and effort required to generate content. It allows creators to get video clips or images by simplely typing a descriptive prompt. Plus, AI dramatically improves our efficiency at work. For instance, it can help draft documents and summarize long reports , which save up people’s valuable time for other tasks.</p><p>Secondly, AI influences people across all age groups. For children, AI can serve as an interactive learning companion, helping them solve complex math equations and offering instant feedback to correct their mistakes. For elderly floks, they can seek useful information and manage daily tasks simply by asking questions in a natural way on their AI-powered smartphones.</p><p>Initially, I was doubted whether AI was as powful as people said. However, after trying it for the first time, I was completely amazed by its power. Now, I try to make good use of AI as a powerful assistant in my daily life. Meanwhile, I am trying not relying heavily on it, focusing on strengthening abilities of problem-solving by myself.</p><h2 id="part-3">Part 3</h2><blockquote><p>What is the most helpful innovation at work?</p></blockquote><p>In my view, two types of innovation are helpful at work.</p><p>The first is AI assistants, such as ChatGPT. They are useful for quickly drafting documents, summarizing long reports, or even giving creative ideas, which significantly imporve our efficiency at work.</p><p>The second is collaborative online platforms like FeiShu and Google Workspace. These tools allow teams to work on documents simultaneously and share information instantly, greatly improving teamwork and efficiency/flexibility.</p><blockquote><p>What household appliances make us lazy?</p></blockquote><p>Several modern household appliances, while convenient, could be seen as contributing to a more sedentary lifestyle. Two prominent examples come to mind.</p><p>First, the robotic vacuum cleaner diligently cleans our floors on its own schedule. This automation completely removes the need for the physical work of walking with a traditional vacuum around the house.</p><p>Second, the dishwasher takes over the daily chore of washing dishes. By simply loading the machine and pressing a button, saving our time to do other things.</p><blockquote><p>What kinds of inventions can be used at school?</p></blockquote><p>Certainly, several modern inventions can significantly enhance the school learning environment, with two standing out.</p><p>First, interactive smart whiteboards are a key innovation. They replace traditional blackboards and connect directly to a computer, allowing teachers to write, draw, and project relevant digital content for a more dynamic lesson.</p><p>Another simple yet crucial invention is a classroom speaker. This device amplifies the teacher’s voice so that every student can hear clearly, which is especially helpful for teachers with softer voices.</p><p>Overall, these tools help create a more engaging and accessible educational setting.</p><blockquote><p>Do you think AI will replace human teachers? Why?</p></blockquote><p>I believe AI is unlikely to completely replace human teachers; instead, it will handle simple tasks while complex and safety-related roles will still require a human touch.</p><p>On one hand, AI can take over repetitive and tedious jobs. For instance, it can provide students with personalized practice exercises and then automatically grade their scores, saving teachers’ time.</p><p>On the other hand, a human teacher is essential for tasks requiring emotional intelligence and judgment. They can inspire creativity, and manage classroom to ensure a good learning environment, which are deeply human skills.</p><ol><li>First, I could send my context and a clear prompt to it</li><li>Second, after a while, it will return an answer to me</li><li>Maybe, I wouldn’t be satisfied by it at first</li><li>So, I would finetune/optimize my prompt so that AI can return me a better version of it</li></ol><h1 id="二手交易">二手交易</h1><h2 id="part2">Part2</h2><blockquote><p>Describe a website that sells second-hand items</p></blockquote><ul><li>what it is</li><li>how you found out about it</li><li>what people can buy from it</li><li>explain whether you like it</li></ul><p>I want to share with you a website called xianyu ,which is kind of like the Chinese version of eBay, where people trade different products and services.</p><p>It’s a quite popular application in China especially among the young people, I first heard about it from my friend, who’s always hunting for cool second-hand stuffs on it. Then, I got curious and started browsing myself.</p><p>On Xianyu, people can find literally everything, from gift cards, books and clothes to digital products like smartphone, laptop , camera and even some online services, for example, I met my English tutor on it.</p><p>Personally, I once used that app to buy a second-hand ipad after receiving my scholarship. The price was great, and it looked almost new in the pictures. When it arrived, the screen had some lines across it—like it had been dropped before. I messaged the seller, but he said it must’ve happened during shipping. Obviously classic excuse. In the end, I got a partial refund. Since then, I’ve become way more careful when shopping second-items online, this app reduces the threshold for people to become a seller, so we should always asking for extra pictures and checking more reviews before deciding which one to buy.</p><h2 id="part3">Part3</h2><blockquote><p>Some people think it’s a waste to buy too many clothes for children. What do you think?</p></blockquote><p>I do think it’s a waste to buy too many clothes for children.</p><p>Firstly, children nowadays just grow too quickly. As a result, they have to purchase more and more clothes, which could be a waste of money and resource.</p><p>Secondly, people can recycle clothes that they don’t want anymore, or to donate to those who need them the most.</p><blockquote><p>what do you usually do with a cell phone?</p></blockquote><p>My phone is basically my second brain, I can do literally everything on it. It provide so many useful functions for me to text with friends, scroll videos, order food. And  you might not believe it, there are almost like five delivery apps on my phone, so I can just choose any app depend on my mood on that day.</p><p>Personally, as you know, as a student, I rely heavily on the AI capabilities of my phone to support my studies. These AI-powered functions are a huge helper, assisting me with everything from research and writing to organizing my study schedule and preparing for exams.</p><blockquote><p>What are the differences between young people and old people when using a cell phone?</p></blockquote><p>There are huge differences in the usage between. old and young people.</p><p>For young people. they mostly use cell phone for self improvement. Many white collar workers actually spend a lot of time and energy on their phone listening to some podcasts, yeah, or even online courses.</p><p>However, the old people would just entertain with a cell phone. since they have nothing to do, they would spend much time on their phone scrolling videos. Or just reading some latest news</p><blockquote><p>what can be done to stop cell phone addiction</p></blockquote><p>There are many ways that we can do. to stop us addicted to the cell phone</p><p>the first is that we can。Do more physical exercise. ok like going to the gym  like going to the gym。Or the park so that we are away from the cell phone</p><p>the second method is that we can download the。The specialized apps designed Help Design to help us concentrate on what matters the most. For example, people could set their screen time so that they can limit their exposure to the phone.</p><blockquote><p>Do you think it is too late to call others at eleven or twelve o’clock at night?</p></blockquote><p>Well, it really depends on different situations. It depends on who you are calling.</p><p>for young people, I think calling them so late is fine. Because as you know, they just they usually stay up late or simply go to bed quite late. Yeah, because most of them would be more energetic, especially in the evening.</p><p>However. if we are talking about elderly folks then it might not be a rational choice. as you know most old people are used to going to bed quite early. Probably. because they have more priorities things uh they have more prioritized the things to do the next morning</p><blockquote><p>Do you think there should be a law to stop people from making phone calls in public?</p></blockquote><p>In the common sense the laws should only people should only abide by the law.</p><p>The normally the laws will only take care of severe behaviors. While answering phone on public should be considered as a basic human right, and the law shouldn’t be so strict otherwise the law loses its <strong>seriousness</strong> and becomes difficult to enforce.</p><blockquote><p>What problems will occur if people don’t recycle?</p></blockquote><p>If fewer people choose to recycle it will lead to lots of problems <strong>,</strong></p><p>Firstly, people would simply waste a lot of their own money. For me, the things that I don’t want anymore can be sold on second hand websites. it could partially saves money.</p><p>another consequence is that the environment could get worse if the products that they don’t want anymore are disposed instead of recycled. The air quality and water quality will be contaminated.</p><blockquote><p>Should the government encourage people to recycle items?</p></blockquote><p>it totally makes sense for the government to encourage people to recycle</p><p>first, for the residents. They can save money by selling their items on second hand websites to those who need them the most, by doing this they partially saved money instead of just directly disposing them.</p><p>Another reason is that recycling can also play a very important role in protection of the environment, if not executed well, The air quality and water quality could be contaminated.</p><h2 id="part2">Part2</h2><p>Describe a cultural place that you would like to learn the culture there(e.g. a libraay, museum, theater)</p><p>Where it is,</p><p>How you knew about this place?</p><p>What it is like?</p><p>explain how this place is related to culture(How you feel)</p><p>I would like to share you with the Former Residence of Qu Yuan which is a significant cultural site in China.</p><p>The residence is located in Hubei province, in the central part of China, and is quite accessible, typically taking less than an hour to reach by metro or bus.</p><p>My first encounter with Qu Yuan was in my primary school classes. As I gained further interest on it, I began to research him and his stories online trying to dig out more details behind it.</p><p>The residence is a magnificent sight. From a distance, its architecture is immediately impressive. As you walk closer, you can find out there are two floors. Once you step through the main gate, you’ll be amazed by all the collection of artifacts. The ground floor serves as an exhibition hall, showcasing the life and legacy of Qu Yuan—his famous poems, his political contributions.</p><p>At first, because I had never been there, I was a bit doubtful and couldn’t fully understand why so many people admired this place. However, as I learned more, I became deeply convinced and moved by the powerful stories behind the man himself. The residence is more than just a building; it’s represent a pivotal figure in our history, and that deep connection to our cultural roots is what makes it so compelling(attractive).</p><h2 id="part3">Part3</h2><p><strong>So what kind of culture is popular among young people?</strong></p><p>I believe there are many different kinds of cultures popular among young people right now.</p><p>First, I would say that staying up late has become a significant part of youth culture. Many young people claim to be more efficient and energetic at midnight, embracing a nocturnal lifestyle.</p><p>A second prevalent cultural trend is cell phone addiction. It’s common to see young people spending an excessive amount of time on their screens like scrolling videos. Their phones literally capture all of their attention, making them easily distracted from what truly matters.</p><p><strong>So how do young people learn about different cultures?</strong></p><p>Young people today have numerous sources for learning about different cultures.</p><p>The most conventional way is through online channels, particularly social media platforms like YouTube. A huge number of content creators produce all these interesting videos that showcase diverse cultures from all over the world, making this a very accessible way to learn.</p><p>However, a second, and I would say more effective, method is through direct, in-person experience. This involves traveling and interacting with locals firsthand. By speaking directly with people and observing their way of life, people can learn the practical ‘know-how’—the knowledge and customs that cannot be fully captured or codified in online content.&quot;</p><p><strong>So how is a culture formed?</strong></p><h2 id="part2">part2</h2><p>描述一部最近看的剧，下面以Shameless举例</p><p>I’d like to share a TV series with you named <em>Shameless</em>. It’s a remarkable show that has both a UK and a US version. The British one came out a bit earlier in 2004, but I watched the American adaptation which started in 2011.</p><p>The series revolves around the daily life of the Gallagher family, who live in the South Side of Chicago. It tells the story of an alcoholic and narcissistic father, Frank, and his six intelligent and independent children. The eldest, Fiona, who is only in her early twenties, has to take on the parental role to raise her five younger siblings.</p><p>I first came across this show back in 2022 when I saw some short clips of it on social media. The chaotic yet heartwarming family dynamic immediately caught my attention. As I gained further interest in this series, I searched for it online to know more details. Eventually, I started watching it on Netflix and got through nine seasons. I still haven’t watched the final two seasons because I just don’t want this incredible story to end.</p><p>Honestly, when I first saw the show’s title and poster, it didn’t appeal to me at all. I thought it would be just another generic drama. However, once I started the first episode, I was completely hooked and ended up binge-watching several episodes in one go. I even enthusiastically recommended it to my friends. Although they didn’t seem to share the same level of interest, I still enjoyed the process. For me, <em>Shameless</em> is definitely one of the best TV series I’ve ever seen, right up there with <em>Breaking Bad</em>, and I always hope to meet other people who love it as much as I do.</p><h1 id="文化">文化</h1><h2 id="part2">Part2</h2><h3 id="问题一">问题一</h3><p>Describe your favorite food at a traditional festival or a special event in your country</p><ul><li>What it is</li><li>At which festival/event you eat it</li><li>how it is made</li><li>explain why you like it</li></ul><p>I want to share with you a traditional Chinese food that many people like to eat, especially during traditional festivals. It is a dish that almost every Chinese person has been eating for years, and it has already symbolized the traditional culture of china.</p><p>We usually eat Jiaozi during important festivals, like the Spring Festival or anytime we get together with our family members. During these times, we would also usually go to pray at temples. For example, If it’s the Mid-Autumn Festival we would also enjoy mooncakes at the same time.</p><p>Well when we talk about how they are made, the process itself is a very simple. The first step to make Jiaozi is to prepare all the raw ingredients/materials, like meat, or vegetables if you are a vegetarian, and of course, the dough, which is made of flour. Second, you need to wrap the fillings in the dough in a specific way. Third, the wrapped Jiaozi should be cooked in boiling water for about 20 to 30 minutes.</p><p>At first, I was pretty doubtful why everybody liked it so much because to me, it just seemed like a random food. After I tried it and gained more interested in it, I realized that the time we spend with our family and those we love is the most important thing. So in the future I’m sure that I’ll be grateful for such a food, and I will also treasure of time eating jiaozi.</p><h3 id="问题二">问题二</h3><p>Describe a popular/well-known person in your country</p><ul><li>Who this person is.</li><li>What he/she has done</li><li>why he/she is popular</li><li>explain how you feel about this person</li></ul><p>I would like to share with you Qu Yuan who was a significant historical figure and probably one of the most popular poets in China. He served as a high-ranking official in one of China’s ancient dynasties. Furthermore, he was a very famous poet who wrote many beautiful and influential poems which was already documented in his former residence.</p><p>As an official, he contributed a lot to his country. He provided his king with many useful suggestions and strategies such as forming alliances with other countries to resis the threat of the country Qin. Unfortunately, his suggestions was dismissed by the king, and he was exiled. Later, when Qu Yuan heard that capital of his country had been captured by the enemy, he was so sad and hopeless that he jumped into the River as a form of protest.</p><p>Well, I think there are several reasons that make him popular. He is still so popular today not just because of his amazing poems, but because he is a symbol of patriotism and integrity. People respect him because he wasn’t afraid of powerful people and always stuck to his beliefs, no matter what.</p><p>At first, I was pretty doubtful why everybody liked him so much because to me, he just seemed like a ordinary guy. After I gained further interests in him, I even searched online for more deails, Then I realized I was convinced by his courage of sticking to his own opinion and his incredible talent as well.</p><h2 id="part3">part3</h2><p><strong>问题：What kinds of people are popular at work?</strong></p><p>回复：there are many factors that make someone popular at work.</p><p>First, kind people are usually very popular. I think it’s their kindness that really makes a difference. As you know, a kind person in the workplace is always willing to help you whenever you have a problem. They will offer a helping hand to anyone who is in need.</p><p>Well, moreover, people who are smart are definitely popular and admired by their colleagues. This is because everyone wants to work with a smart person, as they can often provide unique solutions and solve problems in a creative way. And that’s really valuable because, at work, there are always tons of difficulties and problems that need creative thinking to be solved.</p><p><strong>问题：Which one is more important, maintaining a good relationship with colleagues or doing well at work?</strong></p><p>回复：Well, I believe both of these are very important. In my opinion, they are equally important for a successful career.</p><p>On one hand, getting along well with your colleagues is a big advantage. It can help you go further in your career because you can always depend on each other for support, especially when you run into difficulties at work.</p><p>On the other hand, performing well at your job is also crucial. When you consistently do good work, you earn the  respect of your colleagues and your boss. People will trust your skills and want to include you in important projects, which naturally leads to better opportunities and promotions.</p><p><strong>问题：What benefits are there when a child is popular at school?</strong></p><p>I believe there are many benefits when a child is popular at school.</p><p>First, popular kids are often admired by other children. Because of this, he or she will probably have more opportunities to make new friends, which is great for their social development.</p><p>Another benefit is that these popular children might also attract more attention from their teachers. Teachers sometimes tend to focus more on these students, and this extra attention could be good for their grades and their overall self-improvement.</p><p><strong>问题：Do do you think popular children will grow up to be popular adults?</strong></p><p>Well, I think popular children have a better chance of becoming popular adults, but it’s not guaranteed. I think there are a couple of reasons for this.</p><p>On one hand, being a popular child gives you some advantages. For example, they are used to getting more attention from others, which can help them shape their personality and build their confidence. This is obviously a good foundation for their future.</p><p>On the other hand, it also really depends on how they handle their relationships as they grow up. If they fail to maintain these relationships well, they probably won’t continue to be a popular adult.</p><p>To be honest, I think this happens a lot. As you know, the world of adults is just much more complicated.</p><p><strong>问题：Are bosses more popular than employees at work?</strong></p><p>Well, I would say employees are probably more popular than bosses at work, and I think there are a couple of reasons for this.</p><p>First, let’s think about the boss’s role. Bosses are the ones who give us orders, and sometimes they can be very demanding or set strict deadlines. This can create a lot of pressure, which naturally makes it difficult for employees to build a casual and friendly relationship with them.</p><p>On the other hand, employees usually have a lot in common with each other. We share similar roles and backgrounds within the company. Because we have these shared experiences and common goals—like finishing a project together—it’s much easier for us to connect, become friends, and build solid relationships.</p><p><strong>问题：Are there any disadvantages Ifa Child is popular at school?</strong></p><p>Yes, I believe there can be several drawbacks for a child who is popular at school.</p><p>First, being popular can sometimes attract the wrong kind of attention from peers. For example, other kids might become envious or jealous of them. If that situation gets worse, this jealousy could lead to serious arguments or even cause the popular child to be isolated by others and there could be some severe quarrels or fights between them.</p><p>Another drawback is that popularity itself can be a big distraction. Popular children often need to spend a lot of time and energy maintaining all of their friendships. As a result, they can get distracted and might not have enough time to focus on their studies. In the long term, this could cause their grades to suffer.</p><p><strong>问题：Which is more important in terms of culture, literature or music.</strong></p><p>Well, in my opinion, I believe music is more crucial to a culture than literature, and I have a couple of reasons for this.</p><p>First, music is like a universal language. It doesn’t depend on literacy, so people don’t need to be able to read to understand it. People from all over the world can feel the rhythm and vibe in a piece of music, even if they don’t understand the lyrics. (Literature, on the other hand, is usually limited to people who speak and read a specific language.)</p><p>Second, I think music is more influential and can spread more widely in today’s world. It can easily be shared online and can combine traditional and modern styles. Because it’s so adaptable, I believe music often has a more profound and immediate impact on a wider audience than a book does.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;改变世界的发明&quot;&gt;改变世界的发明&lt;/h1&gt;
&lt;h2 id=&quot;part-2&quot;&gt;Part 2&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Describe an invention that has changed the world in a positive way</summary>
      
    
    
    
    <category term="IELTs" scheme="https://blog.lthero.cn/categories/IELTs/"/>
    
    
    <category term="IELTs" scheme="https://blog.lthero.cn/tags/IELTs/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay2</title>
    <link href="https://blog.lthero.cn/2025/06/25/LeetCodeCampsDay2/"/>
    <id>https://blog.lthero.cn/2025/06/25/LeetCodeCampsDay2/</id>
    <published>2025-06-24T16:12:32.000Z</published>
    <updated>2025-06-28T16:16:14.396Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecamps-day1">LeetCodeCamps—Day1</h1><blockquote><p>同样需要使用快/慢指针/双指针，另外，可以使用前缀和数组、二分查找</p></blockquote><h1 id="209-长度最小的子数组">209. 长度最小的子数组</h1><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">https://leetcode.cn/problems/minimum-size-subarray-sum/</a></p><h2 id="问题">问题</h2><blockquote><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code></p><p>找出该数组中满足其总和大于等于 <code>target</code> 的长度最小的 <strong>子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度**。**如果不存在符合条件的子数组，返回 <code>0</code> 。</p></blockquote><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 4, nums = [1,4,4]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 11, nums = [1,1,1,1,1,1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= target &lt;= 109</code></li><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 104</code></li></ul><p><strong>进阶：</strong></p><ul><li>如果你已经实现 <code>O(n)</code> 时间复杂度的解法, 请尝试设计一个 <code>O(n log(n))</code> 时间复杂度的解法。</li></ul><h2 id="核心思路">核心思路</h2><ol><li>外循环：使用for循环，被遍历对象为快指针(right)，通过 ⁠right 指针扩展窗口</li><li>内循环：当窗口和(the sum of windows) &gt;= ⁠target 时，记录当前窗口长度，并尝试收缩(shrink)窗口以找到更小的子数组</li><li>跳出条件：如果数组为空或没有符合的子数组，⁠min_length 保持为最大值float(‘inf’)时，最终返回 0</li></ol><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        currentSum = <span class="number">0</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># Set the minimumWindows as a positive inf</span></span><br><span class="line">        minimumWindows = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">          <span class="comment"># keep add nums to currentSum</span></span><br><span class="line">            currentSum += nums[right]</span><br><span class="line">            <span class="comment"># if currentSum is bigger than target,</span></span><br><span class="line">            <span class="comment"># try to shrink the minimumWindows from the left to find a smaller currentSum.</span></span><br><span class="line">            <span class="keyword">while</span> currentSum &gt;= target <span class="keyword">and</span> left &lt;= right:</span><br><span class="line">              <span class="comment"># shrink the windows</span></span><br><span class="line">                minimumWindows = <span class="built_in">min</span>(minimumWindows, right - left + <span class="number">1</span>)</span><br><span class="line">                <span class="comment"># remove the leftmost elements from the sum</span></span><br><span class="line">                currentSum -= nums[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> minimumWindows == <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> minimumWindows</span><br></pre></td></tr></table></figure><h2 id="o-nlogn-时间复杂度的解法">O(nlogn)时间复杂度的解法</h2><p>这个解法使用<code>前缀和数组</code>(prefix array)结合<code>二分查找</code>：</p><p>先计算<code>前缀和数组</code>，prefix[i] 表示 nums[0] 到 nums[i-1] 的和</p><p>对于每个右端点 j（对应子数组结束位置），使用二分查找找到第一个子数组和 &gt;= target 的最大右端点。</p><p>时间复杂度：O(n log n)，因为计算前缀和是 O(n)，每个右端点进行一次二分查找是 O(log n)，总共 O(n log n)</p><p>空间复杂度：O(n)，用于存储前缀和数组</p><h2 id="思路">思路</h2><ol><li>使用前缀和数组来快速计算子数组的总和</li><li>我们需要找到一个子区间nums[j…k]，而且sum(nums[j…k]) &gt;= target；而sum(nums[j…k]) = ⁠prefix[k+1] - prefix[j]，于是就有prefix[k+1] - prefix[j] &gt;= target, 于是就有prefix[k+1] &gt;= target + prefix[j]</li><li>使用（变体）二分搜索在前缀和数组中（从prefix[j…k])，找到<strong>第一个大于target + prefix[j]的下标mid</strong>，从而计算最小长度</li></ol><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">L = <span class="built_in">len</span>(nums)</span><br><span class="line">prefix = [<span class="number">0</span>] * (L + <span class="number">1</span>)</span><br><span class="line"><span class="comment"># prefix[1] = nums[0], prefix[2] = nums[1], etc.</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L + <span class="number">1</span>):</span><br><span class="line">    prefix[i] = prefix[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> prefix[L] &lt; target:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(prefix)</span><br><span class="line">minimumWindows = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, L + <span class="number">1</span>):</span><br><span class="line">    <span class="comment"># The need is to find a ⁠nums[j..k] which &gt;= target，the sum of nums[j..k] = ⁠prefix[k+1] - prefix[j]</span></span><br><span class="line">    <span class="comment"># Which means `⁠prefix[k+1] - prefix[j] &gt;= target`, noted by `⁠prefix[k+1] &gt;= prefix[j] + target`</span></span><br><span class="line">    <span class="comment"># Hence, ⁠value = prefix[j] + target is the lowest boundary that satisfied the need</span></span><br><span class="line">    <span class="comment"># value = prefix[j] + target # we can set this result to &#x27;value&#x27; to reduce the repeated calculation.</span></span><br><span class="line">    <span class="keyword">if</span> prefix[j] + target &gt; prefix[L]:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># Find the first value which &gt;= value by using binary search</span></span><br><span class="line">    left, right = j, L</span><br><span class="line">    <span class="keyword">while</span> left != right:</span><br><span class="line">      <span class="comment"># </span></span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> prefix[mid] &gt;= prefix[j] + target:</span><br><span class="line">            right = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">    <span class="comment"># right(or left) is the first index which &gt;= ⁠value in prefix</span></span><br><span class="line">    <span class="comment"># where the right equals to the lowest &#x27;k+1&#x27; making the sum of nums[j..k] &gt;= target</span></span><br><span class="line">    minimumWindows = <span class="built_in">min</span>(minimumWindows, right - j)</span><br><span class="line"><span class="keyword">return</span> minimumWindows</span><br></pre></td></tr></table></figure><h1 id="59-螺旋矩阵-ii">59. 螺旋矩阵 II</h1><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">https://leetcode.cn/problems/spiral-matrix-ii/</a></p><blockquote><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p></blockquote><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[[1,2,3],[8,9,4],[7,6,5]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li></ul><h2 id="思路">思路</h2><p>这题目不考算法，但考编程能力；</p><p>这题目有个关键点是，弄清楚赋值的规律：将上、右、下、左四条边依次赋值，并且每次赋值时，都遵循“左开右闭”原则</p><blockquote><p>比如第一行1-&gt;2-&gt;3，仅赋值1和2），而第二条（3-&gt;4-&gt;5），仅赋值(3-&gt;4);第三条(5-&gt;6-&gt;7)，仅赋值(5-&gt;6)；最后一条(7-&gt;8-&gt;1)，同样仅赋值(7-&gt;8)</p></blockquote><p>这样完成了一个“回”字形赋值</p><h2 id="代码">代码</h2><p>下面代码可以优化成仅用一个offset，因为startX/startY与offset变化方式是一致的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateMatrix</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">      <span class="comment"># startX是指纵向下标</span></span><br><span class="line">        startX = <span class="number">0</span></span><br><span class="line">        <span class="comment"># startY是指横向下标</span></span><br><span class="line">        startY = <span class="number">0</span></span><br><span class="line">        <span class="comment"># offset用来计算开区间</span></span><br><span class="line">        offset = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 左闭右开</span></span><br><span class="line">        nums = [[<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        count = <span class="number">1</span> </span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n//<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(startY, n - offset):</span><br><span class="line">                nums[startX][j] = count</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                <span class="comment"># print(nums)</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startX, n - offset):</span><br><span class="line">                nums[i][n - offset] = count</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                <span class="comment"># print(nums)</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n - offset, startY - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                nums[n - offset][j] = count</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                <span class="comment"># print(nums)</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - offset - <span class="number">1</span>, startX , -<span class="number">1</span>):</span><br><span class="line">                nums[i][j] = count</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                <span class="comment"># print(nums)</span></span><br><span class="line">            startX += <span class="number">1</span></span><br><span class="line">            startY += <span class="number">1</span></span><br><span class="line">            offset += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            nums[n//<span class="number">2</span>][n//<span class="number">2</span>] = count</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecamps-day1&quot;&gt;LeetCodeCamps—Day1&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;同样需要使用快/慢指针/双指针，另外，可以使用前缀和数组、二分查找&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;209-长度最小的子数组</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://blog.lthero.cn/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="https://blog.lthero.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay1</title>
    <link href="https://blog.lthero.cn/2025/06/24/LeetCodeCampsDay1/"/>
    <id>https://blog.lthero.cn/2025/06/24/LeetCodeCampsDay1/</id>
    <published>2025-06-24T14:56:55.000Z</published>
    <updated>2025-06-26T07:12:35.713Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecamps-day1">LeetCodeCamps—Day1</h1><blockquote><p>day1的三个题目都可以使用快慢指针/双指针/多指针的思路，</p><p>慢指针用于存放结果，快指针是遍历原数组用的</p></blockquote><h1 id="27-移除元素">27. 移除元素</h1><p><a href="https://leetcode.cn/problems/remove-element/">https://leetcode.cn/problems/remove-element/</a></p><blockquote><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素。元素的顺序可能发生改变。然后返回 <code>nums</code> 中与 <code>val</code> 不同的元素的数量。</p></blockquote><p>假设 <code>nums</code> 中不等于 <code>val</code> 的元素数量为 <code>k</code>，要通过此题，您需要执行以下操作：</p><ul><li>更改 <code>nums</code> 数组，使 <code>nums</code> 的前 <code>k</code> 个元素包含不等于 <code>val</code> 的元素。<code>nums</code> 的其余元素和 <code>nums</code> 的大小并不重要。</li><li>返回 <code>k</code>。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,2,3], val = 3</span><br><span class="line">输出：2, nums = [2,2,_,_]</span><br><span class="line">解释：你的函数函数应该返回 k = 2, 并且 nums 中的前两个元素均为 2。</span><br><span class="line">你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">输出：5, nums = [0,1,4,0,3,_,_,_]</span><br><span class="line">解释：你的函数应该返回 k = 5，并且 nums 中的前五个元素为 0,0,1,3,4。</span><br><span class="line">注意这五个元素可以任意顺序返回。</span><br><span class="line">你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 50</code></li><li><code>0 &lt;= val &lt;= 100</code></li></ul><h2 id="思路">思路</h2><h3 id="理解问题">理解问题</h3><ul><li>需要原地“移除”等于val的元素，但又不关心留下的前k个元素之后的内容（<strong>暗示不用真的移除</strong>）</li></ul><h3 id="核心步骤">核心步骤</h3><ol><li>派用两个指针，快指针用来遍历nums每个数据，判断是否等于val</li><li>慢指针是res结果数组的下标，用来存放不等于val的数据</li><li>本题可以不使用额外空间，直接原地将nums当成res数组</li></ol><p>动画参考</p><p><img src="https://file1.kamacoder.com/i/algo/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95.gif" alt="img"></p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">      <span class="comment"># resIndex 为慢指针</span></span><br><span class="line">        resIndex = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 先求出L，可以节省每次循环计算len(nums)的时间</span></span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># i其实是快指针，用来遍历每个nums值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != val:</span><br><span class="line">                nums[resIndex] = nums[i]</span><br><span class="line">                resIndex += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resIndex</span><br></pre></td></tr></table></figure><h1 id="704-二分查找">704. 二分查找</h1><h2 id="题目描述">题目描述</h2><p><a href="https://leetcode.cn/problems/binary-search/">https://leetcode.cn/problems/binary-search/</a></p><blockquote><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果 <code>target</code> 存在返回下标，否则返回 <code>-1</code>。</p></blockquote><p>你必须编写一个具有 <code>O(log n)</code> 时间复杂度的算法。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="line">输出: 4</span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 2</span><br><span class="line">输出: -1</span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>你可以假设 <code>nums</code> 中的所有元素是不重复的。</li><li><code>n</code> 将在 <code>[1, 10000]</code>之间。</li><li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间</li></ol><h2 id="思路">思路</h2><h3 id="理解问题">理解问题</h3><ol><li>有一个<strong>升序排序的数组</strong>和一<strong>个目标值</strong>。</li><li>找到目标值在数组中的<strong>下标</strong>，如果不存在就返回-1。</li><li>算法必须是O(log n)的时间复杂度，这意味着每次操作都要将搜索范围减半（这就是二分查找的精髓）。</li></ol><h3 id="核心步骤">核心步骤</h3><p>初始化指针：用两个指针定义搜索范围：left 指向数组的起始位置（通常是0）。⁠right 指向数组的结束位置（通常是数组长度-1）。</p><p>循环查找：</p><ul><li>计算中间位置：mid = left + (right - left) / 2;  // 这样计算避免整数溢出。</li></ul><p>比较数组中mid位置的元素：</p><ul><li>如果 nums[mid] == target，返回 mid（找到了！）</li><li>如果 nums[mid] &lt; target，说明目标在右半部分，所以更新 left = mid + 1。</li><li>如果 nums[mid] &gt; target，说明目标在左半部分，所以更新 right = mid - 1</li></ul><p>重复这个过程，直到 left &gt; right（搜索范围为空）</p><p>结束处理：如果循环结束还没有找到目标，返回 -1</p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        leftIndex = <span class="number">0</span></span><br><span class="line">        rightIndex = L - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 注意跳出条件是小于或等于；如果仅有小于，则会出现nums=[5]输出结果为-1的错误情况</span></span><br><span class="line">        <span class="keyword">while</span> leftIndex &lt;= rightIndex:</span><br><span class="line">            <span class="comment"># 找到个中值pivot, 不断让num[pivot]与target进行判断</span></span><br><span class="line">            pivot = (rightIndex + leftIndex) // <span class="number">2</span></span><br><span class="line">            <span class="comment"># 如果nums[pivot]大于target，则target在[left,pivot]区间</span></span><br><span class="line">            <span class="keyword">if</span> nums[pivot] &gt; target:</span><br><span class="line">                rightIndex = pivot - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[pivot] &lt; target:</span><br><span class="line">                leftIndex = pivot + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> pivot</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="思路二">思路二</h2><p>二分查找的变体：<strong>查找数组中第一个大于等于target的元素下标</strong>，同样可以适用于这题</p><h3 id="核心思想">核心思想</h3><ol><li>同样通过left, right两个指针，<strong>不断 shrink 区间</strong>；</li><li>但对于nums[mid] == target的情况需要特殊处理，<strong>不能直接返回</strong>，因为需要找“第一个大于等于target的”，<strong>需要带着mid继续搜索</strong></li></ol><h3 id="举例">举例</h3><p>例如，假设数组是 ⁠[1, 5, 5, 7, 9] 和 ⁠target = 5：</p><p>mid 是 2 (nums[2] = 5 &gt;= 5)，设置 right = 2，</p><p>下次迭代会继续检查左侧[1，5，5]</p><p>mid 是 1 (nums[1] = 5 &gt;= 5), 设置 right = 5,</p><p>下次迭代会继续检查左侧[1，5]</p><p>mid 是 0 (nums[0] = 1 &lt; 5), 设置 left = mid + 1 = 1，此时left == right， 跳出循环</p><h2 id="代码二">代码二</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = L - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 跳出条件是当left == right</span></span><br><span class="line">        <span class="keyword">while</span> left != right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt;= target:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="comment"># While left equals to right satisfiy the break condition,</span></span><br><span class="line">        <span class="comment"># nums[left] might not equals to target.</span></span><br><span class="line">        <span class="keyword">if</span> nums[right] == target:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="977-有序数组的平方">977. 有序数组的平方</h1><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">https://leetcode.cn/problems/squares-of-a-sorted-array/</a></p><blockquote><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p></blockquote><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-4,-1,0,3,10]</span><br><span class="line">输出：[0,1,9,16,100]</span><br><span class="line">解释：平方后，数组变为 [16,1,0,9,100]</span><br><span class="line">排序后，数组变为 [0,1,9,16,100]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-7,-3,2,3,11]</span><br><span class="line">输出：[4,9,9,49,121]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 已按 <strong>非递减顺序</strong> 排序</li></ul><p><strong>进阶：</strong></p><ul><li>请你设计时间复杂度为 <code>O(n)</code> 的算法解决本问题</li></ul><h2 id="思路">思路</h2><h3 id="理解问题">理解问题</h3><ul><li><strong>nums已经有序</strong></li><li>每个数字平方后的<strong>结果数组</strong>也要有<strong>非递减序</strong></li></ul><h3 id="核心步骤">核心步骤</h3><p>数组平方后的最大值，一定出自nums的两端，[-4,-1,0,3]-&gt;[0,1,9,16]</p><p>所以可以在两端使用两个“快指针”，</p><ol><li>比较<strong>两端数字平方后的结果</strong>，将更大的数字放在“慢指针”的位置</li><li>需要用个res数组，<strong>慢指针指向这个res数组</strong></li><li>需要从后向前遍历慢指针，因为题目要求结果数组非递减序</li></ol><p>可以参考这个动画（偷来的）</p><p><img src="https://file1.kamacoder.com/i/algo/977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif" alt="img"></p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedSquares</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = [<span class="number">0</span>] * L</span><br><span class="line">        <span class="comment"># resIndex作为结果数组的下标（当成慢指针也行）</span></span><br><span class="line">        resIndex = L - <span class="number">1</span></span><br><span class="line">        <span class="comment"># leftIndex和rightIndex当成快指针</span></span><br><span class="line">        leftIndex = <span class="number">0</span></span><br><span class="line">        rightIndex = L - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> resIndex &gt;= <span class="number">0</span>:</span><br><span class="line">            leftNumSquare = nums[leftIndex]*nums[leftIndex]</span><br><span class="line">            rightNumSquare = nums[rightIndex]*nums[rightIndex]</span><br><span class="line">            <span class="keyword">if</span> leftNumSquare &lt; rightNumSquare:</span><br><span class="line">                res[resIndex] = rightNumSquare</span><br><span class="line">                rightIndex -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res[resIndex] = leftNumSquare</span><br><span class="line">                leftIndex += <span class="number">1</span></span><br><span class="line">            resIndex -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecamps-day1&quot;&gt;LeetCodeCamps—Day1&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;day1的三个题目都可以使用快慢指针/双指针/多指针的思路，&lt;/p&gt;
&lt;p&gt;慢指针用于存放结果，快指针是遍历原数组用的&lt;/p&gt;
&lt;/blockq</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://blog.lthero.cn/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="https://blog.lthero.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>HBO Max 低价开通</title>
    <link href="https://blog.lthero.cn/2025/06/24/RegisterHBO/"/>
    <id>https://blog.lthero.cn/2025/06/24/RegisterHBO/</id>
    <published>2025-06-24T14:29:36.000Z</published>
    <updated>2025-06-24T14:30:00.856Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hbo-max-低价开通">HBO Max 低价开通</h1><blockquote><p>本文将讲述如何通过网页、Google Play 和 AppStore 订阅阿根廷的 HBO Max 服务</p></blockquote><p>亚洲区 Max 已正式上线，<strong>新加坡ip下有简体中文界面，港台为繁体中文</strong></p><h2 id="关于-max">关于 Max</h2><p>Max 是华纳媒体提供的流媒体视频服务平台，于 2020 年 5 月 27 日正式运行。虽然平台是根据同名的付费有线电视频道 HBO 的内容构建，但它主要作为华纳媒体制作的影视内容提供，也包含通过第三方许可的其他内容。</p><blockquote><p>HBO Max 于 2023年 5 月 23 日，更名为 Max。<br>在美国，Discovery+ 已被合并入 Max。</p></blockquote><h3 id="hbo-go-升级为-max">HBO GO 升级为 Max</h3><img src="https://yummy.best/content/images/2024/11/CleanShot-2024-11-19-at-12.18.08@2x.png" alt="img" style="zoom:67%;" /><p>Max 推出初期仅在美国运营，支持4K UDH和双杜比。其他地区则为 HBO Go，只有 720p 分辨率。</p><p>后来于 2021 年 6 月 29 日在南美洲上线，其中就包括阿根廷。2024 年 11 月 19 日正式在亚洲地区上线。</p><ul><li>现在订阅阿根廷可享受50%off （仅限南美开业首年）</li></ul><p>Max 亚洲区上线后，原 HBO GO 订阅已被迁移至 Max 的标准订阅(Full HD），无法直接享受 4K + 双杜比.</p><hr><h2 id="低价区开通方式">低价区开通方式</h2><p><strong>目前，价格最低的是阿根廷区，需要通过应用内购买，价格为 $39.99。</strong></p><p>其次是菲律宾，价格为 2790 PHP/年 ≈ $47.40</p><p>截止至撰稿，价格最低的为通过 AppStore 或 Google Play 开通阿根廷区 Max ，<strong>价格为 $39.99，均以美元计价</strong>。</p><p><strong>通过网页购买则需要缴纳 21% 的税款</strong>，由于订阅价格原本就比内购贵，税后价格将比内购贵出 $20。 ARS 60,487.9 ≈ $60.37</p><p><a href="https://yummy.best/content/images/2024/11/telegram-cloud-photo-size-5-6190293710860830359-y.jpg"><img src="https://yummy.best/content/images/2024/11/telegram-cloud-photo-size-5-6190293710860830359-y.jpg" alt="img"></a>🇦🇷阿根廷 Google Play 价格</p><p><img src="https://yummy.best/content/images/2024/11/CleanShot-2024-11-19-at-20.06.10@2x.png" alt="img"></p><hr><h3 id="1-通过网页端订阅-需额外缴税">1️⃣ 通过网页端订阅（需额外缴税）</h3><p>注意事项：</p><ol><li><p>网页显示的是税前价格，你还需额外缴纳 21% 的税款。</p></li><li><p>Max 的网页会有 Cookies 缓存，假如你之前或是首次打开时，没有使用阿根廷节点，由于 Cookies 已经被记录，网页将不会跳转至更换节点后相应的地区页面。</p></li></ol><p>例如：一开始使用了<code>美国节点</code>打开 <a href="https://www.max.com/ar/es?ref=yummy.best">max.com/ar/es</a> ，发现用错了节点。切换至<code>阿根廷节点</code>后，请<code>清理浏览器缓存</code>，否则网页仍将指向 美国地区的 <a href="http://Max.com">Max.com</a>（手动修改网页后缀也无效）</p><ol start="3"><li>由于阿根廷区页面只能选择西班牙语，因此请搭配浏览器翻译进行订阅。</li></ol><p>1、 连接阿根廷节点，进入阿根廷 <a href="https://www.max.com/ar/es?ref=yummy.best"><strong>Max 订阅界面</strong></a></p><p>2、下滑找到价格表</p><p><img src="https://yummy.best/content/images/2024/11/CleanShot-2024-11-20-at-00.20.00@2x-1.png" alt="img"></p><p><strong>3、 选择 ANUAL（年度），选择 Platino 订阅（4设备同屏、4K）</strong></p><p><em><strong>*Platino*</strong></em> 订阅支持 4 设备同屏，4K UHD 以及双杜比。</p><p><strong>4、 创建/登入已有账户，正确填写信用卡信息付款即可。</strong></p><p>需使用 MasterCard（万事达）或 Amex 进行付款，Visa 无法在网页端支付。</p><hr><h3 id="通过-google-play-订阅-推荐">通过 Google Play 订阅（推荐）</h3><p><img src="/Users/lthero/Library/CloudStorage/OneDrive-%E4%B8%AA%E4%BA%BA/Documents/%E7%AC%94%E8%AE%B0/Hexo%E5%BE%85%E5%8F%91%E5%B8%83/%E5%9B%BE/%E5%BC%80%E9%80%9AHBO-%E9%98%BF%E6%A0%B9%E6%8C%BA%E5%8C%BA.png" alt="开通HBO-阿根挺区"></p><blockquote><p>iOS 用户从 第一步 开始，Android 用户从 第三步 开始</p></blockquote><p>1、在电脑下载安卓模拟器，可以选择 <a href="https://www.yeshen.com/?ref=yummy.best">夜神</a>、<a href="https://www.ldmnq.com/?ref=yummy.best">雷电</a>、<a href="https://www.bluestacks.com/tw/index.html?ref=yummy.best">BlueStacks</a> （推荐）;</p><p>部分模拟器可能没有 GMS 框架，请自行安装！</p><p><strong>2、在模拟器下载并安装</strong> <a href="https://github.com/chen08209/FlClash/blob/main/README_zh_CN.md?ref=yummy.best#download"><strong>FLClash</strong></a> ，连接阿根廷节点</p><p>需代理 Google 以及 Max，不会分流直接开全局模式, 可以上<a href="ipcheck.ing">ipcheck.ing</a> 查看当前ip位置</p><p><strong>3、 登录 Google 账户并从 Google Play 下载 Max App（下载时可以选择较快的节点，记得下完切回去）;</strong></p><p>这里登录的 Google 帐号建议使用<strong>未锁区帐号</strong>（或是全新的Google 账号），否则<strong>可能出现无法选购订阅</strong>（如下图）</p><p><img src="https://yummy.best/content/images/2024/11/CleanShot-2024-11-20-at-01.10.48@2x.png" alt="img"></p><p>简单来说，<strong>你只能使用阿根廷 Google Play 订阅阿根廷 Max</strong></p><p>如果你的 Google 帐号之前开通过 YouTube Premium ，大概率已经锁在了某个区。</p><blockquote><p>有两种处理方案</p></blockquote><p>方案一、希望继续使用主帐号：如果确定已经锁了阿根廷，请检查是否登录了多个 Google 账号，然后退出无关账号重试。未锁区/不确定是否锁区，请先<strong>查看账号锁区情况</strong>，有三种方法</p><ul><li>方式1、前往 <a href="https://policies.google.com/terms?hl=zh-CN&amp;fg=1&amp;ref=yummy.best">Google 服务条款</a> 直接查看归属地.</li><li>方式2、前往 <a href="https://one.google.com/plans?ref=yummy.best">Google One</a> 订阅界面查看，使用不同的节点，显示的价格与货币单位也会发生变化，即为未锁区。</li><li>方式3、前往 <a href="https://play.google.com/settings?ref=yummy.best">Google Play</a> 页面查看，假如当前你正在使用<code>美国</code>节点**，<a href="https://play.google.com/settings?ref=yummy.best">Google Play</a> 网页最下方会显示为**<code>美国</code>，<strong>当你更换</strong><code>阿根廷</code>**节点以后，Google Play 网页最下面的地址显示为<code>阿根廷</code></li></ul><p>如果不是阿根廷地区，可以在 <a href="https://payments.google.com/?ref=yummy.best">Google Payment</a> 中删除所有非阿根廷的付款资料(可能会影响当前的 You Tube Premium 续订/解散家庭组？）</p><p>保留/<a href="https://yummy.best/youtube/#%E5%9B%9B%E3%80%81%E5%A6%82%E4%BD%95%E9%A2%84%E9%98%B2%E6%94%AF%E4%BB%98%E8%A2%AB%E9%A3%8E%E6%8E%A7">新增阿根廷的付款资料</a>，尝试购买一本免费图书锁到阿根廷，返回订阅界面重新尝试。</p><p>方案二、直接使用新 Google 帐号：由于新账号并未进行过购买，因此 Google Play 地区仍可根据 ip 灵活变动。</p><p>直接在 <a href="https://payments.google.com/?ref=yummy.best">Google Payment</a> 添加一个阿根廷的付款资料并尝试购买一本免费图书锁到阿根廷，返回订阅界面重新尝试。</p><p><strong>4、下载完毕后，切换阿根廷节点，并进入 Max App ；</strong></p><p><strong>5、没有阿根廷帐号的话，点击第一个选项，后面的操作无论界面是英语还是西班牙语，均一致；</strong></p><p>有阿根廷帐号可以选择 Sign In，然后点击 Renew 即可续订。</p><p>需要使用当地 ip 创建的 Max 帐号进行订阅，例如：美国 IP 创建的 Max 帐号，无法在阿根廷订阅。</p><img src="https://yummy.best/content/images/2024/11/telegram-cloud-photo-size-5-6192467638622470609-x-1.jpg" alt="Gallery Image" style="zoom:67%;" /><img src="https://yummy.best/content/images/2024/11/telegram-cloud-photo-size-5-6192467638622470617-y.jpg" alt="Gallery Image" style="zoom:67%;" /><p>如果显示点击“subscribe now”显示如下信息，则还是google进行了锁区；</p><p><img src="https://yummy.best/content/images/2024/11/CleanShot-2024-11-20-at-01.10.48@2x.png" alt="img"></p><blockquote><p>如果你上述操作都没问题（哪怕使用了全新的google账号并且填写了阿根挺地区账号）, 这里有种解决方法</p></blockquote><p>使用你的全新的阿根挺google账号，在payment里修改地址位置（在设置时，如果你已经填写了阿区地址，google会给个定位，允许你使用google map进行拖动选点，你只要稍微拖动下即可，随便保存修改的信息），然后重新打开HBO MAX软件进行尝试</p><p><strong>6. 选择 Anual，并选择 US$39.99 的订阅，点击<code>白色按钮</code>继续；</strong></p><p>US$ 39.99 的订阅支持 4 设备同屏，4K UHD 以及双杜比。</p><img src="https://yummy.best/content/images/2024/11/telegram-cloud-photo-size-5-6190293710860830359-y-2.jpg" alt="img" style="zoom:67%;" /><p><strong>7、创建新账号（为了方便阅读，放上英文界面图）；</strong></p><p>如果你已经有阿根廷帐号，不想再创建。可以返回至初始页面，选择 Signin（登入）</p><img src="https://yummy.best/content/images/2024/11/telegram-cloud-photo-size-5-6192467638622470630-y.jpg" alt="img" style="zoom:67%;" /><p><strong>8、添加/选择付款信息 &gt; 验证密码 &gt; 购买成功</strong></p><hr><h4 id="遇到需要确认方案-但是点进去后无法确认方案的"><strong>遇到需要确认方案，但是点进去后无法确认方案的</strong></h4><p>1、请先确认是否登录了多个 Google 账号，退出无关 Google 账号后，仅保留订阅用的 Google 账号，重新尝试确认方案；</p><p>2、其次， 可能<strong>与节点有关系，大概率是近期被太多人使用，尝试更换节点再试；</strong></p><p>3、卸载 Max 并重启手机，重新安装 Max，再次尝试确认方案。</p><p><img src="https://yummy.best/content/images/2024/11/CleanShot-2024-11-20-at-22.09.35@2x.png" alt="img"></p><hr><h4 id="遇到所有银行卡均显示不可用-请检查-google-play-商店所属地是否为阿根廷"><strong>遇到所有银行卡均显示不可用，请检查 Google Play 商店所属地是否为阿根廷</strong></h4><p>必须使用阿根廷 ip 注册的 Max 加阿根廷 Google Play 才可以订阅。</p><p><img src="https://yummy.best/content/images/2024/11/CleanShot-2024-11-20-at-22.11.52@2x.png" alt="img"></p><hr><h3 id="3-通过-appstore-订阅">3️⃣ 通过 AppStore 订阅</h3><p>由于阿根廷地区的 AppStore 没有礼品卡，因此你只能绑定当地发行的银行卡进行购买。</p><p><img src="https://yummy.best/content/images/2024/11/CleanShot-2024-11-20-at-13.30.07@2x.png" alt="img"></p><p><a href="https://support.apple.com/zh-cn/111741?ref=yummy.best">可与 Apple ID 搭配使用的付款方式</a></p><p><strong>1、 连接阿根廷节点，注册一个阿根廷 Apple ID；</strong></p><p><strong>2、 在手机登录 Apple ID 后绑定付款方式；</strong></p><p><strong>3、务必使用使用此 ID 重新下载 Max App，否则无法正常内购；</strong></p><p><strong>4、进入 Max 完成内购。（注册账号请参考</strong><a href="https://yummy.best/hbomax/#%E9%80%9A%E8%BF%87-google-play-%E8%AE%A2%E9%98%85%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"> <strong>Google Play 订阅界面</strong></a><strong>）</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;hbo-max-低价开通&quot;&gt;HBO Max 低价开通&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;本文将讲述如何通过网页、Google Play 和 AppStore 订阅阿根廷的 HBO Max 服务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;亚洲区 Max 已正</summary>
      
    
    
    
    <category term="折腾" scheme="https://blog.lthero.cn/categories/%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="HBO" scheme="https://blog.lthero.cn/tags/HBO/"/>
    
  </entry>
  
  <entry>
    <title>IELTsWriting</title>
    <link href="https://blog.lthero.cn/2025/04/26/IELTsWriting/"/>
    <id>https://blog.lthero.cn/2025/04/26/IELTsWriting/</id>
    <published>2025-04-26T05:23:38.000Z</published>
    <updated>2025-06-27T05:45:24.180Z</updated>
    
    <content type="html"><![CDATA[<h3 id="p18-example-1">P18, Example 1.</h3><p><code>按类别划分</code></p><p>Britain: 在所有商品类别的消费最多，其中photographic film最高</p><p>France, 在3种商品第二高，而另外3种最低</p><p>Italy, 在Toys的消费超过该国其它商品各类，并且和France一样高</p><p>Germany,  在所有商品类别的消费最低，6种商品消费量差不多</p><p>The number of people spent on photographic film in Britain stood at around 170,000, which is <strong>the highest figure shown on the chart</strong>. By contrast, Germans were the lowest overall spenders, with the same figure (just under 150,000) for each of the six products.</p><p><strong>The figures for spending on toys were the same</strong> both in Italy and France, at nearly 160,000 sterling. However, while Frence people <strong>paid out more than Italians for</strong> photographic film and CDs, the latter <strong>spent more on</strong> perfumes, tennis racquets and personal stereos. The amount spent by Frence people on tennis racquets is <strong>the lowest number shown on the chart</strong>, at around 145,000 sterling.</p><ol><li><strong>the highest / lowest figure shown on the chart.</strong></li><li>stood at around xxx</li><li>just around/ under/ above/ over/ nearly/ only</li><li>pay out for xxx ==== spend on xxx</li><li>the number of xxx(doing) ==== the figure for xxx(doing)</li></ol><h3 id="p19-example-2">P19, Example 2.</h3><p><code>按时间节划分</code></p><p>1999年， USA 20%, CAnada 10%, Mexico 5%</p><p>2005年， USA 70%, Canada 70%, Mexico 25%</p><p>2009年， USA 80%, Canada 95%, Mexico 45%</p><p>In 1999, the proportion of people using the Internet in the USA was approximately 20%. The figures in Canada and Mexico were lower, at about 10% and 5% respectively.</p><p>可以使用<code>Saw/Witness</code>，适合用 <code>国家/地区/时间</code> 开头，比如</p><p>Both USA and Canada <strong>saw a rose in 2005</strong> on Internet usage <strong>with around 70%</strong> of the population, whereas the figure for Mexico reached just over 25%.</p><p>或者直接用<code>类别</code>开头</p><p>In 2005, the <strong>Internet usage</strong> in both the USA and Canada <strong>rose to around 70%</strong> of the population, while/ by contrast, the figure for Mexico reached just over 25%.</p><p>In the year 2009, <strong>the percentage of</strong> Internet users was the highest in Canada, at over 95%. <strong>Nearly all Canadians used the Internet</strong>（这是个总结句）, compared to about 80% in the USA and only 45% in Mexico.</p><p>还可以用``the highest figure shown on the chart`，比如</p><p><strong>the percentage of</strong> Internet users in Canada was over 95%, which is the highest figure shown on the chart.</p><p>或使用``reach its highest 再配搭 , at over 95%` 比如</p><p>Internet usage in Canada <strong>reached its highest level in 2009</strong>, at over 95%</p><p>或The usage of Internet in Canada reached its highest level…</p><ol><li>the proportion of xxx ==== the percentage of xxx</li><li>the figure for xxx <strong>reached xxx</strong></li><li>XXX <strong>saw a rose</strong> in 2005 <strong>with arount 60%</strong></li><li>XXX reached <strong>its highest level in 2005</strong>, at over 10%.</li><li>Compare to xxx</li></ol><h1 id="table-chart">Table Chart</h1><h2 id="example-1">Example 1.</h2><h3 id="开头段">开头段</h3><p>（改写题目）</p><p>The table compares(gives the information of) the top five countries(the five hightest ranking countries) in terms of (或仅用for) the figures for visits and the money spent by tourists over a period of two years( between 2013 and 2013).</p><h3 id="概括段">概括段</h3><p>（不出现具体数字，仅描述两个趋势/一个最大和一个最小），比如法国游客人数最多（2012和2013），美国钱最多（over the same period) , 写概括段只能从表中看到数据，然后自己捏句子，谁最欢迎，谁挣得钱最多；谁增长飞快等</p><p>It is noticeable that <strong>France was the world’s most popular tourist country(destination)</strong> in the year 2012 and 2013. By contrast(However), the <strong>USA earned by far the most revenue</strong> from tourism <strong>over the same period.</strong></p><h3 id="描述段">描述段</h3><p>段一：讲游客数量</p><p>先按2012和2013划分，再按从高到低讲游客数量（第一梯队，第二梯队，最后梯队等）</p><p>In 2012, there were 83 million tourists visited France, and the USA was <strong>the second most visited destination(country)</strong>, with 66.7 million visitors. Spain and China <strong>received</strong> just under 58 million tourists, whereas <strong>Italy was ranked fifth, at 46.4 million visitors.</strong> 2013 saw a increase of between 1 and 4 million tourists   on each country, with the exception of China, which received a 2 million fewer visitors than <strong>in the previous year.</strong></p><ol><li>Italy <strong>was ranked fifth</strong>, at 46.4 million visitors 和 the five hightest ranking countries，利用rank这个词</li><li>2013 <strong>saw a increase of between 1 and 4 million</strong>， 时间作主语，描述趋势</li><li>in the previous year 前一年</li></ol><p>段二：讲游客花费</p><p>先按2012和2013划分，后续和段一差不多</p><p>People visited the USA spent more in 2013 than 2012 with 139.6 billion and 126.2 billion respectively.</p><p>The figures for spending by visitors in the USA increased from 126.2 billion in 2012 to 139.6 billion in 2013, and which were <strong>well over</strong>(more than) <strong>twice as high as</strong> those for any other country.</p><blockquote><p>When you add a multiplier like&quot;twice,&quot; on “as high as”, it specifies that <strong>the first thing is exactly (or more than) double the second thing.</strong></p></blockquote><p>Spain received <strong>the second highest amounts of</strong> tourists spending(revenue), rising from 56.3 billion to 60.4 billion, followed by France, China and Italy. Interestingly, despite falling numbers of tourists, the number of revenue in China <strong>rose by 1.7 billion in 2013.</strong></p><ol><li>followed by France, China and Italy 表示France, China Italy在Spain后面，这句可以使用respectively句型接具体数字。</li><li><strong>rose by</strong> 表示增加了1.7 billion，通过两个数字减出来的</li><li>despite <strong>falling numbers</strong> of tourists， 中国的游客数量少了，但花销更高了</li><li>the second highest amounts of / the second most visited destination / the widely spoen second language. 表示第二</li></ol><h2 id="c12-test-5-part-1">C12 Test 5-Part 1</h2><p>*<strong>The bar chart below shows the percentage of Australian men and women in different age groups who did regular physical activity in 2010.*</strong></p><p>*<strong>Summarise the information by selecting and reporting the main features, and make comparisons where relevant*</strong></p><p>Write at least 150 words.</p><p>![image-20250612200421842](/Users/lthero/Library/Application Support/typora-user-images/image-20250612200421842.png)</p><p>The bar chart compares the proportion of Australian men and women, categorized into six age groups, who participated in periodic physical activity during 2010.</p><p>Overall, a clear gender disparity is evident, with female participation rates exceeding those of males across almost all age groups. Furthermore, the two genders display contrasting trends over their lifespan: male activity levels formed a U-shaped curve, whereas female participation peaked in middle age before declining.</p><p>Focusing on the males, the highest engagement was recorded among the youngest group (15-24) at 52.8%. <strong>Following this peak</strong>, there was a significant and <strong>steady deterioration</strong> in <strong>activity levels</strong>, which <strong>fell to 42.2%</strong> for the 25-34 age group and subsequently <strong>bottomed out at 39.5% for men aged 35-44</strong>. From this trough, a gradual recovery is observed in the older demographics, with the rate climbing to 46.7% for those aged 65 and over.</p><p>In stark contrast, Australian women <strong>consistently showed higher engagement</strong> from the age of 25 onwards. Their participation rate began at 47.7% for the 15-24 bracket and steadily climbed to a zenith of 53.3% in the 45-54 age group. Thereafter, the figure for women <strong>experienced</strong> a <strong>modest</strong> decline. Notably, the gap in activity between the genders narrowed with age, with the figures converging towards parity in the eldest group (47.1% for women versus 46.7% for men).</p><ul><li>the figure for women <strong>experienced</strong> a <strong>modest</strong> decline. (不一定一直使用see/witness)</li><li>of six age groups/ categorized into six age groups</li></ul><h2 id="p53练习2">P53练习2</h2><p>The first chart below gives information about the money spent by British parents on their children’s sports between 2008 and 2014. The second chart shows the number of children who participated in three sports in Britain over the same time period.</p><p>![image-20250613142305326](/Users/lthero/Library/Application Support/typora-user-images/image-20250613142305326.png)</p><p>开关</p><p>The line graphs show the average amount of money that parents in Birtain spent on their children’s sporting activities per month and the figure for British children who were enrolled in three different sports from 2008 to 2014.</p><p>The line graphs show the average monthly expenditure spent by parents in Birtain on their children’s sporting activities and the number of children in Britain participating three different sporting activities between 2008 and 2014.</p><p>The line graphs show the mean amount of money that British parents spent on their children’s sporting activities every month and the figure for British children who took part in three different sport activities in a period of six years.</p><p>概括</p><p>It is clear that British parents spent more money each year on their children’s participation in sports throughout the period shown. In terms of the figure for children taking part, football was by far the most popular activity , significantly more welcomed by children than athletics and swimming.</p><p>描述</p><p>In 2008, British parents spent an average amount of around 20 pounds every month on their children’s sports. Over the following six years, parents’ spending on children’s sporting activities increased steadly, and by 2014 the average monthly amount had risen to just over 30 pounds.</p><p>In 2008, British parents spent an average monthly amount of around 20 pounds on their children’s sporting activities. Parents’ expenditure on children’s sport increased steadly over the following six years, and by 2014 the figure for average monthly amount of spending had risen to just over 30 pounds.</p><p>描述</p><p>Looking at the participation numbers, in 2008, children enrolled in football account for nearly 8 million, which is nearly four times as high as the figure for those taking part in swimming, and less than 1 million participated athietics. The figure for football participation remained relatively stable over the following six years. By contrast, participation in swimming almost doubled, to nearly 4 million children in the year 2014, and there was a dramatic increase in the number of children doing athietics.</p><p>Looking at the participation numbers, in 2008 approximately 8 million British children were enrolled in football, while only 2 million children taking part in swimming course and less than one million participated athletics. The figure for football participation remained relatively stable around 8 to 9 million over the following years. By contrast, participation in swimming almost doubled, to nearly 4 million children in 2014, and there was a nearly fivefold increase in the figure for children doing athletics.</p><p>这是的第二个图，先写2008的三个数据点，再写一个趋势（可以是football的reamin stable，也可以是swimming doubled），最后写在2014的三个数据点</p><p>比如2008年的三个点</p><ol><li>8 million children played football.<ol><li>扩展： nearly/approximately 8 million British children were enrolled in football.</li></ol></li><li>2 million children played swimming.<ol><li>扩展： only 2 million children signed up for/took part in swimming clubs.</li></ol></li><li>1 million children played athletics.<ol><li>扩展： less than one million participated athletics.(前面已经提到两次children了，这次直接省略)</li></ol></li></ol><p>P53练习2</p><ul><li>there was a dramatic/fivefold increase in the number of xxx  [在xx方面有几倍的增长]</li><li>over the following xx years [在随后的几年内]</li><li>Participation in xx = xx participation [参与xx活动]</li><li>the figure for xx remained relatively stable [xx的数据保持稳定]</li><li>rising steadily between xx and xx [在xx到xx期间稳定增加]</li><li>be enrolled in/taking part/doing/took part in/played/practised/ 都可以表示参加</li></ul><h2 id="p56-练习3">P56 练习3</h2><p>the chart below shows the value of one countries exports in various categories during 2015 and 2016.the table shows the percentage change in each category of exports in 2016 compared with 2015.</p><p>![image-20250615133439307](/Users/lthero/Library/Application Support/typora-user-images/image-20250615133439307.png)</p><p>The bar chart and table compare a country’s exporting revenue on five different group of products in the year 2015 and 2016.</p><p>It is clear that all products, with the exception of germs and jewllery, experienced growth in their export proportion, and textiles had the most significant growth in earnings. Furthermore, petroleum industry had by far the highest earning products in both years.</p><p>Export earnings from petroleum products rose from 61 billion in 2015 to 63 billion in 2016, with an increase of 3%. Revenue from engineered goods had a similar trend, witnessing a marked growth of 8.5% in 2016, stood at around 60 billion.</p><p>With regarding to other categories, between 2015 and 2016, there was a significant growth in export revenue from textiles industry of 15.24%, with earnings rising from 35 billion to over 40 billion. By contrast, <strong>there was no significant change</strong> in the amount of money earned from agricultural industry, which remained stable around 40 billion in both year. Finally, the export earning from gems and jewellery industry dropped by 5.18% during the same period, with revenue falling to around 50 billion.</p><p>Regarding the remaining categories, gems and jewellery, agricultural products, and textiles recorded lower earnings in 2015, roughly 53 billion, 40 billion and 35 billion respectively. Textiles showed the most significant proportion increase at 15.24, reaching to nearly 40 billion in 2016. Agricultural industry remained relatively stable, <strong>with no significant change</strong> in value around 40 billion, while gems and jewellery dropped by 5.18%, falling to approximately 50 billion.</p><h3 id="素材">素材</h3><p>P56 练习3</p><ul><li><p>with no significant change xx/there was almost no change in xx/</p></li><li><p>xx(earnings from xx) dropped by xx, falling to around xx</p></li><li><p>Earnings from/revenue from /the amount of money earned from xx</p></li><li><p>Rose/had rosen/increase/growth</p></li><li><p>Decline/falling to/dropped by/down to</p></li><li><p>Nearly/approximately/around/close to/roughly/</p></li></ul><h2 id="part1-c14test1">Part1 C14Test1</h2><p>The charts below show the average percentages in typical meals of three types of nutrients, all of which may be unhealthy if eaten too much.</p><p>*Summarise the information by selecting and reporting the main features, and make comparisons where relevant.*</p><p>Write at least 150 words.</p><p>![image-20250615161302360](/Users/lthero/Library/Application Support/typora-user-images/image-20250615161302360.png)</p><p>The pie chart illustrates the average proportions of three categories of nutrients added to daily meals consumed by people in America, which can be harmful if consumed in excess.</p><p>It is clear that the percentages for saturated fat and sodium contained in dinner account for the highest percentages among all meals, while the figures for all nutrients during breakfast are the lowest.</p><p>Dinner contains over three times as much sodium as breakfast, standing at 43%,compared to breakfast’s 14%. A similar pattern was observed in the case of saturated fat. The sodium content in lunch exceeds that in snacks and breakfast combined, at 29%.</p><p>With regard to the other nutrients, added sugar in snacks makes up 42%, while the figures for breakfast, lunch, and dinner~~,~~ are only 16%, 19% and 23% respectively. Finally, saturated fat is distributed relatively evenly across the four daily meals, with ~~37% in ~~dinner containing the highest percentage at 37%.</p><h2 id="part1-c15test1">Part1 C15Test1</h2><p>The chart below shows the results of a survey about people’s coffee and tea buying and drinking habits in five Australian cities. Summarise the information by selecting and reporting the main features, and make comparisons where relevant.</p><p>![image-20250615170747157](/Users/lthero/Library/Application Support/typora-user-images/image-20250615170747157.png)</p><p>7分</p><p>The bar chart compares the analysis of a survey conducted among residents of five Australian cities in terms of their coffee and tea comsumption hobbies.</p><p>It is clear that the vast majority of residents visited cafes for coffee or tea in last four weeks across all cities. By contrast, there was no significant difference in the percentage of those who chose to buy instant coffee over the same period.</p><p>Looking first at the metropolitan areas, people living in Melbourne prefer going to cafe for coffee or tea, standing at nearly 64% of the total. In comparison, only 42% of Melburnians prefer buying fresh coffee, while Sydney residents have a slightly higher preference at 44%.</p><p>With regard to other cities, it is noticable that Hobart has the second-highest percentage of residents who enjoy going to stores for coffee or tea, at approximately 63%. There is no t a clear difference between the figures for people living in Adelaide who prefer buying instant coffee versus those who prefer going out for a drink, both of which are around 50%. Finally, only less than 35% of residents in Brisbane and Adelaide purchased fresh coffee during last four weeks.</p><p>9分</p><p>The bar chart illustrates the findings of a survey concerning the coffee and tea consumption habits of residents in five Australian cities: Sydney, Melbourne, Brisbane, Adelaide, and Hobart.</p><p><strong>Overall, the data indicates a clear preference for instant coffee and café visits, while fresh coffee purchases remain comparatively low across all surveyed cities.</strong>  （保持上面7分其它不变，只把这个概括段替换，就能加0.5分）</p><p>In Melbourne and Hobart, the preference for instant coffee is particularly pronounced, with approximately 60% of respondents indicating they purchased instant coffee within the last four weeks. Conversely, fresh coffee purchases are markedly less popular, with only 42% of Melburnians and just 25% of Adelaide residents opting for this choice. Sydney exhibits a similar trend, as 44% of its inhabitants reported buying fresh coffee, but still lagging behind the popularity of instant coffee. <strong>（保持上面7分其它不变，只把这个描述段替换，就能加1分）</strong></p><p>Examining café visits, Sydney and Brisbane reveal significant engagement, with 50% and 55% of their respective populations frequenting cafés for coffee or tea in the same timeframe. Hobart follows closely with around 63%, indicating a robust café culture. Interestingly, Adelaide presents a unique scenario where the tendencies to purchase instant coffee and to visit cafés approximate 50%, highlighting a balanced consumer preference in that city. Overall, fresh coffee emerges as the least favored option across all regions surveyed.</p><h2 id="part1-c15test2">Part1 C15Test2</h2><p>The graph below shows the number of tourists visiting a particular Caribbean island between 2010 and 2017.</p><p>![image-20250616235309231](/Users/lthero/Library/Application Support/typora-user-images/image-20250616235309231.png)</p><p>7分</p><p>This line chart illustrates the figures for visitors to a Caribbean island over a period of eight years.</p><p>It is evident that there was a clear preference for people visiting the Caribbean island between 2010 and 2017, while the figure for people choosing to stay on the island remained relatively stable.</p><p>In 2010, approximately one million tourists visited the island, with merely 0.25 million of them opting to stay on cruise ships. Over the following six years, the figure for those visiting on cruise ships increased considerably, reaching nearly 1.5 million in 2016. By contrast, there was no significant difference in the number of travelers staying on the island during the same period, which stayed around 1.2 million to 1.5 million per year.</p><p>Between 2016 and 2017, the total number of visitors increased dramatically, more than threefold, reaching 3.5 million. During this time, visitors staying on cruise ships made a greater contribution than tourists staying on the island, with 2 million and 1.5 million respectively.</p><p>9分</p><p>The line graph presented delineates the influx of tourists to a Caribbean island from 2010 to 2017, disaggregated by the type of accommodation chosen.</p><p>Overall, there is a notable upward trajectory in the number of visitors across all categories, with those opting to stay on the island consistently outnumbering cruise ship visitors throughout the period under review.</p><p>In 2010, the total number of tourists reached approximately 1 million, comprised of around 0.25 million visitors on cruise ships and around 0.75 million choosing to stay on the island. <strong>The trend over the subsequent years reveals a significant increase in tourist numbers</strong>, with visitors staying on cruise ships experiencing a robust rise. By 2017, numbers for cruise ship visitors had surged to about 1.25 million, while those staying on the island escalated to approximately 2.75 million, reflecting substantial growth in both categories.</p><p>The overall total of visitors to the Caribbean island reached 4 million by 2017, marking a marked increase from previous years. Specifically, the number of tourists on cruise ships and those staying on the island demonstrated a coordinated growth trend. The figure for visitors residing on the island consistently constituted the majority, revealing a sustained preference among tourists for land-based accommodation over the cruise option. This trend underscores the island’s appeal as a desirable destination for extended stays.</p><p>素材</p><ul><li>there was a clear/notable preference for xxx between xx and xx</li><li>Opt to do sth/choosing to do sth.</li><li>there was no significant difference in xxx</li><li>there was a notable/clear upward trajectory in xxx</li><li>The trend over the subsequent(following) years reveals a significant increase in xx number.</li><li>a robust rise (强力提升)</li></ul><h2 id="素材">素材</h2><h4 id="开头">开头</h4><ul><li><strong>单一图表</strong><ul><li>The provided line graph illustrates/depicts/shows the changes in [topic] in [place] over a period of [X] years, from [year] to [year].</li><li>The bar chart compares the [data being compared] across several [categories] in the year [year].</li><li>The pie chart gives information about the proportion of [what is being shown] in [place/context].</li><li>The table provides a breakdown of statistics regarding [topic].</li></ul></li><li><strong>多个图表</strong><ul><li>The two pie charts illustrate the differences in [topic] between the years [year 1] and [year 2].</li><li>The line graph shows [what the line graph shows], while the bar chart reveals [what the bar chart shows].</li></ul></li></ul><h3 id="none"></h3><h4 id="概括-总结句式-overall-conclusion">概括/总结句式 (Overall/Conclusion)</h4><p>用于在开头段之后或结尾段，总结图表最核心、最显著的特征。</p><ul><li>总体趋势<ul><li>Overall, what stands out from the graph is that there was a clear upward/downward trend in [topic] over the period.</li><li>In general, it is evident that [A] experienced a significant increase, whereas [B] saw a steady decline.</li></ul></li><li>最值/最突出特点<ul><li>It is immediately apparent that [category] was the most popular/significant [item] throughout the entire period.</li><li><strong>Another noticeable feature</strong> is that [A] reached its peak in [year], while [B] hit a low point.</li><li></li></ul></li></ul><p>几种固定句式</p><ol><li>N% of 群体/物体 had</li></ol><p>增涨句式</p><ol><li>There was a marked/significant/dramatic/ increase[替换其它涨词] in (the amount of money earned from/ spent by xxx) [主句]</li><li>There was a <strong>fivefold increase</strong> in the number of xxx  [主句，在xx方面有几倍的增长]</li><li>the production <strong>increased more than eightfold</strong> [主句，xx增涨了8倍]</li><li>the oil price had (more than) <strong>doubled/quadrupled</strong> [主句，已经翻2/4倍了]</li><li>物体 experienced/showed a significant an increase of 20% (增长了20%)。 [主句], reaching N[数字] in 2020. [分句，这里不加to]</li><li>The figure for 物体 rose steadily from N in 2020 to N’ in 2021. [主句]</li><li><strong>rising steadily</strong> between xx and xx [在xx到xx期间稳定增加] / before rising steadily [作为<strong>分句</strong>式，主句通常表示稳定一段期间]</li><li>Starting at N in [年份], the figure rose steadily to M in [年份]. [主句]</li><li>the oil price <strong>went up once again</strong> [主句]</li></ol><p>下降句式</p><ol><li>xx(earnings from xx) <strong>dropped by</strong> 50 million(50%, half) / <strong>dropped from xx to</strong> xx [主句]</li><li>xx <strong>fell from 20% in 2019 to</strong> 12% in 2020. [主句]</li><li>xx <strong>rose to</strong> 20% in 2019 but <strong>fell again to</strong> 12% in 2020. [主句，先上升再下降]</li><li>the oil price <strong>had halved</strong> [主句, 半价]</li><li>the oil price <strong>had dropped by(fell to) half</strong> [主句, 半价]</li><li>Decline/falling to/dropped by/down to [作为<strong>分句</strong>]</li><li>the sales of [A] hit a low/bottomed out at just under N in [year]</li><li>After peaking at [N], the number of [A] started to decline. [主句] (在达到顶峰后开始下降)</li></ol><p>稳定句式</p><ol><li><p>the figure for xx <strong>remained relatively stable</strong> [主句，xx的数据保持稳定]</p></li><li><p>spending by American <strong>increased</strong> dramatically/slightly [主句]</p></li><li><p>daily spending <strong>had risen to</strong> around $200 in the year 2020 [主句]</p></li><li><p>The daily expenditure <strong>fluctuated</strong> around $200 / <strong>many fluctuations can be seen</strong> during… [主句]</p></li><li><p>The daily expenditure saw/witnessed significant fluctuations.</p></li><li><p>there <strong>was almost no change</strong> in the daily spending in the year 2020 [主句]</p></li><li><p><strong>with no significant change</strong> in the daily spending [作为<strong>分句</strong>]</p></li></ol><p>描述数字</p><ol><li>Earnings from/revenue from /the amount of money earned from xx [主句]</li><li>主体 spent/employed/recycled 69% of xxx [主句]</li><li>reaching its peak of $100 [作为分句]</li><li>to nearly $100 (单位) [作为分句]</li><li>stood at nearly $100 [作为分句]</li></ol><p>衔接句式</p><ol><li>over the following xx years</li><li>Overall / By contrast /Furthermore /</li><li>We can also see that</li><li>Looking (first) at xxx number(participation numbers)/ the older age group</li><li>In each of the years shown on the chart</li><li>Throughout the 8-year period shown / throughout the period shown</li><li>With the regard to other xxx/ Regrading other xxx</li><li>Over the following five/six years / over the 8-year period (shown),</li></ol><p>自我翻倍</p><ol><li>Increased X-fold / Become X times as much</li><li>Doubled/quadrupled/常见只用doubled，其它的多数用increased X-fold</li></ol><p>倍数关系</p><ol><li>The number of [A] was three times higher than that of [B] (A是B的三倍)</li><li>The number of [A] was three times/twice as high as that of [B] (A是B的三倍)</li><li>[A] spent twice as much money on [X] as on [Y] (A在X上花的钱是Y的2倍)</li></ol><p>趋势相似与不同</p><ol><li><p><strong>a similar pattern was observed</strong> in the case of [B].   [主句] (B也呈现了相似的模式)</p></li><li><p>In contrast, the figure for [B] <strong>showed an opposite trend</strong>.  [主句] (B的数据呈现了相反趋势)</p></li><li><p>[A] and [B] <strong>followed a noticeably different trajectory</strong> over the period. (A和B的轨迹截然不同)</p></li><li><p>the <strong>trends for</strong> both commodity <strong>were noticeably different</strong> from each other/those described above [主句，表示不同]</p></li><li><p>the <strong>trends for</strong> both commodity <strong>were very similar</strong> [主句，表示相同]</p></li><li><p>the <strong>trend reversed itself</strong></p></li><li><p>The <strong>trend</strong> [over the subsequent(following) years] reveals/indicates/shows a significant increase(decrease) in tourist numbers</p></li></ol><p>排名</p><ol><li>[A] accounted for <strong>the largest proportion of the total</strong>, with N% [主句]</li><li>[A] <strong>was followed by</strong> [B] and [C], at N% and M% respectively. [主句]</li><li><strong>The figure for</strong> [A], [B], and [C] were N, M, and P, respectively. [主句]</li></ol><p>描述占比</p><ol><li>[A] made up/accounted for/constituted/comprised nearly 60% of the total.</li><li>A small <strong>fraction</strong> (5%) of resondents indicated/showed/illustrated that</li><li>The vast majority of [A], over 80%, prefered [B].  [主句]</li></ol><p>描述未来</p><ol><li>The number of [A] is projected/forecast/predicted to rise to N by [future year]</li><li>It is anticipated that this trend will continue in the coming years.</li><li>Looking ahead, [A] is expected to overtake [B] as the leading category. [A有希望超过B, 成为领先类别]</li></ol><p>常见同义词</p><ol><li>Spending, expenditure, the amount of money that xx spent, paid out</li><li>revenue, earnings, the amount of money earned, Sales</li><li>Category, group, type</li><li>Company, industry, manufacturers, brand, firm, producer,</li><li>the average amount of money, an average of $200 on</li><li>Annually, average yearly, per year, monthly, per month, weekly, per week, daily, every day, per day</li><li>Feedback, response,</li><li>trend, fluctuation, movement, variation, shift</li><li>proportion, percentage, share, fraction</li><li>Illustrate,  depict, reveal, indicate, represent</li><li>the level of , the rate of, the amount of, the quantity of,</li><li>surge, increase, go up, rise(rose, risen),</li><li>Decline, down to, dropped to , fell to,</li></ol><p>副词</p><ol><li>Nearly/approximately/around/close to/roughly/only</li><li>Respectively</li><li>significantly/slightly/considerably/noticeably</li></ol><p>形容词</p><ol><li>Vast/sifnificant/clear/excellent/</li></ol><p>最高级</p><ol><li>the five most popular</li><li>the vast majority of xxx 谓语 xxx</li><li></li></ol><p>比较级</p><ol><li>two times as high as …</li></ol><h1 id="大作文">大作文</h1><h2 id="观点类">观点类</h2><h3 id="p119">P119</h3><p>Some people believe that nowadays we have too many choices. To what extent do you agree or disagree with this statement.</p><p>开头段</p><p>It is often said that modern life presents us an overwhelming number of choices.</p><p>[由<code>modern life give us more choices</code>扩展]</p><p>I completely agree with this, and I believe that the Internet and globalisation are the two main (major) factors involved.</p><p>[先<strong>一边倒地认同</strong>, 再说原因：Internet&amp;Globalisation are the major factors.]</p><p>主体段一：<strong>网络让人有更多选择</strong></p><p>It is undeniable that the Internet has led to a dramatic expansion in the number of choices that are available to us.</p><p>[同样，主体段一内先说state: <strong>Internet led to expansion in the number of choices.</strong></p><p>再扩展，比如添加形容词dramatic/添加从句that are available to us.]</p><p>For instance, the number of online media options is now almost endless. There are countless websites offering entertainment, news, videos, on-demand TV and music streaming, many of which are free.</p><p>[解释1，同样先说state: <strong>online media options is endless</strong>，然后举例各种实例entertainment, news, videos, on-demand TV and music streaming, 最后再使用个从句 many of which are free.]</p><p>I would argue that this abundance of media leads to confusion on the part of the average user, as we have to make so many decisions about the content that we consume.</p><p>[结果1, 同样先说state: <strong>media leads to confusion on people.</strong> 再说原因 as we have to make decisions on xxx]</p><p>主体段二：<strong>全球化导致人有更多选择</strong></p><p>Alongside the influence of the Internet, globalisation is making the world smaller and compounding this problem of too much choice.</p><p>[除了网络Alongside the Internet,</p><p><strong>State</strong>: 全球化让世界更小，加剧|造成了问题<strong>globalisation makes the world smaller and compound the problem</strong></p><p>太多选择是一种问题：problem of too much choice]</p><p>compound v.复合，加剧，造成</p><p>Cheap international flights have made overseas travel possible for millions of people, but this also means that we are faced with a world of options when deciding where to go on holiday or even where to live.</p><p>[从留学和旅行两个角度补充]</p><p>[旅行：廉价跨国飞行/机票让出国旅行成为可能<strong>cheap international flights makes overseas travel possible</strong></p><p><strong>but this also means 过渡句子</strong></p><p>面对太多选择，无法决定假期去哪儿，或者去哪儿生活<strong>where to go on holiday or where to live.</strong>]</p><p>We no longer <strong>have the limited but simple travel choices</strong> of our grandparents’ generation.</p><p>[旅行角度的解释]</p><p>The same is true if we look at the increasing tendency for young people to study abroad.</p><p>[留学角度：the increasing tendency of study abroad扩展成的一句话,添加主语for young people]</p><p>While the opportunity for overseas study seems appealing, many students are confused about where to go and which path to take</p><p>[留学的解释：people are confused about <strong>where to go and which path to take</strong>]</p><p>总结</p><p>In conclusion, we are faced with a huge number of options in most areas of life nowadays, and this is often more bewildering than beneficial.</p><p>[总结就是改写标题+重申观点：我同意选择太多了]</p><p>It is often said that modern life presents us with an overwhilming number of choi</p><p>It if often said that modern life presents us with an overwhelming number of choices. I completely agree with this, and I believe that the Internet and globalisation are the two major factors involved.</p><p>It is often said that modern life presents us with an overwhelming number of choices, I completely agree with that, and I believe that the Internet and globalisation are the two major factors involved.</p><p>On the one hand, It is undeniable that the Interned has led to a dramatic expansion in the number of choices that are available to us. The number of online media options, for instance, is now almost endless. There are countless websites offering entertainment, news, videos, music and live streaming, many of which are free. I would argue that this abundance of media leads to confusion on average users, as we have to make so many decisions about the content that we consume. A prime example of this trend would be the fact that people had only a few choices of TV channels when they were young, whereas they now have access to thousands of films and series through services like Netflix.</p><p>On the other hand, alongside the influence of the Internet, globalisation is making the world smaller and compounding this problem of too much choice. Cheat international flights have made overseas travel possible for millions of people, but this also means that we are faced with a world of options when deciding where to go on holiday and even where to live. We no longer have the limited but simple travel choices of our grandparents’s generation. The same is true if we look at the increasing tendency for young people to study abroad. While the opportunity for overseas study seems appealing, many students are confused about where to go and which path to take.</p><p>In conclusion, we are faced with a huge number of options in most areas of life nowadays.</p><p>It is often said that modern life presents us an overwhelming number of choices. I completely agree with this, and I believe that the Internet and globalisation are the two major factors involved.</p><p>On the one hand, it is undeniable that the Interned has led to a dramatic expansion in number of choices that are available to us. The number of online meadia options, for example, is now almost endless. There are countless weebsites offering entertainment, news, videos, music and live streaming, many of which are free. I would agree that this amount of media leads to confusion on the part of people, as we have to make so many decisions on the content that we consume. A prime example of this trend would be the fact that people had only a few choice of TV channels when they were young, whhile they now have access to thousands of films and TV series throught services such as Netflix.</p><p>On the other hand, alongside the influence of the Internet, globalisation is making the world smaller and compunding the problem of too much choice. Cheap international flights made overseas travel possible for millions of average people, but this also means that we are faced a with a world of options when we decide where to go on holiday and even where to live. We no longer have the limited but simple travel option of our grandparents’ generation. The same is true if we look at the increasing tendency for young people to study abroad. While the opportunity for overseas study seems appealing, many students are confused about where to go and which path to choice.</p><p>On the other hand, alongside the influence of the Internet, career options is making the world more complex and compunding the problem of too much choice. Emergency of AI opened up a new employment field for many workers, but this also means that we are faced with a huge number of specific and new fields when deciding which path to take. We no longer have the limited but simple career options of our grandparents’ generation. The same is true if we look at the increasing tendency for</p><p>On the one hand, it is undeniable that the Internet has led to a dramatic expansion in the number of choices that are available for us. The number of online media options, for instance, is now almost countless. There are endless websites offering entertainment, news, videos, music and live streaming, most of which are free. I would argue that this abundance of media leads to confusion on the part of average people, as we have to make so many decisions about the content we consume. A prime example of this trend would be the fact that people had only a few TV channels when they were young, while they have access to thousands of films and TV series throught streaming platforms like Netflix.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;p18-example-1&quot;&gt;P18, Example 1.&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;按类别划分&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Britain: 在所有商品类别的消费最多，其中photographic film最高&lt;/p&gt;
&lt;p&gt;France, 在3种商品第二高</summary>
      
    
    
    
    <category term="IELTs" scheme="https://blog.lthero.cn/categories/IELTs/"/>
    
    
    <category term="IELTs" scheme="https://blog.lthero.cn/tags/IELTs/"/>
    
  </entry>
  
  <entry>
    <title>在ComfyUI发布节点</title>
    <link href="https://blog.lthero.cn/2025/04/24/ReleaseNodesForComfyui/"/>
    <id>https://blog.lthero.cn/2025/04/24/ReleaseNodesForComfyui/</id>
    <published>2025-04-24T14:31:31.000Z</published>
    <updated>2025-06-24T14:32:36.450Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在comfyui发布节点">在ComfyUI发布节点</h1><h2 id="创建一个comfyui-registry账号">创建一个ComfyUI-registry账号</h2><p>在 <a href="https://registry.comfy.org/">Comfy Registry</a> 注册账号</p><h3 id="创建一个publisher">创建一个Publisher</h3><p>「Publisher」是创建自定义节点的ID标识，一旦创建后不可以被修改</p><p><img src="https://mintlify.s3.us-west-1.amazonaws.com/dripart/images/publisherid.png" alt="Hero Dark"></p><h3 id="创建一个api-key">创建一个API Key</h3><p><a href="https://registry.comfy.org/nodes">链接</a>，后续使用CLI工具上传文件需要用上</p><p><img src="https://mintlify.s3.us-west-1.amazonaws.com/dripart/images/pat-1.png" alt="Create key for Specific Publisher"></p><p>将APIKey保存好，它只显示一次</p><p><img src="https://mintlify.s3.us-west-1.amazonaws.com/dripart/images/pat-2.png" alt="Create API Key"></p><h3 id="在节点文件中添加meta信息">在节点文件中添加Meta信息</h3><p>先安装comfy-cli</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install comfy-cli</span><br></pre></td></tr></table></figure><p>再进行初始化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">comfy node init</span><br></pre></td></tr></table></figure><p>这行代码会在节点项目中生成<code>pyproject.toml</code></p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pyproject.toml</span></span><br><span class="line"><span class="section">[project]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;&quot;</span> <span class="comment"># Unique identifier for your node. Immutable after creation.</span></span><br><span class="line"><span class="attr">description</span> = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;1.0.0&quot;</span> <span class="comment"># Custom Node version. Must be semantically versioned.</span></span><br><span class="line"><span class="attr">license</span> = &#123; file = <span class="string">&quot;LICENSE.txt&quot;</span> &#125;</span><br><span class="line"><span class="attr">dependencies</span>  = [] <span class="comment"># Filled in from requirements.txt</span></span><br><span class="line"></span><br><span class="line"><span class="section">[project.urls]</span></span><br><span class="line"><span class="attr">Repository</span> = <span class="string">&quot;https://github.com/...&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[tool.comfy]</span></span><br><span class="line"><span class="attr">PublisherId</span> = <span class="string">&quot;&quot;</span> <span class="comment"># TODO (fill in Publisher ID from Comfy Registry Website).</span></span><br><span class="line"><span class="attr">DisplayName</span> = <span class="string">&quot;&quot;</span> <span class="comment"># Display name for the Custom Node. Can be changed later.</span></span><br><span class="line"><span class="attr">Icon</span> = <span class="string">&quot;https://example.com/icon.png&quot;</span> <span class="comment"># SVG, PNG, JPG or GIF (MAX. 800x400px)</span></span><br></pre></td></tr></table></figure><p>查看pyproject.toml的更多信息：<a href="https://docs.comfy.org/registry/specifications">链接</a></p><h2 id="公开到comfy-registry">公开到Comfy-Registry</h2><h3 id="方式一-comfy-cli">方式一: Comfy CLI</h3><p><strong>每次手动</strong>运行下方的代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">comfy node publish</span><br></pre></td></tr></table></figure><p>随后被要求输入API Key</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">API Key <span class="keyword">for</span> publisher <span class="string">&#x27;&lt;publisher id&gt;&#x27;</span>: ****************************************************</span><br><span class="line"></span><br><span class="line">...Version 1.0.0 Published. </span><br><span class="line">See it here: https://registry.comfy.org/publisherId/your-node</span><br></pre></td></tr></table></figure><h3 id="方式二-github-actions">方式二: Github Actions</h3><p>每次自动更新到comfy-registry，这需要用到GitHub Actions</p><h4 id="创建一个github-secret">创建一个Github Secret</h4><p>找到 Settings -&gt; Secrets and Variables -&gt; Actions -&gt; Under Secrets Tab and Repository secrets -&gt; New Repository Secret.</p><p>名字(name)： <code>REGISTRY_ACCESS_TOKEN</code></p><p>值(value)：``API key`（在Comfy-registry创建的)</p><h4 id="创建一个github-action">创建一个Github Action</h4><p>将下面的代码复制到项目的： <code>/.github/workflows/publish_action.yml</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">name: Publish to Comfy registry</span><br><span class="line">on:</span><br><span class="line">  workflow_dispatch:</span><br><span class="line">  push:</span><br><span class="line">    branches:</span><br><span class="line">      - main</span><br><span class="line">    paths:</span><br><span class="line">      - <span class="string">&quot;pyproject.toml&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">jobs</span>:</span><br><span class="line">  publish-node:</span><br><span class="line">    name: Publish Custom Node to registry</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    steps:</span><br><span class="line">      - name: Check out code</span><br><span class="line">        uses: actions/checkout@v4</span><br><span class="line">      - name: Publish Custom Node</span><br><span class="line">        uses: Comfy-Org/publish-node-action@main</span><br><span class="line">        with:</span><br><span class="line">          personal_access_token: <span class="variable">$&#123;&#123; secrets.REGISTRY_ACCESS_TOKEN &#125;</span>&#125; <span class="comment">## Add your own personal access token to your Github Repository secrets and reference it here.</span></span><br></pre></td></tr></table></figure><p>如果你的项目拥有除<code>main</code>外的其它分支，如<code>master</code>，也需要将它添加到<code>publish_action.yml</code>的<strong>branches</strong>中</p><h4 id="测试github-action">测试Github Action</h4><p>更新<code>pyproject.toml</code>的版本号，检查是否已经推着到comfy-registry成功</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;在comfyui发布节点&quot;&gt;在ComfyUI发布节点&lt;/h1&gt;
&lt;h2 id=&quot;创建一个comfyui-registry账号&quot;&gt;创建一个ComfyUI-registry账号&lt;/h2&gt;
&lt;p&gt;在 &lt;a href=&quot;https://registry.comfy.org</summary>
      
    
    
    
    <category term="折腾" scheme="https://blog.lthero.cn/categories/%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="ComfyUI" scheme="https://blog.lthero.cn/tags/ComfyUI/"/>
    
  </entry>
  
  <entry>
    <title>开通土耳其区Prime会员</title>
    <link href="https://blog.lthero.cn/2025/03/24/RegisterPrimeOfTurkey/"/>
    <id>https://blog.lthero.cn/2025/03/24/RegisterPrimeOfTurkey/</id>
    <published>2025-03-24T14:28:18.000Z</published>
    <updated>2025-06-24T14:29:08.552Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>土区 Amazon Prime Video 涨价，由 7.99 TL 上涨至 39 TL，相当于每月不到2.8 CNY涨至 8 CNY</p></blockquote><h1 id="关于amazon">关于Amazon</h1><p>Amazon Prime Video是亚马逊公司开发、持有并运营的互联网视频点播服务，它提供包括亚马逊工作室原创内容在内的电视节目和影音的租借、购买及在线观看。</p><p>最令人耳熟能详的莫过于:</p><ul><li>《<strong>The Boys 黑袍纠察队</strong>》</li><li>《 Upload 上载新生》</li><li>《<strong>The Man in the High Castle 高堡奇人</strong>》</li><li>《<strong>The Marvelous Mrs. Maisel 了不起的麦瑟尔夫人</strong>》</li><li>等等一系列剧集</li></ul><h2 id="amazon-prime-权益">Amazon Prime 权益</h2><p>土耳其的 Prime 权益除包含专属的购物权益外，还有 Prime Video，Prime Gaming</p><blockquote><p>Prime Gaming每月可以免费领取游戏以及 Twitch的频道订阅</p></blockquote><p><a href="https://yummy.best/content/images/2022/07/image-7.png"><img src="https://yummy.best/content/images/2022/07/image-7.png" alt="img"></a>土耳其的 Prime 权益</p><p><a href="https://www.amazon.in/?ref=yummy.best">印度</a> 的 Prime 权益则是 <strong>将 Prime Gaming 换成了 Amazon Music 会员</strong></p><blockquote><p>和免费版没啥区别的会员，不如 Gaming 权益来的实在</p></blockquote><h2 id="开通方式">开通方式</h2><h3 id="一-以土耳其订阅为例子-学生免费白嫖半年请看-方法二">一、以土耳其订阅为例子 （学生免费白嫖半年请看 方法二）</h3><p><strong>1. 进入 <a href="https://www.amazon.com.tr/?ref=yummy.best">*<em>亚马逊土耳其官网*</em></a> 。</strong></p><p>💡网页均为土耳其语,建议使用 Edge / Chrome 浏览器访问,并开启网页翻译</p><blockquote><p><strong>注： 后面出现的截图可能会由于翻译API的问题，显示的文字未必完全相同。</strong></p></blockquote><p><strong>2. 点击网页右上角的按钮(如图) ，完成登录/注册。</strong></p><p>⚠️注意: 这一步注册的邮箱推荐使用Gmail，用自定义域名邮箱接验证码基本上都会直接报错。</p><p><a href="https://yummy.best/content/images/2022/07/image.png"><img src="https://yummy.best/content/images/2022/07/image.png" alt="img"></a></p><p>点击 登录 / 成为新会员</p><p><a href="https://yummy.best/content/images/2022/07/image-1.png"><img src="https://yummy.best/content/images/2022/07/image-1.png" alt="img"></a></p><p><a href="https://yummy.best/content/images/2022/07/image-2.png"><img src="https://yummy.best/content/images/2022/07/image-2.png" alt="img"></a></p><p>推荐使用 Gmail 邮箱接收验证码，否则容易显示系统出错。</p><ol start="3"><li>完成 登录 / 注册 后，点击 我的 Prime 会员资格 ，并点击 免费试用 30 天的按钮</li></ol><p><a href="https://yummy.best/content/images/2022/07/image-4.png"><img src="https://yummy.best/content/images/2022/07/image-4.png" alt="img"></a></p><p><a href="https://yummy.best/content/images/2022/07/image-6.png"><img src="https://yummy.best/content/images/2022/07/image-6.png" alt="img"></a></p><ol start="4"><li>点击 添加信用卡或借记卡</li></ol><p><a href="https://yummy.best/content/images/2022/07/image-8.png"><img src="https://yummy.best/content/images/2022/07/image-8.png" alt="img"></a></p><ol start="5"><li>依次输入 卡片上的姓名、卡号、有效期 ，然后点击 黄色按钮 完成订阅。</li></ol><blockquote><p><strong>P.S 亚马逊这些大厂由于安全度较高且风控严格，所以这一步无需输入CVV</strong></p></blockquote><h4 id="你需要知道的冷知识">你需要知道的冷知识</h4><p>冷知识1： 即使商家收集了您的CVV并发现它不正确，商家仍然可以自行决定向您收取费用。</p><p>冷知识2：亚马逊风控非常严格，别想着不验证CVV就动歪脑筋，商家也不是傻子。</p><p>冷知识3：亚马逊的风控虽然非常严格，但只要你自己是卡主人，跟随风控邮件要求，发送该卡的的账单或者流水即可轻松解除风控。</p><p><a href="https://yummy.best/content/images/2022/07/image-9.png"><img src="https://yummy.best/content/images/2022/07/image-9.png" alt="img"></a></p><p><strong>6. 尽情享受 Prime 权益吧！</strong></p><h3 id="二-美亚amazon-可以白嫖6个月学生会员">二、美亚Amazon 可以白嫖6个月学生会员</h3><ol><li>使用美国节点注册亚马逊Amazon账号，并绑定自己信用卡/借记卡。</li></ol><blockquote><p>注册请参考 方法一 里的内容，这里不再复述。</p></blockquote><ol><li>进入 <a href="https://amzn.to/46t50De?ref=yummy.best">开通页面</a> ，登陆教育邮箱，点击Try Prime Student，根据步骤完成即可白嫖半年Prime。</li></ol><p><a href="https://yummy.best/content/images/2022/07/image-11.png"><img src="https://yummy.best/content/images/2022/07/image-11.png" alt="img"></a></p><p>三、无教育邮箱，正常试用</p><ol><li>如果你没有教育邮箱也通过 <a href="https://amzn.to/3ZWEqQv?ref=yummy.best">这个链接</a> 免费试用一个月Amazon Prime</li><li>如果只想要Prime Video 且试用完需要正常续费的，可以通过 <a href="https://amzn.to/3tsd1Ka?ref=yummy.best">这个链接</a> 开通 , 再通过 <a href="https://amzn.to/3LWSyn8?ref=yummy.best">这个链接</a> 免费获取多达100个频道的免费试用。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;土区 Amazon Prime Video 涨价，由 7.99 TL 上涨至 39 TL，相当于每月不到2.8 CNY涨至 8 CNY&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;关于amazon&quot;&gt;关于Amazon&lt;/h1&gt;
&lt;p&gt;Ama</summary>
      
    
    
    
    <category term="折腾" scheme="https://blog.lthero.cn/categories/%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="prime" scheme="https://blog.lthero.cn/tags/prime/"/>
    
  </entry>
  
  <entry>
    <title>开通尼日利亚地区Netflix</title>
    <link href="https://blog.lthero.cn/2025/03/24/RegisterNetflixAccountOfNigeria/"/>
    <id>https://blog.lthero.cn/2025/03/24/RegisterNetflixAccountOfNigeria/</id>
    <published>2025-03-24T14:26:56.000Z</published>
    <updated>2025-06-24T14:29:15.101Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开通尼日利亚地区netflix">开通尼日利亚地区Netflix</h1><blockquote><p>文章的截图是从https://uuzi.net/subscribe-hongkong-netflix-guide/拿的，图不同，但流程是相似的</p></blockquote><h2 id="准备工作">准备工作</h2><ul><li>一个尼日利亚地区的代理（如机场、VPN或住宅IP）</li><li>指纹浏览器adsPower</li><li>一张尼日利亚信用卡(使用Paga创建虚拟信用卡)</li><li>一个尼日利亚地区手机号</li></ul><h2 id="尼日利亚代理">尼日利亚代理</h2><p><a href="https://iproyal.cn/?r=tuge">iproyal</a>或<a href="https://proxy302.com/">proxy302</a></p><p>花了7美元买了1个G的流量，用了好几个月，每次涉及到转区，开通一些比较稀有国家例如巴基斯坦、尼日利亚、埃及等地区的服务都能用上，开通服务每次也只用十几兆的流量，如果关闭图片显示，更节省流量，能用好久确实很方便。下面我直接跳过购买界面，选择香港代理ip如下：</p><p><img src="https://uuzi.net/wp-content/uploads/2024/01/iShot_2024-01-12_19.34.37-scaled.webp" alt="img"></p><h2 id="指纹浏览器adspower">指纹浏览器adsPower</h2><p>指纹浏览器官方地址：<a href="https://www.adspower.net/">https://www.adspower.net/</a></p><p>新建浏览器环境，将如下的信息参照上图的配置信息填入：</p><p><img src="https://uuzi.net/wp-content/uploads/2024/01/iShot_2024-01-12_19.37.43-1-scaled.webp" alt="img"></p><p><img src="https://uuzi.net/wp-content/uploads/2024/01/iShot_2024-01-12_19.40.59.webp" alt="img"></p><p>打开新建的环境：</p><p><img src="https://uuzi.net/wp-content/uploads/2024/01/iShot_2024-01-12_19.42.02.webp" alt="img"></p><p>显示国家/地区为尼区说明环境没问题</p><p><img src="https://uuzi.net/wp-content/uploads/2024/01/iShot_2024-01-12_19.44.55-scaled.webp" alt="img"></p><h2 id="netflix注册与支付流程">netflix注册与支付流程</h2><p><a href="http://xn--netflix-f43kh3vnqptc6ik5nn03aymlilwmf9b3wkv69i.com/ng%EF%BC%8C%E7%A1%AE%E8%AE%A4%E6%98%AF%E5%90%A6%E4%BC%9A%E8%87%AA%E5%8A%A8%E8%B7%B3%E8%BD%AC%E5%88%B0%E5%88%B0ng%E7%9A%84%E7%BD%91%E5%9D%80%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%98%BE%E7%A4%BAng%E5%88%99%E7%BB%A7%E7%BB%AD%E5%9C%A8%E4%B8%8B%E5%9B%BE%E4%B8%AD%E5%A1%AB%E5%85%A5%E5%BC%80%E9%80%9A%E7%9A%84%E9%82%AE%E7%AE%B1%E5%9C%B0%E5%9D%80%EF%BC%9A">在打开的环境中地址栏输入netflix.com/ng，确认是否会自动跳转到到ng的网址，如果显示ng则继续在下图中填入开通的邮箱地址：</a></p><p><strong>下图用hk举例</strong></p><p><img src="https://uuzi.net/wp-content/uploads/2024/01/iShot_2024-01-12_19.49.55-scaled.webp" alt="img"></p><p>完成账户设定，点击下一步：</p><p><img src="https://uuzi.net/wp-content/uploads/2024/01/iShot_2024-01-12_19.51.05-scaled.webp" alt="img"></p><p>根据需求，选择合适的套餐。我的因为是拼车，所以选择了最高的套餐：</p><p><img src="https://uuzi.net/wp-content/uploads/2024/01/iShot_2024-01-12_19.56.23-scaled.webp" alt="img"></p><p>选择付款方式，可以看到竟然有银联的支持：</p><p><img src="https://uuzi.net/wp-content/uploads/2024/01/iShot_2024-01-12_19.57.18-scaled.webp" alt="img"></p><p>填入信用卡信息，填写完毕后点击启用会员资格：</p><p><img src="https://uuzi.net/wp-content/uploads/2024/01/2024-01-12-20.00.58.jpg" alt="img"></p><p>这里会要求输入尼区地区的手机号，关于手机号也简单，<a href="https://sms-activate.guru/en">SMS-Activate</a>找到尼区奈飞接码即可</p><p><img src="https://uuzi.net/wp-content/uploads/2024/01/iShot_2024-01-12_20.03.29-scaled.webp" alt="img"></p><p><img src="https://uuzi.net/wp-content/uploads/2024/01/iShot_2024-01-12_20.04.45-scaled.webp" alt="img"></p><p><img src="https://uuzi.net/wp-content/uploads/2024/01/iShot_2024-01-12_20.06.17-scaled.webp" alt="img"></p><h2 id="尼区信用卡">尼区信用卡</h2><p>这步最麻烦，目前比较好用的虚拟信用卡开通服务商是Paga</p><h3 id="自己注册-更安全">自己注册（更安全）</h3><p>需要本地人注册认证（需要本地人的身份信息等）；而一套身份信息大概需要30刀；200块左右买断这个身份；还需要本地人的手机号（大概10美元）；所以加起来一共要40刀左右；此方案也有小概率被身份人将账号找回……</p><h3 id="直接购买注册好的账号-不太推荐">直接购买注册好的账号（不太推荐）</h3><p>一个注册好的账号大概6美元，但它的身份信息可能会被别人共用，不太安全；</p><p>有了paga账号后，需要先给paga充值，充值后才能开虚拟卡；</p><h3 id="充值方式">充值方式</h3><p>1、找其它有paga账号的人进行转账</p><p>2、使用wise转账（似乎不太行，会被wise限制）</p><p>3、使用cipper转账</p><p>假设已经充值好了，则可以在paga的&quot;card&quot;里开通奈拉虚拟卡（手续费500奈拉），开通后向卡里充一些钱（结合网飞的实时价格），再去netflix支付即可。</p><h2 id="总结">总结</h2><p>尼区虽然低价（4k版本大概40元/月），但有几个缺点</p><p>1、网飞的尼区账号首月会被限制ip，只能尼区ip或美区能观看；一个月后会解锁，可以各地区使用；但不排除网飞继续限制……</p><p>2、网飞会针对低价区，随时有翻车可能，且费用不退；</p><p>3、paga软件做得非常差，哪怕是自己买了身份信息并做kyc认证，账号还是有被找回的可能，从长期性来看，这种卡早晚会被取消；</p><p>综合上述内容，如果想长期使用netflix（自己开车），还是注册香港区的netflix（4k版本大概100元/月），均摊下每人20/月；</p><p>此外，目前的netflix低价区还有埃及、土耳其，不过也都不太稳定；</p><p>最近折腾了一圈，想靠这个方案挣钱还是难的，也就刚好cover掉成本挣不了多少（卖40/季度），而且随时有翻车风险，以及入金的不安全性和风险</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;开通尼日利亚地区netflix&quot;&gt;开通尼日利亚地区Netflix&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;文章的截图是从https://uuzi.net/subscribe-hongkong-netflix-guide/拿的，图不同，但流程是相似的&lt;/p&gt;
&lt;/</summary>
      
    
    
    
    <category term="折腾" scheme="https://blog.lthero.cn/categories/%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="Netflix" scheme="https://blog.lthero.cn/tags/Netflix/"/>
    
  </entry>
  
  <entry>
    <title>Zerotier自建Planet服务器的使用说明</title>
    <link href="https://blog.lthero.cn/2025/03/11/BuildYourOwnZerotierPlanet/"/>
    <id>https://blog.lthero.cn/2025/03/11/BuildYourOwnZerotierPlanet/</id>
    <published>2025-03-11T02:32:10.000Z</published>
    <updated>2025-06-24T14:24:27.269Z</updated>
    
    <content type="html"><![CDATA[<p><strong>总体分为两大步骤</strong></p><p>第一步、下载并导入 <code>planet</code> 文件：<a href="http://114.66.63.134:3223/planet?key=63122304d122157b">点击下载planet文件</a></p><p>第二步、加入到虚拟局域网网络（由我发送给你的网络ID）</p><h1 id="不同平台的客户端配置过程">不同平台的客户端配置过程</h1><h2 id="windows-配置">Windows 配置</h2><p>1、首先去zerotier官网下载一个zerotier客户端</p><p>2、下载 <code>planet</code> 文件：<a href="http://114.66.63.134:3223/planet?key=63122304d122157b">点击下载planet文件</a></p><p>3、将 <code>planet</code> 文件覆盖粘贴到<code>C:\ProgramData\ZeroTier\One</code>中(这个目录是个隐藏目录，需要运允许查看隐藏目录才行)</p><p>4、按Win+S 搜索 <code>服务</code></p><p>![image-20250310132508140](/Users/lthero/Library/Application Support/typora-user-images/image-20250310132508140.png)</p><p>找到<strong>ZeroTier One</strong>，并且重启服务</p><p>![image-20250310132517587](/Users/lthero/Library/Application Support/typora-user-images/image-20250310132517587.png)</p><h3 id="加入网络">加入网络</h3><p>使用管理员身份打开PowerShell</p><p>执行如下命令，看到<strong>join ok</strong>字样就成功了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\system32&gt; zerotier-cli <span class="built_in">join</span> 网络<span class="built_in">id</span></span><br><span class="line">200 <span class="built_in">join</span> OK</span><br></pre></td></tr></table></figure><p>如果有加入到其它网络，先离开其它网络</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zerotier-cli leave 网络id</span><br></pre></td></tr></table></figure><h3 id="检查">检查</h3><p>执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Windows\system32&gt; zerotier-cli peers</span><br><span class="line">200 peers</span><br><span class="line">&lt;ztaddr&gt;   &lt;ver&gt;  &lt;role&gt; &lt;lat&gt; &lt;link&gt; &lt;lastTX&gt; &lt;lastRX&gt; &lt;path&gt;</span><br><span class="line">0651177f3e x.x.x  PLANET    52 DIRECT 16       8994     1.1.1.1/9994</span><br><span class="line">PS C:\Windows\system32&gt;</span><br></pre></td></tr></table></figure><p>可以看到有一个 <strong>PLANTET</strong> 连接方式为 DIRECT(直连) 即可</p><h2 id="linux-客户端">Linux 客户端</h2><ol><li>安装linux客户端软件</li><li>进入目录 <code>/var/lib/zerotier-one</code></li><li>替换目录下的 <code>planet</code> 文件</li><li>重启 <code>zerotier-one</code> 服务(<code>service zerotier-one restart</code>)</li><li>加入网络 <code>zerotier-cli join</code> 网络 <code>id</code></li><li>管理后台同意加入请求</li><li><code>zerotier-cli peers</code> 可以看到<code> planet</code> 角色</li></ol><h2 id="安卓客户端配置">安卓客户端配置</h2><p><strong>ZerotierFix</strong> 软件下载链接：<a href="https://drive.lthero.cn/s/u26yqa">https://drive.lthero.cn/s/u26yqa</a></p><p>一共两个步骤，先点击右上角，找到“设置”</p><img src="/Users/lthero/Desktop/PixPin_2025-03-11_09-03-18.png" alt="一共两大步骤" style="zoom:50%;" /><p>点击“设置planet文件”并从URL导入文件，随后点击启用</p><img src="/Users/lthero/Desktop/PixPin_2025-03-11_09-01-23.png" alt="替换planet文件" style="zoom:50%;" /><p>返回主界面，选择右下角，输入网络ID并添加网络；</p><img src="/Users/lthero/Desktop/PixPin_2025-03-11_09-02-08.png" alt="添加网络" style="zoom:50%;" /><h2 id="macos-客户端配置">MacOS 客户端配置</h2><ol><li>进入 <code>/Library/Application\ Support/ZeroTier/One/</code> 目录，并替换目录下的 <code>planet</code> 文件</li><li>重启 ZeroTier-One：<code>cat /Library/Application\ Support/ZeroTier/One/zerotier-one.pid | sudo xargs kill</code></li><li>加入网络 <code>zerotier-cli join</code> 网络 <code>id</code></li><li>管理后台同意加入请求</li><li><code>zerotier-cli peers</code> 可以看到<code> planet</code> 角色</li></ol><h2 id="openwrt-客户端配置">OpenWRT 客户端配置</h2><ol><li>安装zerotier客户端</li><li>进入目录 <code>/etc/config/zero/planet</code></li><li>替换目录下的 <code>planet</code> 文件</li><li>在openwrt网页后台先关闭zerotier服务，在开启zerotier服务</li><li>在openwrt网页后台加入网络</li><li>管理后台同意加入请求</li><li>执行 <code>ln -s /etc/config/zero /var/lib/zerotier-one </code></li><li><code>zerotier-cli peers</code> 可以看到<code> planet</code> 角色</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;总体分为两大步骤&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一步、下载并导入 &lt;code&gt;planet&lt;/code&gt; 文件：&lt;a href=&quot;http://114.66.63.134:3223/planet?key=63122304d122157b&quot;&gt;点击下载pla</summary>
      
    
    
    
    <category term="zerotier" scheme="https://blog.lthero.cn/categories/zerotier/"/>
    
    
    <category term="zerotier" scheme="https://blog.lthero.cn/tags/zerotier/"/>
    
  </entry>
  
  <entry>
    <title>【汇总】代理工具</title>
    <link href="https://blog.lthero.cn/2025/02/10/ProxyTools/"/>
    <id>https://blog.lthero.cn/2025/02/10/ProxyTools/</id>
    <published>2025-02-10T11:42:08.000Z</published>
    <updated>2025-02-11T06:34:58.378Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>名称</th><th>平台</th><th>备注</th><th>特点</th></tr></thead><tbody><tr><td><a href="https://github.com/2dust/v2rayN">V2rayN</a></td><td><code>Win/Mac/Linux</code></td><td>不适合新人！功能强！</td><td>支持测速、支持最新协议（Xhttp）</td></tr><tr><td><a href="https://github.com/clash-verge-rev/clash-verge-rev/releases">Clash-verge-rev</a></td><td><code>Win/Mac/Linux</code></td><td>简单好用！适合新手！<strong>PC端强烈推荐</strong></td><td>支持测速、多协议</td></tr><tr><td><a href="https://github.com/2dust/v2rayNG">V2rayNG</a></td><td><code>Android</code></td><td>不适合新人！功能强！</td><td>支持测速、支持最新协议（Xhttp）</td></tr><tr><td><a href="https://github.com/MatsuriDayo/NekoBoxForAndroid">Nekobox</a></td><td><code>Android</code></td><td>简单好用！适合新手！<strong>安卓强烈推荐</strong></td><td>支持测速、多协议</td></tr><tr><td><a href="https://sing-box.sagernet.org/">Sing-box</a></td><td>全平台</td><td>不适合新人！功能强！</td><td>支持测速、支持最新协议（Xhttp）</td></tr><tr><td><a href="https://apps.apple.com/ae/app/shadowrocket/id932747118">Shadowrocket</a></td><td><code>IOS/Mac/Apple TV</code></td><td>最常见，更新最多！<strong>苹果手机推荐</strong></td><td>支持多协议</td></tr><tr><td><a href="https://nssurge.com/">Surge</a></td><td><code>IOS/Mac/Apple TV</code></td><td>苹果系通用，付费版可授权5个设备</td><td></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;平台&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;th&gt;特点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/2dust/v2ray</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>EnglishPod_S02</title>
    <link href="https://blog.lthero.cn/2025/02/09/EnglishPod-S02/"/>
    <id>https://blog.lthero.cn/2025/02/09/EnglishPod-S02/</id>
    <published>2025-02-09T04:38:44.000Z</published>
    <updated>2025-02-11T06:59:17.793Z</updated>
    
    <content type="html"><![CDATA[<h1 id="englishpodseason02">EnglishPodSeason02</h1><h2 id="105-职场夸奖">105 职场夸奖</h2><h3 id="wiz">wiz</h3><blockquote><p>someone who is <strong>really good at</strong> something.</p></blockquote><h3 id="slides">slides</h3><blockquote><p>ppt slides, one page in that presentation.</p></blockquote><h3 id="to-be-completely-blown-away">to be completely blown away</h3><blockquote><p>to be surprised/amazed but in a very positive way.</p></blockquote><p>Carl <strong>blown me away</strong> with his knowledge of science.</p><h3 id="wow">Wow</h3><blockquote><p>to wow someone / impress someone.</p></blockquote><h3 id="it-s-nothing">It’s nothing</h3><blockquote><p>it’s not a big deal. / it isn’t hard.</p><p>这没什么</p></blockquote><p>Thanks for lending me your car this week i really appreciated it.</p><ul><li>It’s okay really it was nothing</li></ul><p>I can’t believe you organize the surprise birthday party thank you so much</p><ul><li>don’t worry about it, it was nothing.</li></ul><h3 id="give-sb-a-hand">give sb. a hand</h3><blockquote><p>to help/assist someone</p></blockquote><h3 id="quite">quite</h3><blockquote><p>very good + n.</p></blockquote><p>quite the baskball player/dancer/</p><p>Nancy is <strong>quite gifted at math</strong> she can solve any math problem you give her</p><h3 id="take-on-board">take on board</h3><blockquote><p>to accept and <strong>use</strong> it.</p></blockquote><p>take on board my ideads/suggestions</p><h3 id="think-it-through-sth">think (it) through sth.</h3><blockquote><p>take it to consideration all the aspections.</p><p>think carefully about all of the small details or something.</p><p>深思熟虑</p></blockquote><p>Have you <strong>thought through</strong> my suggestions.</p><p>You guys are very young i think you have to <strong>think throught</strong> before you get married.</p><h3 id="原文">原文</h3><p>Elementary ‐ The Office ‐ Job Well Done (C0105)</p><p>A: And so, that concludes my outline for our marketing strategy next year. Thank you very much for your time.</p><p>B: Hey, that was <strong>quite</strong> the Presentation! Honestly, I <strong>was</strong> completely <strong>blown away</strong> by your strategy outline. I’ve gotta say, Alex, you really <strong>wowed</strong> me today.</p><p>A: Aw, come on; it was nothing. Im just doing my job.</p><p>B: No, I think you deserve some recognition here; I mean, if I look back on your previous Presentations, this is a huge improvement.</p><p>A: Well, Kristin did <strong>give me a hand</strong> with the <strong>slides</strong>. She’s a real <strong>wiz</strong> on PowerPoint.</p><p>B: And I saw that you <strong>took on board</strong> my feedback about pricing strategies. I really appreciate you taking the time to <strong>think through</strong> my suggestions.</p><p>A: Yeah, well, that was some good advice. You made some really good points.</p><p>B: Well, I just wanted to say well done. Really you did a great job.</p><h2 id="106-话费套餐">106 话费套餐</h2><h3 id="prepaid-plan-pay-as-you-go">prepaid plan/pay as you go.</h3><blockquote><p>you pay before you use the minutes</p></blockquote><h3 id="monthly-rate-plan">monthly rate plan</h3><blockquote><p>you have to pay each month, you get a bill at the end of the month.</p></blockquote><h3 id="activate">activate</h3><blockquote><p>make sth. work, only do it once.</p></blockquote><p>activate your computer software/credit card</p><h3 id="handset">handset</h3><blockquote><p>the device/phone you can call it a handset.</p></blockquote><h3 id="rollover-option">rollover option</h3><blockquote><p>the minutes you don’t use , you can still use it the following month.</p><p>可转结到下个月的流量|通话时间……</p></blockquote><h3 id="to-rollover">to rollover</h3><blockquote><p>move from one place to another.</p></blockquote><h3 id="fee">fee</h3><blockquote><p>the amount you must pay for a <strong>service</strong></p></blockquote><p>you <strong>can’t</strong> say:“what’s the fee for the bottle of water.”</p><p>you <strong>can</strong> say: “what’s the <strong>fee for filling</strong> the bottle of water.”</p><h3 id="to-be-compatible-with">to be compatible with</h3><blockquote><p><strong>to work well with</strong> something else.</p></blockquote><p>Our applicaiton is compatible with most smartphones.</p><p>我们的软件与大多智能手机兼容</p><p>My roomate and I are just not compatible.</p><p>Your computer is not compatible with our software.</p><h3 id="what-s-the-catch">what’s the catch?</h3><blockquote><p><strong>catch</strong> is something <strong>hidden</strong> and <strong>negative</strong> makes the deal seems not great.</p><p>catch 隐性条款、往往是限制条件(condition.)</p></blockquote><p>If you get a car for free but the <strong>catch</strong> is you only drive it at night.</p><h3 id="you-are-in-luck">you are in luck</h3><blockquote><p>sth. luckcy is happen.</p></blockquote><p>you are in luck, i have the very last one.</p><h3 id="throw-in">throw in</h3><blockquote><p>include sth. for free.</p><p>附赠</p></blockquote><p>if you buy the house I will throw in the dog for free.</p><h3 id="原文">原文</h3><p>Elementary ‐ Daily Life ‐ Mobile Phone Plan (C0106)</p><p>A: Hi there, can I help you?</p><p>B: Yeah, I’ve just moved here, and I’d like to <strong>activate</strong> my cell phone, and I’m not sure if I should go with a <strong>prepaid plan</strong>, or a <strong>monthly rate plan</strong>.<br>A: I see. Well, can I have a look at your phone?Unfortunately, this phone can’t be used in the US; it’s not <strong>compatible with</strong> our 3G network.<br>B: What? Really? I don’t really want to have to buy a new phone.<br>A: Well, <strong>you’re in luck!</strong> You see, if you sign up for our three-year plan, we’ll <strong>throw in</strong> a <strong>handset</strong> for free.<br>B: Really? What’s the <strong>catch</strong>?<br>A: There’s no <strong>catch</strong>! You just choose a plan, sign a three-year contract and, that’s it! Actually, we’re running a special promotion right now, and we’re giving away a Blackberry Curve with our special Mega Value forty dollar plan.<br>B: So what does this plan include?<br>A: Well, you get nine hundred anytime minutes, and you can also enjoy free mobile to mobile calling to other Tel-Mobile clients, one thousand text messages per month, and unlimited evening and weekend minutes. Oh, and we also offer a <strong>rollover</strong> option.<br>B: Wow, all this for forty dollars per month?<br>A: That’s right, plus the activation <strong>fee</strong>, the emergancy services fee, the monthly service fee, oh, and any charges for extra minutes, and…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;englishpodseason02&quot;&gt;EnglishPodSeason02&lt;/h1&gt;
&lt;h2 id=&quot;105-职场夸奖&quot;&gt;105 职场夸奖&lt;/h2&gt;
&lt;h3 id=&quot;wiz&quot;&gt;wiz&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;someone who is &lt;st</summary>
      
    
    
    
    
  </entry>
  
</feed>
