<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lthero</title>
  
  <subtitle>个人博客</subtitle>
  <link href="https://blog.lthero.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.lthero.cn/"/>
  <updated>2025-07-14T16:01:11.016Z</updated>
  <id>https://blog.lthero.cn/</id>
  
  <author>
    <name>lthero</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCodeCampsDay19</title>
    <link href="https://blog.lthero.cn/2025/07/14/LeetCodeCampsDay19/"/>
    <id>https://blog.lthero.cn/2025/07/14/LeetCodeCampsDay19/</id>
    <published>2025-07-14T14:50:36.000Z</published>
    <updated>2025-07-14T16:01:11.016Z</updated>
    
    <content type="html"><![CDATA[<h1 id="235-二叉搜索树的最近公共祖先">235. 二叉搜索树的最近公共祖先</h1><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/</a></p><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p>例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" alt="img"></p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4</span><br><span class="line">输出: 2</span><br><span class="line">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li></ul><h2 id="递归思路">递归思路</h2><ol><li>本题是BST，可以利用它的特性；如果node大于q.val且大于p.val，则需要向左遍历，在左子树中找公共祖先节点；如果node小于q.val且小于p.val，需要向右遍历，在右子树中找公共祖先节点；否则，直接返回node, node一定为p和q的公共祖先节点</li></ol><h2 id="递归代码">递归代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(H)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self, node, p, q</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> node == q <span class="keyword">or</span> node == p <span class="keyword">or</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> node.val &gt; p.val <span class="keyword">and</span> node.val &gt; q.val:</span><br><span class="line">            <span class="comment"># 应该向左子树搜索, 返回左子树的公共节点</span></span><br><span class="line">            leftNode = self.foo(node.left, p, q)</span><br><span class="line">            <span class="comment"># 找到了公共节点就返回</span></span><br><span class="line">            <span class="keyword">if</span> leftNode:</span><br><span class="line">                <span class="keyword">return</span> leftNode</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> node.val &lt; p.val <span class="keyword">and</span> node.val &lt; q.val:</span><br><span class="line">            rightNode = self.foo(node.right, p, q)</span><br><span class="line">            <span class="keyword">if</span> rightNode:</span><br><span class="line">                <span class="keyword">return</span> rightNode</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> self.foo(root, p, q)</span><br></pre></td></tr></table></figure><h2 id="迭代思路">迭代思路</h2><ol><li>因为BST已经排序好了，所以不需要借用栈就能自行搜索，迭代的代码反而更简单，如果同时将node与p&amp;q的值对比，如果相等就返回node；否则就继续搜索</li><li>这与在BST中搜索target的代码几乎一样<a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findTarget</span>(<span class="params">self, node: TreeNode, val: <span class="built_in">int</span></span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> node.val &gt; val:</span><br><span class="line">            leftNode = self.findTarget(node.left, val)</span><br><span class="line">            <span class="keyword">if</span> leftNode:</span><br><span class="line">                <span class="keyword">return</span> leftNode</span><br><span class="line">        <span class="keyword">elif</span> node.val &lt; val:</span><br><span class="line">            rightNode = self.findTarget(node.right, val)</span><br><span class="line">            <span class="keyword">if</span> rightNode:</span><br><span class="line">                <span class="keyword">return</span> rightNode</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">searchBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="comment"># BST特点是可以使用类似二分查找，若val小于当前值就在左子树找；否则在右子树找</span></span><br><span class="line">        <span class="comment"># return self.findTarget(root, val)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># BST的迭代</span></span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> root.val == val:</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">            <span class="keyword">elif</span> root.val &lt; val:</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root = root.left</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="迭代代码">迭代代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">    <span class="comment"># return self.foo(root, p, q)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    node = root</span><br><span class="line">    <span class="keyword">while</span> node:</span><br><span class="line">        <span class="keyword">if</span> node.val &gt; q.val <span class="keyword">and</span> node.val &gt; p.val:</span><br><span class="line">            <span class="comment"># 向左遍历</span></span><br><span class="line">            node = node.left</span><br><span class="line">        <span class="keyword">elif</span> node.val &lt; q.val <span class="keyword">and</span> node.val &lt; p.val:</span><br><span class="line">            <span class="comment"># 向右子树遍历</span></span><br><span class="line">            node = node.right</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 否则node.val一定等于q&amp;p</span></span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h1 id="701-二叉搜索树中的插入操作">701. 二叉搜索树中的插入操作</h1><p><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">https://leetcode.cn/problems/insert-into-a-binary-search-tree/</a></p><p>给定二叉搜索树（BST）的根节点 <code>root</code> 和要插入树中的值 <code>value</code> ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 <strong>保证</strong> ，新值和原始二叉搜索树中的任意节点值都不同。</p><p><strong>注意</strong>，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 <strong>任意有效的结果</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3], val = 5</span><br><span class="line">输出：[4,2,7,1,3,5]</span><br><span class="line">解释：另一个满足题目要求可以通过的树是：</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [40,20,60,10,30,50,70], val = 25</span><br><span class="line">输出：[40,20,60,10,30,50,70,null,null,25]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5</span><br><span class="line">输出：[4,2,7,1,3,5]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中的节点数将在 <code>[0, 104]</code>的范围内。</li><li><code>-108 &lt;= Node.val &lt;= 108</code></li><li>所有值 <code>Node.val</code> 是 <strong>独一无二</strong> 的。</li><li><code>-108 &lt;= val &lt;= 108</code></li><li><strong>保证</strong> <code>val</code> 在原始BST中不存在。</li></ul><h2 id="递归思路">递归思路</h2><ol><li><p>需要考虑递归是否需要带输出，如果带输出，输出需要是更新后的输入节点；如果不带输出，如何将更新后的节点表示出来</p></li><li><p>输入输出：输入节点与targetval， 输出插好的子树节点node</p></li><li><p>终止条件：如果遇到空节点，这个空节点就必然是targetVal应该在的地方（因为后面的单层逻辑必须保证这个条件）</p></li><li><p>单层逻辑：node.val与val判断，如果node.val大于val，则在node.left继续搜索，且node.left = foo(node.left, val)；否则就在node.right搜索，注意这里的foo返回值是node.left或node.right已经将val插好后的新节点</p></li></ol><h2 id="递归代码">递归代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(H)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self, node, val</span>):</span><br><span class="line">        <span class="comment"># 返回可以嵌入的节点, 并且直接将这个val放在新节点返回</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(val)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> node.val &lt; val:</span><br><span class="line">            node.right = self.foo(node.right, val)</span><br><span class="line">        <span class="keyword">if</span> node.val &gt; val:</span><br><span class="line">            node.left = self.foo(node.left, val)</span><br><span class="line">        <span class="keyword">return</span> node </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insertIntoBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="comment"># 递归算法</span></span><br><span class="line">        <span class="keyword">return</span> self.foo(root, val)</span><br></pre></td></tr></table></figure><h2 id="迭代代码">迭代代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(H)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insertIntoBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">    <span class="comment"># 迭代算法</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> TreeNode(val)</span><br><span class="line">    partent = root</span><br><span class="line">    cur = root</span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        partent = cur</span><br><span class="line">        <span class="comment"># 二叉搜索</span></span><br><span class="line">        <span class="keyword">if</span> cur.val &gt; val:</span><br><span class="line">            cur = cur.left</span><br><span class="line">        <span class="keyword">elif</span> cur.val &lt; val:</span><br><span class="line">            cur = cur.right</span><br><span class="line">    <span class="comment"># 直到找到了合适位置</span></span><br><span class="line">    <span class="keyword">if</span> partent.val &gt; val:</span><br><span class="line">        partent.left = TreeNode(val)</span><br><span class="line">    <span class="keyword">elif</span> partent.val &lt; val:</span><br><span class="line">        partent.right = TreeNode(val)</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h1 id="450-删除二叉搜索树中的节点">450. 删除二叉搜索树中的节点</h1><p><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">https://leetcode.cn/problems/delete-node-in-a-bst/</a></p><p>给定一个二叉搜索树的根节点 <strong>root</strong> 和一个值 <strong>key</strong>，删除二叉搜索树中的 <strong>key</strong> 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><ol><li>首先找到需要删除的节点；</li><li>如果找到了，删除它。</li></ol><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,3,6,2,4,null,7], key = 3</span><br><span class="line">输出：[5,4,6,2,null,null,7]</span><br><span class="line">解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。</span><br><span class="line">一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。</span><br><span class="line">另一个正确答案是 [5,2,6,null,4,null,7]。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [5,3,6,2,4,null,7], key = 0</span><br><span class="line">输出: [5,3,6,2,4,null,7]</span><br><span class="line">解释: 二叉树不包含值为 0 的节点</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [], key = 0</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li>节点数的范围 <code>[0, 104]</code>.</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li>节点值唯一</li><li><code>root</code> 是合法的二叉搜索树</li><li><code>-105 &lt;= key &lt;= 105</code></li></ul><p><strong>进阶：</strong> 要求算法时间复杂度为 O(h)，h 为树的高度。</p><h2 id="递归思路">递归思路</h2><ol><li>使用带返回值的递归方法，返回的内容是已经将节点删除后的节点</li><li>输入值node与key，输出是将key删除后的节点</li><li>终止条件：如果node为空则直接返回node；</li><li>单层逻辑：判断node.val与key的关系，直到找到node.val等于key，随后需要分四种情况<ol><li>node的左、右子树为空，可以放心删除，直接返回None</li><li>node的左子树为空，右子树不为空；直接返回右子树</li><li>node的左子树不空，右子树为空，直接返回左子树</li><li>node的左、右子树都不空，当时需要特殊处理；将node左子树的root，变成node的右子树的最小的节点的左子树（参考下图），此时可以用个cur节点和while搭配，一直向左找即可</li></ol></li></ol><p><img src="https://file1.kamacoder.com/i/algo/450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.gif" alt="img"></p><h2 id="递归代码">递归代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(H)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 使用递归完成，并且被删除的节点有5种情况</span></span><br><span class="line">    <span class="comment"># </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.parent = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self, node: TreeNode, key: <span class="built_in">int</span></span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        <span class="comment"># 如果node是要被删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> node.val == key:</span><br><span class="line">            <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> node.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">elif</span> node.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> node.right:</span><br><span class="line">                <span class="keyword">return</span> node.right</span><br><span class="line">            <span class="keyword">elif</span> node.left <span class="keyword">and</span> node.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> node.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment">#</span></span><br><span class="line">                cur = node.right</span><br><span class="line">                <span class="keyword">while</span> cur.left:</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                cur.left = node.left</span><br><span class="line">                node = node.right</span><br><span class="line">                <span class="keyword">return</span> node</span><br><span class="line">        <span class="keyword">if</span> node.val &lt; key:</span><br><span class="line">            node.right = self.foo(node.right, key)</span><br><span class="line">        <span class="keyword">if</span> node.val &gt; key:</span><br><span class="line">            node.left = self.foo(node.left, key)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteNode</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], key: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="comment"># 使用递归</span></span><br><span class="line">        <span class="keyword">return</span> self.foo(root, key)</span><br></pre></td></tr></table></figure><h2 id="迭代代码">迭代代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(H)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">deleteNode</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], key: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">    <span class="comment"># 使用迭代</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    parent = <span class="literal">None</span></span><br><span class="line">    node = root</span><br><span class="line">    <span class="keyword">while</span> node:</span><br><span class="line">        <span class="keyword">if</span> node.val == key:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        parent = node</span><br><span class="line">        <span class="keyword">if</span> node.val &gt; key:</span><br><span class="line">            node = node.left</span><br><span class="line">        <span class="keyword">elif</span> node.val &lt; key:</span><br><span class="line">            node = node.right</span><br><span class="line">    <span class="comment"># 如果只有头节点</span></span><br><span class="line">    <span class="keyword">if</span> parent <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> self.deleteOneNode(node)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> parent.left <span class="keyword">and</span> parent.left.val == key:</span><br><span class="line">        parent.left = self.deleteOneNode(parent.left)</span><br><span class="line">    <span class="keyword">if</span> parent.right <span class="keyword">and</span> parent.right.val == key:</span><br><span class="line">        parent.right = self.deleteOneNode(parent.right)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h1 id="删除普通二叉搜索树的节点">删除普通二叉搜索树的节点</h1><p>在450基础上进行扩展</p><h2 id="递归代码">递归代码</h2><ul><li>时间复杂度O(N2)</li><li>空间复杂度O(N2)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">self, node, key</span>) -&gt; TreeNode:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    <span class="keyword">if</span> node.val == key:</span><br><span class="line">        <span class="keyword">if</span> node.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> node.left</span><br><span class="line">        cur = node.right</span><br><span class="line">        <span class="keyword">while</span> cur.left:</span><br><span class="line">            cur = cur.left</span><br><span class="line">        node.val, cur.val = cur.val, node.val</span><br><span class="line">    node.left = self.bar(node.left, key)</span><br><span class="line">    node.right = self.bar(node.right, key)</span><br><span class="line">    <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;235-二叉搜索树的最近公共祖先&quot;&gt;235. 二叉搜索树的最近公共祖先&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/&quot;&gt;h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay18二叉树part06</title>
    <link href="https://blog.lthero.cn/2025/07/13/LeetCodeCampsDay18/"/>
    <id>https://blog.lthero.cn/2025/07/13/LeetCodeCampsDay18/</id>
    <published>2025-07-13T02:51:24.000Z</published>
    <updated>2025-07-14T14:51:19.627Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday18二叉树part06">LeetCodeCampsDay18二叉树part06</h1><blockquote><p>查找公共祖先节点</p></blockquote><h1 id="236-二叉树的最近公共祖先">236. 二叉树的最近公共祖先</h1><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/</a></p><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">输出：3</span><br><span class="line">解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">输出：5</span><br><span class="line">解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2], p = 1, q = 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[2, 105]</code> 内。</li><li><code>-109 &lt;= Node.val &lt;= 109</code></li><li>所有 <code>Node.val</code> <code>互不相同</code> 。</li><li><code>p != q</code></li><li><code>p</code> 和 <code>q</code> 均存在于给定的二叉树中。</li></ul><h2 id="递归思路">递归思路</h2><ol><li>输入输出：输入node, q, p； 输出公共节点</li><li>终止条件：当前节点为空返回None，当前节点为p或q则返回当前节点</li><li>单层逻辑：需要先搜索左、右子树中是否存在p&amp;q<ol><li>如果左、右子树有p&amp;q（即左、右子树不为None），则当前node为公共节点；</li><li>下一步是需要考虑，如何将公共节点传到最上层：这里需要解释下，假设[10,1,7,<strong>2,3</strong>]（其中2，3为p&amp;q），假设当前节点为10，对10来说，1（左子树）返回值是None（因为不存在p或q），而7（右子树）返回值为7（不为空），说明7就是q&amp;p的最近公共祖先；10只需要将7返回，即if leftNode and not rightNode: return leftNode</li></ol></li></ol><p><img src="https://cdn.lthero.cn/post_images/course/MLimage-20250713125002679.png" alt="image-20250713125002679"></p><h2 id="递归代码">递归代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self, node, p, q</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="comment"># 如果当前节点为空</span></span><br><span class="line">        <span class="comment"># 当前节点为p/q，告诉上层节点，发现了目标值；如果上层节点知道左、右子树都不为空，则上层节点就是公共节点</span></span><br><span class="line">        <span class="keyword">if</span> node == q <span class="keyword">or</span> node == p <span class="keyword">or</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 探索左子树是否有p/q</span></span><br><span class="line">        leftNode = self.foo(node.left, p, q)</span><br><span class="line">        <span class="comment"># 探索右子树是否有p/q</span></span><br><span class="line">        rightNode = self.foo(node.right, p, q)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果node节点知道左、右子树都不为空，则node节点就是公共节点</span></span><br><span class="line">        <span class="keyword">if</span> leftNode <span class="keyword">and</span> rightNode:</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 这一步是将已经为公共节点的node，继续向上返回，保证顶部会得到公共节点</span></span><br><span class="line">        <span class="comment"># 这里需要解释下，假设[10,1,7,p,q]，即对10来说，1（左子树）返回值是None，而7（右子树）返回值为7（不为空），说明7就是q&amp;p的最近公共祖先</span></span><br><span class="line">        <span class="comment"># 对10来说，直接返回7就行</span></span><br><span class="line">        <span class="keyword">if</span> leftNode <span class="keyword">and</span> <span class="keyword">not</span> rightNode:</span><br><span class="line">            <span class="keyword">return</span> leftNode</span><br><span class="line">        <span class="comment"># 同理</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> leftNode <span class="keyword">and</span> rightNode:</span><br><span class="line">            <span class="keyword">return</span> rightNode</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> self.foo(root, p, q)</span><br></pre></td></tr></table></figure><h1 id="530-二叉搜索树的最小绝对差">530. 二叉搜索树的最小绝对差</h1><p><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">https://leetcode.cn/problems/minimum-absolute-difference-in-bst/</a></p><p>给你一个二叉搜索树的根节点 <code>root</code> ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。</p><p>差值是一个正数，其数值等于两值之差的绝对值。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,6,1,3]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/05/bst2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,0,48,null,null,12,49]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目范围是 <code>[2, 104]</code></li><li><code>0 &lt;= Node.val &lt;= 105</code></li></ul><h2 id="迭代思路">迭代思路</h2><ol><li>本题和<code>98. 验证二叉搜索树</code> 很像，都可以靠中序遍历，并且判断相邻两位元素的值（差）来解决；这需要用到BST特性，即左节点小于等于root，root小于等于右节点</li></ol><h2 id="迭代代码">迭代代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMinimumDifference</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 使用中序遍历，记录相邻两位元素差值</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        stack = [[root, <span class="literal">False</span>]] <span class="keyword">if</span> root <span class="keyword">else</span> []</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        diff = <span class="literal">None</span></span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node, visited = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> visited:</span><br><span class="line">                <span class="keyword">if</span> pre:</span><br><span class="line">                    <span class="keyword">if</span> diff <span class="keyword">and</span> <span class="built_in">abs</span>(node.val - pre.val) &lt; diff:</span><br><span class="line">                        diff = <span class="built_in">abs</span>(node.val - pre.val)</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> diff:</span><br><span class="line">                        diff = <span class="built_in">abs</span>(node.val - pre.val)</span><br><span class="line">                pre = node</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    stack.append([node.right, <span class="literal">False</span>])</span><br><span class="line">                stack.append([node, <span class="literal">True</span>])</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    stack.append([node.left, <span class="literal">False</span>])</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> diff</span><br></pre></td></tr></table></figure><h1 id="501-二叉搜索树中的众数">501. 二叉搜索树中的众数</h1><p><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">https://leetcode.cn/problems/find-mode-in-binary-search-tree/</a></p><p>给你一个含重复值的二叉搜索树（BST）的根节点 <code>root</code> ，找出并返回 BST 中的所有 <a href="https://baike.baidu.com/item/%E4%BC%97%E6%95%B0/44796">众数</a>（即，出现频率最高的元素）。</p><p>如果树中有不止一个众数，可以按 <strong>任意顺序</strong> 返回。</p><p>假定 BST 满足如下定义：</p><ul><li>结点左子树中所含节点的值 <strong>小于等于</strong> 当前节点的值</li><li>结点右子树中所含节点的值 <strong>大于等于</strong> 当前节点的值</li><li>左子树和右子树都是二叉搜索树</li></ul><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/11/mode-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,null,2,2]</span><br><span class="line">输出：[2]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[1, 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li></ul><p>**进阶：**你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p><h2 id="迭代思路">迭代思路</h2><ol><li>用中序遍历，关键是在「中间节点的操作」，本题和<code>530二叉搜索树的最小绝对差 </code>以及<code>98. 验证二叉搜索树</code> 相似，需要引入pre节点，判断前后两个元素是否相等，如果相等则将count+1，如果不相等则重置count为1。随后判断count是否等于MaxFreq，如果是，则将元素添加到res里；如果count大于MaxFreq，则将res清空并且将元素添加到res里，并设置MaxFreq等于count</li><li>本题如果只有一个众数，那会相对简直一些，只要一直记录count最大的元素就好，也不用对res清空</li></ol><h2 id="迭代代码">迭代代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(H) – 主要是stack占用的</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.MostFreq = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMode</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 还是按中序遍历，出现频率最高的数可以放在res里，用一个</span></span><br><span class="line">        stack = <span class="built_in">list</span>()</span><br><span class="line">        node = root</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> node <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                stack.append(node)</span><br><span class="line">                node = node.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 左</span></span><br><span class="line">                node = stack.pop()</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 中</span></span><br><span class="line">                <span class="keyword">if</span> pre:</span><br><span class="line">                    <span class="keyword">if</span> pre.val == node.val:</span><br><span class="line">                        count += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        count = <span class="number">1</span></span><br><span class="line">                pre = node</span><br><span class="line">                <span class="keyword">if</span> count == self.MostFreq:</span><br><span class="line">                    res.append(node.val)</span><br><span class="line">                    </span><br><span class="line">                <span class="keyword">elif</span> count &gt; self.MostFreq:</span><br><span class="line">                    res.clear()</span><br><span class="line">                    res.append(node.val)</span><br><span class="line">                    self.MostFreq = count</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 右</span></span><br><span class="line">                node = node.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br></pre></td></tr></table></figure><h2 id="递归代码">递归代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(H) – 最好O(logN)最坏O(N)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">self, node</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    <span class="comment"># 左</span></span><br><span class="line">    self.traverse(node.left)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 中</span></span><br><span class="line">    <span class="keyword">if</span> self.pre:</span><br><span class="line">        <span class="keyword">if</span> self.pre.val == node.val:</span><br><span class="line">            self.count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.count = <span class="number">1</span></span><br><span class="line">    self.pre = node</span><br><span class="line">    <span class="keyword">if</span> self.count == self.MostFreq:</span><br><span class="line">        self.res.append(node.val)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">elif</span> self.count &gt; self.MostFreq:</span><br><span class="line">        self.res.clear()</span><br><span class="line">        self.res.append(node.val)</span><br><span class="line">        self.MostFreq = self.count</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 右</span></span><br><span class="line">    self.traverse(node.right)</span><br></pre></td></tr></table></figure><h2 id="思考">思考</h2><p>如果本题不是BST而是普通树，可以先做遍历（中/前/后/层序都行），再进行排序，排序时按频率将最高频率的添加到res里</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday18二叉树part06&quot;&gt;LeetCodeCampsDay18二叉树part06&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;查找公共祖先节点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;236-二叉树的最近公共祖先&quot;&gt;236</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay17二叉树part05</title>
    <link href="https://blog.lthero.cn/2025/07/11/LeetCodeCampsDay17/"/>
    <id>https://blog.lthero.cn/2025/07/11/LeetCodeCampsDay17/</id>
    <published>2025-07-11T10:57:14.000Z</published>
    <updated>2025-07-11T12:51:44.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday17二叉树part05">LeetCodeCampsDay17二叉树part05</h1><blockquote><p>包含二叉搜索树的判断与搜索；以及合并二叉树的应用，最大二叉树的创建</p></blockquote><h1 id="654-最大二叉树">654. 最大二叉树</h1><p><a href="https://leetcode.cn/problems/maximum-binary-tree/">https://leetcode.cn/problems/maximum-binary-tree/</a></p><p>给定一个不重复的整数数组 <code>nums</code> 。 <strong>最大二叉树</strong> 可以用下面的算法从 <code>nums</code> 递归地构建:</p><ol><li>创建一个根节点，其值为 <code>nums</code> 中的最大值。</li><li>递归地在最大值 <strong>左边</strong> 的 <strong>子数组前缀上</strong> 构建左子树。</li><li>递归地在最大值 <strong>右边</strong> 的 <strong>子数组后缀上</strong> 构建右子树。</li></ol><p>返回 <em><code>nums</code> 构建的</em> *<strong>最大二叉树*</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,1,6,0,5]</span><br><span class="line">输出：[6,3,5,null,2,0,null,null,1]</span><br><span class="line">解释：递归调用如下所示：</span><br><span class="line">- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。</span><br><span class="line">    - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。</span><br><span class="line">        - 空数组，无子节点。</span><br><span class="line">        - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。</span><br><span class="line">            - 空数组，无子节点。</span><br><span class="line">            - 只有一个元素，所以子节点是一个值为 1 的节点。</span><br><span class="line">    - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。</span><br><span class="line">        - 只有一个元素，所以子节点是一个值为 0 的节点。</span><br><span class="line">        - 空数组，无子节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/24/tree2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,1]</span><br><span class="line">输出：[3,null,2,null,1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li></ul><h2 id="递归思路">递归思路</h2><ol><li>使用递归解决：<ol><li>终止条件，<strong>当发现叶子节点时返回这个节点，即len(nums)==1就返回构造的节点</strong></li><li>输入输出：输入列表，输出根节点</li><li>单层逻辑：先找到列表中最大值，它为root节点，再以root为界限，<strong>找左、右子树（前提是有左、右子树）</strong>，需要加个对rootIndex的判断；对nums的划分有点儿像之前做的根据前/中序列构造二叉树</li></ol></li></ol><h2 id="递归代码">递归代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(H)—最坏情况O(N)最好O(logN)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.res = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">traversal</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 终止条件是：发现叶子节点就直接返回</span></span><br><span class="line">        <span class="keyword">if</span> L == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(nums[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 找最大值</span></span><br><span class="line">        maxIndex = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt;= nums[maxIndex]:</span><br><span class="line">                maxIndex = i</span><br><span class="line">        root = TreeNode(nums[maxIndex])</span><br><span class="line">        <span class="comment"># 注意，maxIndex至少要有左子树和右子树</span></span><br><span class="line">        <span class="keyword">if</span> maxIndex &gt; <span class="number">0</span>:</span><br><span class="line">            leftTree = self.traversal(nums[:maxIndex])</span><br><span class="line">            root.left = leftTree</span><br><span class="line">        <span class="keyword">if</span> maxIndex &lt; L - <span class="number">1</span>:</span><br><span class="line">            rightTree = self.traversal(nums[maxIndex + <span class="number">1</span>:])</span><br><span class="line">            root.right = rightTree</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">constructMaximumBinaryTree</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="comment"># 注意层序顺序返回结果</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        que = deque()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        root = self.traversal(nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h1 id="700-二叉搜索树中的搜索">700. 二叉搜索树中的搜索</h1><p><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">https://leetcode.cn/problems/search-in-a-binary-search-tree/</a></p><p>给定二叉搜索树（BST）的根节点 <code>root</code> 和一个整数值 <code>val</code>。</p><p>你需要在 BST 中找到节点值等于 <code>val</code> 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 <code>null</code> 。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/12/tree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3], val = 2</span><br><span class="line">输出：[2,1,3]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/12/tree2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3], val = 5</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数在 <code>[1, 5000]</code> 范围内</li><li><code>1 &lt;= Node.val &lt;= 107</code></li><li><code>root</code> 是二叉搜索树</li><li><code>1 &lt;= val &lt;= 107</code></li></ul><h2 id="递归思路">递归思路</h2><ol><li>BST树特点是可以使用类似二分查找，若val小于当前值就在当前node的左子树找；否则在右子树找</li><li>输入输出：输入node和val，输出节点</li><li>终止条件：当前node为空</li><li>单层逻辑：若val小于当前值就在当前node的左子树找；否则在右子树找，如果相等就返回node</li></ol><h2 id="递归代码">递归代码</h2><ul><li>时间复杂度O(h) – 最好O(logN)，最坏O(N)</li><li>空间复杂度O(h) – 最好O(logN)，最坏O(N)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findTarget</span>(<span class="params">self, node: TreeNode, val: <span class="built_in">int</span></span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> node.val &gt; val:</span><br><span class="line">            <span class="keyword">return</span> self.findTarget(node.left, val)</span><br><span class="line">        <span class="keyword">elif</span> node.val &lt; val:</span><br><span class="line">            <span class="keyword">return</span> self.findTarget(node.right, val)</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="comment"># BST特点是可以使用类似二分查找，若val小于当前值就在左子树找；否则在右子树找</span></span><br><span class="line">        <span class="keyword">return</span> self.findTarget(root, val)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="迭代思路">迭代思路</h2><p>一提到二叉树遍历的迭代法，可能立刻想起使用栈来模拟深度遍历，使用队列来模拟广度遍历。</p><p>对于二叉搜索树可就不一样了，因为二叉搜索树的特殊性，也就是节点的有序性，<code>可以不使用辅助栈或者队列就可以写出迭代法</code>。</p><p>对于一般二叉树，递归过程中还有回溯的过程，<strong>例如走一个左方向的分支走到头了，那么要调头，在走右分支</strong>。</p><p>而<strong>对于二叉搜索树，不需要回溯的过程，因为节点的有序性就帮我们确定了搜索的方向。</strong></p><p>例如要搜索元素为3的节点，<strong>我们不需要搜索其他节点，也不需要做回溯，查找的路径已经规划好了。</strong></p><p>中间节点如果大于3就向左走，如果小于3就向右走，如图：</p><p><img src="https://file1.kamacoder.com/i/algo/20200812190213280.png" alt="img"></p><h2 id="迭代代码">迭代代码</h2><ul><li>时间复杂度O(h) – 最好O(logN)，最坏O(N)</li><li>空间复杂度O(h) – 最好O(logN)，最坏O(N)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">searchBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="comment"># BST的迭代</span></span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> root.val == val:</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">            <span class="keyword">elif</span> root.val &lt; val:</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root = root.left</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h1 id="98-验证二叉搜索树">98. 验证二叉搜索树</h1><p><a href="https://leetcode.cn/problems/validate-binary-search-tree/">https://leetcode.cn/problems/validate-binary-search-tree/</a></p><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [2,1,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,1,4,null,null,3,6]</span><br><span class="line">输出：false</span><br><span class="line">解释：根节点的值是 5 ，但是右子节点的值是 4 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目范围在<code>[1, 104]</code> 内</li><li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li></ul><h2 id="中序迭代思路">中序迭代思路</h2><ol><li>先用中序遍历输出到个数组中，再看数组是否是单调的</li><li>验证是否单调就找个maxIndex，如果后一个值大于maxIndex就更新maxIndex并继续搜索；否则就直接return False</li></ol><h2 id="中序迭代代码">中序迭代代码</h2><ul><li>时间复杂度O(N^2) — 主要是后面验证是否单调递增浪费时间</li><li>空间复杂度O(N)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 按中序遍历，输出的应该是单调增长的</span></span><br><span class="line"></span><br><span class="line">        stack = [(root, <span class="literal">False</span>)] <span class="keyword">if</span> root <span class="keyword">else</span> []</span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node, visited = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> visited:</span><br><span class="line">                res.append(node.val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    stack.append([node.right, <span class="literal">False</span>])</span><br><span class="line">                stack.append([node, <span class="literal">True</span>])</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    stack.append([node.left, <span class="literal">False</span>])</span><br><span class="line">        <span class="comment">#print(res)</span></span><br><span class="line">        <span class="comment">#rturn all(x &lt; y for x, y in zip(res, res[1:]))                </span></span><br><span class="line">        maxIndex = <span class="number">0</span></span><br><span class="line">        L = <span class="built_in">len</span>(res)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L):</span><br><span class="line">            <span class="keyword">if</span> res[i] &gt; res[maxIndex]:</span><br><span class="line">                maxIndex = i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="中序迭代思路二">中序迭代思路二</h2><ol><li>添加一个pre节点，在每次对visited==True时进行pre与当前节点的判断，<code>如果pre大于或等于node，则一定有问题！</code></li><li>好处是不需要额外数组装结果，中序遍历过程中就能判断是否有问题</li></ol><p>没错的，使用pre大于或等于node进行判断就行，因为目前是中序输出，不管下面哪种情况，都可以用pre大于或等于node来判断出False</p><p><img src="https://cdn.lthero.cn/post_images/course/MLimage-20250711201453775.png" alt="image-20250711201453775"></p><h2 id="统一中序迭代代码二">统一中序迭代代码二</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isValidBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="comment"># 按中序遍历，输出的应该是单调增长的</span></span><br><span class="line"></span><br><span class="line">    stack = [(root, <span class="literal">False</span>)] <span class="keyword">if</span> root <span class="keyword">else</span> []</span><br><span class="line">    pre = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node, visited = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> visited:</span><br><span class="line">            <span class="keyword">if</span> pre <span class="keyword">and</span> pre.val &gt;= node.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            pre = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append([node.right, <span class="literal">False</span>])</span><br><span class="line">            stack.append([node, <span class="literal">True</span>])</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append([node.left, <span class="literal">False</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="普通中序迭代代码三">普通中序迭代代码三</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> stack = <span class="built_in">list</span>()</span><br><span class="line"> cur = root</span><br><span class="line"> pre = <span class="literal">None</span></span><br><span class="line"><span class="comment"># cur先一路干到最底层的左子树左叶子节点</span></span><br><span class="line"> <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">     <span class="keyword">if</span> cur:</span><br><span class="line">         stack.append(cur)</span><br><span class="line">         cur = cur.left</span><br><span class="line">     <span class="comment"># 到达最左节点后，开始处理栈顶节点</span></span><br><span class="line">     <span class="keyword">else</span>:</span><br><span class="line">       <span class="comment"># 最底层的左子树左叶子节点开始输出，append到</span></span><br><span class="line">         cur = stack.pop()</span><br><span class="line">         <span class="keyword">if</span> pre <span class="keyword">and</span> cur.val &lt;= pre.val:</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">         pre = cur</span><br><span class="line">         <span class="comment"># 取栈顶元素右节点</span></span><br><span class="line">         cur = cur.right</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h1 id="617-合并二叉树">617. 合并二叉树</h1><p><a href="https://leetcode.cn/problems/merge-two-binary-trees/">https://leetcode.cn/problems/merge-two-binary-trees/</a></p><p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p><strong>注意:</strong> 合并过程必须从两个树的根节点开始。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/05/merge.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]</span><br><span class="line">输出：[3,4,5,5,4,null,7]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root1 = [1], root2 = [1,2]</span><br><span class="line">输出：[2,2]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>两棵树中的节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-104 &lt;= Node.val &lt;= 104</code></li></ul><h2 id="递归思路">递归思路</h2><ol><li>本题和<a href="https://leetcode.cn/problems/symmetric-tree/">对称二叉树</a>有点儿像</li><li>终止条件：如果都空就返回None；哪个空就返回另一个；</li><li>输入输出：输入两个节点，输出合并后的节点</li><li>单层逻辑：只有都不空，才创建root节点并将两个节点相加，随后创建root的左、右子树</li></ol><p><img src="https://file1.kamacoder.com/i/algo/617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91.gif" alt="img"></p><h2 id="递归代码">递归代码</h2><ul><li>时间复杂度O(N+M)</li><li>空间复杂度O(H) 其中 H 是两个树中高度的最大值。主要由递归调用栈引起</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, node1, node2</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node1 <span class="keyword">and</span> node2:</span><br><span class="line">            <span class="keyword">return</span> node2</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> node2 <span class="keyword">and</span> node1:</span><br><span class="line">            <span class="keyword">return</span> node1</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> node1 <span class="keyword">and</span> <span class="keyword">not</span> node2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            root = TreeNode(node1.val + node2.val)</span><br><span class="line"></span><br><span class="line">        leftTree = self.buildTree(node1.left, node2.left)</span><br><span class="line">        rightTree = self.buildTree(node1.right, node2.right)</span><br><span class="line"></span><br><span class="line">        root.left = leftTree</span><br><span class="line">        root.right = rightTree</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTrees</span>(<span class="params">self, root1: <span class="type">Optional</span>[TreeNode], root2: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="comment"># 树长度不用相同，使用递归</span></span><br><span class="line">        <span class="keyword">return</span> self.buildTree(root1, root2)</span><br></pre></td></tr></table></figure><h2 id="迭代思路">迭代思路</h2><ol><li>使用层序，和<a href="https://leetcode.cn/problems/symmetric-tree/">对称二叉树</a>有点儿像，每次处理两个节点；每次添加两个节点进去，弹出两个节点出来</li><li>但本题可以直接拿其中一个root当成结果，比如root1</li><li>每次判断时，如果只有当node1和node2的左子树都不为空，才添加到que；否则如果node1.left为空，则让node1.left等于node2.left（这里隐藏了一条代码，如果node2.left为空，则让node1.left等于node1.left，即不变）；对node1和node2的右子树同样这样操作</li><li>最终返回root1即可</li></ol><h2 id="迭代代码">迭代代码</h2><ul><li>时间复杂度O(N+M)</li><li>空间复杂度O(H) 其中 H 是两个树中高度的最大值。主要由递归调用栈引起</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mergeTrees</span>(<span class="params">self, root1: <span class="type">Optional</span>[TreeNode], root2: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">    <span class="comment"># 迭代版，使用层序</span></span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">    que = deque()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root1:</span><br><span class="line">        <span class="keyword">return</span> root2</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root2:</span><br><span class="line">        <span class="keyword">return</span> root1</span><br><span class="line">    que.append(root1)</span><br><span class="line">    que.append(root2)</span><br><span class="line">    <span class="keyword">while</span> que:</span><br><span class="line">        L = <span class="built_in">len</span>(que)</span><br><span class="line">        node1 = que.popleft()</span><br><span class="line">        node2 = que.popleft()</span><br><span class="line"></span><br><span class="line">        node1.val += node2.val</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> node1.left <span class="keyword">and</span> node2.left:</span><br><span class="line">            que.append(node1.left)</span><br><span class="line">            que.append(node2.left)</span><br><span class="line">        <span class="keyword">if</span> node1.right <span class="keyword">and</span> node2.right:</span><br><span class="line">            que.append(node1.right)</span><br><span class="line">            que.append(node2.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node1.left <span class="keyword">and</span> node2.left:</span><br><span class="line">            node1.left = node2.left</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node1.right <span class="keyword">and</span> node2.right:</span><br><span class="line">            node1.right = node2.right</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="103-二叉树的锯齿形层序遍历">103. 二叉树的锯齿形层序遍历</h1><p><a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/</a></p><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>锯齿形层序遍历</strong> 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：[[3],[20,9],[15,7]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h2 id="层序迭代思路">层序迭代思路</h2><ol><li>按层序遍历即可，先把每层元素全添加到level，再按奇偶反转level内部,再添加到res</li></ol><h2 id="层序迭代代码">层序迭代代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(H)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">zigzagLevelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 先全添加到level，再按奇偶反转level内部,再添加到res</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        que = deque()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        que.append(root)</span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        countLevel = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            L = <span class="built_in">len</span>(que)</span><br><span class="line">            level = <span class="built_in">list</span>()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">                node = que.popleft()</span><br><span class="line">                level.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    que.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    que.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> countLevel % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                level = level[::-<span class="number">1</span>]</span><br><span class="line">            res.append(level)</span><br><span class="line">            countLevel += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday17二叉树part05&quot;&gt;LeetCodeCampsDay17二叉树part05&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;包含二叉搜索树的判断与搜索；以及合并二叉树的应用，最大二叉树的创建&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>从AutoRegression到Diffusion</title>
    <link href="https://blog.lthero.cn/2025/07/10/AutoRegressionToDiffusion/"/>
    <id>https://blog.lthero.cn/2025/07/10/AutoRegressionToDiffusion/</id>
    <published>2025-07-10T15:44:54.000Z</published>
    <updated>2025-07-10T16:11:04.448Z</updated>
    
    <content type="html"><![CDATA[<h1 id="why-does-diffusion-work-better-than-auto-regression">Why Does Diffusion Work Better than Auto-Regression?</h1><blockquote><p><a href="https://www.youtube.com/watch?v=zc5NTeJbk-k">https://www.youtube.com/watch?v=zc5NTeJbk-k</a></p><p>原标题是为什么Diffusion比AutoRegression效果好？</p><p>刷到个有意思的视频，没什么公式与理论，但很通彻地讲了AutoRegression到Diffusion的过渡，Diffusion不是一蹿而就的，终究也是AutoRegression成就了它；</p></blockquote><h2 id="最早期">最早期</h2><p>假设我们有labels（实际图片），有个网络，我们关心输入，反正让网络训练就行了；最终效果是让网络学到从输入到labels的映射</p><p><img src="https://cdn.lthero.cn/post_images/course/MLimage-20250710234829391.png" alt="image-20250710234829391"></p><p>但问题是，网络最终得到是所有训练集的一个平均值图片；因为所有labels的平均值也可以是个meaningful的label</p><p><img src="https://cdn.lthero.cn/post_images/course/MLimage-20250710235012110.png" alt="image-20250710235012110"></p><h2 id="早期">早期</h2><p>那，我们退一万步，让一个网络只预测一个位置的像素；比如网络–编号768，只预测第768位置上的像素；</p><p>网络可能会将整个图像学习，得输出一个像素</p><p><img src="https://cdn.lthero.cn/post_images/course/MLimage-20250710235157236.png" alt="image-20250710235157236"></p><p>那更进一步，让输入是缺少两个像素，然后让网络–编号767训练并输出倒数第二个位置的像素，再把补齐后的像素给网络768预测最后一位置的像素</p><p><img src="https://cdn.lthero.cn/post_images/course/MLimage-20250710235357625.png" alt="image-20250710235357625"></p><p>那，再进768步；训练768个网络，每个网络就预测一个像素，网络–编号1预测了第一个像素后交给网络–编号2……</p><p><img src="https://cdn.lthero.cn/post_images/course/MLimage-20250710235533536.png" alt="image-20250710235533536"></p><p>这听起来似乎是pleassible的，但现实上，如果每个网络都直接输出这个网络的最高概率像素值，<strong>最终，不管运行多少次，得到的图片会是完全一样的</strong>；这个问题也很好解决，每次添加一些扰动，每次选择不同概率的值，从而增加多样性</p><p><img src="https://cdn.lthero.cn/post_images/course/MLimage-20250710235802260.png" alt="image-20250710235802260"></p><p>而且，这样的网络有什么好处呢？它是自监督的，不需要人类给图片打标签，网络可以根据已有的像素推算下一个像素</p><p>小结下，如果让网络同时预测一堆像素，最终会产生一堆比较合理的结果，网络会输出一个平均值</p><p><img src="https://cdn.lthero.cn/post_images/course/MLimage-20250711000026049.png" alt="image-20250711000026049"></p><p>但如果只让网络一次预测一个像素，效果就会比较好</p><p><img src="https://cdn.lthero.cn/post_images/course/MLimage-20250711000125217.png" alt="image-20250711000125217"></p><p>那，为什么会这样呢？----因为这些像素是“有相关性”的</p><p>比如，如果这些像素本身就是无关的，这些像素对下一个像素的预测本身也帮不上什么忙，从而，模型就不需要知道（或者查看）之前的像素是什么（知道了也没用）</p><p><img src="https://cdn.lthero.cn/post_images/course/MLimage-20250711000224312.png" alt="image-20250711000224312"></p><p>所以，现在的理想目标是，让网络学会“不依赖原像素”预测新像素；</p><p>那么，在选择数据集时，就不一定将连续的像素块儿扣下来，而是应该随机选择一些像素块儿让网络去预测</p><p><img src="https://cdn.lthero.cn/post_images/course/MLimage-20250711000453635.png" alt="连续相似的像素块"></p><p>并且，最好让这些被扣下来的像素块尽量分散（in a random order）</p><p><img src="https://cdn.lthero.cn/post_images/course/MLimage-20250711000608747.png" alt="image-20250711000608747"></p><p>目前呢，是将像素完全扣下来，直接变成黑色；</p><p>不过，我们可以不这样做，而是让像素逐渐丢失信息，比如，加点儿噪声？</p><p><img src="https://cdn.lthero.cn/post_images/course/MLimage-20250711000754578.png" alt="image-20250711000754578"></p><p>虽然我们不知道原图是什么了，但我们知道加了什么噪声</p><p>看，逐渐添加了很多噪声，<strong>让图像失去了信息，并且让像素相互独立</strong></p><p><img src="https://cdn.lthero.cn/post_images/course/MLimage-20250711000900198.png" alt="image-20250711000900198"></p><h2 id="最终">最终</h2><p>于是，按上面的方法，似乎就让Diffusion的出现变得合理了</p><p><img src="https://cdn.lthero.cn/post_images/course/MLimage-20250711001022827.png" alt="image-20250711001022827"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;why-does-diffusion-work-better-than-auto-regression&quot;&gt;Why Does Diffusion Work Better than Auto-Regression?&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a hr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Transformer-03-LayerNorm</title>
    <link href="https://blog.lthero.cn/2025/07/10/Transformer-03-LayerNorm/"/>
    <id>https://blog.lthero.cn/2025/07/10/Transformer-03-LayerNorm/</id>
    <published>2025-07-10T15:15:21.000Z</published>
    <updated>2025-07-10T15:22:09.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="transformer学习笔记三：为什么transformer要用layernorm-batch-normalization-layer-normalization">Transformer学习笔记三：为什么Transformer要用LayerNorm/Batch Normalization &amp; Layer Normalization</h1><p>参考：<a href="https://zhuanlan.zhihu.com/p/456863215%E4%BB%A5%E5%8F%8A%E7%A7%81%E6%9C%89%E8%B5%84%E6%96%99">https://zhuanlan.zhihu.com/p/456863215以及私有资料</a></p><p>一般来说，BatchNorm适用于CV，LayerNorm适用于NLP。关键是要看需要保留什么信息，举个例子</p><p>NLP中，[‘搜推yyds’，LLM大法好’，‘CV永不为奴’]三句话做normalization，</p><p>其中，样本数量(N)为3，而每个字看作图像里的一个通道，</p><p>假设一个词是一个token，BatchNorm效果是[‘搜’，L’，‘C’]，[‘推’，‘L’，‘V’]…做归一化；LayerNorm是三句话分别各自归一化；</p><p>前者归一到同一分布后变无法保留一个句子里的分布信息了（比如·搜推yyds用Batch Norm后就变了），而LayerNorm可以成功保留上下文分布信息</p><p>CV中BatchNorm是对图像的不同channel（比如对N个样本的R通道）各自进行归一化(如下图，batch Norm，本身CV任务不需要channel之间的信息交互，归一化后仅保留各channel的分布信息作后续判断即可</p><p>![image-20250710231823710](/Users/lthero/Library/Application Support/typora-user-images/image-20250710231823710.png)</p><p>而NLP中的layerNorm是对每个样本的所有通道做归一化</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;transformer学习笔记三：为什么transformer要用layernorm-batch-normalization-layer-normalization&quot;&gt;Transformer学习笔记三：为什么Transformer要用LayerNorm/Batch</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay16</title>
    <link href="https://blog.lthero.cn/2025/07/10/LeetCodeCampsDay16/"/>
    <id>https://blog.lthero.cn/2025/07/10/LeetCodeCampsDay16/</id>
    <published>2025-07-10T11:13:28.000Z</published>
    <updated>2025-07-11T11:18:11.220Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday16">LeetCodeCampsDay16</h1><blockquote><p>记录下，今儿三个题目一次过；</p><p>其中<strong>路径总和问题</strong>和之前<strong>求二叉树的所有路径相似</strong></p><p>找树左下角的值可以用层序解决</p><p><strong>从中序与后序遍历序列构造二叉树</strong> 可以用递归方法，找到<strong>输入输出；终止条件；单层逻辑</strong>就能解决</p></blockquote><h1 id="找树左下角的值">找树左下角的值</h1><p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">https://leetcode.cn/problems/find-bottom-left-tree-value/</a></p><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的 <strong>最底层 最左边</strong> 节点的值。</p><p>假设二叉树中至少有一个节点。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/14/tree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [2,1,3]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,null,5,6,null,null,7]</span><br><span class="line">输出: 7</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li>二叉树的节点个数的范围是 <code>[1,104]</code></li><li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li></ul><h2 id="层序迭代思路">层序迭代思路</h2><ol><li>使用迭代–层序的方法, 令res存储每层第一个元素，遍历到最后一层结束，再返回res即可</li></ol><h2 id="层序迭代代码">层序迭代代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(W)—二叉树最大宽度（也即二叉树每层最大长度）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findBottomLeftValue</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 使用迭代--层序的方法, 令res存储每层第一个元素，遍历到最后一层结束，再返回res即可</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        que = deque()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        que.append(root)</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            L = <span class="built_in">len</span>(que)</span><br><span class="line">            level = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">                node = que.popleft()</span><br><span class="line">                <span class="keyword">if</span> i ==<span class="number">0</span>:</span><br><span class="line">                    level = node.val</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    que.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    que.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> level</span><br></pre></td></tr></table></figure><h1 id="112-路径总和">112. 路径总和</h1><p><a href="https://leetcode.cn/problems/path-sum/">https://leetcode.cn/problems/path-sum/</a></p><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22</span><br><span class="line">输出：true</span><br><span class="line">解释：等于目标和的根节点到叶节点路径如上图所示。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3], targetSum = 5</span><br><span class="line">输出：false</span><br><span class="line">解释：树中存在两条根节点到叶子节点的路径：</span><br><span class="line">(1 --&gt; 2): 和为 3</span><br><span class="line">(1 --&gt; 3): 和为 4</span><br><span class="line">不存在 sum = 5 的根节点到叶子节点的路径。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [], targetSum = 0</span><br><span class="line">输出：false</span><br><span class="line">解释：由于树是空的，所以不存在根节点到叶子节点的路径。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[0, 5000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li><li><code>-1000 &lt;= targetSum &lt;= 1000</code></li></ul><h2 id="后序迭代思路">后序迭代思路</h2><ol><li>这题目和“<strong>二叉树所有路径</strong>”(day15)相似，只是将保存路径变成<code>保存路径上所有元素的和</code>；遇到叶子节点时，判断这和是否与target相等即可</li><li>本题同样对前/中/后，甚至逆向的前/中/后顺序不敏感，所有顺序都能通过</li><li>下面代码使用后序</li></ol><h2 id="后序迭代代码">后序迭代代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(H)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 使用后序遍历+栈？</span></span><br><span class="line">        stack = <span class="built_in">list</span>()</span><br><span class="line">        path = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        stack.append(root)</span><br><span class="line">        path.append(root.val)</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            pathNode = path.pop()</span><br><span class="line">            <span class="comment"># 终止条件，遇到叶子节点了</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                <span class="keyword">if</span> pathNode == targetSum:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">                path.append(pathNode + node.right.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">                path.append(pathNode + node.left.val)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="递归思路">递归思路</h2><ol><li>输入输出：输入节点和targetSum，这里的targetSum每次都需要变小; 输出True/False</li><li>终止条件：不能是判断node是否为空，因为它说明不了什么；需要判断是否为叶子节点，并且判断targetSum是否为零，为零则返回True；如果叶子节点且targetSum不为零，返回False</li><li>单层逻辑，判断左、右子树是否已经存在了满足target的路径，存在就返回True</li></ol><h2 id="递归代码">递归代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(N)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self, node: TreeNode, targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 终止条件不能是判断node是否为空，因为它说明不了什么</span></span><br><span class="line">        <span class="comment"># 需要判断是否为叶子节点，并且判断targetSum是否为零</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right <span class="keyword">and</span> <span class="number">0</span> == targetSum:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 如果叶子节点且targetSum不为零，返回False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            <span class="comment"># 每一次都需要判断是否它的左子树已经找到了targetSum为零的情况</span></span><br><span class="line">            <span class="keyword">if</span> self.foo(node.left, targetSum - node.left.val):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            <span class="comment"># 每一次都需要判断是否它的右子树已经找到了targetSum为零的情况</span></span><br><span class="line">            <span class="keyword">if</span> self.foo(node.right, targetSum - node.right.val):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># </span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.foo(root, targetSum)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="113-路径总和-ii">113. 路径总和 II</h1><p><a href="https://leetcode.cn/problems/path-sum-ii/">https://leetcode.cn/problems/path-sum-ii/</a></p><p>给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22</span><br><span class="line">输出：[[5,4,11,2],[5,8,4,5]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3], targetSum = 5</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2], targetSum = 0</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点总数在范围 <code>[0, 5000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li><li><code>-1000 &lt;= targetSum &lt;= 1000</code></li></ul><h2 id="思路">思路</h2><ol><li>和之前做的差不多，但注意，这里是将<code>pathNode + [node.right.val]</code> 传进去path里，所以对pathNode本身没有修改，如果直接修改pathNode，会把所有路径的值都添加进去，就不对了</li></ol><h2 id="迭代代码">迭代代码</h2><ul><li>时间复杂度O(N^2)</li><li>空间复杂度O(N^2)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        stack = <span class="built_in">list</span>()</span><br><span class="line">        path = <span class="built_in">list</span>()</span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack.append(root)</span><br><span class="line">        path.append([root.val])</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            <span class="comment"># print(path)</span></span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="comment"># 先把节点从path中弹出</span></span><br><span class="line">            pathNode = path.pop()</span><br><span class="line">            <span class="comment"># 为了实现中、前、后，入栈需要使用中、后、前</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">sum</span>(pathNode) == targetSum:</span><br><span class="line">                    res.append(pathNode)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">                <span class="comment"># 注意，这里是将pathNode + [node.right.val]传进去，所以对pathNode本身没有修改</span></span><br><span class="line">                <span class="comment"># 如果直接修改pathNode，会把所有路径的值都添加进去，就不对了</span></span><br><span class="line">                path.append(pathNode + [node.right.val])</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">                path.append(pathNode + [node.left.val])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="递归代码">递归代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(N)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.res = <span class="built_in">list</span>()</span><br><span class="line">        self.path = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self, node: TreeNode, targetSum: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="comment"># 终止条件不能是判断node是否为空，因为它说明不了什么</span></span><br><span class="line">        <span class="comment"># 需要判断是否为叶子节点，并且判断targetSum是否为零</span></span><br><span class="line">        <span class="comment"># print(self.res, self.path)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right <span class="keyword">and</span> targetSum == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(self.res, self.path, )</span><br><span class="line">            self.res.append(self.path[:])</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果叶子节点且targetSum不为零，返回False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            <span class="comment"># 每一次都需要判断是否它的左子树已经找到了targetSum为零的情况</span></span><br><span class="line">            self.path.append(node.left.val)</span><br><span class="line">            self.foo(node.left, targetSum - node.left.val)</span><br><span class="line">            self.path.pop()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            <span class="comment"># 每一次都需要判断是否它的右子树已经找到了targetSum为零的情况</span></span><br><span class="line">            self.path.append(node.right.val)</span><br><span class="line">            self.foo(node.right, targetSum - node.right.val)</span><br><span class="line">            self.path.pop()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        self.res.clear()</span><br><span class="line">        self.path.clear()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> self.res</span><br><span class="line">        self.path.append(root.val)</span><br><span class="line">        self.foo(root, targetSum - root.val)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure><h1 id="106-从中序与后序遍历序列构造二叉树">106. 从中序与后序遍历序列构造二叉树</h1><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/</a></p><p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗 <em>二叉树</em> 。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]</span><br><span class="line">输出：[3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：inorder = [-1], postorder = [-1]</span><br><span class="line">输出：[-1]</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= inorder.length &lt;= 3000</code></li><li><code>postorder.length == inorder.length</code></li><li><code>-3000 &lt;= inorder[i], postorder[i] &lt;= 3000</code></li><li><code>inorder</code> 和 <code>postorder</code> 都由 <strong>不同</strong> 的值组成</li><li><code>postorder</code> 中每一个值都在 <code>inorder</code> 中</li><li><code>inorder</code> <strong>保证</strong>是树的中序遍历</li><li><code>postorder</code> <strong>保证</strong>是树的后序遍历</li></ul><h2 id="递归思路">递归思路</h2><ol><li>用两个指针，一个指针指向inorder首，一个指向postorder末尾</li><li>使用while循环，当left.val == right.val时<ol><li>右子树</li><li>left的下标也是右子树的postorder的开始下标</li><li>right - 1的下标是右子树postorder的结束下标（注意python里列表的右是开区间，所以写postorder[left: right]即可）</li><li>left + 1 是inorder中右子树开始下标，并且后面全是右子树</li><li>左子树</li><li>left 是inorder中左子树结束下标，并且前面全是左子树</li><li>left 是postorder中左子树结束下标，并且前面全是左子树</li></ol></li></ol><p>把左子树想成一大块儿；右子树想成一大块儿，就好理解了</p><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>in</td><td><code>左子树</code></td><td><code>左子树</code></td><td>3</td><td><strong>右子树</strong></td><td><strong>右子树</strong></td><td><strong>右子树</strong></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Post</td><td><code>左子树</code></td><td><code>左子树</code></td><td><strong>右子树</strong></td><td><strong>右子树</strong></td><td><strong>右子树</strong></td><td>3</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>left</td><td></td><td></td><td>Right</td></tr></tbody></table><p>这是对于3的两个子树的区间位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">leftTree = self.foo(inorder[:left], postorder[:left])</span><br><span class="line">rightTree = self.foo(inorder[left + <span class="number">1</span>:], postorder[left: right])</span><br></pre></td></tr></table></figure><h2 id="递归代码">递归代码</h2><ul><li>时间复杂度O(N^2)—最好情况O(NlogN)</li><li>空间复杂度O(N^2)</li><li>可以将while找root替换成index函数，即<code>left = inorder.index(postorder[right])</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self, inorder: <span class="type">List</span>[<span class="built_in">int</span>], postorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(inorder) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(postorder) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> inorder[left] != postorder[right]:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        leftTree = self.foo(inorder[:left], postorder[:left])</span><br><span class="line">        rightTree = self.foo(inorder[left + <span class="number">1</span>:], postorder[left: right])</span><br><span class="line"></span><br><span class="line">        node = TreeNode(inorder[left])</span><br><span class="line">        node.left = leftTree</span><br><span class="line">        node.right = rightTree</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, inorder: <span class="type">List</span>[<span class="built_in">int</span>], postorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="keyword">return</span> self.foo(inorder, postorder)</span><br></pre></td></tr></table></figure><h1 id="105-从前序与中序遍历序列构造二叉树">105. 从前序与中序遍历序列构造二叉树</h1><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]</span><br><span class="line">输出: [3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: preorder = [-1], inorder = [-1]</span><br><span class="line">输出: [-1]</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= preorder.length &lt;= 3000</code></li><li><code>inorder.length == preorder.length</code></li><li><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li><li><code>preorder</code> 和 <code>inorder</code> 均 <strong>无重复</strong> 元素</li><li><code>inorder</code> 均出现在 <code>preorder</code></li><li><code>preorder</code> <strong>保证</strong> 为二叉树的前序遍历序列</li><li><code>inorder</code> <strong>保证</strong> 为二叉树的中序遍历序列</li></ul><h2 id="代码">代码</h2><ul><li>时间复杂度O(N)—最好情况O(logN)</li><li>空间复杂度O(N)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], inorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(preorder) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = inorder.index(preorder[left])</span><br><span class="line"></span><br><span class="line">        leftTree = self.foo(preorder[left + <span class="number">1</span>: right + <span class="number">1</span>], inorder[:right])</span><br><span class="line">        rightTree = self.foo(preorder[right + <span class="number">1</span>:], inorder[right + <span class="number">1</span>:])</span><br><span class="line">        root = TreeNode(preorder[left])</span><br><span class="line">        root.left = leftTree</span><br><span class="line">        root.right = rightTree</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], inorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">return</span> self.foo(preorder, inorder)</span><br></pre></td></tr></table></figure><h1 id="889-根据前序和后序遍历构造二叉树">889. 根据前序和后序遍历构造二叉树</h1><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/</a></p><p>给定两个整数数组，<code>preorder</code> 和 <code>postorder</code> ，其中 <code>preorder</code> 是一个具有 <strong>无重复</strong> 值的二叉树的前序遍历，<code>postorder</code> 是同一棵树的后序遍历，重构并返回二叉树。</p><p>如果存在多个答案，您可以返回其中 <strong>任何</strong> 一个。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/07/24/lc-prepost.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]</span><br><span class="line">输出：[1,2,3,4,5,6,7]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: preorder = [1], postorder = [1]</span><br><span class="line">输出: [1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= preorder.length &lt;= 30</code></li><li><code>1 &lt;= preorder[i] &lt;= preorder.length</code></li><li><code>preorder</code> 中所有值都 <strong>不同</strong></li><li><code>postorder.length == preorder.length</code></li><li><code>1 &lt;= postorder[i] &lt;= postorder.length</code></li><li><code>postorder</code> 中所有值都 <strong>不同</strong></li><li>保证 <code>preorder</code> 和 <code>postorder</code> 是同一棵二叉树的前序遍历和后序遍历</li></ul><h2 id="递归思路">递归思路</h2><ol><li>和中充&amp;后序构造/前序&amp;中序构造不太一样，只知道前序和后序，需要更精确地知道左、右子树的区间；</li><li>除了需要知道当前root节点rootIndexPost以外，还需要知道左（或者右）的root节点rootIndexLeftTreeInPost的位置，这样才能判断左（或右）子树的区间</li><li>输入输出：输入为前&amp;后序列，输出为子树</li><li>终止条件：序列为空则返回None表示空节点，序列长度为1则返回这个叶子节点</li><li>单层逻辑：找到root（preorder的第一个就是），再以当前root为中心，找到它的左、右子树区间；使用递归找左、右子树，按拼接到root上就好；难度在于找到左、右树区间范围</li></ol><h2 id="递归代码">递归代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, preorder, postorder </span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(preorder)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(preorder) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># </span></span><br><span class="line">        rootIndexPost = <span class="built_in">len</span>(postorder)</span><br><span class="line">        rootIndexLeftTreeInPost = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> postorder[rootIndexLeftTreeInPost] != preorder[<span class="number">1</span>]:</span><br><span class="line">            rootIndexLeftTreeInPost += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        leftTree = self.buildTree(preorder[<span class="number">1</span>: <span class="number">1</span> + rootIndexLeftTreeInPost + <span class="number">1</span>], postorder[: rootIndexLeftTreeInPost + <span class="number">1</span>])</span><br><span class="line">        rightTree = self.buildTree(preorder[<span class="number">1</span> + rootIndexLeftTreeInPost + <span class="number">1</span>: ], postorder[rootIndexLeftTreeInPost + <span class="number">1</span>: -<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        root = TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line">        root.left = leftTree</span><br><span class="line">        root.right = rightTree</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">constructFromPrePost</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], postorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">return</span> self.buildTree(preorder, postorder)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday16&quot;&gt;LeetCodeCampsDay16&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;记录下，今儿三个题目一次过；&lt;/p&gt;
&lt;p&gt;其中&lt;strong&gt;路径总和问题&lt;/strong&gt;和之前&lt;strong&gt;求二叉树的所有路径相似&lt;/s</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay15二叉树part03</title>
    <link href="https://blog.lthero.cn/2025/07/09/LeetCodeCampsDay15/"/>
    <id>https://blog.lthero.cn/2025/07/09/LeetCodeCampsDay15/</id>
    <published>2025-07-09T06:12:49.000Z</published>
    <updated>2025-07-10T10:40:48.171Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday15二叉树part03">LeetCodeCampsDay15二叉树part03</h1><blockquote><p>涉及树的高度/深度求解，以及平衡二叉树的判断，完全二叉树求节点个数；</p><p>根节点到任意节点的路径/深度求解</p></blockquote><h1 id="平衡二叉树">平衡二叉树</h1><p><a href="https://leetcode.cn/problems/balanced-binary-tree/">https://leetcode.cn/problems/balanced-binary-tree/</a></p><p>给定一个二叉树，判断它是否是 平衡二叉树</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,2,3,3,null,null,4,4]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中的节点数在范围 <code>[0, 5000]</code> 内</li><li><code>-104 &lt;= Node.val &lt;= 104</code></li></ul><h2 id="后序递归思路">后序递归思路</h2><p>这里强调一波概念：</p><ul><li>二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。</li><li>二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。</li></ul><p>但leetcode中强调的深度和高度很明显是按照节点来计算的，如图：</p><p><img src="https://file1.kamacoder.com/i/algo/20210203155515650.png" alt="img"></p><p>如何判断一个树是不是平衡二叉树？—<strong>判断它的左树和右树的高度是否差大于1</strong></p><p>使用<strong>递归+后序</strong>遍历方法</p><ol><li>输入节点；输出高度（或者-1，表示高度差已经大于1了）</li><li>终止条件：节点为空返回0</li><li>单层逻辑：分别求左、右子树的高度，判断两者高度差，如果大于1则返回-1；否则返回1+max(左,右)</li></ol><p>顺便提一下，在day14写过“求最大深度”，当时也使用后序递归算法；当时仅需要每个节点找到子树的深度，再加一即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">leftDeepth = self.traverse(node.left)</span><br><span class="line">rightDeepth = self.traverse(node.right)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>(leftDeepth, rightDeepth) + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>而现在需要求每个节点的子树高度，是同样的代码，因为求最大深度，即**“根节点的高度就是二叉树的最大深度”**</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">leftHeight = self.getHeight(node.left)</span><br><span class="line">rightHeight = self.getHeight(node.right)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(leftHeight, rightHeight)</span><br></pre></td></tr></table></figure><p>但需要添加几个约束条件，比如求了leftH和righH后判断两者是否为-1，如果是，直接提前退出；以及判断两者高度差是否大于1</p><h2 id="后序递归代码">后序递归代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(H)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getHeight</span>(<span class="params">self, node</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 分别求左、右子树的高度，如果高度差大于1，则返回-1</span></span><br><span class="line">        leftHeight = self.getHeight(node.left)</span><br><span class="line">        <span class="keyword">if</span> leftHeight == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        rightHeight = self.getHeight(node.right)</span><br><span class="line">        <span class="keyword">if</span> rightHeight == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(leftHeight, rightHeight)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isBalanced</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 本题目尝试用递归法</span></span><br><span class="line">        res = self.getHeight(root)</span><br><span class="line">        <span class="keyword">if</span> res != -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h1 id="257-二叉树的所有路径">257. 二叉树的所有路径</h1><p><a href="https://leetcode.cn/problems/binary-tree-paths/">https://leetcode.cn/problems/binary-tree-paths/</a></p><p>给你一个二叉树的根节点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3,null,5]</span><br><span class="line">输出：[&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：[&quot;1&quot;]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[1, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h2 id="思路">思路</h2><p>已知前序遍历是长这样的</p><p><img src="https://file1.kamacoder.com/i/algo/20210204151702443.png" alt="img"></p><p>还是按递归的方式写个前序，但终止条件有点儿不同，以往是判断node为空就直接返回，但这题目需要<strong>判断“如果当前节点为叶子节点”，就将根到节点的路径保存</strong>。所以，还需要有个path列表来记录路径，同时还需要个res列表记录所有从根节点到叶子节点的路径</p><p>于是，</p><ol><li>递归的输入：node, path, res；输出就是res（用引用的方式输出就好）</li><li>终止条件：当前节点无孩子节点，则将当前的path添加到res里</li><li>单层逻辑：依然使用前序遍历，但需要添加判断条件，仅当left/right不为空时才能执行递归；而且递归后，需要将当前节点从path中弹出去<ol><li>比如[1,2,3,null,5],当找到了path=[1,2,5]后，如果不把[2,5]弹出，下次path会记录成[1,2,5,3]而不是正确答案[1,3]</li></ol></li></ol><p>本题使用递归写简单直接一点儿，用迭代也可以完成</p><h2 id="递归代码">递归代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(H)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preOrder</span>(<span class="params">self, node: TreeNode, path: <span class="built_in">list</span>, res: <span class="built_in">list</span></span>):</span><br><span class="line">        <span class="comment"># 操作, 必须放最前面（在终止条件前面）</span></span><br><span class="line">        path.append(node.val)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">            <span class="comment"># res里已经记录了[1,2,5]，需要将它转成1-&gt;2-&gt;5</span></span><br><span class="line">            s = <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(path) - <span class="number">1</span>):</span><br><span class="line">                s += (<span class="built_in">str</span>(path[i]) + <span class="string">&quot;-&gt;&quot;</span>)</span><br><span class="line">            s += <span class="built_in">str</span>(path[-<span class="number">1</span>])</span><br><span class="line">            res.append(s)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历</span></span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            self.preOrder(node.left, path, res)</span><br><span class="line">            <span class="comment"># 回溯只会发生在，当前节点的子节点都被遍历完了</span></span><br><span class="line">            <span class="comment"># 假设现在子节点已经被遍历完，需要进行回溯</span></span><br><span class="line">            path.pop()</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            self.preOrder(node.right, path, res)</span><br><span class="line">            <span class="comment"># 回溯</span></span><br><span class="line">            path.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">binaryTreePaths</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="comment"># 先用递归实现个前序遍历</span></span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        path = <span class="built_in">list</span>()</span><br><span class="line">        self.preOrder(root, path, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="迭代代码">迭代代码</h2><p>迭代的过程更简单一点儿</p><ul><li>时间复杂度O(N)</li><li>空间复杂度O(H)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  stack = <span class="built_in">list</span>()</span><br><span class="line">  path = <span class="built_in">list</span>()</span><br><span class="line">  res = <span class="built_in">list</span>()</span><br><span class="line">  stack.append(root)</span><br><span class="line">  path.append(<span class="built_in">str</span>(root.val))</span><br><span class="line">  <span class="keyword">while</span> stack:</span><br><span class="line">      node = stack.pop()</span><br><span class="line"><span class="comment"># 先把节点从path中弹出</span></span><br><span class="line">      pathNode = path.pop()</span><br><span class="line">      <span class="comment"># 为了实现中、前、后，入栈需要使用中、后、前</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">          res.append(pathNode)</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> node.right:</span><br><span class="line">          stack.append(node.right)</span><br><span class="line">          <span class="comment"># </span></span><br><span class="line">          path.append(pathNode + <span class="string">&quot;-&gt;&quot;</span> + <span class="built_in">str</span>(node.right.val))</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> node.left:</span><br><span class="line">          stack.append(node.left)</span><br><span class="line">          path.append(pathNode + <span class="string">&quot;-&gt;&quot;</span> + <span class="built_in">str</span>(node.left.val))</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="思考">思考</h2><p>day14以及day15中都有求二叉树的高度的题目（实现起来不难），并且有一个求最大深度的题目（但当时是直接用“根节点的高度“），但它规避了求某个节点所在深度的问题</p><p>深度的定义：<strong>指从根节点到该节点的最长简单路径边的长度</strong></p><p>比如[3,9,20,7]，其中7所在深度为3，对应的路径为[3,20,7]长度也为3</p><p>那么问题可以变成如何求根节点到任意节点的路径，思路可以和本题很像，这题目的终止条件是“遇到叶子节点”才把路径添加到res；而可以扩展成，遇到“target节点”就把路径添加到res</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">binaryTreePaths</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], target: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        stack = <span class="built_in">list</span>()</span><br><span class="line">        path = <span class="built_in">list</span>()</span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        stack.append(root)</span><br><span class="line">        path.append(<span class="built_in">str</span>(root.val))</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            pathNode = path.pop()</span><br><span class="line">            <span class="comment"># 为了实现中、前、后，入栈需要使用中、后、前</span></span><br><span class="line">            <span class="comment"># 这里使用val数值判断，当然可以通过地址判断，从而唯一对应target</span></span><br><span class="line">            <span class="comment"># if node.val == target.val:</span></span><br><span class="line">            <span class="comment">#     res.append(pathNode)</span></span><br><span class="line">            <span class="comment"># 可以使用地址进行唯一的对应</span></span><br><span class="line">            <span class="keyword">if</span> node == target:</span><br><span class="line">                res.append(pathNode)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">                path.append(pathNode + <span class="string">&quot;-&gt;&quot;</span> + <span class="built_in">str</span>(node.right.val))</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">                path.append(pathNode + <span class="string">&quot;-&gt;&quot;</span> + <span class="built_in">str</span>(node.left.val))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">root = TreeNode(<span class="number">1</span>)</span><br><span class="line">root.left = TreeNode(<span class="number">2</span>)</span><br><span class="line">root.right = TreeNode(<span class="number">3</span>)</span><br><span class="line">target = TreeNode(<span class="number">5</span>)</span><br><span class="line">root.left.left = target</span><br><span class="line"><span class="built_in">print</span>(so.binaryTreePaths(root, target))</span><br></pre></td></tr></table></figure><p>输入root为[1,2,3,null,5]，target为[5]</p><p>输出[‘1-&gt;2-&gt;5’]，从而得知5的深度为3</p><h1 id="404-左叶子之和">404. 左叶子之和</h1><p><a href="https://leetcode.cn/problems/sum-of-left-leaves/">https://leetcode.cn/problems/sum-of-left-leaves/</a></p><p>给定二叉树的根节点 <code>root</code> ，返回所有左叶子之和。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/04/08/leftsum-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [3,9,20,null,null,15,7] </span><br><span class="line">输出: 24 </span><br><span class="line">解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [1]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li>节点数在 <code>[1, 1000]</code> 范围内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h2 id="递归思路">递归思路</h2><p>这题目要求是求“左子树之和”，如图所示；</p><p><img src="https://file1.kamacoder.com/i/algo/20220902165805.png" alt="img"></p><p>可以使用递归的后序遍历</p><ol><li>终止条件：if not node: return 0</li><li>输入输出：输入为node，输出为int，表示当前节点的左叶子之和</li><li>单层递归逻辑：求左子树的左叶子和、右子树的左叶子之和，再将两者相加，得到了当前节点的左叶子之和（这也是使用后序遍历的原因）</li></ol><p>但有个不同点，如何判断当前节点是父节点的左叶子；</p><p>可以当父节点是当前节点时，判断node.left.left和node.left.right是否为空，判断当前的左子节点是否为空，<strong>如果其左子节点是叶子，则当前节点的左子树之和就是node.left.val</strong></p><h2 id="递归代码">递归代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(H)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postOrder</span>(<span class="params">self, node: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 终止条件</span></span><br><span class="line">        <span class="comment"># 如果当前节点为空，则返回0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 终止条件二，找到了叶子节点，返回零，因为它的左右子树为空(Optional，不写这个终止条件也行，无非是多递归一层)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 需要在当前节点，判断，它的左子节点是否为空，如果不为空，则判断它左子节点是否为叶子节点</span></span><br><span class="line">        <span class="comment"># 左子树</span></span><br><span class="line">        sumOfLeft = self.postOrder(node.left)</span><br><span class="line">        <span class="comment"># 左子树的特殊情况，即“左叶子节点”，此时才能将 sumOfLeft 设置为 node.left.val</span></span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left.left <span class="keyword">and</span> <span class="keyword">not</span> node.left.right:</span><br><span class="line">                sumOfLeft = node.left.val</span><br><span class="line">        <span class="comment"># 右</span></span><br><span class="line">        sumOfRight = self.postOrder(node.right)</span><br><span class="line">        <span class="comment"># 中，求合</span></span><br><span class="line">        <span class="keyword">return</span> sumOfLeft + sumOfRight</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumOfLeftLeaves</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 使用后序遍历，目标是从收集左子树和右子树的“左叶子之和”，再将总和相加</span></span><br><span class="line">        <span class="keyword">return</span> self.postOrder(root)</span><br></pre></td></tr></table></figure><h2 id="迭代思路">迭代思路</h2><ol><li>仍然使用后序遍历，注意入栈时，先中、再右、最后左，这样才能让出栈时的顺序为“左、右、中”</li><li>迭代的过程看着更简单一点儿</li><li>使用前序/中序也可以完成任务，而且这题目对实际顺序不敏感</li><li>比如入栈顺序为[中，右，左]、[中，左，右]、[左，中，右]、[右，中，左]、[左，右，中]、[右，左，中]都可以</li></ol><h2 id="迭代代码">迭代代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(H),最坏O(N)，最好O(logN)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sumOfLeftLeaves</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="comment"># 使用后序遍历（迭代）</span></span><br><span class="line">    stack = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    stack.append(root)</span><br><span class="line">    sumLeftLeaves = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.left.left <span class="keyword">and</span> <span class="keyword">not</span> node.left.right:</span><br><span class="line">            sumLeftLeaves += node.left.val</span><br><span class="line">        <span class="comment"># 注意使用栈时的入栈顺序，先right再left</span></span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            stack.append(node.right)</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            stack.append(node.left)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sumLeftLeaves</span><br></pre></td></tr></table></figure><p>这题目使用前序也可以，如果使用栈+迭代，最好从while的底层向上读代码来理解实际的输出顺序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sumOfLeftLeaves</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    stack = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    stack.append(root)</span><br><span class="line">    sumLeftLeaves = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">      <span class="comment"># 前序，后入先出</span></span><br><span class="line">        node = stack.pop()</span><br><span class="line">        <span class="comment"># 保持&quot;右，左，中“入栈，才能得到“中左右”的效果</span></span><br><span class="line">        <span class="comment"># 处理右</span></span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            stack.append(node.right)</span><br><span class="line">        <span class="comment"># 处理左</span></span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            stack.append(node.left)</span><br><span class="line">        <span class="comment"># 处理中</span></span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.left.left <span class="keyword">and</span> <span class="keyword">not</span> node.left.right:</span><br><span class="line">            sumLeftLeaves += node.left.val</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sumLeftLeaves</span><br></pre></td></tr></table></figure><h1 id="222-完全二叉树的节点个数">222. 完全二叉树的节点个数</h1><p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">https://leetcode.cn/problems/count-complete-tree-nodes/</a></p><p>给你一棵 <strong>完全二叉树</strong> 的根节点 <code>root</code> ，求出该树的节点个数。</p><p><a href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin">完全二叉树</a> 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 <code>h</code> 层（从第 0 层开始），则该层包含 <code>1~ 2h</code> 个节点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/14/complete.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3,4,5,6]</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目范围是<code>[0, 5 * 104]</code></li><li><code>0 &lt;= Node.val &lt;= 5 * 104</code></li><li>题目数据保证输入的树是 <strong>完全二叉树</strong></li></ul><p>**进阶：**遍历树来统计节点是一种时间复杂度为 <code>O(n)</code> 的简单解决方案。你可以设计一个更快的算法吗？</p><h2 id="普通树处理思路">普通树处理思路</h2><ol><li>不管它是什么树，直接用前/中/后/层序遍历处理（递归）就行</li><li>递归输入：节点，输出：子树的节点个数</li><li>终止条件：节点为空返回0</li><li>单层逻辑：求左、右子树节点个数，再计算总和并加一</li></ol><h2 id="普通树的递归代码">普通树的递归代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(H) – 最坏O(N)，最好O(logN)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 使用递归求解, 尝试后序</span></span><br><span class="line">    <span class="comment"># 返回子树的节点个数, 如果当前普通树处理，时间复杂度为O(N)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postOrder</span>(<span class="params">self, node: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        countOfLeft = self.postOrder(node.left)</span><br><span class="line">        countOfRight = self.postOrder(node.right)</span><br><span class="line">        <span class="keyword">return</span> countOfLeft + countOfRight + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countNodes</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.postOrder(root)</span><br></pre></td></tr></table></figure><h2 id="普通树的迭代代码">普通树的迭代代码</h2><p>使用前序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">countNodes</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="comment"># 使用栈+迭代实现</span></span><br><span class="line">    stack = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    stack.append(root)</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            stack.append(node.right)</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            stack.append(node.left)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p>使用层序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">countNodes</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:      </span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">      que = deque()</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">      que.append(root)</span><br><span class="line">      count = <span class="number">0</span></span><br><span class="line">      <span class="keyword">while</span> que:</span><br><span class="line">          node = que.popleft()</span><br><span class="line">          count += <span class="number">1</span></span><br><span class="line">          <span class="keyword">if</span> node.right:</span><br><span class="line">              que.append(node.right)</span><br><span class="line">          <span class="keyword">if</span> node.left:</span><br><span class="line">              que.append(node.left)</span><br><span class="line">          </span><br><span class="line">      <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h2 id="完成二叉树思路">完成二叉树思路</h2><p>在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^(h-1)  个节点。</p><p><img src="https://file1.kamacoder.com/i/algo/20200920221638903-20230310123444151.png" alt="img"></p><p>完全二叉树只有两种情况，情况一：就是满二叉树，情况二：最后一层叶子节点没有满。</p><p>对于情况一，可以直接用 2^树深度 - 1 来计算，注意这里根节点深度为1。</p><p>对于情况二，分别递归左孩子，和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后依然可以按照情况1来计算。</p><p>完全二叉树（一）如图：</p><p><img src="https://file1.kamacoder.com/i/algo/20201124092543662.png" alt="img"></p><p>完全二叉树（二）如图：</p><p><img src="https://file1.kamacoder.com/i/algo/20201124092634138.png" alt="img"></p><p>可以看出如果整个树不是满二叉树，就递归其左右孩子，直到遇到满二叉树为止，用公式计算这个子树（满二叉树）的节点数量。</p><p>这里关键在于<strong>如何去判断一个左子树或者右子树是不是满二叉树呢？</strong> —如果<strong>递归向左遍历的深度等于递归向右遍历的深度</strong>，那说明就是满二叉树</p><p>顺便提一句，如何判断一个树是否为平衡二叉树？----判断左、右子树的高度差，如果高度差大于1则不是</p><p><img src="https://file1.kamacoder.com/i/algo/20220829163554.png" alt="img"></p><p>下面这图中“向右遍历的深度为2”指的是，令rightNode = node.right，并且循环rightNode = rightNode.right并count+=1，一路向右，如果出现了“非满二叉树”就出出现深度为2，否则深度一定为3；就像左边一样</p><blockquote><p>通过<strong>leftNode一路向左，rightNode一路向右</strong>，来判断子树的深度是否一样，是否是满二叉树</p><p>之所以能用<strong>leftNode一路向左，rightNode一路向右</strong>，也是利用了完全二叉树的性质</p></blockquote><p><img src="https://file1.kamacoder.com/i/algo/20220829163709.png" alt="img"></p><h2 id="完全二叉树代码">完全二叉树代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countNum</span>(<span class="params">self, node: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        leftNode = node.left</span><br><span class="line">        rightNode = node.right</span><br><span class="line">        <span class="comment"># 求左、右子树的深度</span></span><br><span class="line">        leftDepth = <span class="number">0</span></span><br><span class="line">        rightDepth = <span class="number">0</span></span><br><span class="line">        <span class="comment"># leftNode一路向左</span></span><br><span class="line">        <span class="keyword">while</span> leftNode:</span><br><span class="line">            leftNode = leftNode.left</span><br><span class="line">            leftDepth += <span class="number">1</span></span><br><span class="line">        <span class="comment"># rightNode一路向右</span></span><br><span class="line">        <span class="keyword">while</span> rightNode:</span><br><span class="line">            rightNode = rightNode.right</span><br><span class="line">            rightDepth += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 满二叉树</span></span><br><span class="line">        <span class="keyword">if</span> leftDepth == rightDepth:</span><br><span class="line">            <span class="comment"># 直接返回总数2^D - 1</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="number">2</span> &lt;&lt; leftDepth) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 单层逻辑</span></span><br><span class="line">        leftNum = self.countNum(node.left)</span><br><span class="line">        rightNum = self.countNum(node.right)</span><br><span class="line">        <span class="keyword">return</span> leftNum + rightNum + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">countNodes</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 完全二叉树统计</span></span><br><span class="line">        <span class="keyword">return</span> self.countNum(root)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday15二叉树part03&quot;&gt;LeetCodeCampsDay15二叉树part03&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;涉及树的高度/深度求解，以及平衡二叉树的判断，完全二叉树求节点个数；&lt;/p&gt;
&lt;p&gt;根节点到任意节点的路径/</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
    <category term="二叉树" scheme="https://blog.lthero.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>gitSwitchAccount</title>
    <link href="https://blog.lthero.cn/2025/07/09/gitSwitchAccount/"/>
    <id>https://blog.lthero.cn/2025/07/09/gitSwitchAccount/</id>
    <published>2025-07-09T03:32:11.000Z</published>
    <updated>2025-07-10T01:36:22.348Z</updated>
    
    <content type="html"><![CDATA[<p>起因是本地git存在多个账号,提交时显示登录的是lthero-g,我需要切换回lthero-big</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lthero@LtherodeMac-mini HiFi-Mark % git push</span><br><span class="line">remote: Permission to lthero-big/HiFi-Mark.git denied to Lthero-g.</span><br><span class="line">fatal: unable to access &#x27;https://github.com/lthero-big/HiFi-Mark/&#x27;: The requested URL returned error: 403</span><br></pre></td></tr></table></figure><p>These should reflect the lthero-big account. If not, update them:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config user.name &quot;lthero-big&quot;</span><br><span class="line"></span><br><span class="line">git config user.email &quot;email-associated-with-lthero-big&quot;</span><br></pre></td></tr></table></figure><p><strong>Update Remote URL to Include lthero-big Credentials</strong> Modify the repository’s remote URL to explicitly include the lthero-big username:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin https://lthero-big@github.com/lthero-big/HiFi-Mark.git</span><br></pre></td></tr></table></figure><p>This forces Git to authenticate as lthero-big. When you push, Git will prompt for the password or use a stored token.</p><p><strong>Clear Cached Credentials</strong> Your system may have cached Lthero-g credentials. Clear them:</p><ul><li><p>On macOS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git credential-osxkeychain erase</span><br></pre></td></tr></table></figure><p>Then enter:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">host=github.com</span><br><span class="line">protocol=https</span><br></pre></td></tr></table></figure><p>Press Enter twice to clear the cached credentials.</p></li><li><p>Alternatively, open <strong>Keychain Access</strong>, search for <a href="http://github.com">github.com</a>, and delete entries related to Lthero-g.</p></li></ul><p><strong>H Key</strong> (recommended for frequent use):</p><ul><li><p>Generate an SSH key for</p><p>lthero-big</p><p>if not already set up:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t ed25519 -C &quot;email-associated-with-lthero-big&quot;</span><br></pre></td></tr></table></figure><p>Save it (e.g., ~/.ssh/id_ed25519_lthero_big).</p></li><li><p>Add the public key to GitHub under <strong>Settings &gt; SSH and GPG keys</strong>. <a href="https://github.com/settings/keys">https://github.com/settings/keys</a></p></li><li><p>Update the remote URL to use SSH:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin git@github.com:lthero-big/HiFi-Mark.git</span><br></pre></td></tr></table></figure></li><li><p>Ensure the correct SSH key is used by configuring</p><p>~/.ssh/config</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host github.com-lthero-big</span><br><span class="line">    HostName github.com</span><br><span class="line">    User git</span><br><span class="line">    IdentityFile ~/.ssh/id_ed25519_lthero_big</span><br></pre></td></tr></table></figure><p>Update the remote URL:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin git@github.com-lthero-big:lthero-big/HiFi-Mark.git</span><br></pre></td></tr></table></figure></li></ul><p>最后，输入<code>ssh -T git@github.com</code> 来验证是否是lthero-big</p><p>这样操作下来，可以解决账号切换的问题，<code>git credential-osxkeychain erase</code>应该是关键步骤</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;起因是本地git存在多个账号,提交时显示登录的是lthero-g,我需要切换回lthero-big&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay14-二叉树part02</title>
    <link href="https://blog.lthero.cn/2025/07/08/LeetCodeCampsDay14/"/>
    <id>https://blog.lthero.cn/2025/07/08/LeetCodeCampsDay14/</id>
    <published>2025-07-08T05:39:14.000Z</published>
    <updated>2025-07-09T08:39:01.061Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday14-二叉树part02">LeetCodeCampsDay14-二叉树part02</h1><blockquote><p>继续使用深度/广度遍历解决问题，包含迭代&amp;递归的方法</p></blockquote><h1 id="翻转二叉树">翻转二叉树</h1><p><a href="https://leetcode.cn/problems/invert-binary-tree/">https://leetcode.cn/problems/invert-binary-tree/</a></p><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [2,1,3]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目范围在 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h2 id="递归思路">递归思路</h2><p><img src="https://file1.kamacoder.com/i/algo/20210203192724351.png" alt="img"></p><p>可以发现想要翻转它，其实就把每一个节点的左右孩子交换一下就可以了。</p><ol><li>可以按“前序/中序/后序”的方法，将中间节点进行“调换”，然后用递归的方式去处理左、右子树</li><li>递归三步走：返回值与输入值；终止条件（传入node为空）；单层递归的逻辑（调换node的左右子树，再执行递归处理左、右子树）</li></ol><h2 id="递归代码">递归代码</h2><h3 id="前序递归">前序递归</h3><ul><li>时间复杂度O(N)</li><li>空间复杂度O(h)，其中，h为树的高度，最坏情况下递归栈的空间用调用O(N)；而最好情况下，即平衡二叉树O(logN)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">self, node: TreeNode</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 中, 交换两个节点</span></span><br><span class="line">        node.left, node.right = node.right, node.left</span><br><span class="line">        self.traverse(node.left) <span class="comment">#左</span></span><br><span class="line">        self.traverse(node.right)<span class="comment">#右</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        self.traverse(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h3 id="中序递归">中序递归</h3><p><strong>这道题目使用前序遍历和后序遍历都可以，唯独中序遍历不方便，因为中序遍历会把某些节点的左右孩子翻转了两次！建议拿纸画一画，就理解了</strong></p><p>这题目如果使用中序遍历，需要修改逻辑</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">self, node: TreeNode</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        self.traverse(node.left)  <span class="comment">#原左子树</span></span><br><span class="line">        <span class="comment"># 中, 交换两个节点</span></span><br><span class="line">        node.left, node.right = node.right, node.left</span><br><span class="line">        self.traverse(node.left)  <span class="comment">#原右子树，因为刚刚发生了左右翻转，原来的右子树现在是left</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        self.traverse(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h3 id="后序递归">后序递归</h3><p>后序递归不用进行特殊处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">self, node: TreeNode</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        self.traverse(node.left) <span class="comment">#左</span></span><br><span class="line">        self.traverse(node.right)<span class="comment">#右</span></span><br><span class="line">        <span class="comment"># 中, 交换两个节点</span></span><br><span class="line">        node.left, node.right = node.right, node.left</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        self.traverse(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>当然，还可以使用栈的方式做这题目（栈+迭代，可以达到递归的效果）</p><h2 id="迭代代码-标记法">迭代代码(标记法)</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(h)–和递归一样，最坏情况为O(N)，最好情况为O(logN)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">    stack = [(root, <span class="literal">False</span>)] <span class="keyword">if</span> root <span class="keyword">else</span> []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node, visit_status = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> visit_status:</span><br><span class="line">            node.left, node.right = node.right, node.left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stack.append((node, <span class="literal">True</span>))</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append((node.left, <span class="literal">False</span>))</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append((node.right, <span class="literal">False</span>))</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>当然，也可以使用普通的迭代方法，下面是前序迭代遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">    stack = <span class="built_in">list</span>()</span><br><span class="line">    stack.append(root)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        <span class="comment"># 将结果记录到res的步骤替换成节点交换即可</span></span><br><span class="line">        node.left, node.right = node.right, node.left</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            stack.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            stack.append(node.right)</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h1 id="对称二叉树">对称二叉树</h1><p><a href="https://leetcode.cn/problems/symmetric-tree/">https://leetcode.cn/problems/symmetric-tree/</a></p><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><p><strong>示例 1：</strong></p><p><img src="https://pic.leetcode.cn/1698026966-JDYPDU-image.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,2,3,4,4,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://pic.leetcode.cn/1698027008-nPFLbM-image.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,2,null,3,null,3]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[1, 1000]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p>**进阶：**你可以运用递归和迭代两种方法解决这个问题吗？</p><h2 id="思路">思路</h2><ol><li>如果使用递归的方法解决，仍然需要解决三个问题<ol><li>输入与输出；因为需要判断二叉树是否对称，每次需要判断“左、右”两个节点是否相等，所以输入是leftNode, rightNode</li><li>终止条件：如果leftNode和rightNode都为空，也算是True；leftNode不空而rightNode为空，算False；leftNode为空而rightNode不空，算False；若leftNode和rightNode都不空，但数值不相同，也算False；只有当leftNode和rightNode数值相等时，才进行它俩的子树判断</li><li>单层递归的操作逻辑：先判断终止条件；当leftNode和rightNode数值相等时，才进行它俩的子树判断，这里要判断<ol><li>leftNode的左子树与rightNode的右子树是否相等（外部判断）</li><li>leftNode的右子树与rightNode的左子树是否相等（内部判断）</li><li>只有内、外都相等时才返回True</li></ol></li></ol></li></ol><p><img src="https://file1.kamacoder.com/i/algo/20210203144624414.png" alt="img"></p><h2 id="代码">代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(h)—同样，因为递归调用的空间取决于树的深度，最差情况是O(N)，最好情况是O(logN)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">self, leftNode: TreeNode, rightNode: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> leftNode <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> rightNode <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> leftNode <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> rightNode <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> leftNode <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> rightNode <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> leftNode.val != rightNode.val:  <span class="comment"># 如果都不为空，此时需要判断数值是否相等</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 都不为空，而且数值相等</span></span><br><span class="line">            outSide = self.traverse(leftNode.left, rightNode.right)</span><br><span class="line">            inSide = self.traverse(leftNode.right, rightNode.left)</span><br><span class="line">            res = outSide <span class="keyword">and</span> inSide <span class="comment"># 仅当内部与外部同时相等时，二叉树才是对称的</span></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.traverse(root.left, root.right)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="迭代思路">迭代思路</h2><ol><li>使用队列或栈，每次从栈/队列中取出两个节点，判断它们是否（值一样或都为空），然后再判断他俩的内、外子树是否一致</li></ol><p><img src="https://file1.kamacoder.com/i/algo/101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.gif" alt="img"></p><h2 id="栈-迭代代码">栈+迭代代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(h)—同样，因为栈占用的空间取决于树的深度，最差情况是O(N)，最好情况是O(logN)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    stack = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    stack.append(root.left)</span><br><span class="line">    stack.append(root.right)</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        <span class="comment"># 这里将pop出来的顺序先给rightNode或先出leftNode都可以，效果一样，因为后面的代码是对称的</span></span><br><span class="line">        rightNode = stack.pop()</span><br><span class="line">        leftNode = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> leftNode <span class="keyword">and</span> <span class="keyword">not</span> rightNode:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> leftNode <span class="keyword">or</span> <span class="keyword">not</span> rightNode <span class="keyword">or</span> leftNode.val != rightNode.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 仅当两个节点值相等时，再判断它的内、外</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 进行外部判断</span></span><br><span class="line">        stack.append(leftNode.left)</span><br><span class="line">        stack.append(rightNode.right)</span><br><span class="line">        <span class="comment"># 进行内部判断</span></span><br><span class="line">        stack.append(leftNode.right)</span><br><span class="line">        stack.append(rightNode.left)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="队列-迭代代码">队列+迭代代码</h2><p>把栈（list)换成队列即可</p><ul><li>时间复杂度O(N)</li><li>空间复杂度O(h)—同样，因为队列占用的空间取决于树的深度，最差情况是O(N)，最好情况是O(logN)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用队列</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">que = deque()</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">que.append(root.left)</span><br><span class="line">que.append(root.right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> que:</span><br><span class="line">    <span class="comment"># 弹出两个节点</span></span><br><span class="line">    leftNode = que.popleft()</span><br><span class="line">    rightNode = que.popleft()</span><br><span class="line">    <span class="comment"># 判断是否相等（同样为空也是可以的）</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> leftNode <span class="keyword">and</span> <span class="keyword">not</span> rightNode:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="comment"># 如果不相等直接返回False</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> leftNode <span class="keyword">or</span> <span class="keyword">not</span> rightNode <span class="keyword">or</span> leftNode.val != rightNode.val:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果值相等，再判断它俩的内、外子树</span></span><br><span class="line">    que.append(leftNode.left)</span><br><span class="line">    que.append(rightNode.right)</span><br><span class="line"></span><br><span class="line">    que.append(leftNode.right)</span><br><span class="line">    que.append(rightNode.left)</span><br><span class="line"><span class="comment"># 如果都没问题，才返回True</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="层序思路">层序思路</h2><ol><li>使用一个队列deque遍历每个节点</li><li>每层再使用一个list，将每层的节点都装进来，并且每层结束后进行清算，如果这层不是对称的，则直接返回False</li></ol><h2 id="层序遍历代码">层序遍历代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(h)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">que = deque()</span><br><span class="line">que.append(root.left)</span><br><span class="line">que.append(root.right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> que:</span><br><span class="line">    levelSize = <span class="built_in">len</span>(que)</span><br><span class="line">    <span class="keyword">if</span> levelSize % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    levelRes = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(levelSize):</span><br><span class="line">        node = que.popleft()</span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            levelRes.append(node.val)</span><br><span class="line">            que.append(node.left)</span><br><span class="line">            que.append(node.right)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            levelRes.append(<span class="literal">None</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 对每层进行清算，如果levelRes不是一个对称列表，则返回False</span></span><br><span class="line">    <span class="keyword">if</span> levelRes != levelRes[::-<span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h1 id="相同的树">相同的树</h1><p><a href="https://leetcode.cn/problems/same-tree/">https://leetcode.cn/problems/same-tree/</a></p><p>给你两棵二叉树的根节点 <code>p</code> 和 <code>q</code> ，编写一个函数来检验这两棵树是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：p = [1,2,3], q = [1,2,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：p = [1,2], q = [1,null,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：p = [1,2,1], q = [1,1,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>两棵树上的节点数目都在范围 <code>[0, 100]</code> 内</li><li><code>-104 &lt;= Node.val &lt;= 104</code></li></ul><h2 id="递归思路">递归思路</h2><ol><li>和对称二叉树几乎一样，先取两个节点，判断两个节点值是否一样（如果都为空直接就True）</li><li>如果两个节点值一样，再判断他俩的子树，leftNode.left是否等于rightNode.left；并且leftNode.right是否等于rightNode.right；这里和对称二叉树是不一样的，对称二叉树需要判断“内部是否相等，外部是否相等”</li></ol><h2 id="递归代码">递归代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(h)—取决于深度；最坏O(N),最好O(logN)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">self, leftNode: TreeNode, rightNode: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> leftNode <span class="keyword">and</span> <span class="keyword">not</span> rightNode:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> leftNode <span class="keyword">and</span> rightNode:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> leftNode <span class="keyword">and</span> <span class="keyword">not</span> rightNode:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> leftNode.val != rightNode.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 当前两个节点值相同，需要判断它俩的内、外子树是否相等（这里和对称不一样）</span></span><br><span class="line">            outSide = self.traverse(leftNode.left, rightNode.left)</span><br><span class="line">            inSide = self.traverse(leftNode.right, rightNode.right)</span><br><span class="line">            <span class="keyword">return</span> outSide <span class="keyword">and</span> inSide</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSameTree</span>(<span class="params">self, p: <span class="type">Optional</span>[TreeNode], q: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> self.traverse(p, q)</span><br></pre></td></tr></table></figure><h2 id="栈-迭代代码">栈+迭代代码</h2><p>大体思路和递归差不多；主要是终止条件判断，单层逻辑（判断左边是否一样，判断右边是否一样）；两种方法的代码结构几乎一样</p><ul><li>时间复杂度O(N)</li><li>空间复杂度O(h)—取决于深度；最坏O(N),最好O(logN)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isSameTree</span>(<span class="params">self, p: <span class="type">Optional</span>[TreeNode], q: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="comment"># return self.traverse(p, q)</span></span><br><span class="line"></span><br><span class="line">    stack = <span class="built_in">list</span>()</span><br><span class="line">    stack.append(p)</span><br><span class="line">    stack.append(q)</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        rightNode = stack.pop()</span><br><span class="line">        leftNode = stack.pop()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> leftNode <span class="keyword">and</span> <span class="keyword">not</span> rightNode:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> leftNode <span class="keyword">and</span> rightNode:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> leftNode <span class="keyword">and</span> <span class="keyword">not</span> rightNode:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> leftNode.val != rightNode.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 判断左边是否一样</span></span><br><span class="line">            stack.append(leftNode.left)</span><br><span class="line">            stack.append(rightNode.left)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 判断右边是否一样</span></span><br><span class="line">            stack.append(leftNode.right)</span><br><span class="line">            stack.append(rightNode.right)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h1 id="另一棵树的子树">另一棵树的子树</h1><p><a href="https://leetcode.cn/problems/subtree-of-another-tree/">https://leetcode.cn/problems/subtree-of-another-tree/</a></p><p>给你两棵二叉树 <code>root</code> 和 <code>subRoot</code> 。检验 <code>root</code> 中是否包含和 <code>subRoot</code> 具有相同结构和节点值的子树。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>二叉树 <code>tree</code> 的一棵子树包括 <code>tree</code> 的某个节点和这个节点的所有后代节点。<code>tree</code> 也可以看做它自身的一棵子树。</p><p><strong>示例 1：</strong></p><p><img src="https://pic.leetcode.cn/1724998676-cATjhe-image.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,4,5,1,2], subRoot = [4,1,2]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://pic.leetcode.cn/1724998698-sEJWnq-image.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>root</code> 树上的节点数量范围是 <code>[1, 2000]</code></li><li><code>subRoot</code> 树上的节点数量范围是 <code>[1, 1000]</code></li><li><code>-104 &lt;= root.val &lt;= 104</code></li><li><code>-104 &lt;= subRoot.val &lt;= 104</code></li></ul><h2 id="暴力思路">暴力思路</h2><ol><li>使用前/中/后序进行遍历，并且对每个节点进行匹配</li></ol><h2 id="暴力代码">暴力代码</h2><ul><li>时间复杂度O(N*M)，N为root节点数，M为subRoot节点数</li><li>空间复杂度O(H)，然后取决于root树的高度</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSame</span>(<span class="params">self, leftNode, rightNode</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> leftNode <span class="keyword">and</span> <span class="keyword">not</span> rightNode:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> leftNode <span class="keyword">or</span> <span class="keyword">not</span> rightNode <span class="keyword">or</span> leftNode.val != rightNode.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            leftSideSame = self.isSame(leftNode.left, rightNode.left)</span><br><span class="line">            rightSideSame = self.isSame(leftNode.right, rightNode.right)</span><br><span class="line">            <span class="keyword">return</span> leftSideSame <span class="keyword">and</span> rightSideSame</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSubtree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], subRoot: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 明确了只可能root包含subRoot，其中判断子树是否一样和100.相同的树同样的思路</span></span><br><span class="line">        <span class="comment"># 最暴力的写法是每个root节点都检测一遍</span></span><br><span class="line">        <span class="comment"># 前序遍历(标记法)</span></span><br><span class="line">        stack = [(root, <span class="literal">False</span>)] <span class="keyword">if</span> root <span class="keyword">else</span> []</span><br><span class="line">        res = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node, visited = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> visited:</span><br><span class="line">                res = self.isSame(node, subRoot)</span><br><span class="line">                <span class="keyword">if</span> res:</span><br><span class="line">                    <span class="built_in">print</span>(node)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 前序</span></span><br><span class="line">                stack.append((node, <span class="literal">True</span>))</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    stack.append((node.left, <span class="literal">False</span>))</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    stack.append((node.right, <span class="literal">False</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">           </span><br></pre></td></tr></table></figure><h2 id="kmp匹配思路">KMP匹配思路</h2><ol><li>如果先使用前/中/后序将root与subRoot遍历一遍，<strong>得到的不就是两串字符串序列</strong>，然后就可以使用KMP匹配方法解决</li><li>但，这里有个需要注意的点，不能使用常规的前/中/后序遍历，而是需要使用下面这种方式：引入两个空值 <code>lNull</code> 和 <code>rNull</code>，当一个节点的左孩子或者右孩子为空的时候，就插入这两个空值，这样<strong>深度优先搜索序列就唯一对应一棵树</strong><ol><li>比如[4,1,2]得到的前序遍历是[4,1,lNone,rNone,2,lNone,rNone]</li><li>而[4,1]得到的前序遍历是[4,1,lNone,rNone,rNone]</li></ol></li><li>如果不这样做，会遇到一类错误，比如root是[3,4,5,1,2,null,null,null,null,0]；而subRoot是[4,1,2]</li><li><img src="https://cdn.lthero.cn/post_images/course/MLimage-20250708155426830.png" alt="image-20250708155426830"><ol><li>使用普通前序遍历后，得到[3, 4, 1,  2,  0,  5]和[4,1,2]，如果直接使用KMP进行匹配，会得到True的错误结果；</li><li>使用修改后的前序遍历，得到[3, <strong>4, ‘r’, ‘l’, 1, ‘r’, 2, ‘r’, ‘l’</strong>, 0, ‘r’, ‘l’, 5] 和 [4, ‘r’, ‘l’, 1, ‘r’, ‘l’, 2]，此时再用KMP匹配就正确了</li></ol></li></ol><p><img src="https://assets.leetcode-cn.com/solution-static/572/572_fig1.png" alt="img"></p><h2 id="kmp代码">KMP代码</h2><ul><li>时间复杂度O(N+M)</li><li>空间复杂度O(N)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 需要对这个前序遍历进行修改，引入lNone与rNone两个值，当一个节点的左/右节点为空，就赋值这个空值</span></span><br><span class="line">    <span class="comment"># 这样好处是产生“唯一”的对应树</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preOrder</span>(<span class="params">self, root</span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        stack = [(root, <span class="literal">False</span>)] <span class="keyword">if</span> root <span class="keyword">else</span> []</span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node, visited = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> visited:</span><br><span class="line">                res.append(node.val)</span><br><span class="line">                <span class="comment"># 在这里修改，当一个节点的左/右节点为空，就赋值这个空值</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node.left:</span><br><span class="line">                    res.append(<span class="string">&quot;l&quot;</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                    res.append(<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 前序</span></span><br><span class="line">                stack.append((node, <span class="literal">True</span>))</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    stack.append((node.left, <span class="literal">False</span>))</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    stack.append((node.right, <span class="literal">False</span>))</span><br><span class="line">        <span class="comment"># 需要反转</span></span><br><span class="line">        res = res[::-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getNext</span>(<span class="params">self, s: <span class="built_in">list</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        L = <span class="built_in">len</span>(s)</span><br><span class="line">        nextArray = [<span class="number">0</span>] * L</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L):</span><br><span class="line">            <span class="keyword">while</span> left &gt; <span class="number">0</span> <span class="keyword">and</span> s[left] != s[right]:</span><br><span class="line">                left = nextArray[left - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> s[left] == s[right]:</span><br><span class="line">                left = left + <span class="number">1</span></span><br><span class="line">            nextArray[right] = left</span><br><span class="line">        <span class="keyword">return</span> nextArray</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSubtree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], subRoot: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        rootList = self.preOrder(root)</span><br><span class="line">        subRootList = self.preOrder(subRoot)</span><br><span class="line">        nextArray = self.getNext(subRootList)</span><br><span class="line">        <span class="comment"># print(rootList)</span></span><br><span class="line">        <span class="comment"># print(subRootList)</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        L_subRoot = <span class="built_in">len</span>(subRootList)</span><br><span class="line">        L_root = <span class="built_in">len</span>(rootList)</span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(L_root):</span><br><span class="line">            <span class="keyword">while</span> left &gt; <span class="number">0</span> <span class="keyword">and</span> rootList[right] != subRootList[left]:</span><br><span class="line">                left = nextArray[left - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> rootList[right] == subRootList[left]:</span><br><span class="line">                left = left + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left == L_subRoot:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>或者使用递归版本的前序遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">preOrderTraverse</span>(<span class="params">self, node, res</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    res.append(node.val)</span><br><span class="line">    <span class="keyword">if</span> node.left:</span><br><span class="line">        self.preOrderTraverse(node.left, res)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        res.append(<span class="string">&#x27;l&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> node.right:</span><br><span class="line">        self.preOrderTraverse(node.right, res)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        res.append(<span class="string">&#x27;r&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="二叉树的最大深度">二叉树的最大深度</h1><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">https://leetcode.cn/problems/maximum-depth-of-binary-tree/</a></p><p>给定一个二叉树 <code>root</code> ，返回其最大深度。</p><p>二叉树的 <strong>最大深度</strong> 是指从根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,null,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数量在 <code>[0, 104]</code> 区间内。</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h2 id="后序递归思路">后序递归思路</h2><p>补充下什么是深度与高度，这里要求“最大深度”，其实就是求“根节点的高度”</p><p><img src="https://file1.kamacoder.com/i/algo/20210203155515650.png" alt="img"></p><ol><li><strong>根节点的高度就是二叉树的最大深度</strong>，所以本题中我们通过后序求的<strong>根节点高度</strong>来求的二叉树最大深度</li><li>确定递归函数的参数和返回值：参数就是传入树的根节点，返回就返回这棵树的深度，所以返回值为int类型</li><li>确定终止条件：如果为空节点的话，就返回0，表示高度为0</li><li>确定单层递归的逻辑：先求它的左子树的深度，再求右子树的深度，最后取左右深度最大的数值 再+1 （加1是因为算上当前中间节点）就是目前节点为根节点的树的深度。</li></ol><p>所以这里的代码也同样是求高度的代码，还是比较好写的</p><p><strong>如果要求某个节点所在位置的深度</strong>，有个思路是，根节点到这个节点的路径是唯一的，可以求出这路径长度，即是深度；至于怎么求这个路径，可以参考day15的「二叉树的所有路径」</p><h2 id="后序递归代码">后序递归代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(h) 最坏情况O(N)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">self, node</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        leftDeepth = self.traverse(node.left)</span><br><span class="line">        rightDeepth = self.traverse(node.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(leftDeepth, rightDeepth) + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.traverse(root)</span><br></pre></td></tr></table></figure><h2 id="迭代思路">迭代思路</h2><ol><li>层序遍历就是最好求深度的过程</li></ol><h2 id="迭代代码">迭代代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(N)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    que = deque()</span><br><span class="line">    que.append(root)</span><br><span class="line">    level = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> que:</span><br><span class="line">        L = <span class="built_in">len</span>(que)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">            node = que.popleft()</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                que.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                que.append(node.right)</span><br><span class="line">        <span class="comment"># 每层的操作（结算）</span></span><br><span class="line">        level += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> level</span><br></pre></td></tr></table></figure><h1 id="n-叉树的最大深度">N 叉树的最大深度</h1><p><a href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/">https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/</a></p><p>给定一个 N 叉树，找到其最大深度。</p><p>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p><p>N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,null,3,2,4,null,5,6]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树的深度不会超过 <code>1000</code> 。</li><li>树的节点数目位于 <code>[0, 104]</code> 之间。</li></ul><h2 id="迭代思路">迭代思路</h2><ol><li>使用层序遍历，和二叉树的层序遍历求最大深度基本一样</li></ol><h2 id="迭代代码">迭代代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(N)  which can scale with the tree’s width. 最多是树的宽度</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val: Optional[int] = None, children: Optional[List[&#x27;Node&#x27;]] = None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.children = children</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 注意n叉树的子节点是个列表</span></span><br><span class="line">        <span class="comment"># 本题可以使用层序遍历</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        que = deque()</span><br><span class="line">        que.append(root)</span><br><span class="line">        levels = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            L = <span class="built_in">len</span>(que)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">                node = que.popleft()</span><br><span class="line">                <span class="keyword">for</span> eachNode <span class="keyword">in</span> node.children:</span><br><span class="line">                    que.append(eachNode)</span><br><span class="line">            levels += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> levels</span><br></pre></td></tr></table></figure><h2 id="递归代码">递归代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">self, node</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    deepthList = []</span><br><span class="line">    <span class="keyword">for</span> eachNode <span class="keyword">in</span> node.children:</span><br><span class="line">        deepthList.append(self.traverse(eachNode))</span><br><span class="line">    <span class="comment"># 除了这层本身还有它的子树，加max of 子树</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(deepthList):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(deepthList)</span><br><span class="line">    <span class="comment"># 这层本身</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="二叉树的最小深度">二叉树的最小深度</h1><p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">https://leetcode.cn/problems/minimum-depth-of-binary-tree/</a></p><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p>**说明：**叶子节点是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [2,null,3,null,4,null,5,null,6]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数的范围在 <code>[0, 105]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h2 id="递归后序思路">递归后序思路</h2><p>求最大深度时，使用了下面的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> leftDepth = getDepth(node-&gt;left);</span><br><span class="line"><span class="built_in">int</span> rightDepth = getDepth(node-&gt;right);</span><br><span class="line"><span class="built_in">int</span> result = <span class="number">1</span> + <span class="built_in">min</span>(leftDepth, rightDepth);</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><p><img src="https://file1.kamacoder.com/i/algo/111.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6.png" alt="img"></p><p>如果这么求的话，<strong>没有左孩子的分支会算为最短深度。</strong></p><p>所以，<strong>如果左子树为空，右子树不为空，说明最小深度是 1 + 右子树的深度</strong>。</p><p>反之，<strong>右子树为空，左子树不为空，最小深度是 1 + 左子树的深度。</strong></p><p>最后如果左右子树都不为空，返回左右子树深度最小值 + 1 。</p><p><strong>求二叉树的最小深度和求二叉树的最大深度的差别主要在于处理左右孩子不为空的逻辑。</strong></p><h2 id="递归后序代码">递归后序代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(H)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        leftDeepth = self.traverse(node.left)</span><br><span class="line">        rightDeepth = self.traverse(node.right)</span><br><span class="line">        <span class="comment"># 如果左节点为空，则求右节点的deepth+1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> node.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + rightDeepth</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.right <span class="keyword">and</span> node.left:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + leftDeepth</span><br><span class="line">        <span class="comment"># </span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(leftDeepth, rightDeepth) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.traverse(root)</span><br></pre></td></tr></table></figure><h2 id="迭代思路">迭代思路</h2><ol><li>使用层序遍历即可，但有个退出条件：</li><li>if not node.right and not node.left:<ol><li>return levels</li></ol></li></ol><p>不加这行就报错，因为那样就会变成求最大深度了而不是“最小深度”</p><p>比如这个例子，如果不加这行，会输出3而不是2</p><p><img src="https://cdn.lthero.cn/post_images/course/MLimage-20250708181016447.png" alt="image-20250708181016447"></p><h2 id="迭代代码">迭代代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">minDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="comment"># 使用迭代法（层序）</span></span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">    que = deque()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    que.append(root)</span><br><span class="line">    levels = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> que:</span><br><span class="line">        L = <span class="built_in">len</span>(que)</span><br><span class="line">        levels += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">            node = que.popleft()</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                que.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                que.append(node.right)</span><br><span class="line">            <span class="comment"># 当左右孩子都为空的时候，说明是最低点的一层了，退出</span></span><br><span class="line">            <span class="comment"># 不加这行就报错，因为那样就会变成求最大深度了而不是“最小深度”</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.right <span class="keyword">and</span> <span class="keyword">not</span> node.left:</span><br><span class="line">                <span class="keyword">return</span> levels</span><br><span class="line">    <span class="keyword">return</span> levels</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday14-二叉树part02&quot;&gt;LeetCodeCampsDay14-二叉树part02&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;继续使用深度/广度遍历解决问题，包含迭代&amp;amp;递归的方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
    <category term="二叉树" scheme="https://blog.lthero.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay13-二叉树part01</title>
    <link href="https://blog.lthero.cn/2025/07/07/LeetCodeCampsDay13/"/>
    <id>https://blog.lthero.cn/2025/07/07/LeetCodeCampsDay13/</id>
    <published>2025-07-07T04:15:53.000Z</published>
    <updated>2025-07-11T12:09:52.927Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday13-二叉树part01">LeetCodeCampsDay13-二叉树part01</h1><blockquote><p>二叉树的遍历，前序/中序/后序/层序，以及迭代、递归等方法实现</p></blockquote><h1 id="二叉树的递归遍历">二叉树的递归遍历</h1><p>二叉树的递归遍历，或者说“所有的递归”都离不开三个因素</p><ol><li>确定递归函数的input与output(参数与返回值)</li><li>终止条件</li><li>单层递归的逻辑</li></ol><p>以中序遍历为例</p><ol><li><p>确定递归函数的参数与返回值：</p><ol><li>需要有“当前节点”，其次，需要将中序遍历的结果放在res数组中;可以不返回</li><li><code>def traversal(cur: TreeNode, res: List): ..... return</code></li></ol></li><li><p>终止条件</p><ol><li>当“当前节点”为空时，则终止</li><li><code>if not cur: return</code></li></ol></li><li><p>单层递归的逻辑</p><ol><li><p>先将&quot;cur.val&quot;添加到res中，再递归遍历&quot;cur.left&quot;，最终递归遍历&quot;cur.right&quot;</p></li><li><p>res.append(cur.val)    // 中<br>traversal(cur.left, res);  // 左<br>traversal(cur.right, res); // 右</p></li></ol></li></ol><h1 id="二叉树的前序遍历">二叉树的前序遍历</h1><p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">https://leetcode.cn/problems/binary-tree-preorder-traversal/</a></p><p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p><p><strong>示例 1：</strong></p><p>**输入：**root = [1,null,2,3]</p><p><strong>输出：</strong>[1,2,3]</p><p><strong>解释：</strong></p><p><img src="https://assets.leetcode.com/uploads/2024/08/29/screenshot-2024-08-29-202743.png" alt="img"></p><p><strong>示例 2：</strong></p><p>**输入：**root = [1,2,3,4,5,null,8,null,null,6,7,9]</p><p><strong>输出：</strong>[1,2,4,5,6,7,3,8,9]</p><p><strong>解释：</strong></p><p><img src="https://assets.leetcode.com/uploads/2024/08/29/tree_2.png" alt="img"></p><p><strong>示例 3：</strong></p><p>**输入：**root = []</p><p><strong>输出：</strong>[]</p><p><strong>示例 4：</strong></p><p>**输入：**root = [1]</p><p><strong>输出：</strong>[1]</p><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p>**进阶：**递归算法很简单，你可以通过迭代算法完成吗？</p><h2 id="递归思路">递归思路</h2><ol><li>确定递归函数的输入&amp;输出；确定终止条件；确定单层递归的逻辑</li><li>前序遍历，先记录cur.val，再分别递归左、右子树</li></ol><h2 id="递归代码">递归代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># preorder</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">traversal</span>(<span class="params">self, cur: TreeNode, res: <span class="type">List</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        res.append(cur.val)</span><br><span class="line">        self.traversal(cur.left, res)</span><br><span class="line">        self.traversal(cur.right, res)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        self.traversal(root, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="迭代思路">迭代思路</h2><ol><li>取：中间节点</li><li>处理：将中间节点元素放进result数组中</li><li>访问：遍历子节点，但需要注意，因为使用栈用来存储数据，所以先将right入栈，再让left入栈；（后入先出），最后再处理中间节点</li></ol><p><img src="https://file1.kamacoder.com/i/algo/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89.gif" alt="img"></p><h2 id="普通迭代代码">普通迭代代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="comment"># 迭代实现</span></span><br><span class="line">    stack = <span class="built_in">list</span>()</span><br><span class="line">    res = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    stack.append(root)</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        <span class="comment"># 取中间节点</span></span><br><span class="line">        node = stack.pop()</span><br><span class="line">        <span class="comment"># 访问：遍历子节点</span></span><br><span class="line">        <span class="keyword">if</span> node.right: <span class="comment"># 先加入右节点</span></span><br><span class="line">            stack.append(node.right)</span><br><span class="line">        <span class="keyword">if</span> node.left: <span class="comment"># 再加入左节点</span></span><br><span class="line">            stack.append(node.left)</span><br><span class="line">        <span class="comment"># 处理：将元素放在res # 最后处理中间节点</span></span><br><span class="line">        res.append(node.val)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="统一迭代代码">统一迭代代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        stack = [(root, <span class="literal">False</span>)] <span class="keyword">if</span> root <span class="keyword">else</span> []</span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node, visit_status = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> visit_status:</span><br><span class="line">                res.append(node.val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 按前序遍历，“中左右”，但这里是栈，所以应该是按“右左中”入栈；</span></span><br><span class="line">                <span class="comment"># 不过，我决定在最后使用反转大法</span></span><br><span class="line">                <span class="comment"># 所以这里还是按“中左右”进行入栈</span></span><br><span class="line">                stack.append((node, <span class="literal">True</span>))</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    stack.append((node.left, <span class="literal">False</span>))</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    stack.append((node.right, <span class="literal">False</span>))</span><br><span class="line">                </span><br><span class="line">        res = res[::-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>或者使用常规的入栈顺序应该是“右，左，中”，出栈顺序也是“中左右”</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">stack = [(root, <span class="literal">False</span>)] <span class="keyword">if</span> root <span class="keyword">else</span> []</span><br><span class="line">res = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> stack:</span><br><span class="line">    node, visit_status = stack.pop()</span><br><span class="line">    <span class="keyword">if</span> visit_status:</span><br><span class="line">        res.append(node.val)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 按前序遍历，“中左右”，但这里是栈，所以应该是“右左中”；</span></span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            stack.append((node.right, <span class="literal">False</span>))</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            stack.append((node.left, <span class="literal">False</span>))</span><br><span class="line">        stack.append((node, <span class="literal">True</span>))</span><br><span class="line"><span class="comment"># 不需要有反转</span></span><br><span class="line"><span class="comment"># res = res[::-1]</span></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="二叉树的后序遍历">二叉树的后序遍历</h1><p><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">https://leetcode.cn/problems/binary-tree-postorder-traversal/</a></p><p>给你一棵二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>后序遍历</strong> 。</p><p><strong>示例 1：</strong></p><p>**输入：**root = [1,null,2,3]</p><p><strong>输出：</strong>[3,2,1]</p><p><strong>解释：</strong></p><p><img src="https://assets.leetcode.com/uploads/2024/08/29/screenshot-2024-08-29-202743.png" alt="img"></p><p><strong>示例 2：</strong></p><p>**输入：**root = [1,2,3,4,5,null,8,null,null,6,7,9]</p><p><strong>输出：</strong>[4,6,7,5,2,9,8,3,1]</p><p><strong>解释：</strong></p><p><img src="https://assets.leetcode.com/uploads/2024/08/29/tree_2.png" alt="img"></p><p><strong>示例 3：</strong></p><p>**输入：**root = []</p><p><strong>输出：</strong>[]</p><p><strong>示例 4：</strong></p><p>**输入：**root = [1]</p><p><strong>输出：</strong>[1]</p><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p>**进阶：**递归算法很简单，你可以通过迭代算法完成吗？</p><h2 id="递归代码">递归代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">traversal</span>(<span class="params">self, cur: TreeNode, res: <span class="type">List</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.traversal(cur.left, res) <span class="comment"># 左</span></span><br><span class="line">        self.traversal(cur.right, res) <span class="comment"># 右</span></span><br><span class="line">        res.append(cur.val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        self.traversal(root, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="迭代思路">迭代思路</h2><ol><li>前序遍历是&quot;中左右&quot;，将它换成&quot;中右左&quot;，再将res反转就得到了&quot;左右中&quot;（多少是带了技巧的）</li></ol><p><img src="https://file1.kamacoder.com/i/algo/20200808200338924.png" alt="img"></p><h2 id="迭代代码">迭代代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(N)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="comment"># 迭代遍历</span></span><br><span class="line">    stack = <span class="built_in">list</span>()</span><br><span class="line">    res = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    stack.append(root)</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        res.append(node.val)</span><br><span class="line">        <span class="comment"># 将前序遍历的顺序更换</span></span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            stack.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            stack.append(node.right)</span><br><span class="line">    <span class="comment"># 最后将结果反转</span></span><br><span class="line">    res = res[::-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">        </span><br></pre></td></tr></table></figure><h2 id="统一迭代代码">统一迭代代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 统一迭代遍历</span></span><br><span class="line">    <span class="comment"># stack使用bool对每个节点进行标记，False表示没访问过，True则访问过</span></span><br><span class="line">    stack = [(root, <span class="literal">False</span>)] <span class="keyword">if</span> root <span class="keyword">else</span> []</span><br><span class="line">    res = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node, visit_statue = stack.pop()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果节点已经visited，</span></span><br><span class="line">        <span class="keyword">if</span> visit_statue:</span><br><span class="line">            res.append(node.val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 没有访问过这节点，则按后序遍历方式&quot;左右中“”</span></span><br><span class="line">            <span class="comment"># 当然也可以使用反转大法，这里就按“左右中”的方式入栈，最后需要将res反转</span></span><br><span class="line">            <span class="keyword">if</span> node.left: <span class="comment"># 左子节点</span></span><br><span class="line">                stack.append((node.left, <span class="literal">False</span>)) </span><br><span class="line">            <span class="keyword">if</span> node.right: <span class="comment"># 右子节点</span></span><br><span class="line">                stack.append((node.right, <span class="literal">False</span>))</span><br><span class="line">            <span class="comment"># 中间节点，注意标记为True</span></span><br><span class="line">            stack.append((node, <span class="literal">True</span>))</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">    res = res[::-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="二叉树的中序遍历">二叉树的中序遍历</h1><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">https://leetcode.cn/problems/binary-tree-inorder-traversal/</a></p><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,null,2,3]</span><br><span class="line">输出：[1,3,2]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><h2 id="递归代码">递归代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">traversal</span>(<span class="params">self, cur: TreeNode, res: <span class="type">List</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.traversal(cur.left, res) <span class="comment"># 左</span></span><br><span class="line">        res.append(cur.val)</span><br><span class="line">        self.traversal(cur.right, res) <span class="comment"># 右</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        self.traversal(root, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="迭代思路">迭代思路</h2><p>1.中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了<strong>处理顺序和访问顺序是不一致的。</strong></p><p>那么<strong>在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</strong></p><p><img src="https://file1.kamacoder.com/i/algo/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89.gif" alt="img"></p><h2 id="迭代代码">迭代代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="comment"># res = list()</span></span><br><span class="line">    <span class="comment"># self.traversal(root, res)</span></span><br><span class="line">    <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 迭代</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    res = <span class="built_in">list</span>()</span><br><span class="line">    stack = <span class="built_in">list</span>()</span><br><span class="line">    cur = root</span><br><span class="line">    <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">        <span class="comment"># 先一路干到最底层的左子树叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> cur:</span><br><span class="line">            stack.append(cur)</span><br><span class="line">            cur = cur.left</span><br><span class="line">        <span class="comment"># 到达最左节点后，开始处理栈顶节点</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">          <span class="comment"># 最底层的左子树左叶子节点开始输出，append到res，就能按前、中、后输出了</span></span><br><span class="line">            cur = stack.pop()</span><br><span class="line">            res.append(cur.val)</span><br><span class="line">            <span class="comment"># 取栈顶元素右节点</span></span><br><span class="line">            cur = cur.right</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="统一迭代代码">统一迭代代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="comment"># 统一迭代</span></span><br><span class="line">    stack = [(root, <span class="literal">False</span>)] <span class="keyword">if</span> root <span class="keyword">else</span> []</span><br><span class="line">    res = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node, visit_status = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> visit_status:</span><br><span class="line">            res.append(node.val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 按中序遍历，“左中右”，但这里是栈，所以应该是“右中左”；不过，我决定在最后使用反转大法</span></span><br><span class="line">            <span class="comment"># 所以这里还是按“左中右”进行入栈</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append((node.left, <span class="literal">False</span>))</span><br><span class="line">            stack.append((node, <span class="literal">True</span>))</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append((node.right, <span class="literal">False</span>))</span><br><span class="line">            </span><br><span class="line">    <span class="comment"># 上面为了方便理解，使用left, mid, right的方式进行入栈，最后需要进行反转结果</span></span><br><span class="line">    res = res[::-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="二叉树的迭代遍历">二叉树的迭代遍历</h1><p>除了使用递归的方式实现二叉树的遍历，还可以使用“迭代的方法”</p><p>递归的本质是：<strong>每一次递归调用，都会把函数的局部变量</strong>，参数值和返回地址等信息压入调用栈中，等递归返回的时候，<strong>从栈顶弹出上一次递归的各项参数</strong></p><p>前序遍历（迭代实现）</p><p>前序遍历输出“中，左，右”，所以需要先将“中间”节点放在栈中，然后弹出，并将右孩子入栈，再加入左孩子（因为后入先出，左孩子得先出，所以得后入）</p><p><img src="https://file1.kamacoder.com/i/algo/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89.gif" alt="img"></p><h1 id="二叉树的统一迭代">二叉树的统一迭代</h1><h2 id="标记法">标记法</h2><p><strong>加一个 <code>boolean</code> 值跟随每个节点，<code>false</code> (默认值) 表示需要为该节点和它的左右儿子安排在栈中的位次，<code>true</code> 表示该节点的位次之前已经安排过了，可以收割节点了。</strong></p><p>这种方法可以叫做<code>boolean 标记法</code>， 这种方法更容易理解，在面试中更容易写出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># stack的初始化</span></span><br><span class="line"><span class="comment"># 其中的False表示这个节点没有访问过，需要给这个节点以及它的左、右两个节点安排位置</span></span><br><span class="line">stack = [(root, <span class="literal">False</span>)] <span class="keyword">if</span> root <span class="keyword">else</span> []</span><br><span class="line">res = <span class="built_in">list</span>()</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="keyword">while</span> stack:</span><br><span class="line">  <span class="comment"># 弹出一个节点进行visit状态的判断</span></span><br><span class="line">    node, visit_status = stack.pop()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果已经visited过，说明可以收割了，将node结果放在res里</span></span><br><span class="line">    <span class="keyword">if</span> visit_status:</span><br><span class="line">      res.append(node.val)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="comment"># 下面就是按“既定顺序”添加到stack中即可</span></span><br><span class="line">      <span class="comment"># 比如前序就是“中左右”</span></span><br><span class="line">      stack.append((node, <span class="literal">True</span>))</span><br><span class="line">      <span class="keyword">if</span> node.left:</span><br><span class="line">        stack.append((node.left, <span class="literal">False</span>))</span><br><span class="line">      <span class="keyword">if</span> node.right:</span><br><span class="line">        stack.append((node.right, <span class="literal">False</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于res是个栈，而上面添加到栈的顺序是按“既定顺序”添加的，而实际输出需要进行反转(因为栈是先入后出)</span></span><br><span class="line">res = res[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="空指针法">空指针法</h2><p><strong>就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。</strong> 这种方法可以叫做<code>空指针标记法</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        result = []</span><br><span class="line">        st= []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            st.append(root)</span><br><span class="line">        <span class="keyword">while</span> st:</span><br><span class="line">            node = st.pop()</span><br><span class="line">            <span class="keyword">if</span> node != <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> node.right: <span class="comment">#右</span></span><br><span class="line">                    st.append(node.right)</span><br><span class="line">                <span class="keyword">if</span> node.left: <span class="comment">#左</span></span><br><span class="line">                    st.append(node.left)</span><br><span class="line">                st.append(node) <span class="comment">#中</span></span><br><span class="line">                st.append(<span class="literal">None</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = st.pop()</span><br><span class="line">                result.append(node.val)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h1 id="层序遍历">层序遍历</h1><p>之前的前/中/后序遍历都使用了栈/递归的思想（本质是深度优先遍历），而层序遍历是广度优先遍历，如果提到广度优先，就需要使用队列了</p><p><strong>队列先进先出，符合一层一层遍历的逻辑</strong>，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。</p><p><img src="https://file1.kamacoder.com/i/algo/102%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.gif" alt="img"></p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">queue = deque()</span><br><span class="line">res = <span class="built_in">list</span>()</span><br><span class="line">queue.append(root)</span><br><span class="line"><span class="keyword">while</span> queue:</span><br><span class="line">  <span class="comment"># level记录的是每层的结果</span></span><br><span class="line">level = <span class="built_in">list</span>()</span><br><span class="line">L = <span class="built_in">len</span>(queue)</span><br><span class="line"><span class="comment"># 注意这里的L不会跟着queue增加或减少而变化</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">cur = queue.popleft()</span><br><span class="line"></span><br><span class="line">level.append(cur.val)</span><br><span class="line"><span class="keyword">if</span> cur.left:</span><br><span class="line">queue.append(cur.left)</span><br><span class="line"><span class="keyword">if</span> cur.right:</span><br><span class="line">queue.append(cur.right)</span><br><span class="line">    <span class="comment"># 最终将每层的结果汇总到res中</span></span><br><span class="line">res.append(level)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="102-二叉树的层序遍历">102. 二叉树的层序遍历</h1><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">https://leetcode.cn/problems/binary-tree-level-order-traversal/</a></p><p>提示</p><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：[[3],[9,20],[15,7]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h2 id="迭代法思路">迭代法思路</h2><ol><li>队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。</li><li>层序遍历有两个可以操作的位置，分别是每次弹出一个node后；以及每层的清算</li></ol><p><img src="https://file1.kamacoder.com/i/algo/102%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.gif" alt="img"></p><h2 id="迭代法代码">迭代法代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(N)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        queue = deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            level_res = <span class="built_in">list</span>()</span><br><span class="line">            <span class="comment"># 操作位置1</span></span><br><span class="line">            L = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                level_res.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">            <span class="comment"># 操作位置2 （每层的清算）</span></span><br><span class="line">            res.append(level_res)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="递归法">递归法</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(N)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="comment"># 确定好输入与输出</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">self, node, level, levels</span>):</span><br><span class="line">      <span class="comment"># 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 单次递归做的事儿</span></span><br><span class="line">        <span class="comment"># 这里表示，需要给levels添加一个新level，用来装新level的数据</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(levels) == level:</span><br><span class="line">            levels.append([])</span><br><span class="line">        <span class="comment"># 注意，这里使用的是levels[level]</span></span><br><span class="line">        levels[level].append(node.val)</span><br><span class="line">        self.traverse(node.left, level + <span class="number">1</span>, levels)</span><br><span class="line">        self.traverse(node.right, level + <span class="number">1</span>, levels)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        levels = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">        self.traverse(root, <span class="number">0</span>, levels)</span><br><span class="line">        <span class="keyword">return</span> levels</span><br></pre></td></tr></table></figure><h1 id="二叉树的层序遍历-ii">二叉树的层序遍历 II</h1><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/</a></p><p>给你二叉树的根节点 <code>root</code> ，返回其节点值 <strong>自底向上的层序遍历</strong> 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：[[15,7],[9,20],[3]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h2 id="代码">代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(N)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrderBottom</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 把res数组反转下就好</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue = deque()</span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        queue.append(root)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            level_res = <span class="built_in">list</span>()</span><br><span class="line">            L = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                level_res.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">            res.append(level_res)</span><br><span class="line">        <span class="comment"># 将res结果反转即可</span></span><br><span class="line">        <span class="keyword">return</span> res[::-<span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="199-二叉树的右视图">199. 二叉树的右视图</h1><p><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">https://leetcode.cn/problems/binary-tree-right-side-view/</a></p><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p><strong>示例 1：</strong></p><p>**输入：**root = [1,2,3,null,5,null,4]</p><p><strong>输出：</strong>[1,3,4]</p><p><strong>解释：</strong></p><p><img src="https://assets.leetcode.com/uploads/2024/11/24/tmpd5jn43fs-1.png" alt="img"></p><p><strong>示例 2：</strong></p><p>**输入：**root = [1,2,3,4,null,null,null,5]</p><p><strong>输出：</strong>[1,3,4,5]</p><p><strong>解释：</strong></p><p><img src="https://assets.leetcode.com/uploads/2024/11/24/tmpkpe40xeh-1.png" alt="img"></p><p><strong>示例 3：</strong></p><p>**输入：**root = [1,null,3]</p><p><strong>输出：</strong>[1,3]</p><p><strong>示例 4：</strong></p><p>**输入：**root = []</p><p><strong>输出：</strong>[]</p><p><strong>提示:</strong></p><ul><li>二叉树的节点个数的范围是 <code>[0,100]</code></li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h2 id="思路">思路</h2><ol><li>在层序遍历基础上，将level_res替换成只记录一个值（只记录当前层的最后一个节点）</li></ol><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rightSideView</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 层序遍历，但规则是：只遍历这层最后一个节点</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue = deque()</span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        queue.append(root)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="comment"># level_res其实只要保持一个节点即可</span></span><br><span class="line">            level_res = <span class="literal">None</span></span><br><span class="line">            L = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                <span class="comment"># 用这层新节点替换掉之前的结果，保证level_res只记录当前层最后一个节点</span></span><br><span class="line">                level_res = node.val</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">            res.append(level_res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="思路二">思路二</h2><ol><li>判断当前循环是否是当前层最后一个，如果是，则记录</li></ol><h2 id="代码二">代码二</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rightSideView</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue = deque()</span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        queue.append(root)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            L = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line"><span class="comment"># 如果是当前层最后一个，才记录</span></span><br><span class="line">                <span class="keyword">if</span> i == L - <span class="number">1</span>:</span><br><span class="line">                    res.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="二叉树的层平均值">二叉树的层平均值</h1><p><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">https://leetcode.cn/problems/average-of-levels-in-binary-tree/</a></p><p>给定一个非空二叉树的根节点 <code>root</code> , 以数组的形式返回每一层节点的平均值。与实际答案相差 <code>10-5</code> 以内的答案可以被接受。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/09/avg1-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：[3.00000,14.50000,11.00000]</span><br><span class="line">解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。</span><br><span class="line">因此返回 [3, 14.5, 11] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/09/avg2-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,9,20,15,7]</span><br><span class="line">输出：[3.00000,14.50000,11.00000]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数量在 <code>[1, 104]</code> 范围内</li><li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li></ul><h2 id="思路">思路</h2><p>在层序的基础上记录每层的总和与个数，再求个均值即可</p><h2 id="代码">代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(W)—取决于二叉树的最大宽度</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">averageOfLevels</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">        que = deque()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        que.append(root)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            L = <span class="built_in">len</span>(que)</span><br><span class="line">            levelsum = <span class="number">0</span></span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">                node = que.popleft()</span><br><span class="line">                levelsum += node.val</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    que.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    que.append(node.right)</span><br><span class="line">            res.append(levelsum/count)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="429-n-叉树的层序遍历">429. N 叉树的层序遍历</h1><p><a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">https://leetcode.cn/problems/n-ary-tree-level-order-traversal/</a></p><p>给定一个 N 叉树，返回其节点值的<em>层序遍历</em>。（即从左到右，逐层遍历）。</p><p>树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,null,3,2,4,null,5,6]</span><br><span class="line">输出：[[1],[3,2,4],[5,6]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]</span><br><span class="line">输出：[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树的高度不会超过 <code>1000</code></li><li>树的节点总数在 <code>[0, 104]</code> 之间</li></ul><h2 id="代码">代码</h2><ul><li>时间复杂度O(N)—每个元素遍历一次</li><li>空间复杂度O(W)—取决于二叉树的最大宽度</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val: Optional[int] = None, children: Optional[List[&#x27;Node&#x27;]] = None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.children = children</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        que = deque()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        que.append(root)</span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            L = <span class="built_in">len</span>(que)</span><br><span class="line">            levelList = <span class="built_in">list</span>()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">                node = que.popleft()</span><br><span class="line">                levelList.append(node.val)</span><br><span class="line">                <span class="keyword">for</span> eachNode <span class="keyword">in</span> node.children:</span><br><span class="line">                    que.append(eachNode)</span><br><span class="line">            res.append(levelList)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="515-在每个树行中找最大值">515. 在每个树行中找最大值</h1><p><a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">https://leetcode.cn/problems/find-largest-value-in-each-tree-row/</a></p><p>给定一棵二叉树的根节点 <code>root</code> ，请找出该二叉树中每一层的最大值。</p><p><strong>示例1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/21/largest_e1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [1,3,2,5,3,null,9]</span><br><span class="line">输出: [1,3,9]</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [1,2,3]</span><br><span class="line">输出: [1,3]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>二叉树的节点个数的范围是 <code>[0,104]</code></li><li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li></ul><h2 id="代码">代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(w)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestValues</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">        que = deque()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        que.append(root)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            L = <span class="built_in">len</span>(que)</span><br><span class="line">            levelMax = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">                node = que.popleft()</span><br><span class="line">                <span class="keyword">if</span> levelMax <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    levelMax = node.val</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    levelMax = <span class="built_in">max</span>(levelMax, node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    que.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    que.append(node.right)</span><br><span class="line">            res.append(levelMax)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="116-填充每个节点的下一个右侧节点指针">116. 填充每个节点的下一个右侧节点指针</h1><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/</a></p><p>给定一个 <strong>完美二叉树</strong> ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code>。</p><p>初始状态下，所有 next 指针都被设置为 <code>NULL</code>。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3,4,5,6,7]</span><br><span class="line">输出：[1,#,2,3,#,4,5,6,7,#]</span><br><span class="line">解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，&#x27;#&#x27; 标志着每一层的结束。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数量在 <code>[0, 212 - 1]</code> 范围内</li><li><code>-1000 &lt;= node.val &lt;= 1000</code></li></ul><p><strong>进阶：</strong></p><ul><li>你只能使用常量级额外空间。</li><li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li></ul><h2 id="思路">思路</h2><ol><li>使用层序遍历，将每个节点保存在levelList里，在每层结算时，将levelList节点串起来</li></ol><h2 id="代码">代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(w)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val: int = 0, left: &#x27;Node&#x27; = None, right: &#x27;Node&#x27; = None, next: &#x27;Node&#x27; = None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self, root: <span class="string">&#x27;Optional[Node]&#x27;</span></span>) -&gt; <span class="string">&#x27;Optional[Node]&#x27;</span>:</span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">        que = deque()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        que.append(root)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            L = <span class="built_in">len</span>(que)</span><br><span class="line">            levelList = <span class="built_in">list</span>()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">                node = que.popleft()</span><br><span class="line">                levelList.append(node)</span><br><span class="line">                <span class="comment"># 添加下一层到队列</span></span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    que.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    que.append(node.right)</span><br><span class="line">            <span class="comment"># 将这层串起来</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(levelList) - <span class="number">1</span>):</span><br><span class="line">                levelList[i].<span class="built_in">next</span> = levelList[i+<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>或者使用一个pre节点，记录前一个值，再令pre.next = node即可</p><ul><li>时间复杂度O(N)</li><li>空间复杂度O(W)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val: int = 0, left: &#x27;Node&#x27; = None, right: &#x27;Node&#x27; = None, next: &#x27;Node&#x27; = None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self, root: <span class="string">&#x27;Optional[Node]&#x27;</span></span>) -&gt; <span class="string">&#x27;Optional[Node]&#x27;</span>:</span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">        que = deque()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        que.append(root)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> que:</span><br><span class="line">            L = <span class="built_in">len</span>(que)</span><br><span class="line">            nodePrev = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">                node = que.popleft()</span><br><span class="line">                <span class="keyword">if</span> nodePrev:</span><br><span class="line">                    nodePrev.<span class="built_in">next</span> = node</span><br><span class="line">                nodePrev = node</span><br><span class="line">                <span class="comment"># 添加下一层到队列</span></span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    que.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    que.append(node.right)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday13-二叉树part01&quot;&gt;LeetCodeCampsDay13-二叉树part01&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;二叉树的遍历，前序/中序/后序/层序，以及迭代、递归等方法实现&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
    <category term="二叉树" scheme="https://blog.lthero.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay11-栈与队列part02</title>
    <link href="https://blog.lthero.cn/2025/07/06/LeetCodeCampsDay11/"/>
    <id>https://blog.lthero.cn/2025/07/06/LeetCodeCampsDay11/</id>
    <published>2025-07-06T14:37:48.000Z</published>
    <updated>2025-07-08T11:30:23.043Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday11-栈与队列part02">LeetCodeCampsDay11-栈与队列part02</h1><blockquote><p>使用栈与队列解决问题，栈适合深度搜索/深度遍历的问题；而队列适用于广度搜索/遍历</p><p>这里有个滑动窗口最大值的问题值得关注下</p></blockquote><h1 id="150-逆波兰表达式求值">150. 逆波兰表达式求值</h1><p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">https://leetcode.cn/problems/evaluate-reverse-polish-notation/</a></p><p>给你一个字符串数组 <code>tokens</code> ，表示一个根据 <a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437">逆波兰表示法</a> 表示的算术表达式。</p><p>请你计算该表达式。返回一个表示表达式值的整数。</p><p><strong>注意：</strong></p><ul><li>有效的算符为 <code>'+'</code>、<code>'-'</code>、<code>'*'</code> 和 <code>'/'</code> 。</li><li>每个操作数（运算对象）都可以是一个整数或者另一个表达式。</li><li>两个整数之间的除法总是 <strong>向零截断</strong> 。</li><li>表达式中不含除零运算。</li><li>输入是一个根据逆波兰表示法表示的算术表达式。</li><li>答案及所有中间计算结果可以用 <strong>32 位</strong> 整数表示。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]</span><br><span class="line">输出：9</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]</span><br><span class="line">输出：6</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]</span><br><span class="line">输出：22</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：</span><br><span class="line">  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / (12 * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / -132)) + 17) + 5</span><br><span class="line">= ((10 * 0) + 17) + 5</span><br><span class="line">= (0 + 17) + 5</span><br><span class="line">= 17 + 5</span><br><span class="line">= 22</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= tokens.length &lt;= 104</code></li><li><code>tokens[i]</code> 是一个算符（<code>&quot;+&quot;</code>、<code>&quot;-&quot;</code>、<code>&quot;*&quot;</code> 或 <code>&quot;/&quot;</code>），或是在范围 <code>[-200, 200]</code> 内的一个整数</li></ul><p><strong>逆波兰表达式：</strong></p><p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p><ul><li>平常使用的算式则是一种中缀表达式，如 <code>( 1 + 2 ) * ( 3 + 4 )</code> 。</li><li>该算式的逆波兰表达式写法为 <code>( ( 1 2 + ) ( 3 4 + ) * )</code> 。</li></ul><p>逆波兰表达式主要有以下两个优点：</p><ul><li>去掉括号后表达式无歧义，上式即便写成 <code>1 2 + 3 4 + * </code>也可以依据次序计算出正确结果。</li><li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</li></ul><h2 id="思路">思路</h2><p>其实逆波兰表达式相当于是二叉树中的后序遍历</p><ol><li>使用个栈实现，遇到数字就进栈，遇到符号则弹出两个数字进行计算，将计算结果再入栈</li><li>本题中每一个子表达式要得出一个结果，然后拿这个结果再进行运算，那么这岂不就是一个相邻字符串消除的过程，和<a href="https://programmercarl.com/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.html">1047.删除字符串中的所有相邻重复项 (opens new window)</a>中的对对碰游戏是不是就非常像了</li></ol><p><img src="https://file1.kamacoder.com/i/algo/150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.gif" alt="img"></p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">evalRPN</span>(<span class="params">self, tokens: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 使用个栈实现，遇到数字就进栈，遇到符号则弹出两个数字进行计算，将计算结果再入栈</span></span><br><span class="line">        <span class="comment"># python可用list实现</span></span><br><span class="line">        curStack = <span class="built_in">list</span>()</span><br><span class="line">        symbolList = [<span class="string">&#x27;+&#x27;</span>, <span class="string">&quot;-&quot;</span>, <span class="string">&quot;*&quot;</span>, <span class="string">&quot;/&quot;</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> tokens:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> symbolList:</span><br><span class="line">                curStack.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(curStack) &gt;= <span class="number">2</span>:</span><br><span class="line">                    num2 = <span class="built_in">int</span>(curStack.pop())</span><br><span class="line">                    num1 = <span class="built_in">int</span>(curStack.pop())</span><br><span class="line">                    <span class="keyword">if</span> i == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                        res = num1 + num2</span><br><span class="line">                    <span class="keyword">elif</span> i == <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                        res = num1 - num2</span><br><span class="line">                    <span class="keyword">elif</span> i == <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                        res = num1 * num2</span><br><span class="line">                    <span class="keyword">elif</span> i == <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                        res = num1 / num2</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">                    curStack.append(res)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(curStack.pop())              </span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="单调队列">单调队列</h1><blockquote><p>维护一个只能单调增加/减少的队列，队列的front值一定是最大/最小值</p></blockquote><p><img src="https://file1.kamacoder.com/i/algo/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.gif" alt="img"></p><p>对于窗口里的元素{2, 3, 5, 1 ,4}，单调队列里只维护{5, 4} 就够了，保持单调队列里单调递减，此时队列出口元素就是窗口里最大元素。</p><p>设计单调队列的时候，pop，和push操作要保持如下规则：</p><ol><li>pop(value)：如果窗口移除的元素value等于单调队列的front元素，那么队列弹出元素，否则不用任何操作（滑动窗口在右移时需要用到pop，此时只能pop出最大/小值，<strong>因为非“最大/最小”值都已经不在这个队列里的</strong>）</li><li>push(value)：如果push的元素value大于tail元素的数值(que[-1]，那么就将队列tail的元素弹出，直到push元素的数值小于等于队列tail元素的数值为止，保证能找到一个合适的位置，让它前面没有比它小的值；保证如果value是最大/最小值，则value一定会在front</li></ol><p>保持如上规则，每次窗口移动的时候，只要问que.front()就可以返回当前窗口的最大值。</p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myQueue</span>():</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,</span>):</span><br><span class="line">            self.que = deque()</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, value</span>):</span><br><span class="line">            <span class="built_in">print</span>(self.que)</span><br><span class="line">            <span class="comment"># 若value大于que的tail值，需要不断tail值弹出，保证如果value是最大/最小值，则value一定会在front</span></span><br><span class="line">            <span class="comment"># 这里的que[-1]是tail值，比如que=[6,3,2]，下一个value=8,则value=8&gt;que[-1]=2；将2弹出；再value=8&gt;que[-1]=3，将3弹出；value=8&gt;que[-1]=6,将6弹出</span></span><br><span class="line">            <span class="keyword">while</span> self.que <span class="keyword">and</span> value &gt; self.que[-<span class="number">1</span>]:</span><br><span class="line">                self.que.pop()</span><br><span class="line">            <span class="comment"># 最后将value加进来，它已经到了合适的位置（保证它前面没有比它小的值）</span></span><br><span class="line">            self.que.append(value)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self, value</span>):</span><br><span class="line">            <span class="built_in">print</span>(self.que)</span><br><span class="line">            <span class="comment"># 判断value是否等于front值，如果相等则弹出</span></span><br><span class="line">            <span class="keyword">if</span> self.que <span class="keyword">and</span> value == self.que[<span class="number">0</span>]:</span><br><span class="line">                self.que.popleft()</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">front</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="comment"># 返回队列前端(即最大值)</span></span><br><span class="line">            <span class="keyword">return</span> self.que[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h1 id="239-滑动窗口最大值">239. 滑动窗口最大值</h1><p><a href="https://leetcode.cn/problems/sliding-window-maximum/">https://leetcode.cn/problems/sliding-window-maximum/</a></p><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p><p>返回 <em>滑动窗口中的最大值</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1], k = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>1 &lt;= k &lt;= nums.length</code></li></ul><h2 id="思路">思路</h2><ol><li>需要使用单调队列，这题目的重点是如何创建并维护一个单调队列</li><li>实际应用时，先创建个单调队列，然后依次地对nums进行遍历（不断pop窗口内最左边的元素），再push新元素到窗口</li></ol><p>以题目示例为例，输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3，动画如下：</p><p><img src="https://file1.kamacoder.com/i/algo/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-2.gif" alt="img"></p><h2 id="代码">代码</h2><ul><li>时间复杂度O(n) — nums 中的每个元素最多也就被 push_back 和 pop_back 各一次，没有任何多余操作，所以整体的复杂度还是 O(n)</li><li>空间复杂度O(k)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myQueue</span>():</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,</span>):</span><br><span class="line">            self.que = deque()</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, value</span>):</span><br><span class="line">            <span class="built_in">print</span>(self.que)</span><br><span class="line">            <span class="comment"># 若value大于que的tail值，需要不断tail值弹出，保证如果value是最大/最小值，则value一定会在front</span></span><br><span class="line">            <span class="keyword">while</span> self.que <span class="keyword">and</span> value &gt; self.que[-<span class="number">1</span>]:</span><br><span class="line">                self.que.pop()</span><br><span class="line">            self.que.append(value)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self, value</span>):</span><br><span class="line">            <span class="built_in">print</span>(self.que)</span><br><span class="line">            <span class="comment"># 判断value是否等于front值，如果相等则弹出</span></span><br><span class="line">            <span class="keyword">if</span> self.que <span class="keyword">and</span> value == self.que[<span class="number">0</span>]:</span><br><span class="line">                self.que.popleft()</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">front</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="comment"># 返回队列前端(即最大值)</span></span><br><span class="line">            <span class="keyword">return</span> self.que[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">      <span class="comment"># 创建一个单调队列</span></span><br><span class="line">        que = myQueue()</span><br><span class="line">        results = <span class="built_in">list</span>()</span><br><span class="line">        <span class="comment"># 将前k个先入队列</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            que.push(nums[i])</span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 第一个窗口的结果放在res中</span></span><br><span class="line">        results.append(que.front())</span><br><span class="line">        <span class="comment"># 开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, L):</span><br><span class="line">          <span class="comment"># 一上来窗口就应该要滑动，所以一上来就pop</span></span><br><span class="line">            que.pop(nums[i - k])</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;que.pop: <span class="subst">&#123;nums[i - k]&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="comment"># 再push新数据进来</span></span><br><span class="line">            que.push(nums[i])</span><br><span class="line">            <span class="comment"># 将队列的最前面的值（必须是最大值）保存到res</span></span><br><span class="line">            results.append(que.front())</span><br><span class="line">        <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><h1 id="347-前-k-个高频元素">347. 前 K 个高频元素</h1><p><a href="https://leetcode.cn/problems/top-k-frequent-elements/">https://leetcode.cn/problems/top-k-frequent-elements/</a></p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">输出: [1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1], k = 1</span><br><span class="line">输出: [1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>k</code> 的取值范围是 <code>[1, 数组中不相同的元素的个数]</code></li><li>题目数据保证答案唯一，换句话说，数组中前 <code>k</code> 个高频元素的集合是唯一的</li></ul><p>**进阶：**你所设计算法的时间复杂度 <strong>必须</strong> 优于 <code>O(n log n)</code> ，其中 <code>n</code> 是数组大小。</p><h2 id="思路">思路</h2><ol><li>要统计元素出现频率、对频率排序、找出前K个高频元素</li><li>其中，<strong>统计频率</strong>-----可以使用map完成；</li><li>对<strong>频率排序</strong>----则需要使用“优先级队列”：<strong>一个披着队列外衣的堆</strong>，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列；而且优先级队列内部元素是<strong>自动依照元素的权值排列</strong></li></ol><p><strong>堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。</strong> 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。所以大家经常说的大顶堆（堆头是最大元素），小顶堆（堆头是最小元素）</p><p>题目要求<strong>前 K 个高频元素—决定使用大顶堆还是小顶堆</strong>（因为需要将不需要的数据pop出去），如果使用大顶堆，定义一个大小为k的大顶堆，在每次移动更新大顶堆的时候，每次弹出都把最大的元素弹出去了，那么怎么保留下来前K个高频元素呢。</p><p>而且使用大顶堆就要把所有元素都进行排序，那能不能只排序k个元素呢？</p><p><strong>所以我们要用小顶堆，因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素。</strong></p><h2 id="代码">代码</h2><ul><li>时间复杂度O(nlogk)</li><li>空间复杂度O(k)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">topKFrequent</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        map_ = &#123;&#125;</span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">            map_[nums[i]] = map_.get(nums[i], <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        pri_que = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> key, freq <span class="keyword">in</span> map_.items():</span><br><span class="line">            <span class="comment"># 将(freq, key)添加到pri_que，并且按freq从小到大排序，形成个小顶堆</span></span><br><span class="line">            heapq.heappush(pri_que, (freq, key))</span><br><span class="line">            <span class="comment"># 超出k个则自动弹出，保证仅有k个高频元素在小顶堆中</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(pri_que) &gt; k:</span><br><span class="line">                heapq.heappop(pri_que)</span><br><span class="line">        <span class="built_in">print</span>(pri_que)</span><br><span class="line">        </span><br><span class="line">        results = [<span class="number">0</span>] * k</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            results[i] = heapq.heappop(pri_que)[<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday11-栈与队列part02&quot;&gt;LeetCodeCampsDay11-栈与队列part02&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;使用栈与队列解决问题，栈适合深度搜索/深度遍历的问题；而队列适用于广度搜索/遍历&lt;/p&gt;
&lt;p&gt;这里</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
    <category term="栈与队列" scheme="https://blog.lthero.cn/tags/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay10栈与队列part01</title>
    <link href="https://blog.lthero.cn/2025/07/04/LeetCodeCampsDay10/"/>
    <id>https://blog.lthero.cn/2025/07/04/LeetCodeCampsDay10/</id>
    <published>2025-07-04T13:59:27.000Z</published>
    <updated>2025-07-08T10:15:11.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday10栈与队列part01">LeetCodeCampsDay10栈与队列part01</h1><blockquote><p>使用队列实现栈；</p><p>使用栈实现队列；</p><p>以及两个关于栈的题目</p></blockquote><h1 id="232-用栈实现队列">232. 用栈实现队列</h1><p><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">https://leetcode.cn/problems/implement-queue-using-stacks/</a></p><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p><p>实现 <code>MyQueue</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li><li><code>int pop()</code> 从队列的开头移除并返回元素</li><li><code>int peek()</code> 返回队列开头的元素</li><li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li></ul><p><strong>说明：</strong></p><ul><li>你 <strong>只能</strong> 使用标准的栈操作 —— 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li><li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;]</span><br><span class="line">[[], [1], [2], [], [], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, 1, 1, false]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyQueue myQueue = new MyQueue();</span><br><span class="line">myQueue.push(1); // queue is: [1]</span><br><span class="line">myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)</span><br><span class="line">myQueue.peek(); // return 1</span><br><span class="line">myQueue.pop(); // return 1, queue is [2]</span><br><span class="line">myQueue.empty(); // return false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= x &lt;= 9</code></li><li>最多调用 <code>100</code> 次 <code>push</code>、<code>pop</code>、<code>peek</code> 和 <code>empty</code></li><li>假设所有操作都是有效的 （例如，一个空的队列不会调用 <code>pop</code> 或者 <code>peek</code> 操作）</li></ul><p><strong>进阶：</strong></p><ul><li>你能否实现每个操作均摊时间复杂度为 <code>O(1)</code> 的队列？换句话说，执行 <code>n</code> 个操作的总时间复杂度为 <code>O(n)</code> ，即使其中一个操作可能花费较长时间。</li></ul><h2 id="思路">思路</h2><ol><li>维护两个列表list，其中一个用于入栈(stack_in)，一个出栈(stack_out)</li><li>push函数，直接入栈到stack_in</li><li>empty函数，只要stack_out或stack_in不为空即可</li><li>pop函数，先判断是否为“empyt”；<ol><li>其次，如果stack_out中有数字，就出栈这个数；</li><li>stack_out为空的时候，将stack_in全部转移到stack_out，再弹出一个数（比如下面动画弹出“1”和“3”时，明显是将stack_in的所有数据都移到了stack_out中）</li></ol></li></ol><p>下面动画模拟以下队列的执行过程：</p><p>执行语句：<br>queue.push(1);<br>queue.push(2);<br>queue.pop(); <strong>注意此时的输出栈的操作</strong> ,输出1<br>queue.push(3);<br>queue.push(4);<br>queue.pop(); # 输出2<br>queue.pop();<strong>注意此时的输出栈的操作</strong> 输出3<br>queue.pop(); # 输出4<br>queue.empty();</p><p><img src="https://file1.kamacoder.com/i/algo/232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%89%88%E6%9C%AC2.gif" alt="img"></p><h2 id="代码">代码</h2><ul><li>时间复杂度O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.stack_in = []</span><br><span class="line">        self.stack_out = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.stack_in.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> self.empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 如果stack_out中有数据，直接从stack_out中弹出这个 </span></span><br><span class="line">        <span class="keyword">if</span> self.stack_out:</span><br><span class="line">            <span class="keyword">return</span> self.stack_out.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">          <span class="comment"># 先将stack_in的全部转移到stack_out中</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.stack_in)):</span><br><span class="line">                self.stack_out.append(self.stack_in.pop())</span><br><span class="line">            <span class="comment"># 再从stack_out中弹出一个</span></span><br><span class="line">            <span class="keyword">return</span> self.stack_out.pop()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = self.pop()</span><br><span class="line">        self.stack_out.append(ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> (self.stack_in <span class="keyword">or</span> self.stack_out)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyQueue()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.peek()</span></span><br><span class="line"><span class="comment"># param_4 = obj.empty()</span></span><br></pre></td></tr></table></figure><h1 id="225-用队列实现栈">225. 用队列实现栈</h1><p><a href="https://leetcode.cn/problems/implement-stack-using-queues/">https://leetcode.cn/problems/implement-stack-using-queues/</a></p><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code>push</code>、<code>top</code>、<code>pop</code> 和 <code>empty</code>）。</p><p>实现 <code>MyStack</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 压入栈顶。</li><li><code>int pop()</code> 移除并返回栈顶元素。</li><li><code>int top()</code> 返回栈顶元素。</li><li><code>boolean empty()</code> 如果栈是空的，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul><p><strong>注意：</strong></p><ul><li>你只能使用队列的标准操作 —— 也就是 <code>push to back</code>、<code>peek/pop from front</code>、<code>size</code> 和 <code>is empty</code> 这些操作。</li><li>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MyStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;top&quot;, &quot;pop&quot;, &quot;empty&quot;]</span><br><span class="line">[[], [1], [2], [], [], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, 2, 2, false]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyStack myStack = new MyStack();</span><br><span class="line">myStack.push(1);</span><br><span class="line">myStack.push(2);</span><br><span class="line">myStack.top(); // 返回 2</span><br><span class="line">myStack.pop(); // 返回 2</span><br><span class="line">myStack.empty(); // 返回 False</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= x &lt;= 9</code></li><li>最多调用<code>100</code> 次 <code>push</code>、<code>pop</code>、<code>top</code> 和 <code>empty</code></li><li>每次调用 <code>pop</code> 和 <code>top</code> 都保证栈不为空</li></ul><p>**进阶：**你能否仅用一个队列来实现栈。</p><h2 id="思路">思路</h2><ol><li>使用两个队列实现栈，一个输入队列que_in，一个输出队列que_backup</li><li>push函数，直接用que_in加入；</li><li>empty函数，如果queue_in不为空即可</li><li>pop函数，先判断是否为空；<ol><li>先将L-1个数字转移到que_backup，再将que_backup与que_in交换，再将最后一个数字弹出</li></ol></li><li>top函数，调用pop函数，再将数据添加回que_in即可</li></ol><p>模拟的队列执行语句如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">queue.<span class="built_in">push</span>(<span class="number">1</span>);        </span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">2</span>);        </span><br><span class="line">queue.<span class="built_in">pop</span>();   <span class="comment">// 注意弹出的操作       </span></span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">3</span>);        </span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">4</span>);       </span><br><span class="line">queue.<span class="built_in">pop</span>();  <span class="comment">// 注意弹出的操作    </span></span><br><span class="line">queue.<span class="built_in">pop</span>();    </span><br><span class="line">queue.<span class="built_in">pop</span>();    </span><br><span class="line">queue.<span class="built_in">empty</span>();    </span><br></pre></td></tr></table></figure><p><img src="https://file1.kamacoder.com/i/algo/225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.gif" alt="img"></p><h2 id="代码">代码</h2><ul><li>时间复杂度O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>:</span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.queue_in = deque()</span><br><span class="line">        self.queue_out = deque()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.queue_in.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> self.empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 由于queue是FIFO，比如stack中有[1-&gt;3-&gt;4   如果想弹出4，</span></span><br><span class="line">        <span class="comment"># 此时队列A中  4-&gt;3-&gt;1，需要将3-&gt;1这两个数字转移到另一个队列B，再将4弹出去</span></span><br><span class="line">        <span class="comment"># 这里是len(self.queue_in) - 1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.queue_in) - <span class="number">1</span>):</span><br><span class="line">            self.queue_out.append(self.queue_in.popleft())</span><br><span class="line">        <span class="comment"># 然后进行两个队列的交换，因为只有一个数据在queue_in中，其余都在queue_out</span></span><br><span class="line">        self.queue_in, self.queue_out = self.queue_out, self.queue_in</span><br><span class="line">        <span class="keyword">return</span> self.queue_out.popleft()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 调用self.pop，将pop出来的数字再加回到self.queue_in里</span></span><br><span class="line">        ans = self.pop()</span><br><span class="line">        self.queue_in.append(ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.queue_in</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.empty()</span></span><br></pre></td></tr></table></figure><h2 id="思路二-仅用一个队列">思路二(仅用一个队列)</h2><ol><li>上述使用的que_backup可以省略掉，将数据反复加入到queue_in即可了</li></ol><h2 id="代码">代码</h2><ul><li>时间复杂度O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>:</span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.queue_in = deque()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.queue_in.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> self.empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 由于queue是FIFO，比如stack中有[1-&gt;3-&gt;4   如果想弹出4，</span></span><br><span class="line">        <span class="comment"># 此时队列A中  4-&gt;3-&gt;1，需要将3-&gt;1这两个数字转移到另一个队列B，再将4弹出去</span></span><br><span class="line">        <span class="comment"># 这里是len(self.queue_in) - 1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.queue_in) - <span class="number">1</span>):</span><br><span class="line">          <span class="comment"># 重新添加回去</span></span><br><span class="line">            self.queue_in.append(self.queue_in.popleft())</span><br><span class="line">        <span class="keyword">return</span> self.queue_in.popleft()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 调用self.pop，将pop出来的数字再加回到self.queue_in里</span></span><br><span class="line">        ans = self.pop()</span><br><span class="line">        self.queue_in.append(ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.queue_in</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.empty()</span></span><br></pre></td></tr></table></figure><h1 id="20-有效的括号">20. 有效的括号</h1><p><a href="https://leetcode.cn/problems/valid-parentheses/">https://leetcode.cn/problems/valid-parentheses/</a></p><p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'&#123;'</code>，<code>'&#125;'</code>，<code>'['</code>，<code>']'</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><p><strong>示例 1：</strong></p><p>**输入：**s = “()”</p><p>**输出：**true</p><p><strong>示例 2：</strong></p><p>**输入：**s = “()[]{}”</p><p>**输出：**true</p><p><strong>示例 3：</strong></p><p>**输入：**s = “(]”</p><p>**输出：**false</p><p><strong>示例 4：</strong></p><p>**输入：**s = “([])”</p><p>**输出：**true</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅由括号 <code>'()[]&#123;&#125;'</code> 组成</li></ul><h2 id="思路">思路</h2><ol><li>使用栈解决<ol><li>如果是左括号就入栈</li><li>如果是右括号就出栈（且栈不空）并判断是否是对应的左括号（使用下标判断）</li><li>否则就直接返回False，比如s=’]’</li></ol></li><li>最后再判断栈是否还有剩余，比如s=’[’</li></ol><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 如果是左括号就入栈，如果是右括号就出栈</span></span><br><span class="line">        leftList = [<span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>, <span class="string">&#x27;[&#x27;</span>]</span><br><span class="line">        rightList = [<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;]&#x27;</span>]</span><br><span class="line"></span><br><span class="line">        stack = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> leftList:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">elif</span> i <span class="keyword">in</span> rightList <span class="keyword">and</span> <span class="built_in">len</span>(stack) != <span class="number">0</span>:</span><br><span class="line">                l = stack.pop()</span><br><span class="line">                <span class="keyword">if</span> leftList.index(l) != rightList.index(i):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(stack) != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h1 id="1047-删除字符串中的所有相邻重复项">1047. 删除字符串中的所有相邻重复项</h1><p><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/</a></p><p>给出由小写字母组成的字符串 <code>s</code>，<strong>重复项删除操作</strong>会选择两个相邻且相同的字母，并删除它们。</p><p>在 <code>s</code> 上反复执行重复项删除操作，直到无法继续删除。</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;abbaca&quot;</span><br><span class="line">输出：&quot;ca&quot;</span><br><span class="line">解释：</span><br><span class="line">例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= s.length &lt;= 105</code></li><li><code>s</code> 仅由小写英文字母组成</li></ol><h2 id="思路">思路</h2><ol><li>使用栈可以解决，用栈的top函数，可惜python的列表只有pop没有top；不过可以将弹出的重新添加回去</li><li>如果栈不空，就弹出最后元素并与s[i]判断<ol><li>如果相等就不执行操作了（因为已经弹出了）</li><li>如果不相等，则需要将弹出的元素添加回去，并且再将s[i]入栈</li></ol></li><li>如果栈为空，默认添加s[i]入栈</li></ol><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 使用栈的top()，可惜python的列表只有pop没有top</span></span><br><span class="line">        <span class="comment"># </span></span><br><span class="line">        stack = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">          <span class="comment"># 如果栈不空，就弹出并判断</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(stack):</span><br><span class="line">              <span class="comment"># 默认弹出来并进行判断</span></span><br><span class="line">                l = stack.pop()</span><br><span class="line">                <span class="keyword">if</span> l != i:</span><br><span class="line">                    <span class="comment"># 如果l不等于i，再添加回去</span></span><br><span class="line">                    stack.append(l)</span><br><span class="line">                    stack.append(i)</span><br><span class="line">            <span class="comment"># 栈空就默认添加</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(stack)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday10栈与队列part01&quot;&gt;LeetCodeCampsDay10栈与队列part01&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;使用队列实现栈；&lt;/p&gt;
&lt;p&gt;使用栈实现队列；&lt;/p&gt;
&lt;p&gt;以及两个关于栈的题目&lt;/p&gt;
&lt;/blo</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
    <category term="栈与队列" scheme="https://blog.lthero.cn/tags/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay9字符串part02</title>
    <link href="https://blog.lthero.cn/2025/07/03/LeetCodeCampsDay9/"/>
    <id>https://blog.lthero.cn/2025/07/03/LeetCodeCampsDay9/</id>
    <published>2025-07-03T08:10:02.000Z</published>
    <updated>2025-07-08T10:23:30.595Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday9字符串part02">LeetCodeCampsDay9字符串part02</h1><blockquote><p>字符串反转/kmp算法/重复字符串的查找</p></blockquote><h1 id="151-反转字符串中的单词">151. 反转字符串中的单词</h1><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">https://leetcode.cn/problems/reverse-words-in-a-string/</a></p><p>给你一个字符串 <code>s</code> ，请你反转字符串中 <strong>单词</strong> 的顺序。</p><p><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code> 中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p><p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串。</p><p>**注意：**输入字符串 <code>s</code>中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;the sky is blue&quot;</span><br><span class="line">输出：&quot;blue is sky the&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;  hello world  &quot;</span><br><span class="line">输出：&quot;world hello&quot;</span><br><span class="line">解释：反转后的字符串中不能存在前导空格和尾随空格。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;a good   example&quot;</span><br><span class="line">输出：&quot;example good a&quot;</span><br><span class="line">解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 包含英文大小写字母、数字和空格 <code>' '</code></li><li><code>s</code> 中 <strong>至少存在一个</strong> 单词</li></ul><p>**进阶：**如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 <code>O(1)</code> 额外空间复杂度的 <strong>原地</strong> 解法</p><h2 id="思路">思路</h2><ol><li>先去年多余的空格，可以使用快慢指针思路，当快指针遇到字符时，先给slow添加个空格，当作每两个单词之间的空格（当然slow不能为0）；再同时推进slow与fast，将fast指向的单词转移到slow的位置</li><li>再将整体反转</li><li>最后，将每个单词反转for i in range(L + 1):  if i == L or s[i] == &quot; &quot;: 这里需要注意跳出的条件，因为有时最后一个词也需要反转，但最后一个词后面是没有空格的，所以需要将i的范围从0到L都遍历一遍，并且遇到i==L时，再做一次反转（特殊情况）</li></ol><h2 id="代码">代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseClip</span>(<span class="params">self, s:<span class="built_in">list</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        L = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L//<span class="number">2</span>):</span><br><span class="line">            s[i], s[L - i -<span class="number">1</span>] = s[L - i - <span class="number">1</span>], s[i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeSpace</span>(<span class="params">self, s: <span class="built_in">list</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        L = <span class="built_in">len</span>(s)</span><br><span class="line">        slow = <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; L:</span><br><span class="line">            <span class="keyword">if</span> s[i] != <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> slow != <span class="number">0</span>:</span><br><span class="line">                    s[slow] = <span class="string">&quot; &quot;</span></span><br><span class="line">                    slow += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> i &lt; L <span class="keyword">and</span> s[i] != <span class="string">&quot; &quot;</span>:</span><br><span class="line">                    s[slow] = s[i]</span><br><span class="line">                    slow += <span class="number">1</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[:slow]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseWords</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        s = <span class="built_in">list</span>(s)</span><br><span class="line">        <span class="comment"># 先删除空格</span></span><br><span class="line">        s = self.removeSpace(s)</span><br><span class="line">        <span class="comment"># 先反转整体，再局部反转</span></span><br><span class="line">        s = self.reverseClip(s)</span><br><span class="line">        L = <span class="built_in">len</span>(s)</span><br><span class="line">        leftIndex = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i == L <span class="keyword">or</span> s[i] == <span class="string">&quot; &quot;</span>:</span><br><span class="line">                s[leftIndex: i] = self.reverseClip(s[leftIndex: i])</span><br><span class="line">                leftIndex = i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(s)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="右旋字符串-第八期模拟笔试">右旋字符串（第八期模拟笔试）</h1><p><strong>题目描述</strong></p><p>字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。</p><p>例如，对于输入字符串 “abcdefg” 和整数 2，函数应该将其转换为 “fgabcde”。</p><p><strong>输入描述</strong></p><p>输入共包含两行，第一行为一个正整数 k，代表右旋转的位数。第二行为字符串 s，代表需要旋转的字符串。</p><p><strong>输出描述</strong></p><p>输出共一行，为进行了右旋转操作后的字符串。</p><p><strong>输入示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">abcdefg</span><br></pre></td></tr></table></figure><p><strong>输出示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fgabcde</span><br></pre></td></tr></table></figure><p><strong>提示信息</strong></p><p>数据范围：<br>1 &lt;= k &lt; 10000,<br>1 &lt;= s.length &lt; 10000;</p><h2 id="思路">思路</h2><ol><li>将整体反转</li><li>再将前k个反转，以及剩下的L-k个反转</li></ol><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseClip</span>(<span class="params">self, s: <span class="built_in">list</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        L = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L//<span class="number">2</span>):</span><br><span class="line">            s[i], s[L - i - <span class="number">1</span>] = s[L - i - <span class="number">1</span>], s[i]</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseR</span>(<span class="params">self, k: <span class="built_in">int</span>, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        s = <span class="built_in">list</span>(s)</span><br><span class="line">        s = self.reverseClip(s)</span><br><span class="line">        s[<span class="number">0</span>:k] = self.reverseClip(s[<span class="number">0</span>:k])</span><br><span class="line">        s[k:] = self.reverseClip(s[k:])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(s)</span><br><span class="line"></span><br><span class="line">k = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line">solu = solution()</span><br><span class="line">res = solu.reverseR(k, s)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><h1 id="kmp算法">KMP算法</h1><blockquote><p>核心是求“子串的最长相等前后缀”</p><p>比如&quot;aabaaf&quot;，对f来说，它的子串（即aabaa）的最长相等前后缀是&quot;aa&quot;</p><p>前缀不包含最后一个尾字母，后缀不包含首字母</p><p>kmp学了忘，忘记再学，哎，之前都没理解深刻，这次发现了一个很有意思的两个重点</p><ol><li><strong>left指针是个重点</strong>，它是“已经匹配上的前缀的长度”，而且它不是单调变化的</li><li>kmp每次将前n个字符与后n个字符进行匹配，并且n逐个减一地再进行循环匹配，完美解决了“最长前后缀”的匹配问题</li></ol></blockquote><h2 id="kmp思路">KMP思路</h2><ol><li>KMP的核心思路是找“子串的最长相等前后缀”（所谓的前缀表，即，prefix或next数组）</li><li>比如<strong>aa</strong>b<strong>aa</strong>的最长相等前后缀是&quot;aa&quot;，aabaaf的最长相等前后缀是&quot;&quot;，<strong>a</strong>abaaf<strong>a</strong>的最长相等前后缀是&quot;a&quot;</li><li>可以使用双指针思路来找&quot;最长相等前后缀&quot;</li><li>将数组一分为二，比如aa|baaf，其中aa为前缀子串；baaf为后缀子串</li><li>left指针：指向<strong>已匹配上的前缀的长度</strong>，left是非单向的，它初始化为0-&gt;1-&gt;0-&gt;1-&gt;2-&gt;1，只有当s[left]==s[right]时才递增；否则就会下降</li><li>right指针：指向后缀最后一个位置, right是单向递增的，它只会从1-&gt;2-&gt;3…-&gt;n</li></ol><table><thead><tr><th>下标</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td>串</td><td>a</td><td>a</td><td>b</td><td>a</td><td>a</td><td>b</td><td>f</td></tr><tr><td>前缀表(next数组)</td><td>0</td><td>1</td><td>0</td><td>1</td><td>2</td><td>3</td><td>0</td></tr></tbody></table><h3 id="举例求-aabaa-的next数组">举例求&quot;aabaa&quot;的next数组</h3><p>初始化left=0;next数组全为0；right=1</p><table><thead><tr><th>下标</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>串</td><td>a</td><td>a</td><td>b</td><td>a</td><td>a</td></tr><tr><td>前缀表(next数组)</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>变量位置</td><td>left</td><td>right</td><td></td><td></td><td></td></tr></tbody></table><p>s[left]==s[right]，说明找到了一对最长前后缀&quot;aa&quot;</p><p>left更新：left=left+1即下标1（此时需要指向right的位置），left维护的是0~1这个子串里最长前缀的下标</p><p>并更新next数组，next[right]=left，更新了下标1位置的next数组，说明<strong>长度为1的前缀</strong>与**‘a’(1)匹配**</p><table><thead><tr><th>下标</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>串</td><td>a</td><td>a</td><td>b</td><td>a</td><td>a</td></tr><tr><td>前缀表(next数组)</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>变量位置</td><td></td><td>left</td><td>right</td><td></td><td></td></tr></tbody></table><p><strong>While…</strong></p><ul><li>s[left]!=s[right](s[1]!=s[2])，说明’aa’是无法与’b’匹配的</li><li>Left更新left = next[left-1],即left=0</li><li>然后s[left]再与s[right]判断，此时s[left]!=s[right]，再想更新left = next[left-1]，但此时left已经为0，无法更新，因为越界了，所以需要添加个判断条件left&gt;0时才能更新left（这一步是在一个while执行的）</li></ul><p><strong>If…</strong></p><ul><li>s[left]!=s[right](s[0]!=s[2])，说明’a’无法与’b’匹配</li></ul><p>next[right] = left；更新了下标2位置的next数组，说明<strong>长度为0的前缀</strong>与**'b’匹配**</p><p>最后，right更新，指向下标3</p><table><thead><tr><th>下标</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>串</td><td>a</td><td>a</td><td>b</td><td>a</td><td>a</td></tr><tr><td>前缀表(next数组)</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>变量位置</td><td>left</td><td></td><td></td><td>right</td><td></td></tr></tbody></table><p><strong>While…</strong></p><ul><li>s[left]==s[right](s[0]==s[3])，说明’a’(0)是与’a’(3)匹配的，退出while</li></ul><p><strong>If…</strong></p><ul><li>s[left]==s[right](s[0]==s[3])，说明’a’(0)是与’a’(3)匹配的</li><li>left += 1,  # left = 1</li></ul><p>next[right] = left；更新了下标3位置的next数组，说明<strong>长度为1的前缀</strong>与**‘a’(3)匹配**</p><p>最后，right更新，指向下标4</p><table><thead><tr><th>下标</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>串</td><td>a</td><td>a</td><td>b</td><td>a</td><td>a</td></tr><tr><td>前缀表(next数组)</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td>变量位置</td><td></td><td>left</td><td></td><td></td><td>right</td></tr></tbody></table><p><strong>While…</strong></p><ul><li>s[left]==s[right](s[1]==s[4])，说明’aa’(0,1)是与’aa’(3,4)匹配的，退出while</li></ul><p><strong>If…</strong></p><ul><li>s[left]==s[right](s[1]==s[4])，说明’aa’(0,1)是与’aa’(3,4)匹配的</li><li>left += 1, # left = 2</li></ul><p>next[right] = left；更新了下标4位置的next数组，说明<strong>长度为2的前缀</strong>与**‘aa’(3,4)匹配**</p><p>最后，right更新，指向下标5</p><table><thead><tr><th>下标</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>串</td><td>a</td><td>a</td><td>b</td><td>a</td><td>a</td><td>f</td></tr><tr><td>前缀表(next数组)</td><td>0</td><td>1</td><td>0</td><td>1</td><td>2</td><td>0</td></tr><tr><td>变量位置</td><td></td><td></td><td>left</td><td></td><td></td><td>right</td></tr></tbody></table><p><strong>While…</strong></p><blockquote><p>注意，这里虽然只比较了s[left]!=s[right](s[2]!=s[5])，但它实际比较的是**‘aab’(0,1,2)是与’aaf’(3,4,5)不匹配的**，因为**‘aa’(0,1)是与’aa’(3,4)匹配是已知的信息**，只有将s[2]与s[5]判断，就能直接知道这s(0~2)与s(3~5)是否一样了</p></blockquote><ul><li>s[left]!=s[right](s[2]!=s[5])，说明’aab’(0,1,2)是与’aaf’(3,4,5)不匹配的，于是退而求其次</li><li>left = next[left - 1] # left = 1</li><li>s[left]==s[right](s[1]==s[5])，说明’aa’(0,1)是与’af’(4,5)不匹配的，于是退而求其次</li><li>left = next[left - 1] # left = 0</li><li>s[left]==s[right](s[0]==s[5])，说明’a’(0)是与’f’(5)不匹配的，没得退了，此时left=0</li></ul><p><strong>If…</strong></p><ul><li>s[left]!=s[right](s[0]==s[5])，说明’a’(0)是与’f’(5)不匹配的，if不操作</li></ul><p>next[right] = left；更新了下标4位置的next数组，说明<strong>长度为0的前缀</strong>与**‘f’(5)匹配**</p><p>最后，right更新，指向下标6</p><table><thead><tr><th>下标</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td>串</td><td>a</td><td>a</td><td>b</td><td>a</td><td>a</td><td>f</td><td>a</td></tr><tr><td>前缀表(next数组)</td><td>0</td><td>1</td><td>0</td><td>1</td><td>2</td><td>0</td><td>0</td></tr><tr><td>变量位置</td><td>left</td><td></td><td></td><td></td><td></td><td></td><td>right</td></tr></tbody></table><p><img src="https://file1.kamacoder.com/i/algo/KMP%E7%B2%BE%E8%AE%B22.gif" alt="img"></p><blockquote><p>KMP一个很神奇的一点是，它每次将前n个字符与后n个字符进行匹配，并且n逐个减一地再进行循环匹配，比如</p></blockquote><p><strong>’aab’(0,1,2)是与’aaf’(3,4,5)不匹配的</strong></p><p>然后会比较</p><p><strong>’aa’(0,1)是与’af’(4,5)不匹配的</strong>，</p><p>然后再比较</p><p><strong>’a’(0)是与’f’(5)不匹配的</strong></p><p>很完美地完成了“最长前后缀”问题</p><h3 id="怎么理解left指针是已匹配上的前缀的长度呢">怎么理解left指针是已匹配上的前缀的长度呢</h3><p>left代表当前子串 <code>s[0...right]</code> 的“最长相等前后缀”的长度。</p><p>left同时也是指向“最长前缀”的下一个字符的下标。</p><ul><li>当 <code>left</code> 为 0 时，我们比较 <code>s[0]</code> 和 <code>s[right]</code>。</li><li>当 <code>left</code> 为 1 时，意味着前缀 <code>s[0]</code> 已经匹配上了，我们接下来要比较 <code>s[1]</code> 和 <code>s[right]</code>。</li><li>当 <code>left</code> 为 <code>k</code> 时，意味着前缀 <code>s[0...k-1]</code> 已经匹配上了，我们接下来要比较 <code>s[k]</code> 和 <code>s[right]</code>。</li></ul><h2 id="kmp代码">KMP代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(N)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getNext</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        <span class="comment"># 函数返回s的最大相等前缀的数值结果表</span></span><br><span class="line">        L = <span class="built_in">len</span>(s)</span><br><span class="line">        nextArry = [<span class="number">0</span>] * L</span><br><span class="line">        left = <span class="number">0</span> <span class="comment"># “已匹配上的前缀的长度”（很关键的一句话，如果能解理就能明白KMP算法了）</span></span><br><span class="line">        nextIndex = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L):</span><br><span class="line">            <span class="comment"># 这里有个假设，next表是已经打造好的东西（或者是一边打造一边就要用）</span></span><br><span class="line">            <span class="comment"># 当s[left] != s[right]，让right向前搜索，令right = next[right - 1];</span></span><br><span class="line">            <span class="comment"># 很关键的思想，有点儿递归的意思</span></span><br><span class="line">            <span class="keyword">while</span> s[left] != s[right] <span class="keyword">and</span> left &gt; <span class="number">0</span>:</span><br><span class="line">                left = nextArry[left - <span class="number">1</span>]</span><br><span class="line">            <span class="comment"># 当s[left]等于s[right]说明找到了一组相等的前后缀</span></span><br><span class="line">            <span class="keyword">if</span> s[left] == s[right]:</span><br><span class="line">                <span class="comment"># 前缀指针向后移动</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 更新next数组，这里的right即是next的下标，也是后缀的下标</span></span><br><span class="line">            <span class="comment"># 当然可以将nextIndex与right分开；这样更明确一点儿</span></span><br><span class="line">            nextArry[nextIndex] = left</span><br><span class="line">            nextIndex += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nextArry</span><br></pre></td></tr></table></figure><h1 id="28-找出字符串中第一个匹配项的下标">28. 找出字符串中第一个匹配项的下标</h1><p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/</a></p><p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串的第一个匹配项的下标（下标从 0 开始）。如果 <code>needle</code> 不是 <code>haystack</code> 的一部分，则返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：haystack = &quot;sadbutsad&quot;, needle = &quot;sad&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：&quot;sad&quot; 在下标 0 和 6 处匹配。</span><br><span class="line">第一个匹配项的下标是 0 ，所以返回 0 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：haystack = &quot;leetcode&quot;, needle = &quot;leeto&quot;</span><br><span class="line">输出：-1</span><br><span class="line">解释：&quot;leeto&quot; 没有在 &quot;leetcode&quot; 中出现，所以返回 -1 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= haystack.length, needle.length &lt;= 104</code></li><li><code>haystack</code> 和 <code>needle</code> 仅由小写英文字符组成</li></ul><h2 id="思路">思路</h2><ol><li>先求next数组；</li><li>再进行匹配，不过求next数组的代码和匹配字符串时的代码是相似的，但需要注意<ol><li>root串使用「right」指针进行遍历，下标从0开始，而不是求next中的从1开始，一直遍历到len(root)</li><li>终止条件是当len(subRoot) == left时，说明找到了匹配的下标，此时right - len(subRoot) + 1即是匹配的下标</li></ol></li></ol><h2 id="代码">代码</h2><ul><li>时间复杂度O(N+M), 其中N为haystack长度，M是needle长度</li><li>空间复杂度O(M)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getNext</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        <span class="comment"># 函数返回s的最大相等前缀的数值结果表</span></span><br><span class="line">        L = <span class="built_in">len</span>(s)</span><br><span class="line">        nextArry = [<span class="number">0</span>] * L</span><br><span class="line">        left = <span class="number">0</span> <span class="comment"># “当前子串中的最长前缀的下标”（很关键的一句话，如果能解理就能明白KMP算法了）</span></span><br><span class="line">        nextIndex = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L):</span><br><span class="line">            <span class="comment"># 这里有个假设，next表是已经打造好的东西（或者是一边打造一边就要用）</span></span><br><span class="line">            <span class="comment"># 当s[left] != s[right]，让right向前搜索，令right = next[right - 1];</span></span><br><span class="line">            <span class="comment"># 很关键的思想，有点儿递归的意思</span></span><br><span class="line">            <span class="keyword">while</span> s[left] != s[right] <span class="keyword">and</span> left &gt; <span class="number">0</span>:</span><br><span class="line">                left = nextArry[left - <span class="number">1</span>]</span><br><span class="line">            <span class="comment"># 当s[left]等于s[right]说明找到了一组相等的前后缀</span></span><br><span class="line">            <span class="keyword">if</span> s[left] == s[right]:</span><br><span class="line">                <span class="comment"># 前缀指针向后移动</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 更新next数组，这里的right即是next的下标，也是后缀的下标</span></span><br><span class="line">            <span class="comment"># 当然可以将nextIndex与right分开；这样更明确一点儿</span></span><br><span class="line">            nextArry[right] = left</span><br><span class="line">            <span class="comment"># nextIndex += 1</span></span><br><span class="line">        <span class="keyword">return</span> nextArry</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">strStr</span>(<span class="params">self, haystack: <span class="built_in">str</span>, needle: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nextArry = self.getNext(needle)</span><br><span class="line">        L_needle = <span class="built_in">len</span>(needle)</span><br><span class="line">        L_hay = <span class="built_in">len</span>(haystack)</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(L_hay):</span><br><span class="line">            <span class="keyword">while</span> left &gt; <span class="number">0</span> <span class="keyword">and</span> haystack[right] != needle[left]:</span><br><span class="line">                left = nextArry[left - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> needle[left] == haystack[i]:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 唯独需要在这儿判断是否到了needle的尾部</span></span><br><span class="line">            <span class="keyword">if</span> left == L_needle:</span><br><span class="line">                <span class="keyword">return</span> right - L_needle + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="459-重复的子字符串">459. 重复的子字符串</h1><p><a href="https://leetcode.cn/problems/repeated-substring-pattern/">https://leetcode.cn/problems/repeated-substring-pattern/</a></p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abab&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 可由子串 &quot;ab&quot; 重复两次构成。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;aba&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcabcabc&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 可由子串 &quot;abc&quot; 重复四次构成。 (或子串 &quot;abcabc&quot; 重复两次构成。)</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 由小写英文字母组成</li></ul><h2 id="思路">思路</h2><p>思路分析看</p><p><a href="https://programmercarl.com/0459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html#%E6%80%9D%E8%B7%AF">https://programmercarl.com/0459.重复的子字符串.html#思路</a></p><p><img src="https://file1.kamacoder.com/i/algo/459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2_1.png" alt="img"></p><p><code>next[len - 1] = 7</code>，<code>next[len - 1] + 1 = 8</code>，8就是此时字符串asdfasdfasdf的最长相同前后缀的长度。</p><p><code>(len - (next[len - 1] + 1))</code> 也就是： 12(字符串的长度) - 8(最长公共前后缀的长度) = 4， 为最长相同前后缀不包含的子串长度</p><p>4可以被 12(字符串的长度) 整除，所以说明有重复的子字符串（asdf）</p><p>这种重复的子字符串检测可以应用在“程序中的”密码检测，如果是弱密码比如abcacb，可以进行实时的提醒</p><h2 id="代码">代码</h2><ul><li>时间复杂度(N)</li><li>空间复杂度(N)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getNext</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        L = <span class="built_in">len</span>(s)</span><br><span class="line">        nextArray = [<span class="number">0</span>] * L</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L):</span><br><span class="line">            <span class="keyword">while</span> s[left]!=s[right] <span class="keyword">and</span> left &gt; <span class="number">0</span>:</span><br><span class="line">                left = nextArray[left - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> s[left]==s[right]:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            nextArray[right] = left</span><br><span class="line">        <span class="keyword">return</span> nextArray</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">repeatedSubstringPattern</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        L = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">if</span> L == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        nextArray = self.getNext(s)</span><br><span class="line">        <span class="keyword">if</span> nextArray[-<span class="number">1</span>]!=<span class="number">0</span> <span class="keyword">and</span> L % (L - nextArray[-<span class="number">1</span>]) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday9字符串part02&quot;&gt;LeetCodeCampsDay9字符串part02&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;字符串反转/kmp算法/重复字符串的查找&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;151-反转字符串</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
    <category term="字符串" scheme="https://blog.lthero.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="kmp" scheme="https://blog.lthero.cn/tags/kmp/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay8字符串01</title>
    <link href="https://blog.lthero.cn/2025/07/02/LeetCodeCampsDay8/"/>
    <id>https://blog.lthero.cn/2025/07/02/LeetCodeCampsDay8/</id>
    <published>2025-07-02T08:32:11.000Z</published>
    <updated>2025-07-08T10:17:50.847Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday8字符串part01">LeetCodeCampsDay8字符串part01</h1><blockquote><p>双指针/字符串反转/python列表与字符串互换/python列表语法糖</p></blockquote><h1 id="344-反转字符串">344. 反转字符串</h1><p><a href="https://leetcode.cn/problems/reverse-string/">https://leetcode.cn/problems/reverse-string/</a></p><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>s</code> 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>修改输入数组**、使用 O(1) 的额外空间解决这一问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]</span><br><span class="line">输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 105</code></li><li><code>s[i]</code> 都是 <a href="https://baike.baidu.com/item/ASCII">ASCII</a> 码表中的可打印字符</li></ul><h2 id="思路零">思路零</h2><ol><li>使用python内置库函数，可以了解下</li></ol><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseString</span>(<span class="params">self, s: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># method1</span></span><br><span class="line">s[::] = s[::-<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># method2</span></span><br><span class="line">        <span class="comment"># s[::] = reversed(s)</span></span><br></pre></td></tr></table></figure><h2 id="思路一双指针">思路一双指针</h2><ol><li>使用双指针，一个从头开始一个从尾部开始，逐个交换即可</li></ol><h2 id="代码">代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseString</span>(<span class="params">self, s: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        L = <span class="built_in">len</span>(s)</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = L - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            s[left], s[right] = s[right], s[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="思路二用range">思路二用range</h2><ol><li>因为while每次都要判断条件，增加了时间复杂度，可以使用range(0, L//2)</li></ol><h2 id="代码">代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseString</span>(<span class="params">self, s: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        L = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L//<span class="number">2</span>):</span><br><span class="line">            s[i], s[L - i - <span class="number">1</span>] = s[L - i -<span class="number">1</span>], s[i]</span><br></pre></td></tr></table></figure><h2 id="思路三用栈">思路三用栈</h2><ol><li>将数据入栈，再逐个弹出；缺点是需要两个循环</li></ol><h2 id="代码">代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseString</span>(<span class="params">self, s: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        L = <span class="built_in">len</span>(s)</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">            s[i] = stack.pop()</span><br></pre></td></tr></table></figure><h1 id="541-反转字符串-ii">541. 反转字符串 II</h1><p><a href="https://leetcode.cn/problems/reverse-string-ii/">https://leetcode.cn/problems/reverse-string-ii/</a></p><p>给定一个字符串 <code>s</code> 和一个整数 <code>k</code>，从字符串开头算起，每计数至 <code>2k</code> 个字符，就反转这 <code>2k</code> 字符中的前 <code>k</code> 个字符。</p><ul><li>如果剩余字符少于 <code>k</code> 个，则将剩余字符全部反转。</li><li>如果剩余字符小于 <code>2k</code> 但大于或等于 <code>k</code> 个，则反转前 <code>k</code> 个字符，其余字符保持原样。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">输出：&quot;bacdfeg&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abcd&quot;, k = 2</span><br><span class="line">输出：&quot;bacd&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅由小写英文组成</li><li><code>1 &lt;= k &lt;= 104</code></li></ul><h2 id="思路">思路</h2><ol><li>输入是字符串，必须经过处理转成列表；字符串无法被直接修改</li><li>使用反转字符串的思路，写个完全反转的辅助函数</li><li>主思路，使用两个指针，每次按2k的长度对s进行滑动（所谓滑动窗口）<ol><li>对窗口内的子段进行长度判断，如果长度大于等于k，则只反转前k个；否则反转窗口内所有内容</li></ol></li><li>更新left与right；其中left = right；而right = left + 2 * k;</li></ol><h2 id="代码">代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseStrClip</span>(<span class="params">self, s:<span class="built_in">list</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        L = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L//<span class="number">2</span>):</span><br><span class="line">            s[i], s[L - i - <span class="number">1</span>] = s[L - i -<span class="number">1</span>], s[i]</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseStr</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">      <span class="comment"># 字符串无法被修改，必须转成list</span></span><br><span class="line">        s = <span class="built_in">list</span>(s)</span><br><span class="line">        left = right = <span class="number">0</span></span><br><span class="line">        L = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="comment"># 退出条件是left到底</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;  L:</span><br><span class="line">            left = right</span><br><span class="line">            right = left + <span class="number">2</span> * k</span><br><span class="line">            <span class="keyword">if</span> right - left &gt;= k:</span><br><span class="line">                s[left: left+k] = self.reverseStrClip(s[left: left+k])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">              <span class="comment"># 因为剩下所有的内容已经小于k了，全部反转即可</span></span><br><span class="line">              s[left:] = self.reverseStrClip(s[left:])</span><br><span class="line">                <span class="comment">#s[left: right] = self.reverseStrClip(s[left: right])</span></span><br><span class="line">        <span class="comment"># 转回字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(s)</span><br></pre></td></tr></table></figure><p>改进，同样的，推荐使用range而不是while，可以提高速度</p><p>Range(0, L, 2 * k)，即将i作为left，而right每次手动计算下即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseStrClip</span>(<span class="params">self, s:<span class="built_in">list</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        L = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L//<span class="number">2</span>):</span><br><span class="line">            s[i], s[L - i - <span class="number">1</span>] = s[L - i -<span class="number">1</span>], s[i]</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseStr</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 设置好开始结束区间</span></span><br><span class="line">        <span class="comment"># 一共两个条件</span></span><br><span class="line">        s = <span class="built_in">list</span>(s)</span><br><span class="line">        left = right = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 退出条件是left到底</span></span><br><span class="line">        L = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, L , <span class="number">2</span> * k):</span><br><span class="line">            <span class="keyword">if</span> i + k &lt;= L:</span><br><span class="line">                s[i: i + k] = self.reverseStrClip(s[i: i + k])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">              <span class="comment"># 剩下内容个数小于k，全部反转</span></span><br><span class="line">              <span class="comment"># s[i:] = self.reverseStrClip(s[i:]) 也是可以的</span></span><br><span class="line">                s[i: i + <span class="number">2</span> * k] = self.reverseStrClip(s[i: i + <span class="number">2</span> * k])</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(s)</span><br></pre></td></tr></table></figure><h2 id="思路二-python列表特性语法糖">思路二(Python列表特性语法糖)</h2><blockquote><p>Python列表特性语法糖</p></blockquote><ol><li>更直接一点儿，都不用进行条件判断，<strong>直接对每次2k内的前k个元素进行反转即可</strong>（不用管它长度是大于k还是小于k，直接按k个进行切片）</li><li>这里利用了<strong>python的一个列表性质</strong>：s[start:end]，哪怕end越出了实际长度，python只会把它当成s[start:-1]，也就是把start后所有内容返回，而不会报错；<ul><li>比如s = [‘a’, ‘b’] 且k = 4，如果i = 0时，s[0 + 4]会是[‘a’, ‘b’]</li></ul></li><li>利用这种性质，可以直接<code>s[i: i + k] = self.reverseStrClip(s[i: i + k])</code> ，而不用进行长度的判断；这也算是语法糖了，这种东西最好不要用，不然容易解释不清楚，还以为这样的算法是正确的，但没想到是语言在兜底</li></ol><h2 id="代码">代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(N)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseStr</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">L = <span class="built_in">len</span>(s)</span><br><span class="line">        s = <span class="built_in">list</span>(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, L, <span class="number">2</span> * k):</span><br><span class="line">          <span class="comment"># </span></span><br><span class="line">            s[i: i + k] = s[i: i + k][::-<span class="number">1</span>]</span><br><span class="line">            <span class="comment"># 或者用自己写的函数也行</span></span><br><span class="line">            <span class="comment"># s[i: i + k] = self.reverseStrClip(s[i: i + k])</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(s)</span><br></pre></td></tr></table></figure><h1 id="54-替换数字">54.替换数字</h1><p><a href="https://kamacoder.com/problempage.php?pid=1064">https://kamacoder.com/problempage.php?pid=1064</a></p><p><strong>题目描述</strong></p><p>给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。 例如，对于输入字符串 “a1b2c3”，函数应该将其转换为 “anumberbnumbercnumber”。</p><p><strong>输入描述</strong></p><p>输入一个字符串 s,s 仅包含小写字母和数字字符。</p><p><strong>输出描述</strong></p><p>打印一个新的字符串，其中每个数字字符都被替换为了number</p><p><strong>输入示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a1b2c3</span><br></pre></td></tr></table></figure><p><strong>输出示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anumberbnumbercnumber</span><br></pre></td></tr></table></figure><p><strong>提示信息</strong></p><p>数据范围：<br>1 &lt;= s.length &lt; 10000。</p><h2 id="思路">思路</h2><ol><li>偷懒思路：字符串转成列表，再判断是否为数字，是则替换</li><li>可以使用ord()来找ascii码，比较通用；或者使用python库函数s.isdigit()</li></ol><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">s:<span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    s = <span class="built_in">list</span>(s)</span><br><span class="line">    L = <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">ord</span>(<span class="string">&#x27;9&#x27;</span>) &gt;= <span class="built_in">ord</span>(s[i]) &gt;= <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>):</span><br><span class="line">            s[i] = <span class="string">&quot;number&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(s)</span><br><span class="line"></span><br><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line"><span class="built_in">print</span>(foo(s))</span><br></pre></td></tr></table></figure><h2 id="思路二-纯算法">思路二(纯算法)</h2><ol><li>如果需要正常写，需要进行 <code>数组扩展</code> 以及 <code>数组填充</code>（倒序填充）</li><li>先统计原数组内的digital个数，再创建个新数组res，容量为<strong>len(s) + countDig * 5</strong></li><li>随后，使用双指针，同时对s与res从后向前遍历，如果遇到s[indexOld]是digital则将res[indexNew-5: indexNew+1]=&quot;number&quot;直接赋值即可，或者逐个赋值；如果不是digital，直接将s[indexOld]复制到res[indexNew]即可</li></ol><p><img src="https://file1.kamacoder.com/i/algo/20231030173058.png" alt="img"></p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        L = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="comment"># 统计str中digital个数</span></span><br><span class="line">        countDigital = <span class="built_in">sum</span>(<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> s <span class="keyword">if</span> i.isdigit())</span><br><span class="line">        <span class="comment"># 创建新结果数组, 等于原数组长度 + countDigital * 5</span></span><br><span class="line">        res = [<span class="string">&#x27;&#x27;</span>] * (countDigital * <span class="number">5</span> + L)</span><br><span class="line">        <span class="comment"># 从后向前对res进行填充</span></span><br><span class="line">        newIndex = <span class="built_in">len</span>(res) - <span class="number">1</span></span><br><span class="line">        oldIndex = L - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> oldIndex &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> s[oldIndex].isdigit():</span><br><span class="line">                res[newIndex - <span class="number">5</span>: newIndex + <span class="number">1</span>] = <span class="string">&quot;number&quot;</span></span><br><span class="line">                newIndex -= <span class="number">6</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res[newIndex] = s[oldIndex]</span><br><span class="line">                newIndex -= <span class="number">1</span></span><br><span class="line">            oldIndex -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(res)</span><br><span class="line"></span><br><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line">solu = solution()</span><br><span class="line"><span class="built_in">print</span>(solu.foo(s))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday8字符串part01&quot;&gt;LeetCodeCampsDay8字符串part01&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;双指针/字符串反转/python列表与字符串互换/python列表语法糖&lt;/p&gt;
&lt;/blockquote&gt;
&lt;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
    <category term="字符串" scheme="https://blog.lthero.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay7哈希表part02</title>
    <link href="https://blog.lthero.cn/2025/06/30/LeetCodeCampsDay7/"/>
    <id>https://blog.lthero.cn/2025/06/30/LeetCodeCampsDay7/</id>
    <published>2025-06-30T13:49:11.000Z</published>
    <updated>2025-07-08T10:17:40.014Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday7哈希表part02">LeetCodeCampsDay7哈希表part02</h1><blockquote><p>双指针/生产者消费者/HashTable</p></blockquote><h1 id="383-赎金信">383. 赎金信</h1><p><a href="https://leetcode.cn/problems/ransom-note/">https://leetcode.cn/problems/ransom-note/</a></p><p>给你两个字符串：<code>ransomNote</code> 和 <code>magazine</code> ，判断 <code>ransomNote</code> 能不能由 <code>magazine</code> 里面的字符构成。</p><p>如果可以，返回 <code>true</code> ；否则返回 <code>false</code> 。</p><p><code>magazine</code> 中的每个字符只能在 <code>ransomNote</code> 中使用一次。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：ransomNote = &quot;a&quot;, magazine = &quot;b&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：ransomNote = &quot;aa&quot;, magazine = &quot;ab&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：ransomNote = &quot;aa&quot;, magazine = &quot;aab&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= ransomNote.length, magazine.length &lt;= 105</code></li><li><code>ransomNote</code> 和 <code>magazine</code> 由小写英文字母组成</li></ul><h2 id="思路">思路</h2><ol><li>把这题目当成生成者，消费者问题：ransomNote是消费者，它需要消费指定数量的指定字符；matezine是生产者</li><li><strong>ransomNote 长度要少于等于 magazine</strong>, 因为magazine中字符只能使用一次</li><li>需要用到hash table</li></ol><h3 id="与242-区别">与242.区别</h3><p>在242. 有效的字母异位词中，可以同步遍历的原因是<strong>两者相互为生产者与消费者</strong>；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 仅当长度相等时，同步推进，减少一次遍历次数</span></span><br><span class="line"><span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">zip</span>(s,t):</span><br><span class="line">    nums[<span class="built_in">ord</span>(i) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">    nums[<span class="built_in">ord</span>(j) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] -= <span class="number">1</span></span><br></pre></td></tr></table></figure><p>本题特殊性是，<strong>magazine需要cover掉ransomNote用的字符</strong>，所以必须先遍历ransomNote，<strong>了解ransomNote的需求</strong>；</p><p>再遍历magazine，如果某个字符需求数量大于0，再将需求减一；<strong>否则没必要操作</strong>：</p><p>比如ransomNote = “aa”, magazine = “aab”，虽然’b’在magazine中，但table[‘b’-‘a’]=0，没必要进行操作的</p><h2 id="代码">代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canConstruct</span>(<span class="params">self, ransomNote: <span class="built_in">str</span>, magazine: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 本题特殊性是，magazine需要cover掉ransomNote用的字符</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(ransomNote) &gt; <span class="built_in">len</span>(magazine):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        table = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 消费者需要的量</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> ransomNote:</span><br><span class="line">            table[<span class="built_in">ord</span>(i) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 生产者有的量</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> magazine:</span><br><span class="line">            <span class="comment"># 如果消费者有这个字符的需求，才减少，不然没必须操作</span></span><br><span class="line">            <span class="keyword">if</span> table[<span class="built_in">ord</span>(i) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] &gt; <span class="number">0</span>:</span><br><span class="line">                table[<span class="built_in">ord</span>(i) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 直接求和，只有等于零时才满足要求</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">sum</span>(table)!= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 或者逐个遍历也是一样的</span></span><br><span class="line">        <span class="comment"># for i in table:</span></span><br><span class="line">        <span class="comment">#     if i != 0:</span></span><br><span class="line">        <span class="comment">#         return False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure><h1 id="15-三数之和">15. 三数之和</h1><blockquote><p>对于<a href="https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html">15.三数之和 (opens new window)</a>双指针法就是将原本暴力O(n^3)的解法，降为O(n^2)的解法，四数之和的双指针解法就是将原本暴力O(n^4)的解法，降为O(n^3)的解法。</p></blockquote><p><a href="https://leetcode.cn/problems/3sum/">https://leetcode.cn/problems/3sum/</a></p><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p><p>**注意：**答案中不可以包含重复的三元组。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br><span class="line">解释：</span><br><span class="line">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。</span><br><span class="line">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。</span><br><span class="line">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。</span><br><span class="line">不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span><br><span class="line">注意，输出的顺序和三元组的顺序并不重要。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,1]</span><br><span class="line">输出：[]</span><br><span class="line">解释：唯一可能的三元组和不为 0 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,0,0]</span><br><span class="line">输出：[[0,0,0]]</span><br><span class="line">解释：唯一可能的三元组和为 0 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 3000</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul><h2 id="思路">思路</h2><ol><li>这题目和1. 两数之和很像，但本题target固定为0</li><li>这题目用hash table会变得复杂，使用双指针更简单</li><li>从左向右遍历，先固定一个数,如num[0]，则num[1:]可以看成一个“两数之和”的问题，并且target变成0-num[0]</li><li></li></ol><h2 id="代码">代码</h2><ul><li>时间复杂度O(N^2)</li><li>空间复杂度O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 这题目和1. 两数之和很像，但本题target固定为0</span></span><br><span class="line">        <span class="comment"># 这题目用hash table会变得复杂，使用双指针更简单</span></span><br><span class="line">        <span class="comment"># 从左向右遍历，先固定一个数,如num[0]，则num[1:]可以看成一个“两数之和”的问题，并且target变成0-num[0]</span></span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">            <span class="keyword">if</span> nums[index] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            <span class="comment"># 对于nums[index]来说, 跳过相同的数字</span></span><br><span class="line">            <span class="keyword">if</span> index &gt; <span class="number">0</span> <span class="keyword">and</span> nums[index] == nums[index - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            left = index + <span class="number">1</span></span><br><span class="line">            right = L - <span class="number">1</span></span><br><span class="line">            currentTarget = - nums[index]</span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                <span class="comment"># 计算双指针的和</span></span><br><span class="line">                currentSum = nums[left] + nums[right]</span><br><span class="line">                <span class="keyword">if</span> currentSum == currentTarget:</span><br><span class="line">                    res.append([nums[index], nums[left], nums[right]]) </span><br><span class="line">                    <span class="comment"># 需要去重复</span></span><br><span class="line">                    <span class="keyword">while</span> right &gt; left <span class="keyword">and</span> nums[right] == nums[right - <span class="number">1</span>]:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> right &gt; left <span class="keyword">and</span> nums[left] == nums[left + <span class="number">1</span>]:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 记得修改条件</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> currentSum &lt; currentTarget:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="思路二-字典">思路二(字典)</h2><ol><li>或者和之前一样，使用字典也能做</li><li>同样，对nums里每个num遍历，把剩下的nums看成双数相加等于target问题</li><li>创建个字典，用来记录剩下nums的其中一个值，并在剩下nums找另一个值；如果</li></ol><p><img src="https://file1.kamacoder.com/i/algo/20220711202638.png" alt="img"></p><h2 id="代码">代码</h2><ul><li>时间复杂度O(N^2)</li><li>空间复杂度O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">            <span class="keyword">if</span> nums[index] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            <span class="comment"># 对于nums[index]来说, 跳过相同的数字</span></span><br><span class="line">            <span class="keyword">if</span> index &gt; <span class="number">0</span> <span class="keyword">and</span> nums[index] == nums[index - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            table = <span class="built_in">dict</span>()</span><br><span class="line">            <span class="comment"># 更新target</span></span><br><span class="line">            target = <span class="number">0</span> - nums[index]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(index + <span class="number">1</span>, L):</span><br><span class="line">              <span class="comment"># 跳过重复的值</span></span><br><span class="line">                <span class="keyword">if</span> j &gt; index + <span class="number">2</span> <span class="keyword">and</span> nums[j] == nums[j - <span class="number">1</span>] == nums[j - <span class="number">2</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 后面的思路和1. 两数之和完全一样，判断某个值是否已经在table里了，如果在，说明它就是需要被找到的值</span></span><br><span class="line">                <span class="comment"># 否则就把它添加进去</span></span><br><span class="line">                <span class="keyword">if</span> nums[j] <span class="keyword">in</span> table:</span><br><span class="line">                    res.append([nums[index], nums[j], target - nums[j]])</span><br><span class="line">                    table.pop(nums[j])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    table[target - nums[j]] = j</span><br></pre></td></tr></table></figure><h1 id="18-四数之和">18. 四数之和</h1><p><a href="https://leetcode.cn/problems/4sum/">https://leetcode.cn/problems/4sum/</a></p><p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code> ，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p><ul><li><code>0 &lt;= a, b, c, d &lt; n</code></li><li><code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> <strong>互不相同</strong></li><li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li></ul><p>你可以按 <strong>任意顺序</strong> 返回答案 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,0,-1,0,-2,2], target = 0</span><br><span class="line">输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,2,2,2,2], target = 8</span><br><span class="line">输出：[[2,2,2,2]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 200</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li></ul><h2 id="思路">思路</h2><ol><li>和三数之和几乎一样，这题目可以扩展到N数之和</li><li>可以不提前退出，但必须“去重复”；否则[2,2,2,2,2]（输入），会输出[[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2]]</li><li>提前退出的条件<ol><li>条件1：if nums[i] &gt; target and nums[i] &gt; 0 and target &gt; 0:</li><li>条件2：if nums[i] + nums[j] &gt; target and target &gt; 0</li><li>满足其中一个即可退出</li></ol></li></ol><h2 id="代码">代码</h2><ul><li>时间复杂度O(N^3)</li><li>空间复杂度O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 和三数之和相似，但可以用两层for循环，将原本需要O(n^4)降为O(n^3)</span></span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">            <span class="comment"># 必须去重复，否则[2,2,2,2,2]（输入），会输出[[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2]]</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 提前退出[Optional]</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; target <span class="keyword">and</span> nums[i] &gt; <span class="number">0</span> <span class="keyword">and</span> target &gt; <span class="number">0</span>:</span><br><span class="line">              <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, L):</span><br><span class="line">                <span class="comment"># 必须去重复</span></span><br><span class="line">                <span class="keyword">if</span> j &gt; i + <span class="number">1</span> <span class="keyword">and</span> nums[j] == nums[j - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 提前退出[Optional]</span></span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[j] &gt; target <span class="keyword">and</span> target &gt; <span class="number">0</span></span><br><span class="line">                <span class="keyword">break</span> </span><br><span class="line">                  </span><br><span class="line">                <span class="comment"># 双指针</span></span><br><span class="line">                left = j + <span class="number">1</span></span><br><span class="line">                right = L - <span class="number">1</span></span><br><span class="line">                current_target = target - nums[i] - nums[j]</span><br><span class="line">                <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                    currentSum = nums[left] + nums[right]</span><br><span class="line">                    <span class="keyword">if</span> current_target == currentSum:</span><br><span class="line">                        res.append([nums[i], nums[j], nums[left], nums[right]])</span><br><span class="line">                        <span class="comment"># 同样是为了去重复</span></span><br><span class="line">                        <span class="keyword">while</span> right &gt; left <span class="keyword">and</span> nums[right] == nums[right - <span class="number">1</span>]:</span><br><span class="line">                            right -= <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> right &gt; left <span class="keyword">and</span> nums[left] == nums[left + <span class="number">1</span>]:</span><br><span class="line">                            left += <span class="number">1</span></span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> currentSum &lt; current_target:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="思路二-字典">思路二(字典)</h2><p>同样，这题目也可以用dict解决，我刚开始没有去重复，于是错误了</p><ul><li>时间复杂度O(N^3)</li><li>空间复杂度O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 和三数之和相似，但可以用两层for循环，将原本需要O(n^4)降为O(n^3)</span></span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">            <span class="comment"># 必须去重复，否则[2,2,2,2,2]（输入），会输出[[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2]]</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, L):</span><br><span class="line">                <span class="comment"># 必须去重复</span></span><br><span class="line">                <span class="keyword">if</span> j &gt; i + <span class="number">1</span> <span class="keyword">and</span> nums[j] == nums[j - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 用hash table试试</span></span><br><span class="line">                table = <span class="built_in">dict</span>()</span><br><span class="line">                current_target = target - nums[i] - nums[j]</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(j + <span class="number">1</span>, L):</span><br><span class="line">                    <span class="keyword">if</span> k &gt; j + <span class="number">3</span> <span class="keyword">and</span> nums[k] == nums[k - <span class="number">1</span>] == nums[k - <span class="number">2</span>] == nums[k - <span class="number">3</span>]:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> nums[k] <span class="keyword">in</span> table:</span><br><span class="line">                        res.append([nums[i], nums[j], nums[k], current_target - nums[k]])</span><br><span class="line">                        table.pop(nums[k])</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        table[current_target - nums[k]] = k</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                </span><br></pre></td></tr></table></figure><h1 id="454-四数相加-ii">454. 四数相加 II</h1><p><a href="https://leetcode.cn/problems/4sum-ii/">https://leetcode.cn/problems/4sum-ii/</a></p><p>给你四个整数数组 <code>nums1</code>、<code>nums2</code>、<code>nums3</code> 和 <code>nums4</code> ，数组长度都是 <code>n</code> ，请你计算有多少个元组 <code>(i, j, k, l)</code> 能满足：</p><ul><li><code>0 &lt;= i, j, k, l &lt; n</code></li><li><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">两个元组如下：</span><br><span class="line">1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0</span><br><span class="line">2. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums1.length</code></li><li><code>n == nums2.length</code></li><li><code>n == nums3.length</code></li><li><code>n == nums4.length</code></li><li><code>1 &lt;= n &lt;= 200</code></li><li><code>-228 &lt;= nums1[i], nums2[i], nums3[i], nums4[i] &lt;= 228</code></li></ul><h2 id="思路">思路</h2><ol><li>之前的三数之和、四数之和是在同一个数组查找，现在是四个不同的数组</li><li>用两个双层for循环，先算A, B的所有和，放在字典中；再算C, D所有排列组合可能的和，从字典中查找是否存在这样的键，如果存在就将这个键对应的值（即A,B的所有的和出现的次数</li></ol><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSumCount</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>], nums3: <span class="type">List</span>[<span class="built_in">int</span>], nums4: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 统计 a+b+c+d = 0 出现的次数</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="comment"># key放a和b两数之和，value 放a和b两数之和出现的次数</span></span><br><span class="line">        table = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="comment"># 先计算nums1, nums2的排列组合可能的和</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> nums2:</span><br><span class="line">                table[i + j] = table.get(i + j, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="comment"># </span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums3:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> nums4:</span><br><span class="line">                <span class="keyword">if</span> table.get(- i - j, <span class="number">0</span>):</span><br><span class="line">                    res += table[<span class="number">0</span> - i - j]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday7哈希表part02&quot;&gt;LeetCodeCampsDay7哈希表part02&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;双指针/生产者消费者/HashTable&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;383-赎金信&quot;&gt;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay6哈希表part01</title>
    <link href="https://blog.lthero.cn/2025/06/30/LeetCodeCampsDay6/"/>
    <id>https://blog.lthero.cn/2025/06/30/LeetCodeCampsDay6/</id>
    <published>2025-06-30T06:37:28.000Z</published>
    <updated>2025-07-08T10:18:18.248Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday6哈希表part01">LeetCodeCampsDay6哈希表part01</h1><blockquote><p>以及几题目主要利用hash table的“唯一性”思想解决题目</p><p>关键词：哈希表；快慢指针；双指针；用set/dict/当成hash表；</p></blockquote><h1 id="242-有效的字母异位词">242. 有效的字母异位词</h1><p><a href="https://leetcode.cn/problems/valid-anagram/">https://leetcode.cn/problems/valid-anagram/</a></p><blockquote><p>给定两个字符串 <code>s</code> 和 <code>t</code> ，编写一个函数来判断 <code>t</code> 是否是 <code>s</code> 的 字母异位词。</p></blockquote><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;rat&quot;, t = &quot;car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= s.length, t.length &lt;= 5 * 104</code></li><li><code>s</code> 和 <code>t</code> 仅包含小写字母</li></ul><p><strong>进阶:</strong> 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p><h2 id="思路">思路</h2><ol><li>使用hash table可解决</li><li>开辟一块26个int型的数组即可，比如对于字符串s，&quot;a&quot;出现一次，则’a’ - ‘a’的下标（应该是0）对应的数据加一；而对于字符串t，就将反着“检查”，比如’n’出现一次，就要将’n’ - 'a’的下标对应的数据减一；</li><li>最后，判断是否有「非零」数，若存在则s与t不是字母异位词</li><li>可以通过判断s与t长度提前判断；</li></ol><p>如动画所示</p><p><img src="https://file1.kamacoder.com/i/algo/242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.gif" alt="img"></p><h2 id="代码">代码</h2><p>ord(.)用于获取字符的ascii码</p><ul><li>时间复杂度O(n)</li><li>空间复杂度O(1)，指仅用了26个int型（因为length &lt;= 5*10^4)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        nums = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        <span class="comment"># 如果两者长度不相等直接False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s)!= <span class="built_in">len</span>(t):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            nums[<span class="built_in">ord</span>(i) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> t:</span><br><span class="line">            nums[<span class="built_in">ord</span>(i) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>代码改进，可以使用zip减少一次遍历次数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        nums = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        <span class="comment"># 如果两者长度不相等直接False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s)!= <span class="built_in">len</span>(t):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 仅当长度相等时，同步推进，减少一次遍历次数</span></span><br><span class="line">        <span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">zip</span>(s,t):</span><br><span class="line">            nums[<span class="built_in">ord</span>(i) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">            nums[<span class="built_in">ord</span>(j) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h1 id="349-两个数组的交集">349. 两个数组的交集</h1><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">https://leetcode.cn/problems/intersection-of-two-arrays/</a></p><p>给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>它们的 交集</em> 。输出结果中的每个元素一定是 <strong>唯一</strong> 的。我们可以 <strong>不考虑输出结果的顺序</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">输出：[2]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span><br><span class="line">输出：[9,4]</span><br><span class="line">解释：[4,9] 也是可通过的</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li><li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li></ul><h2 id="思路">思路</h2><ol><li><p>如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费，此时就要使用另一种<strong>结构体set</strong></p></li><li><p>先将nums1转成unordered_set，再将nums2与这unordered_set比较，得到二次筛选后的unordered_set.</p></li><li><p>在python时使用dict字典即可，将nums1的数据添加到字典了（如果已经存在就不用添加了，也是变相地一种set）</p></li></ol><p>如动画所示</p><p><img src="https://file1.kamacoder.com/i/algo/20220707173513.png" alt="img"></p><h2 id="代码">代码</h2><p>python提供了集合set函数，可以直接使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intersection</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">set</span>(nums1) &amp; <span class="built_in">set</span>(nums2))</span><br></pre></td></tr></table></figure><p>手动实现，使用字典dict和列表list实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">intersection</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        dictSet = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">          <span class="comment"># 如果i 不在dictSet中，返回-1，并且添加到dictSet中，赋值为1（随便给）</span></span><br><span class="line">            <span class="comment"># get 方法内部也会进行哈希表查找，一次查询的平均时间复杂度也是 O(1)</span></span><br><span class="line">            <span class="comment"># 与if i in dictSet:一样</span></span><br><span class="line">            <span class="keyword">if</span> dictSet.get(i, -<span class="number">1</span>) == -<span class="number">1</span>:</span><br><span class="line">                dictSet[i] = <span class="number">1</span></span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums2:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> dictSet:</span><br><span class="line">                res.append(i)</span><br><span class="line">                <span class="comment"># 删除dictSet中的这个数据，防止被反复添加</span></span><br><span class="line">                <span class="keyword">del</span> dictSet[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">      </span><br><span class="line">        <span class="comment"># 或者将res设置为set，可以减少删除dictSet中数字的步骤</span></span><br><span class="line">        <span class="comment"># res = set()</span></span><br><span class="line">        <span class="comment"># for i in nums2:</span></span><br><span class="line">        <span class="comment">#     if dictSet.get(i, -1) != -1:</span></span><br><span class="line">        <span class="comment">#         res.add(i)</span></span><br><span class="line">        <span class="comment"># return list(res)</span></span><br></pre></td></tr></table></figure><p>当然也可以使用数组（list）实现，这题目限制范围是0&lt;=num&lt;=1000数据，可以开1001个位置的数据并按<code>242. 有效的字母异位词的思路</code>赋值再查询</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   dictSet = [<span class="number">0</span>] * <span class="number">1001</span></span><br><span class="line"><span class="comment"># 在nums1中的数据先在dictSet设置为1</span></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">       dictSet[i] = <span class="number">1</span></span><br><span class="line">   <span class="comment"># 在nums2中的数据，并且在dictSet设置为1的，再设置为2</span></span><br><span class="line">   <span class="comment"># 好处是如果dictSet中有重复的数据，不用被重复设置</span></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> nums2:</span><br><span class="line">       <span class="keyword">if</span> dictSet[i] == <span class="number">1</span>:</span><br><span class="line">           dictSet[i] = <span class="number">2</span></span><br><span class="line">   res = <span class="built_in">list</span>()</span><br><span class="line">   <span class="comment"># 最后输出dictSet中为2的，就是同时出现在两个nums的并且不重复的数据</span></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1001</span>):</span><br><span class="line">       <span class="keyword">if</span> dictSet[i] == <span class="number">2</span>:</span><br><span class="line">           res.append(i)</span><br><span class="line">   <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="pytorch版本">Pytorch版本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">intersection</span>(<span class="params">nums1: <span class="type">List</span>, nums2: <span class="type">List</span></span>)</span><br><span class="line"><span class="comment"># 转成tensor</span></span><br><span class="line">nums1_tensor = torch.tensor(nums1)</span><br><span class="line">  nums2_tensor = troch.tensor(nums2)</span><br><span class="line">    <span class="comment"># 使用unique（与set类似）</span></span><br><span class="line">    unique_nums1 = torch.unique(nums1_tensor)</span><br><span class="line">    <span class="comment"># isin返回一个bool张量，表示每个元素是否在nums2_tensor中</span></span><br><span class="line">    mask = torch.isin(unique_nums1, nums2_tensor)</span><br><span class="line">    <span class="comment"># 傅mask过滤得到交集元素。</span></span><br><span class="line">    intersection_tensor = unique_nums1[mask]</span><br><span class="line">    <span class="comment"># 转回list格式</span></span><br><span class="line">    <span class="keyword">return</span> intersection_tensor.tolist()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例测试</span></span><br><span class="line">nums1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>]</span><br><span class="line">nums2 = [<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line">result = intersection(nums1, nums2)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出: [2, 6]</span></span><br></pre></td></tr></table></figure><h1 id="202-快乐数">202. 快乐数</h1><p><a href="https://leetcode.cn/problems/happy-number/">https://leetcode.cn/problems/happy-number/</a></p><p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p><p><strong>「快乐数」</strong> 定义为：</p><ul><li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li><li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</li><li>如果这个过程 <strong>结果为</strong> 1，那么这个数就是快乐数。</li></ul><p>如果 <code>n</code> 是 <em>快乐数</em> 就返回 <code>true</code> ；不是，则返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 19</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">12 + 92 = 82</span><br><span class="line">82 + 22 = 68</span><br><span class="line">62 + 82 = 100</span><br><span class="line">12 + 02 + 02 = 1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 231 - 1</code></li></ul><h2 id="思路一">思路一</h2><ol><li>题目中说了会 <strong>无限循环</strong>，那么也就是说<strong>求和的过程中，sum会重复出现，这对解题很重要！</strong></li><li>可以使用Hash Table，如果sum在表中出现了则说明有循环，可以直接退出；否则就一直找，直到sum=1</li></ol><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 设置个set，如果未在set中即可添加进来，否则就出现循环了</span></span><br><span class="line">        table = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">while</span> n != <span class="number">1</span>:</span><br><span class="line">          <span class="comment"># python中将数字按位划分的最方便形式就是转成str后按数组对付</span></span><br><span class="line">            n_str = <span class="built_in">str</span>(n)</span><br><span class="line">            n = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> n_str:</span><br><span class="line">                n += <span class="built_in">int</span>(i)*<span class="built_in">int</span>(i)</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> table:</span><br><span class="line">                table.add(n)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>相似的思路，如果不在list中就添加进来，一直计算sum直到等于1停止</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 设置个set，如果未在set中即可添加进来，否则就出现循环了</span></span><br><span class="line">        table = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">while</span> n <span class="keyword">not</span> <span class="keyword">in</span> table:</span><br><span class="line">          table.append(n)</span><br><span class="line">          <span class="comment"># python中将数字按位划分的最方便形式就是转成str后按数组对付</span></span><br><span class="line">            n_str = <span class="built_in">str</span>(n)</span><br><span class="line">            n = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> n_str:</span><br><span class="line">                n += <span class="built_in">int</span>(i)*<span class="built_in">int</span>(i)</span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="思路二快慢指针">思路二快慢指针</h2><ol><li>这题目可以用快慢指针解决，如果出现了&quot;循环&quot;（sum会重复出现），其实就是“链表有环”的问题</li><li>慢指针每次走一步；快指针每次走两步。即慢指针每次计算sumN(slow)，快指针每次计算sumN(sumN(fast))</li><li>如果slow == fast则说明有环（有重复的sum）返回False</li><li>while跳出条件是sumN(fast)!=1，这和fast.next不为空即可[在有环链表题目中，while fast and fast.next则执行]</li></ol><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumN</span>(<span class="params">self, n:<span class="built_in">int</span></span>):</span><br><span class="line">        n_str = <span class="built_in">str</span>(n)</span><br><span class="line">        new_n = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> n_str:</span><br><span class="line">            new_n += <span class="built_in">int</span>(i)*<span class="built_in">int</span>(i)  </span><br><span class="line">        <span class="keyword">return</span> new_n</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumNByhand</span>(<span class="params">self, n:<span class="built_in">int</span></span>):</span><br><span class="line">        new_n = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            temp = n % <span class="number">10</span></span><br><span class="line">            new_n += temp ** <span class="number">2</span></span><br><span class="line">            n = n // <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> new_n</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        slow = n</span><br><span class="line">        fast = n</span><br><span class="line">        <span class="keyword">while</span> self.sumN(n) != <span class="number">1</span> <span class="keyword">and</span> self.sumN(self.sumN(fast)) != <span class="number">1</span>:</span><br><span class="line">            slow = self.sumN(slow)</span><br><span class="line">            fast = self.sumN(self.sumN(fast))</span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h1 id="1-两数之和">1. 两数之和</h1><p><a href="https://leetcode.cn/problems/two-sum/">https://leetcode.cn/problems/two-sum/</a></p><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li><li><strong>只会存在一个有效答案</strong></li></ul><p>**进阶：**你可以想出一个时间复杂度小于 <code>O(n2)</code> 的算法吗？</p><h2 id="思路">思路</h2><ol><li>使用hash map, 本题目可以使用dict，因为它已经假设每种输入只有一个答案</li><li>记录table[target - nums[i_1]] = i_1，如果target - nums[i_1] == nums[i_2]则说明target == nums[i_1] + nums[i_2]</li><li>如果nums[i_2]在table中，则找到了一个匹配的返回i_1和i_2</li></ol><p><img src="https://file1.kamacoder.com/i/algo/20220711202638.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20230220223536.png" alt="img"></p><h2 id="代码">代码</h2><p>如果使用双重循环的方式，时间复杂度O(N^2)，但空间复杂度可以到O(1)；所以本质还是空间换时间</p><ul><li>时间复杂度O(N)</li><li>空间复杂度O(N)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 使用个hash map，记录table[target - nums[i_1]] = i_1</span></span><br><span class="line">        <span class="comment"># 如果nums[i_2]在table中，则找到了一个匹配的返回i_1和i_2</span></span><br><span class="line">        table = <span class="built_in">dict</span>()</span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">          <span class="comment"># 如果当前元素在table内，说明已经找到匹配的了</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> table:</span><br><span class="line">                <span class="keyword">return</span> table[nums[i]], i</span><br><span class="line">            <span class="comment"># 否则，target-nums[i] 就是需要等的数字</span></span><br><span class="line">            table[target - nums[i]] = i</span><br><span class="line">        <span class="keyword">return</span> </span><br></pre></td></tr></table></figure><h2 id="思路二双指针">思路二双指针</h2><ol><li>可以使用双指针做，<strong>但前提是：数组是有序的(从小到大）</strong></li><li>left指针从左向右遍历；right指针从右向左遍历</li><li>每次计算left和right所指数字的和；并与target判断大小；如果current_sum大了，则right向左移动；小了则left向右移动；如果相等，有点儿的麻烦的是，需要将left和right在原nums的下标进行还原；</li><li>初次的还原使用nums.index(nums_sorted[left])，但会出现left_index == right_index的情况，因为题目规定不能使用同一个下标，所以需要将right_index进行调整，调整到nums[left_index+1:].index(nums_sorted[right]) + left_index + 1，也就是强行在nums[left_index+1:]里找right数字对应的下标（返回的是nums[left_index+1:]的下标值，即<code>相对下标</code>）所以需要再加上left_index+1成为<code>绝对下标</code></li></ol><h2 id="代码">代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(N)—因为占用了个空间存放排序后的数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># method2 双指针</span></span><br><span class="line">nums_sorted = <span class="built_in">sorted</span>(nums)</span><br><span class="line"></span><br><span class="line">left = <span class="number">0</span></span><br><span class="line">right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> left &lt; right:</span><br><span class="line">    current_sum = nums_sorted[left] + nums_sorted[right]</span><br><span class="line">    <span class="built_in">print</span>(current_sum)</span><br><span class="line">    <span class="keyword">if</span> current_sum == target:</span><br><span class="line">        <span class="comment"># 如果两个数字之和等于target就返回两个数的下标（原nums数组中的）</span></span><br><span class="line">        left_index = nums.index(nums_sorted[left])</span><br><span class="line">        right_index = nums.index(nums_sorted[right])</span><br><span class="line">        <span class="keyword">if</span> left_index == right_index:</span><br><span class="line">            right_index = nums[left_index+<span class="number">1</span>:].index(nums_sorted[right]) + left_index + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left_index, right_index</span><br><span class="line">    <span class="comment"># 否则left向右移动</span></span><br><span class="line">    <span class="keyword">elif</span> current_sum &lt; target:</span><br><span class="line">        left += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        right -= <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday6哈希表part01&quot;&gt;LeetCodeCampsDay6哈希表part01&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;以及几题目主要利用hash table的“唯一性”思想解决题目&lt;/p&gt;
&lt;p&gt;关键词：哈希表；快慢指针；双指针；</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
    <category term="哈希表" scheme="https://blog.lthero.cn/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay4链表part02</title>
    <link href="https://blog.lthero.cn/2025/06/28/LeetCodeCampsDay4/"/>
    <id>https://blog.lthero.cn/2025/06/28/LeetCodeCampsDay4/</id>
    <published>2025-06-28T03:16:53.000Z</published>
    <updated>2025-07-08T10:18:38.305Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday4链表part02">LeetCodeCampsDay4链表part02</h1><blockquote><p>大多修改/删除/添加操作需要使用dummy_head；仅查询的话，可以不用dummy_head</p><p>如果需要一遍扫描完成一些题目，需要借用额外的变量（时间换空间），比如多指针/快慢指针</p></blockquote><h1 id="24-两两交换链表中的节点">24. 两两交换链表中的节点</h1><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">https://leetcode.cn/problems/swap-nodes-in-pairs/</a></p><blockquote><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p></blockquote><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4]</span><br><span class="line">输出：[2,1,4,3]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 100</code></li></ul><h2 id="思路">思路</h2><h3 id="初始化">初始化</h3><ol><li>需要<strong>创建dummy_head</strong>，方便解题，尤其头节点和第二个节点的交换，有dummy_head后更方便</li><li>如果current is None或current.next is None直接返回；说明链表为空或仅一个节点</li><li>需要一个pre节点，一个current节点</li><li>比如：[[],[1],[2],[3]]<ol><li>令[]为dummy_head，且初始化为pre</li><li>令[1]为current节点</li><li>令[2]为tmp节点</li><li>令[3]为nextToGO节点（因为至少有两个节点，所以这里的[3]可能是None，不过没关系）</li></ol></li></ol><h3 id="循环体内">循环体内</h3><ol><li>初始化：tmp节点，指向current.next; 以及nextToGO节点，指向tmp.next</li></ol><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>[]-&gt;</td><td>1-&gt;</td><td>2-&gt;</td><td>3-&gt;</td><td>4-&gt;</td><td>None</td></tr><tr><td>pre</td><td>cur</td><td>tmp</td><td>nextToGO</td><td></td><td></td></tr></tbody></table><ol><li>开始swap： #和交换数字的思路比较像<ol><li>pre.next = tmp</li><li>current.next = nextToGO</li><li>tmp.next = current</li></ol></li></ol><p>此时的链表</p><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>[]-&gt;</td><td>2-&gt;</td><td>1-&gt;</td><td>3-&gt;</td><td>4-&gt;</td><td>None</td></tr><tr><td>pre</td><td>tmp</td><td>cur</td><td>nextToGO</td><td></td><td></td></tr></tbody></table><ol><li>更新pre和current<ol><li>pre = current</li><li>current = nextToGO</li></ol></li></ol><h2 id="代码">代码</h2><ul><li>时间复杂度 O(n)</li><li>空间复杂度 O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__printVal</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;node.val <span class="subst">&#123;node.val&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swapPairs</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy_head = ListNode(<span class="built_in">next</span> = head)</span><br><span class="line"></span><br><span class="line">        pre = dummy_head</span><br><span class="line">        current = dummy_head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># init</span></span><br><span class="line">        <span class="keyword">if</span> current <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> current.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> current <span class="keyword">and</span> current.<span class="built_in">next</span>:</span><br><span class="line">            temp = current.<span class="built_in">next</span></span><br><span class="line">            nextToGo = temp.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># swap</span></span><br><span class="line">            pre.<span class="built_in">next</span> = temp</span><br><span class="line">            current.<span class="built_in">next</span> = nextToGo</span><br><span class="line">            temp.<span class="built_in">next</span> = current</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># update</span></span><br><span class="line">            pre = current</span><br><span class="line">            current = nextToGo</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy_head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>如果不使用nextToGo也可以，但需要理解好几个节点的关系</p><h3 id="初始化">初始化</h3><ol><li>需要创建dummy_head，方便解题，尤其头节点和第二个节点的交换，有dummy_head后更方便</li><li>如果current is None或current.next is None直接返回；说明链表为空或仅一个节点</li><li>需要一个pre节点，一个current节点</li><li>比如：[[],[1],[2],[3]]<ol><li>令[]为dummy_head，且初始化为pre</li><li>令[1]为current节点</li><li>令[2]为tmp节点</li></ol></li></ol><h3 id="循环体内">循环体内</h3><ol><li>初始化：tmp节点，指向current.next</li></ol><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>[]-&gt;</td><td>1-&gt;</td><td>2-&gt;</td><td>3-&gt;</td><td>4-&gt;</td><td>None</td></tr><tr><td>pre</td><td>cur</td><td>tmp</td><td></td><td></td><td></td></tr></tbody></table><ol><li>开始swap： #和交换数字的思路比较像<ol><li>pre.next = tmp</li><li>current.next = tmp.next</li><li>tmp.next = current</li></ol></li></ol><p>此时的链表</p><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>[]-&gt;</td><td>2-&gt;</td><td>1-&gt;</td><td>3-&gt;</td><td>4-&gt;</td><td>None</td></tr><tr><td>pre</td><td>tmp</td><td>cur</td><td></td><td></td><td></td></tr></tbody></table><ol><li>更新pre和current<ol><li>pre = current</li><li>current = current.next</li></ol></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line">            temp = current.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># swap</span></span><br><span class="line">            pre.<span class="built_in">next</span> = temp</span><br><span class="line">            current.<span class="built_in">next</span> = temp.<span class="built_in">next</span></span><br><span class="line">            temp.<span class="built_in">next</span> = current</span><br><span class="line">            <span class="comment"># update</span></span><br><span class="line">            pre = current</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><h1 id="19-删除链表的倒数第-n-个结点">19. 删除链表的倒数第 N 个结点</h1><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">https://leetcode.cn/problems/remove-nth-node-from-end-of-list/</a></p><blockquote><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p></blockquote><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], n = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], n = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中结点的数目为 <code>sz</code></li><li><code>1 &lt;= sz &lt;= 30</code></li><li><code>0 &lt;= Node.val &lt;= 100</code></li><li><code>1 &lt;= n &lt;= sz</code></li></ul><p>进阶：你能尝试使用一趟扫描实现吗？</p><p>提示：Maintain two pointers and update one with a delay of n steps.</p><h2 id="思路">思路</h2><ol><li>使用dummy_head，方便解题</li><li>使用快慢指针，快指针比慢指针多走n+1步，因为需要让慢指针stops at 被删除节点的前一个节点;<strong>从而一次扫描即可实现</strong></li></ol><h2 id="代码">代码</h2><ul><li>时间复杂度 O(n)</li><li>空间复杂度 O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], n: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">      <span class="comment"># init a dummy head</span></span><br><span class="line">        dummy_head = ListNode(<span class="built_in">next</span> = head)</span><br><span class="line">        current = dummy_head</span><br><span class="line">        slow = dummy_head</span><br><span class="line"><span class="comment"># Move the current pointer forward by n+1 steps so that the slow pointer stops at the node immediately before the one that need to be deleted.</span></span><br><span class="line">        <span class="keyword">while</span> n+<span class="number">1</span> <span class="keyword">and</span> current:</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># </span></span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        slow.<span class="built_in">next</span> = slow.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy_head.<span class="built_in">next</span></span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      <span class="comment"># The following method is my dummy one.</span></span><br><span class="line">        <span class="comment"># count = 0</span></span><br><span class="line">        <span class="comment"># while current.next:</span></span><br><span class="line">        <span class="comment">#     current = current.next</span></span><br><span class="line">        <span class="comment">#     if count&lt; n:</span></span><br><span class="line">        <span class="comment">#         count += 1</span></span><br><span class="line">        <span class="comment">#         continue</span></span><br><span class="line">        <span class="comment">#     else:</span></span><br><span class="line">        <span class="comment">#         slow = slow.next</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment"># slow.next = slow.next.next</span></span><br><span class="line">        <span class="comment"># return dummy_head.next</span></span><br><span class="line">        </span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="面试题-02-07-链表相交">面试题 02.07. 链表相交</h1><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/</a></p><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 <code>null</code> 。</p><p>图示两个链表在节点 <code>c1</code> 开始相交**：**</p><p><img src="https://cdn.lthero.cn/post_images/course/ML160_statement.png" alt="img"></p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.lthero.cn/post_images/course/ML160_example_1.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Intersected at &#x27;8&#x27;</span><br><span class="line">解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。</span><br><span class="line">在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://cdn.lthero.cn/post_images/course/ML160_example_2.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</span><br><span class="line">输出：Intersected at &#x27;2&#x27;</span><br><span class="line">解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。</span><br><span class="line">在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="https://cdn.lthero.cn/post_images/course/ML160_example_3.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</span><br><span class="line">输出：null</span><br><span class="line">解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。</span><br><span class="line">由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">这两个链表不相交，因此返回 null 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>listA</code> 中节点数目为 <code>m</code></li><li><code>listB</code> 中节点数目为 <code>n</code></li><li><code>0 &lt;= m, n &lt;= 3 * 104</code></li><li><code>1 &lt;= Node.val &lt;= 105</code></li><li><code>0 &lt;= skipA &lt;= m</code></li><li><code>0 &lt;= skipB &lt;= n</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA + 1] == listB[skipB + 1]</code></li></ul><p>**进阶：**你能否设计一个时间复杂度 <code>O(n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p><h2 id="思路">思路</h2><ol><li>可以使用dummy_head，确实方便一点儿; 不过本题目没有插入/删除，可以不用dummy_head.</li><li>注意它是“指针相等”而不是数值相等；并且A和B如果相交，它们则一定是到某个节点后，是指向同一节点的，不要把它们当成两条完全独立的链表处理；</li><li>可以通过判断最后一个元素是否相等来初步筛选</li><li>如果两个链表长度相等，则可以同步地遍历，找到共同节点</li><li>如果两个链表长度不相等，可以让长的先遍历n步n = abs(L_A - L_B), where L_A is the length of A. 然后再按长度相等的方式处理</li></ol><h2 id="代码">代码</h2><ul><li>时间复杂度：O(L_A + L_B) [指A和B的总长度]</li><li>空间复杂度：O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        <span class="comment"># 如果A,B链表长度相同，则可以同步遍历</span></span><br><span class="line">        <span class="comment"># 如果A,B链表长度不同，则让长的先走n步, where n = abs(L_a - L_b)</span></span><br><span class="line">        L_A = <span class="number">0</span></span><br><span class="line">        L_B = <span class="number">0</span></span><br><span class="line">        <span class="comment"># dh指dummy_head</span></span><br><span class="line">        dhA = ListNode(<span class="built_in">next</span> = headA)</span><br><span class="line">        endA = dhA</span><br><span class="line">        <span class="keyword">while</span> endA.<span class="built_in">next</span>:</span><br><span class="line">            endA = endA.<span class="built_in">next</span></span><br><span class="line">            L_A += <span class="number">1</span></span><br><span class="line">        dhB = ListNode(<span class="built_in">next</span> = headB)</span><br><span class="line">        endB = dhB</span><br><span class="line">        <span class="keyword">while</span> endB.<span class="built_in">next</span>:</span><br><span class="line">            endB = endB.<span class="built_in">next</span></span><br><span class="line">            L_B += <span class="number">1</span></span><br><span class="line">        <span class="comment"># If the last elements are not equal return NULL</span></span><br><span class="line">        <span class="keyword">if</span> endA != endB <span class="keyword">or</span> L_A == <span class="number">0</span> <span class="keyword">or</span> L_B == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">        curA = dhA</span><br><span class="line">        curB = dhB</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Adjust the Make sure they start at same step.</span></span><br><span class="line">        gap = <span class="built_in">abs</span>(L_B - L_A)</span><br><span class="line">        <span class="keyword">if</span> L_A &lt; L_B:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(gap):</span><br><span class="line">                curB = curB.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">elif</span> L_A &gt; L_B:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(gap):</span><br><span class="line">                curA = curA.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> curA.<span class="built_in">next</span>:</span><br><span class="line">            curA = curA.<span class="built_in">next</span></span><br><span class="line">            curB = curB.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> curA == curB:</span><br><span class="line">                <span class="keyword">return</span> curA</span><br><span class="line">        <span class="keyword">return</span> </span><br></pre></td></tr></table></figure><h1 id="142-环形链表-ii">142. 环形链表 II</h1><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">https://leetcode.cn/problems/linked-list-cycle-ii/</a></p><blockquote><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p></blockquote><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p><strong>不允许修改</strong> 链表。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.lthero.cn/post_images/course/MLcircularlinkedlist.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://cdn.lthero.cn/post_images/course/MLcircularlinkedlist_test2.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：返回索引为 0 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="https://cdn.lthero.cn/post_images/course/MLcircularlinkedlist_test3.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：返回 null</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li></ul><p>**进阶：**你是否可以使用 <code>O(1)</code> 空间解决此题？</p><h2 id="快慢指针思路">快慢指针思路</h2><ol><li>这题不用dummy_head</li><li>本题有两个任务：<ol><li>是否有环</li><li>如果有环，怎么找到环的入口</li></ol></li></ol><h3 id="是否有环">是否有环</h3><p>如果使用快慢指针的方式，快指针每次走两步，慢指针每次走一步，如果有环，一定能相遇</p><p><img src="https://cdn.lthero.cn/post_images/course/ML141.%25E7%258E%25AF%25E5%25BD%25A2%25E9%2593%25BE%25E8%25A1%25A8-20250628155706375.gif" alt="img"></p><h3 id="如何找环的入口">如何找环的入口</h3><ul><li>令头节点到入口节点的距离为x(个节点)。</li><li>环形<strong>入口节点</strong> 到 fast指针与slow指针<strong>相遇节点</strong> 节点数为y。</li><li>从<strong>相遇节点</strong> 再到<strong>环形入口节点节点数为 z</strong>。</li></ul><p>如图所示：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20220925103433-20250628155649033.png" alt="img"></p><p>那么相遇时：</p><ul><li>slow指针走过的节点数为: <code>x + y</code></li><li>fast指针走过的节点数：<code>x + y + n (y + z)</code>，n为fast指针在环内走了n圈才遇到slow指针，（y+z）为 一圈内节点的个数A。</li></ul><p>因为fast指针是一步走两个节点，slow指针一步走一个节点， 所以 fast指针走过的节点数 = slow指针走过的节点数 * 2 ：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo stretchy="false">)</mo><mo>∗</mo><mn>2</mn><mo>=</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo>+</mo><mi>n</mi><mo stretchy="false">(</mo><mi>y</mi><mo>+</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x + y) * 2 = x + y + n (y + z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span></span></p><p>两边消掉一个（x+y）: <code>x + y = n (y + z)</code></p><blockquote><p>因为要找环形的入口，则需要求的元素是<code>x</code>，因为x表示：the <strong>distance</strong> between <strong>头节点</strong> and <strong>入口节点</strong>。即<code>x = n (y + z) - y</code></p></blockquote><p>再从n(y+z)中提出一个 （y+z）来，整理公式之后为如下公式：<code>x = (n - 1) (y + z) + z</code> 注意这里n一定是大于等于1的，因为 fast指针至少要多走一圈才能相遇slow指针。</p><p>这个公式说明什么呢？</p><p>先拿<strong>n为1</strong>的情况来举例，意味着fast指针在环形里转了一圈之后，就遇到了 slow指针了。</p><p>当 n为1的时候，公式就化解为 <code>x = z</code>，</p><p>这就意味着，从<strong>头结点</strong>出发<strong>一个指针</strong>，从<strong>相遇节点</strong>也出发<strong>一个指针</strong>，这两个指针每次都只走一个节点， 那么当这<strong>两个指针相遇</strong>的时候就是 <strong>环形入口的节点</strong>。</p><p>也就是在相遇节点处，定义一个指针index1，在头结点处定一个指针index2（也可以让slow继续走，并且让fast每次只走一步）</p><p>让index1和index2同时移动，每次移动一个节点， 那么他们相遇的地方就是 环形入口的节点。</p><p>动画如下：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML142.%25E7%258E%25AF%25E5%25BD%25A2%25E9%2593%25BE%25E8%25A1%25A8II%25EF%25BC%2588%25E6%25B1%2582%25E5%2585%25A5%25E5%258F%25A3%25EF%25BC%2589.gif" alt="img"></p><p>那么 n如果大于1是什么情况呢，就是<strong>fast指针在环形转n圈之后才遇到 slow指针</strong>。</p><p>其实这种情况和n为1的时候 效果是一样的，一样可以通过这个方法找到 环形的入口节点，只不过，index1 指针在环里 多转了(n-1)圈，然后再遇到index2，相遇点依然是环形的入口节点。</p><h2 id="代码">代码</h2><ul><li>时间复杂度 O(N) --slow走完一遍即可（slow不用在环内转圈）/60ms</li><li>空间复杂度 O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detectCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="comment"># 快慢指针，如果有环，快指针必能遇到慢指针</span></span><br><span class="line">        fast = head</span><br><span class="line">        slow = head</span><br><span class="line"><span class="comment"># 注意退出条件，只控制fast即可了</span></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 如果快慢指针相遇，说明有环，当前位置是相遇点；下一任务是找入口</span></span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                <span class="comment"># 让slow从头开始，而fast仍在相遇点；fast和slow都是每次走一步</span></span><br><span class="line">                slow = head</span><br><span class="line">                <span class="keyword">while</span> slow != fast:</span><br><span class="line">                    fast = fast.<span class="built_in">next</span></span><br><span class="line">                    slow = slow.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> slow</span><br><span class="line">        <span class="keyword">return</span> </span><br></pre></td></tr></table></figure><h2 id="普通思路">普通思路</h2><p>创建一个visited_list，将遍历过的节点都添加进去，如果新的节点已经存在于visited_list说明它就是“入口节点”</p><h2 id="代码">代码</h2><ul><li>时间复杂度 O(N)—844ms</li><li>空间复杂度 O(N)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detectCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line"><span class="comment"># 普通解法，记录所有节点</span></span><br><span class="line">        visitedList = []</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur <span class="keyword">in</span> visitedList:</span><br><span class="line">                <span class="keyword">return</span> cur</span><br><span class="line">            visitedList.append(cur)</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday4链表part02&quot;&gt;LeetCodeCampsDay4链表part02&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;大多修改/删除/添加操作需要使用dummy_head；仅查询的话，可以不用dummy_head&lt;/p&gt;
&lt;p&gt;如果需</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
    <category term="链表" scheme="https://blog.lthero.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay3链表part01</title>
    <link href="https://blog.lthero.cn/2025/06/26/LeetCodeCampsDay3/"/>
    <id>https://blog.lthero.cn/2025/06/26/LeetCodeCampsDay3/</id>
    <published>2025-06-26T13:54:25.000Z</published>
    <updated>2025-07-08T10:18:56.447Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday3链表part01">LeetCodeCampsDay3链表part01</h1><blockquote><p>主要与链表相关</p><p>记住：<strong>一般涉及到 增删改操作，用虚拟头结点dummy_head都会方便很多， 如果只能查的话，用不用虚拟头结点都差不多。</strong></p></blockquote><h2 id="链表理论基础">链表理论基础</h2><p>建议：了解一下链表基础，以及链表和数组的区别</p><p>文章链接：<a href="https://programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">https://programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html</a></p><h1 id="203-移除链表元素">203. 移除链表元素</h1><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">https://leetcode.cn/problems/remove-linked-list-elements/</a></p><blockquote><p>一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p></blockquote><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,6,3,4,5,6], val = 6</span><br><span class="line">输出：[1,2,3,4,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [], val = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [7,7,7,7], val = 7</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>列表中的节点数目在范围 <code>[0, 104]</code> 内</li><li><code>1 &lt;= Node.val &lt;= 50</code></li><li><code>0 &lt;= val &lt;= 50</code></li></ul><h2 id="思路">思路</h2><ol><li>head是输入链表，是不动的；需要一个遍历的指针，可以使用index = head创建；</li><li>不断判断index.next的值是否等于val（因为，如果index.next.val等于val，可以通过操作，让index.next被删除）</li><li>最后判断下，如果head.val等于val，需要将head=head.next ；以免出现val=1, 但head返回是[1，2]的情况</li></ol><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElements</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        index = head</span><br><span class="line">        <span class="keyword">while</span> index.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> val == index.<span class="built_in">next</span>.val:</span><br><span class="line">                index.<span class="built_in">next</span> = index.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                index = index.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> head.val == val:</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h2 id="思路二">思路二</h2><p>思路一有个缺点，需要单独写一段逻辑处理头结点的情况，可以设置一个虚拟头部dummy_head，其中dummy_head.next=head；从而原链表的所有节点都可以统一处理</p><p><img src="https://file1.kamacoder.com/i/algo/20210316095619221.png" alt="img"></p><h2 id="代码二">代码二</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElements</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummpy_head = ListNode(<span class="built_in">next</span> = head)</span><br><span class="line"><span class="comment"># 同样需要index作为当前指针</span></span><br><span class="line">        index = dummpy_head</span><br><span class="line">        <span class="keyword">while</span> index.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> val == index.<span class="built_in">next</span>.val:</span><br><span class="line">                index.<span class="built_in">next</span> = index.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                index = index.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummpy_head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><h1 id="206-反转链表">206. 反转链表</h1><p><a href="https://leetcode.cn/problems/reverse-linked-list/">https://leetcode.cn/problems/reverse-linked-list/</a></p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：[2,1]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 5000]</code></li><li><code>-5000 &lt;= Node.val &lt;= 5000</code></li></ul><p>进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p><h2 id="思路一">思路一</h2><p>至少需要三个辅助节点，pre, current, current_next(temp)</p><ol><li>先记录current.next到temp</li><li>不断将current.next设置为pre</li><li>pre转成current；current转成temp</li></ol><p><img src="https://file1.kamacoder.com/i/algo/206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.gif" alt="img"></p><h2 id="代码一">代码一</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:        </span><br><span class="line">        current = head</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> current <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            temp = current.<span class="built_in">next</span></span><br><span class="line">            current.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = current</span><br><span class="line">            current = temp</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure><h2 id="思路二-递归">思路二（递归）</h2><p>退出条件：如果head为空/head.next为空，则直接返回haed，因为它已经反转了</p><p>让递归函数输入head.next(即剩下链表)，返回结果为new_head；new_head会先变成原head链表最后一个元素，如[1,2,3,4,5]则new_head为5，且整个递归过程new_head一直为5</p><p>foo([1,2,3,4,5])</p><p>foo([1,foo([2,3,4,5])])</p><p>foo([1,foo([2,foo([3,4,5])])])</p><p>foo([1,foo([2,foo([3,foo([4,5])])])])</p><p>foo([1,foo([2,foo([3,foo([4,foo([5])])])])])</p><p>逐个分析下</p><ul><li>foo([5])返回head，并且成为new_head</li><li>对于foo([4,foo([5])])，new_head = 5；head.next.next = head 意为将4.next.next（原来为5）设置为4，即5.next = 4；且head.next = None，即4.next = None；这里把4当成反转后的最后一个节点</li><li>对于foo([3,foo([4,foo([5])])])，new_head = 5; head.next.next = head意为将3.next.next(原为4)设置为3，即4.next = 3且head.next = None，即3.next = None；这里把3当成反转后的最后一个节点</li><li>对于foo([2,foo([3,foo([4,foo([5])])])])，new_head = 5; head.ext.next = head意为将2.next.next(原为3)设置为2，即3.next = 2且head.next = None，即2.next = None；这里把2当成反转后的最后一个节点</li><li>对于foo([1,foo([2,foo([3,foo([4,foo([5])])])])])，new_head = 5; head.ext.next = head意为将1.next.next(原为2)设置为1，即2.next = 1且head.next = None，即1.next = None；这里把1当成反转后的最后一个节点</li></ul><p>从而完成递归的反转链表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">head: <span class="type">Optional</span>[ListNode]</span>):</span><br><span class="line">            <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> head</span><br><span class="line">            <span class="comment"># new_head会先变成原head链表最后一个元素</span></span><br><span class="line">            <span class="comment"># [1,2,3,4,5]则new_head为5，且一直为5</span></span><br><span class="line">            new_head = foo(head.<span class="built_in">next</span>)</span><br><span class="line">            <span class="comment"># 反转两个节点</span></span><br><span class="line">            head.<span class="built_in">next</span>.<span class="built_in">next</span> = head</span><br><span class="line">            <span class="comment"># 反转后的最后一个节点的next设置为None</span></span><br><span class="line">            head.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> new_head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> foo(head)</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)，其中n是链表节点数，每个节点被访问一次</p><p>空间复杂度O(N)，递归调用栈的空间，最坏的情况下，stack深度为n</p><h1 id="707-设计链表">707. 设计链表</h1><p><a href="https://leetcode.cn/problems/design-linked-list/">https://leetcode.cn/problems/design-linked-list/</a></p><p>你可以选择使用单链表或者双链表，设计并实现自己的链表。</p><p>单链表中的节点应该具备两个属性：<code>val</code> 和 <code>next</code> 。<code>val</code> 是当前节点的值，<code>next</code> 是指向下一个节点的指针/引用。</p><p>如果是双向链表，则还需要属性 <code>prev</code> 以指示链表中的上一个节点。假设链表中的所有节点下标从 <strong>0</strong> 开始。</p><p>实现 <code>MyLinkedList</code> 类：</p><ul><li><code>MyLinkedList()</code> 初始化 <code>MyLinkedList</code> 对象。</li><li><code>int get(int index)</code> 获取链表中下标为 <code>index</code> 的节点的值。如果下标无效，则返回 <code>-1</code> 。</li><li><code>void addAtHead(int val)</code> 将一个值为 <code>val</code> 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。</li><li><code>void addAtTail(int val)</code> 将一个值为 <code>val</code> 的节点追加到链表中作为链表的最后一个元素。</li><li><code>void addAtIndex(int index, int val)</code> 将一个值为 <code>val</code> 的节点插入到链表中下标为 <code>index</code> 的节点之前。如果 <code>index</code> 等于链表的长度，那么该节点会被追加到链表的末尾。如果 <code>index</code> 比长度更大，该节点将 <strong>不会插入</strong> 到链表中。</li><li><code>void deleteAtIndex(int index)</code> 如果下标有效，则删除链表中下标为 <code>index</code> 的节点。</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;MyLinkedList&quot;, &quot;addAtHead&quot;, &quot;addAtTail&quot;, &quot;addAtIndex&quot;, &quot;get&quot;, &quot;deleteAtIndex&quot;, &quot;get&quot;]</span><br><span class="line">[[], [1], [3], [1, 2], [1], [1], [1]]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, null, 2, null, 3]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">MyLinkedList myLinkedList = new MyLinkedList();</span><br><span class="line">myLinkedList.addAtHead(1);</span><br><span class="line">myLinkedList.addAtTail(3);</span><br><span class="line">myLinkedList.addAtIndex(1, 2);    // 链表变为 1-&gt;2-&gt;3</span><br><span class="line">myLinkedList.get(1);              // 返回 2</span><br><span class="line">myLinkedList.deleteAtIndex(1);    // 现在，链表变为 1-&gt;3</span><br><span class="line">myLinkedList.get(1);              // 返回 3</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= index, val &lt;= 1000</code></li><li>请不要使用内置的 LinkedList 库。</li><li>调用 <code>get</code>、<code>addAtHead</code>、<code>addAtTail</code>、<code>addAtIndex</code> 和 <code>deleteAtIndex</code> 的次数不超过 <code>2000</code> 。</li></ul><h2 id="思路">思路</h2><ol><li>先确定使用单链表，包含head和L(表示节点个数)</li><li>addAtHead设置借用<strong>203.移除链表元素</strong>里dummy_head思想即可</li><li>addAtIndex才是核心需要设置的东西<ol><li>如果index为0，addAtIndex直接调用addAtHead；</li><li>如果index &gt; self.L or index &lt; 0 直接返回</li><li>如果index有效，寻找<code>index</code>前一节点current，令current.next = newNode</li></ol></li><li>addAtTail直接调用addAtIndex就行，传入self.L,val</li><li>deleteAtIndex难度不大<ol><li>Index == 0，直接跳过head即可</li><li>Index &gt;= self.L 直接返回</li><li>Index有效时，找到index前一节点current，令current.next = current.next.next</li></ol></li></ol><p>另外，定义个函数__getIndexPreNode，用来找到index的前一个节点；因为有至少三个函数需要调用到它</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__getIndexPreNode</span>(<span class="params">self, node, index</span>):</span><br><span class="line">        current = node</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index - <span class="number">1</span>):</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> current</span><br></pre></td></tr></table></figure><p>__printList用来打印当前链表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__printList</span>(<span class="params">self, node</span>):</span><br><span class="line">        caller_name = inspect.stack()[<span class="number">1</span>].function</span><br><span class="line">        current = self.head</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;caller_name: <span class="subst">&#123;caller_name&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">while</span> current.<span class="built_in">next</span>:</span><br><span class="line">            <span class="built_in">print</span>(current.val, end = <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;, self.L <span class="subst">&#123;self.L&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,val = <span class="number">0</span>, <span class="built_in">next</span> = <span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.head = ListNode()</span><br><span class="line">        self.L = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getIndexPreNode</span>(<span class="params">self, node, index</span>):</span><br><span class="line">        current = node</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index - <span class="number">1</span>):</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> current</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__printList</span>(<span class="params">self, node</span>):</span><br><span class="line">        caller_name = inspect.stack()[<span class="number">1</span>].function</span><br><span class="line">        current = self.head</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;caller_name: <span class="subst">&#123;caller_name&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">while</span> current.<span class="built_in">next</span>:</span><br><span class="line">            <span class="built_in">print</span>(current.val, end = <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;, self.L <span class="subst">&#123;self.L&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, index: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> index &gt;= self.L <span class="keyword">or</span> index &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> index == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.head.val</span><br><span class="line"></span><br><span class="line">        current = self.__getIndexPreNode(self.head, index)</span><br><span class="line">        <span class="comment"># self.__printList(self.head)</span></span><br><span class="line">        <span class="keyword">return</span> current.<span class="built_in">next</span>.val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addAtHead</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        dummy_head = ListNode(val = val, <span class="built_in">next</span> = self.head)</span><br><span class="line">        self.head = dummy_head</span><br><span class="line">        self.L += <span class="number">1</span></span><br><span class="line">        <span class="comment"># self.__printList(self.head)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addAtTail</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.addAtIndex(self.L, val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addAtIndex</span>(<span class="params">self, index: <span class="built_in">int</span>, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> index &gt; self.L <span class="keyword">or</span> index &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> index ==<span class="number">0</span> :</span><br><span class="line">            <span class="keyword">return</span> self.addAtHead(val)</span><br><span class="line">        </span><br><span class="line">        current = self.__getIndexPreNode(self.head, index)</span><br><span class="line">        newNode = ListNode(val, current.<span class="built_in">next</span>)</span><br><span class="line">        current.<span class="built_in">next</span> = newNode</span><br><span class="line">        self.L += <span class="number">1</span></span><br><span class="line">        <span class="comment"># self.__printList(self.head)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteAtIndex</span>(<span class="params">self, index: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> index &gt;= self.L <span class="keyword">or</span> index &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">if</span> index == <span class="number">0</span>:</span><br><span class="line">            self.head = self.head.<span class="built_in">next</span></span><br><span class="line">            self.L -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        current = self.__getIndexPreNode(self.head, index)</span><br><span class="line">        current.<span class="built_in">next</span> = current.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        self.L -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># self.__printList(self.head)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyLinkedList()</span></span><br><span class="line"><span class="comment"># param_1 = obj.get(index)</span></span><br><span class="line"><span class="comment"># obj.addAtHead(val)</span></span><br><span class="line"><span class="comment"># obj.addAtTail(val)</span></span><br><span class="line"><span class="comment"># obj.addAtIndex(index,val)</span></span><br><span class="line"><span class="comment"># obj.deleteAtIndex(index)</span></span><br></pre></td></tr></table></figure><h2 id="改进版">改进版</h2><ol><li>其它思路不变，规定将head作为“dummy_head”</li><li>新增__getIndexNode函数，指获得Index对应节点</li><li>优点：<strong>代码更统一了，减少了需要额外讨论index==0以及index==self.L的情况</strong>！！所以，有dummy_head非常方便</li><li>因为head是dummy_head，所以__getIndexNode(index)得到的就是index的pre节点，和原版作用是一样的</li><li>所以get函数中需要传入head.next而不是head</li></ol><blockquote><p>一般涉及到 增删改操作，用虚拟头结点dummy_head都会方便很多， 如果只能查的话，用不用虚拟头结点都差不多。</p></blockquote><h2 id="代码二">代码二</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,val = <span class="number">0</span>, <span class="built_in">next</span> = <span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.head = ListNode()</span><br><span class="line">        self.L = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getIndexNode</span>(<span class="params">self, node, index</span>):</span><br><span class="line">        current = node</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index):</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> current</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, index: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> index &gt;= self.L <span class="keyword">or</span> index &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"><span class="comment"># 注意，这里传入head.next而不是head</span></span><br><span class="line">        current = self.__getIndexNode(self.head.<span class="built_in">next</span>, index)</span><br><span class="line">        <span class="keyword">return</span> current.val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addAtHead</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.head.<span class="built_in">next</span> = ListNode(val = val, <span class="built_in">next</span> = self.head.<span class="built_in">next</span>)</span><br><span class="line">        self.L += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addAtTail</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.addAtIndex(self.L, val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addAtIndex</span>(<span class="params">self, index: <span class="built_in">int</span>, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> index &gt; self.L <span class="keyword">or</span> index &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        current = self.__getIndexNode(self.head, index)</span><br><span class="line">        current.<span class="built_in">next</span> =  ListNode(val, current.<span class="built_in">next</span>)</span><br><span class="line">        self.L += <span class="number">1</span></span><br><span class="line">        <span class="comment"># self.__printList(self.head)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteAtIndex</span>(<span class="params">self, index: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> index &gt;= self.L <span class="keyword">or</span> index &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">        current = self.__getIndexNode(self.head, index)</span><br><span class="line">        current.<span class="built_in">next</span> = current.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        self.L -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># self.__printList(self.head)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyLinkedList()</span></span><br><span class="line"><span class="comment"># param_1 = obj.get(index)</span></span><br><span class="line"><span class="comment"># obj.addAtHead(val)</span></span><br><span class="line"><span class="comment"># obj.addAtTail(val)</span></span><br><span class="line"><span class="comment"># obj.addAtIndex(index,val)</span></span><br><span class="line"><span class="comment"># obj.deleteAtIndex(index)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday3链表part01&quot;&gt;LeetCodeCampsDay3链表part01&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;主要与链表相关&lt;/p&gt;
&lt;p&gt;记住：&lt;strong&gt;一般涉及到 增删改操作，用虚拟头结点dummy_head都会方便</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
    <category term="链表" scheme="https://blog.lthero.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>IELTsSpeaking</title>
    <link href="https://blog.lthero.cn/2025/06/26/IELTsSpeaking/"/>
    <id>https://blog.lthero.cn/2025/06/26/IELTsSpeaking/</id>
    <published>2025-06-26T12:32:09.000Z</published>
    <updated>2025-07-12T13:05:24.309Z</updated>
    
    <content type="html"><![CDATA[<h1 id="改变世界的发明">改变世界的发明</h1><h2 id="part-2">Part 2</h2><blockquote><p>Describe an invention that has changed the world in a positive way</p></blockquote><p>You should say:</p><p>•        <strong>what</strong> it is</p><p>•        Basically, AI brings many benefits</p><p>•        <strong>how</strong> it influences people of different ages</p><p>•        <strong>explain</strong> how it changed people’s lives = how you felt about it</p><h3 id="大纲">大纲</h3><p>•        <strong>what</strong> it is</p><p>•        AI is a new invention that was just released several years ago</p><p>•        For example, there are many AI applications like DeepSeek and ChatGPT</p><p>•        Personally, I use it everyday</p><p>•        <strong>what</strong> benefits it has brought</p><p>•        Basically, AI brings many benefits</p><p>•        Firstly, it reduces the cost of generating content</p><p>•        Secondly, it can improve our efficiency at work</p><p>•        <strong>how</strong> it influences people of different ages</p><p>•        Overall, all kinds of people can be benefited by AI</p><p>•        For the kids, AI help them calculate the math equations and correct their errors</p><p>•        For the elderly, it allows them to seek for useful information they need</p><p>•        <strong>explain</strong> how it changed people’s lives = how you felt about it</p><p>AI is a new invention that was just released several years ago which changed the world significantly. For example, there are many AI applications like DeepSeek and ChatGPT.</p><p>Firstly, it significantly reduces the cost and effort required to generate content. It allows creators to get video clips or images by simplely typing a descriptive prompt. Plus, AI dramatically improves our efficiency at work. For instance, it can help draft documents and summarize long reports , which save up people’s valuable time for other tasks.</p><p>Secondly, AI influences people across all age groups. For children, AI can serve as an interactive learning companion, helping them solve complex math equations and offering instant feedback to correct their mistakes. For elderly floks, they can seek useful information and manage daily tasks simply by asking questions in a natural way on their AI-powered smartphones.</p><p>Initially, I was doubted whether AI was as powful as people said. However, after trying it for the first time, I was completely amazed by its power. Now, I try to make good use of AI as a powerful assistant in my daily life. Meanwhile, I am trying not relying heavily on it, focusing on strengthening abilities of problem-solving by myself.</p><h2 id="part-3">Part 3</h2><blockquote><p>What is the most helpful innovation at work?</p></blockquote><p>In my view, two types of innovation are helpful at work.</p><p>The first is AI assistants, such as ChatGPT. They are useful for quickly drafting documents, summarizing long reports, or even giving creative ideas, which significantly imporve our efficiency at work.</p><p>The second is collaborative online platforms like FeiShu and Google Workspace. These tools allow teams to work on documents simultaneously and share information instantly, greatly improving teamwork and efficiency/flexibility.</p><blockquote><p>What household appliances make us lazy?</p></blockquote><p>Several modern household appliances, while convenient, could be seen as contributing to a more sedentary lifestyle. Two prominent examples come to mind.</p><p>First, the robotic vacuum cleaner diligently cleans our floors on its own schedule. This automation completely removes the need for the physical work of walking with a traditional vacuum around the house.</p><p>Second, the dishwasher takes over the daily chore of washing dishes. By simply loading the machine and pressing a button, saving our time to do other things.</p><blockquote><p>What kinds of inventions can be used at school?</p></blockquote><p>Certainly, several modern inventions can significantly enhance the school learning environment, with two standing out.</p><p>First, interactive smart whiteboards are a key innovation. They replace traditional blackboards and connect directly to a computer, allowing teachers to write, draw, and project relevant digital content for a more dynamic lesson.</p><p>Another simple yet crucial invention is a classroom speaker. This device amplifies the teacher’s voice so that every student can hear clearly, which is especially helpful for teachers with softer voices.</p><p>Overall, these tools help create a more engaging and accessible educational setting.</p><blockquote><p>Do you think AI will replace human teachers? Why?</p></blockquote><p>I believe AI is unlikely to completely replace human teachers; instead, it will handle simple tasks while complex and safety-related roles will still require a human touch.</p><p>On one hand, AI can take over repetitive and tedious jobs. For instance, it can provide students with personalized practice exercises and then automatically grade their scores, saving teachers’ time.</p><p>On the other hand, a human teacher is essential for tasks requiring emotional intelligence and judgment. They can inspire creativity, and manage classroom to ensure a good learning environment, which are deeply human skills.</p><ol><li>First, I could send my context and a clear prompt to it</li><li>Second, after a while, it will return an answer to me</li><li>Maybe, I wouldn’t be satisfied by it at first</li><li>So, I would finetune/optimize my prompt so that AI can return me a better version of it</li></ol><h1 id="二手交易">二手交易</h1><h2 id="part2">Part2</h2><blockquote><p>Describe a website that sells second-hand items</p></blockquote><ul><li>what it is</li><li>how you found out about it</li><li>what people can buy from it</li><li>explain whether you like it</li></ul><p>I want to share with you a website called xianyu ,which is kind of like the Chinese version of eBay, where people trade different products and services.</p><p>It’s a quite popular application in China especially among the young people, I first heard about it from my friend, who’s always hunting for cool second-hand stuffs on it. Then, I got curious and started browsing myself.</p><p>On Xianyu, people can find literally everything, from gift cards, books and clothes to digital products like smartphone, laptop , camera and even some online services, for example, I met my English tutor on it.</p><p>Personally, I once used that app to buy a second-hand ipad after receiving my scholarship. The price was great, and it looked almost new in the pictures. When it arrived, the screen had some lines across it—like it had been dropped before. I messaged the seller, but he said it must’ve happened during shipping. Obviously classic excuse. In the end, I got a partial refund. Since then, I’ve become way more careful when shopping second-items online, this app reduces the threshold for people to become a seller, so we should always asking for extra pictures and checking more reviews before deciding which one to buy.</p><h2 id="part3">Part3</h2><blockquote><p>Some people think it’s a waste to buy too many clothes for children. What do you think?</p></blockquote><p>I do think it’s a waste to buy too many clothes for children.</p><p>Firstly, children nowadays just grow too quickly. As a result, they have to purchase more and more clothes, which could be a waste of money and resource.</p><p>Secondly, people can recycle clothes that they don’t want anymore, or to donate to those who need them the most.</p><blockquote><p>what do you usually do with a cell phone?</p></blockquote><p>My phone is basically my second brain, I can do literally everything on it. It provide so many useful functions for me to text with friends, scroll videos, order food. And  you might not believe it, there are almost like five delivery apps on my phone, so I can just choose any app depend on my mood on that day.</p><p>Personally, as you know, as a student, I rely heavily on the AI capabilities of my phone to support my studies. These AI-powered functions are a huge helper, assisting me with everything from research and writing to organizing my study schedule and preparing for exams.</p><blockquote><p>What are the differences between young people and old people when using a cell phone?</p></blockquote><p>There are huge differences in the usage between. old and young people.</p><p>For young people. they mostly use cell phone for self improvement. Many white collar workers actually spend a lot of time and energy on their phone listening to some podcasts, yeah, or even online courses.</p><p>However, the old people would just entertain with a cell phone. since they have nothing to do, they would spend much time on their phone scrolling videos. Or just reading some latest news</p><blockquote><p>what can be done to stop cell phone addiction</p></blockquote><p>There are many ways that we can do. to stop us addicted to the cell phone</p><p>the first is that we can。Do more physical exercise. ok like going to the gym  like going to the gym。Or the park so that we are away from the cell phone</p><p>the second method is that we can download the。The specialized apps designed Help Design to help us concentrate on what matters the most. For example, people could set their screen time so that they can limit their exposure to the phone.</p><blockquote><p>Do you think it is too late to call others at eleven or twelve o’clock at night?</p></blockquote><p>Well, it really depends on different situations. It depends on who you are calling.</p><p>for young people, I think calling them so late is fine. Because as you know, they just they usually stay up late or simply go to bed quite late. Yeah, because most of them would be more energetic, especially in the evening.</p><p>However. if we are talking about elderly folks then it might not be a rational choice. as you know most old people are used to going to bed quite early. Probably. because they have more priorities things uh they have more prioritized the things to do the next morning</p><blockquote><p>Do you think there should be a law to stop people from making phone calls in public?</p></blockquote><p>In the common sense the laws should only people should only abide by the law.</p><p>The normally the laws will only take care of severe behaviors. While answering phone on public should be considered as a basic human right, and the law shouldn’t be so strict otherwise the law loses its <strong>seriousness</strong> and becomes difficult to enforce.</p><blockquote><p>What problems will occur if people don’t recycle?</p></blockquote><p>If fewer people choose to recycle it will lead to lots of problems <strong>,</strong></p><p>Firstly, people would simply waste a lot of their own money. For me, the things that I don’t want anymore can be sold on second hand websites. it could partially saves money.</p><p>another consequence is that the environment could get worse if the products that they don’t want anymore are disposed instead of recycled. The air quality and water quality will be contaminated.</p><blockquote><p>Should the government encourage people to recycle items?</p></blockquote><p>it totally makes sense for the government to encourage people to recycle</p><p>first, for the residents. They can save money by selling their items on second hand websites to those who need them the most, by doing this they partially saved money instead of just directly disposing them.</p><p>Another reason is that recycling can also play a very important role in protection of the environment, if not executed well, The air quality and water quality could be contaminated.</p><h2 id="part2">Part2</h2><p>Describe a cultural place that you would like to learn the culture there(e.g. a libraay, museum, theater)</p><p>Where it is,</p><p>How you knew about this place?</p><p>What it is like?</p><p>explain how this place is related to culture(How you feel)</p><p>I would like to share you with the Former Residence of Qu Yuan which is a significant cultural site in China.</p><p>The residence is located in Hubei province, in the central part of China, and is quite accessible, typically taking less than an hour to reach by metro or bus.</p><p>My first encounter with Qu Yuan was in my primary school classes. As I gained further interest on it, I began to research him and his stories online trying to dig out more details behind it.</p><p>The residence is a magnificent sight. From a distance, its architecture is immediately impressive. As you walk closer, you can find out there are two floors. Once you step through the main gate, you’ll be amazed by all the collection of artifacts. The ground floor serves as an exhibition hall, showcasing the life and legacy of Qu Yuan—his famous poems, his political contributions.</p><p>At first, because I had never been there, I was a bit doubtful and couldn’t fully understand why so many people admired this place. However, as I learned more, I became deeply convinced and moved by the powerful stories behind the man himself. The residence is more than just a building; it’s represent a pivotal figure in our history, and that deep connection to our cultural roots is what makes it so compelling(attractive).</p><h2 id="part3">Part3</h2><p><strong>So what kind of culture is popular among young people?</strong></p><p>I believe there are many different kinds of cultures popular among young people right now.</p><p>First, I would say that staying up late has become a significant part of youth culture. Many young people claim to be more efficient and energetic at midnight, embracing a nocturnal lifestyle.</p><p>A second prevalent cultural trend is cell phone addiction. It’s common to see young people spending an excessive amount of time on their screens like scrolling videos. Their phones literally capture all of their attention, making them easily distracted from what truly matters.</p><p><strong>So how do young people learn about different cultures?</strong></p><p>Young people today have numerous sources for learning about different cultures.</p><p>The most conventional way is through online channels, particularly social media platforms like YouTube. A huge number of content creators produce all these interesting videos that showcase diverse cultures from all over the world, making this a very accessible way to learn.</p><p>However, a second, and I would say more effective, method is through direct, in-person experience. This involves traveling and interacting with locals firsthand. By speaking directly with people and observing their way of life, people can learn the practical ‘know-how’—the knowledge and customs that cannot be fully captured or codified in online content.&quot;</p><p><strong>So how is a culture formed?</strong></p><h2 id="part2">part2</h2><p>描述一部最近看的剧，下面以Shameless举例</p><p>I’d like to share a TV series with you named <em>Shameless</em>. It’s a remarkable show that has both a UK and a US version. The British one came out a bit earlier in 2004, but I watched the American adaptation which started in 2011.</p><p>The series revolves around the daily life of the Gallagher family, who live in the South Side of Chicago. It tells the story of an alcoholic and narcissistic father, Frank, and his six intelligent and independent children. The eldest, Fiona, who is only in her early twenties, has to take on the parental role to raise her five younger siblings.</p><p>I first came across this show back in 2022 when I saw some short clips of it on social media. The chaotic yet heartwarming family dynamic immediately caught my attention. As I gained further interest in this series, I searched for it online to know more details. Eventually, I started watching it on Netflix and got through nine seasons. I still haven’t watched the final two seasons because I just don’t want this incredible story to end.</p><p>Honestly, when I first saw the show’s title and poster, it didn’t appeal to me at all. I thought it would be just another generic drama. However, once I started the first episode, I was completely hooked and ended up binge-watching several episodes in one go. I even enthusiastically recommended it to my friends. Although they didn’t seem to share the same level of interest, I still enjoyed the process. For me, <em>Shameless</em> is definitely one of the best TV series I’ve ever seen, right up there with <em>Breaking Bad</em>, and I always hope to meet other people who love it as much as I do.</p><h1 id="文化">文化</h1><h2 id="part2">Part2</h2><h3 id="问题一">问题一</h3><p>Describe your favorite food at a traditional festival or a special event in your country</p><ul><li>What it is</li><li>At which festival/event you eat it</li><li>how it is made</li><li>explain why you like it</li></ul><p>I want to share with you a traditional Chinese food that many people like to eat, especially during traditional festivals. It is a dish that almost every Chinese person has been eating for years, and it has already symbolized the traditional culture of china.</p><p>We usually eat Jiaozi during important festivals, like the Spring Festival or anytime we get together with our family members. During these times, we would also usually go to pray at temples. For example, If it’s the Mid-Autumn Festival we would also enjoy mooncakes at the same time.</p><p>Well when we talk about how they are made, the process itself is a very simple. The first step to make Jiaozi is to prepare all the raw ingredients/materials, like meat, or vegetables if you are a vegetarian, and of course, the dough, which is made of flour. Second, you need to wrap the fillings in the dough in a specific way. Third, the wrapped Jiaozi should be cooked in boiling water for about 20 to 30 minutes.</p><p>At first, I was pretty doubtful why everybody liked it so much because to me, it just seemed like a random food. After I tried it and gained more interested in it, I realized that the time we spend with our family and those we love is the most important thing. So in the future I’m sure that I’ll be grateful for such a food, and I will also treasure of time eating jiaozi.</p><h3 id="问题二">问题二</h3><p>Describe a popular/well-known person in your country</p><ul><li>Who this person is.</li><li>What he/she has done</li><li>why he/she is popular</li><li>explain how you feel about this person</li></ul><p>I would like to share with you Qu Yuan who was a significant historical figure and probably one of the most popular poets in China. He served as a high-ranking official in one of China’s ancient dynasties. Furthermore, he was a very famous poet who wrote many beautiful and influential poems which was already documented in his former residence.</p><p>As an official, he contributed a lot to his country. He provided his king with many useful suggestions and strategies such as forming alliances with other countries to resis the threat of the country Qin. Unfortunately, his suggestions was dismissed by the king, and he was exiled. Later, when Qu Yuan heard that capital of his country had been captured by the enemy, he was so sad and hopeless that he jumped into the River as a form of protest.</p><p>Well, I think there are several reasons that make him popular. He is still so popular today not just because of his amazing poems, but because he is a symbol of patriotism and integrity. People respect him because he wasn’t afraid of powerful people and always stuck to his beliefs, no matter what.</p><p>At first, I was pretty doubtful why everybody liked him so much because to me, he just seemed like a ordinary guy. After I gained further interests in him, I even searched online for more deails, Then I realized I was convinced by his courage of sticking to his own opinion and his incredible talent as well.</p><h2 id="part3">part3</h2><p><strong>问题：What kinds of people are popular at work?</strong></p><p>回复：there are many factors that make someone popular at work.</p><p>First, kind people are usually very popular. I think it’s their kindness that really makes a difference. As you know, a kind person in the workplace is always willing to help you whenever you have a problem. They will offer a helping hand to anyone who is in need.</p><p>Well, moreover, people who are smart are definitely popular and admired by their colleagues. This is because everyone wants to work with a smart person, as they can often provide unique solutions and solve problems in a creative way. And that’s really valuable because, at work, there are always tons of difficulties and problems that need creative thinking to be solved.</p><p><strong>问题：Which one is more important, maintaining a good relationship with colleagues or doing well at work?</strong></p><p>回复：Well, I believe both of these are very important. In my opinion, they are equally important for a successful career.</p><p>On one hand, getting along well with your colleagues is a big advantage. It can help you go further in your career because you can always depend on each other for support, especially when you run into difficulties at work.</p><p>On the other hand, performing well at your job is also crucial. When you consistently do good work, you earn the  respect of your colleagues and your boss. People will trust your skills and want to include you in important projects, which naturally leads to better opportunities and promotions.</p><p><strong>问题：What benefits are there when a child is popular at school?</strong></p><p>I believe there are many benefits when a child is popular at school.</p><p>First, popular kids are often admired by other children. Because of this, he or she will probably have more opportunities to make new friends, which is great for their social development.</p><p>Another benefit is that these popular children might also attract more attention from their teachers. Teachers sometimes tend to focus more on these students, and this extra attention could be good for their grades and their overall self-improvement.</p><p><strong>问题：Do do you think popular children will grow up to be popular adults?</strong></p><p>Well, I think popular children have a better chance of becoming popular adults, but it’s not guaranteed. I think there are a couple of reasons for this.</p><p>On one hand, being a popular child gives you some advantages. For example, they are used to getting more attention from others, which can help them shape their personality and build their confidence. This is obviously a good foundation for their future.</p><p>On the other hand, it also really depends on how they handle their relationships as they grow up. If they fail to maintain these relationships well, they probably won’t continue to be a popular adult.</p><p>To be honest, I think this happens a lot. As you know, the world of adults is just much more complicated.</p><p><strong>问题：Are bosses more popular than employees at work?</strong></p><p>Well, I would say employees are probably more popular than bosses at work, and I think there are a couple of reasons for this.</p><p>First, let’s think about the boss’s role. Bosses are the ones who give us orders, and sometimes they can be very demanding or set strict deadlines. This can create a lot of pressure, which naturally makes it difficult for employees to build a casual and friendly relationship with them.</p><p>On the other hand, employees usually have a lot in common with each other. We share similar roles and backgrounds within the company. Because we have these shared experiences and common goals—like finishing a project together—it’s much easier for us to connect, become friends, and build solid relationships.</p><p><strong>问题：Are there any disadvantages Ifa Child is popular at school?</strong></p><p>Yes, I believe there can be several drawbacks for a child who is popular at school.</p><p>First, being popular can sometimes attract the wrong kind of attention from peers. For example, other kids might become envious or jealous of them. If that situation gets worse, this jealousy could lead to serious arguments or even cause the popular child to be isolated by others and there could be some severe quarrels or fights between them.</p><p>Another drawback is that popularity itself can be a big distraction. Popular children often need to spend a lot of time and energy maintaining all of their friendships. As a result, they can get distracted and might not have enough time to focus on their studies. In the long term, this could cause their grades to suffer.</p><p><strong>问题：Which is more important in terms of culture, literature or music.</strong></p><p>Well, in my opinion, I believe music is more crucial to a culture than literature, and I have a couple of reasons for this.</p><p>First, music is like a universal language. It doesn’t depend on literacy, so people don’t need to be able to read to understand it. People from all over the world can feel the rhythm and vibe in a piece of music, even if they don’t understand the lyrics. (Literature, on the other hand, is usually limited to people who speak and read a specific language.)</p><p>Second, I think music is more influential and can spread more widely in today’s world. It can easily be shared online and can combine traditional and modern styles. Because it’s so adaptable, I believe music often has a more profound and immediate impact on a wider audience than a book does.</p><h1 id="保健方式">保健方式</h1><h3 id="part-2">Part 2</h3><p>Describe an article on health you read in a magazine or on the internet</p><p>You should say:</p><p>•     <strong>what</strong> it was</p><p>•     <strong>where</strong> you read it</p><p>•     <strong>why</strong> you read it</p><p>•     how you felt about it</p><p>Well, I’d like to share with you an interesting health article I read online recently. The title was something along the lines of, “Be Happy, Live Longer.” If I had to conclude the whole article into one sentence, it would be that leading a happy life with a positive attitude is one of the keys to live longer.</p><p>I came across this article about two weeks ago on RedNote, which is a popular social media app in China, a bit like Instagram. I was actually chatting with a friend about some health-related topics, as I hadn’t been feeling that great lately. I was feeling a bit down due to some recent setbacks. Then he shared this article with me from the app, since I had nothing else to do and it came at the perfect time for me, I immediately started to read it.</p><p>Honestly, I can’t recall the specific name of the author, but I’m pretty sure they are an expert in this field. The article explained how a positive attitude can reduce stress and lower the risk of mental illness, which directly impacts our physical health.</p><p>At first, I was a bit doubtful, thinking it was just another ordinary article. But as I read it thoroughly, I was completely convinced by its philosophy.Reading that article made me realize that health isn’t just about eating vegetables or hitting the gym, it’s also about your attitude, taking care of my happiness is just as important as diet and exercise for my overall health.</p><h3 id="part-2">Part 2</h3><p>Describe a person you know who has chosen a career in the medical field (e.g. a doctor, a nurse)</p><p>You should say:</p><p>•     <strong>who</strong> he/she is</p><p>•     <strong>what</strong> he/she does</p><p>•     <strong>why</strong> he/she chose this career</p><p>•     explain <strong>how you feel</strong> about him/her</p><p>I’d like to talk about a doctor I really respect, Zhong Nanshan. He’s a very famous doctor in China, and what’s amazing about him is that even though he’s over 80 years old, he’s always on the front line, fighting against new diseases.</p><p>He’s most famous for his work during the COVID-19 outbreak. When it started, he led a team of experts to fight the virus. He was on TV a lot, giving people important advice and telling everyone to stay calm. At the same time, he was also busy leading the research for a cure. Basically, everyone saw him as a person they could trust during that difficult time.</p><p>As for why he chose this career, I don’t think it was for fame or money. I watched an interview with him once, and he said he just really wants to save people’s lives and protect them from getting sick. I believe he has a real passion for helping others, and that seems to be his main motivation.</p><p>Honestly, my feelings about him have changed a lot. Before the pandemic, I knew his name, but he was just another famous doctor to me. But after seeing how hard he worked during that difficult time and how much contribution that he made to the country, I really started to admire him. I feel very lucky that we have a role model like him, and he’s a real inspiration.</p><h3 id="part-2">Part 2</h3><p>Describe something you do to keep fit and healthy</p><p>You should say:</p><p>•     what it is</p><p>•     <strong>when</strong> you do it</p><p>•     who you do it with</p><p>•     explain why it can help you keep fit and healthy = how you felt about it</p><p>I’d like to talk about what I do to keep fit, which is basically going to the gym and running. My routine is usually a mix of aerobic exercise, like jogging on the treadmill, and some anaerobic exercise, like weight training. It’s a pretty popular way to stay in shape among young people nowadays.</p><p>I try to do this several times a week, often with my friends. Just last night, my best friend and I went to the gym together. We felt we had eaten some unhealthy food the day before, so we thought it was a good idea to burn some calories. It’s always more motivating to have a partner because we can encourage each other to keep going.</p><p>Honestly, when I first started, I was a bit doubtful about whether this routine would really help me. I guess I had never stuck to an exercise plan for a long time before, so I hadn’t seen any real benefits. But after I followed this plan for a couple of months, I really started to feel the difference. My health definitely improved. I felt more energetic during the day and even my mood got better. That’s when I was totally convinced, and it made me realize that consistency is the key to staying healthy and fit.</p><h3 id="part-3">Part 3</h3><ol><li>How do children and old people keep fit and healthy?</li><li>What do people normally do to keep fit and healthy in your country?</li><li>How can parents help and guide their kids to keep healthy?</li><li>Do you think it is good for governments to utilize popular celebrities to help build health awareness?</li><li>How can we use technology to keep fit?</li><li>Should schools provide physical education to students? Why and how?</li></ol><h1 id="健康与医疗">健康与医疗</h1><h2 id="part1">part1</h2><blockquote><p>Have you had any achievements recently？</p></blockquote><p>Well, I wouldn’t say I’ve had any major achievements recently, but there is something small that I’m quite proud of, which is related to my personal learning.</p><p>Over the past few weeks, I’ve been spending my time learning some new knowledge about machine learning. I watched online courses and readed articles to understand some of the key concepts. The main reason I consider this an achievement is that I was actually able to use this new knowledge to solve a real problem.</p><blockquote><p>So have you ever been praised or encouraged by a teacher?</p></blockquote><p>Yes, definitely. I was lucky to have been encouraged by my teachers many times, especially during my high school years.</p><p>I remember this happening most often whenever I made small achievements or showed improvement in my studies. For example, if I got a better score on a difficult test or shared a creative idea in class, my teacher would notice. He wouldn’t just say “good job”; he would often encourage me to keep pushing myself and to always try to “go the extra mile.”</p><p>That kind of encouragement was incredibly important and motivating for me. He often told me that every small effort <strong>accumulates</strong>, and that all these little steps would eventually lead to future success. Hearing that really taught me that progress isn’t just about big wins, but about being consistent. That lesson has stayed with me for a long time.</p><blockquote><p>When was the last time you praised someone?</p></blockquote><p>Actually, it just happened last night. I had a chance to encourage my good friend, Tommy, who was feeling a bit down about his job.</p><p>He was quite worried about his future career path and was feeling a lot of pressure from a new project. He started to doubt his own ability to handle the challenge. The first thing I did was just to calm him down. I told him that I have complete faith in him and that this sort of thing was something he could handle perfectly.</p><p>After that, I tried to motivate him a bit more. I reminded him of his past successes and encouraged him to believe in himself. I told him not just to meet expectations, but to “go the extra mile” on this project to show everyone what he’s capable of. He seemed much more confident after our chat, so I was glad I could be there for him.</p><blockquote><p>How do you feel when you are praised?</p></blockquote><p>Honestly, being praised always makes me feel really good, but for me, it’s more than just a happy feeling; it’s about feeling valued.</p><p>When someone praises me, I feel that my hard work has been seen and <strong>acknowledged</strong>. It’s a sign that they believe in me and trust my abilities. Sometimes, another person might notice a small achievement that I have overlooked myself, and that makes their praise feel even more meaningful and special.</p><p>More importantly, praise is a huge source of <strong>motivation</strong> for me. That feeling of being valued and trusted really encourages me to keep pushing myself and to “go the extra mile.” It gives me the confidence to take on new challenges and reminds me that my efforts are worthwhile, which is incredibly powerful.</p><blockquote><p>Do you think parents should always praise and encourage their children?</p></blockquote><p>Yes, I think it’s incredibly important for parents to praise and encourage their children, especially when they are young, although it needs to be done thoughtfully.</p><p>The main reason is that children need this kind of positive feedback to build up their <strong>self-confidence</strong>. For a child, praise from a parent works as a powerful form of <strong>external stimulus</strong> or motivation. When parents <strong>acknowledge</strong> their child’s efforts, it helps the child feel valued and capable, which is essential for their healthy emotional development.</p><p>However, I believe the ultimate goal of this praise is to help children gradually develop their own internal <strong>self-motivation</strong>. As they grow more confident from this encouragement, they learn to be proud of their own achievements without always needing approval from others. So, in the beginning, it’s a crucial tool to help them become independent and resilient adults.</p><h2 id="part03">part03</h2><blockquote><p>do you think doctors and nurses are very important?</p></blockquote><p>Yes, absolutely. I believe that both doctors and nurses are incredibly important to our society, and they each play a different but equally crucial role.</p><p>On one hand, for doctors, Their main job is to use their expert knowledge to <strong>diagnose</strong> our health problems and find ways to <strong>cure</strong> our illnesses. They are like medical detectives who figure out what’s wrong. Furthermore, they are also on the front line of <strong>research</strong>, working hard to find cures for new and dangerous diseases, like we saw during the COVID-19 pandemic.</p><p>On the other hand, nurses are just as essential because they provide the direct, hands-on care that helps us recover. They give us practical advice on <strong>health-related issues</strong> and, more importantly, they offer emotional support. They help us build the confidence we need to defeat an illness, and that kind of encouragement can have a direct, positive <strong>impact</strong> on a patient’s physical recovery.</p><blockquote><p>[总起句练习]Do you think doctors and nurses are very important?</p></blockquote><p><strong>Main Opening Sentences:</strong></p><ol><li>Yes, absolutely. In my view, both doctors and nurses are vital to our society, though they contribute in different ways.</li><li>When it comes to their importance, I believe it’s clear that doctors and nurses are both essential, each playing a unique and crucial role.</li><li>There’s no doubt in my mind that they are both incredibly important; our healthcare system simply couldn’t function without them.</li></ol><p><strong>First Point (About Doctors):</strong></p><ol><li><strong>On one hand,</strong> doctors are responsible for the scientific and diagnostic side of medicine.</li><li><strong>Looking at the role of doctors,</strong> their main job is to use expert knowledge to diagnose illnesses and research new cures.</li><li><strong>The primary contribution of doctors</strong> is to act as medical detectives, figuring out what’s wrong with a patient.</li></ol><p><strong>Second Point (About Nurses):</strong></p><ol><li><strong>On the other hand,</strong> nurses are just as essential for providing direct, hands-on patient care.</li><li><strong>The role of nurses, in contrast,</strong> focuses on the recovery and support phase of treatment.</li><li><strong>Equally important is the compassionate,</strong> hands-on care that nurses provide to patients daily.</li></ol><blockquote><p>is it good for hospital to remove the position of nurses</p></blockquote><p>No, not at all. In my opinion, it makes no sense to <strong>eliminate</strong> the position of nurses. I believe a hospital simply could not <strong>function</strong> well without them for a couple of key reasons.</p><p>For one thing, nurses are great helpers for doctors, which allows the entire hospital to run more efficiently. While doctors are busy <strong>diagnosing</strong> complex problems and deciding on major treatments, nurses handle many of the essential, hands-on tasks. For example, they are the ones who give injections, take care of wounds, and constantly monitor a patient’s condition. This frees up doctors to focus on the most critical decisions.</p><p>More importantly, nurses provide direct support to patients, both physically and <strong>mentally</strong>. They are often the first ones to step forward when a patient feels pain or is scared. They provide not just medicine, but also comfort and encouragement, which is a vital part of the healing process. This kind of compassionate care is something that machines or other staff members simply can’t replace.</p><blockquote><p>[总起句练习]Is it good for a hospital to remove the position of nurses?</p></blockquote><p><strong>Main Opening Sentences:</strong></p><ol><li>No, not at all. In my opinion, it makes no sense to eliminate the position of nurses for a couple of key reasons.</li><li>Thinking about that idea, I believe a hospital simply could not function well without nurses.</li><li>That would be a terrible decision; it’s clear that nurses are completely essential to any hospital.</li></ol><p><strong>First Point (Supporting Doctors):</strong></p><ol><li><strong>For one thing,</strong> nurses are great helpers for doctors, which allows the hospital to run more efficiently.</li><li><strong>One key function of nurses</strong> is to handle many of the essential, hands-on tasks, which frees up doctors’ time.</li><li><strong>Looking at hospital workflow,</strong> you can see that nurses are vital for supporting doctors with tasks like giving injections and monitoring patients.</li></ol><p><strong>Second Point (Supporting Patients):</strong></p><ol><li><strong>More importantly,</strong> nurses provide direct support to patients, both physically and mentally.</li><li><strong>Another crucial aspect</strong> is the emotional comfort and encouragement that nurses offer to patients.</li><li><strong>What we can’t forget</strong> is the compassionate care nurses provide, which is a vital part of the healing process.</li></ol><blockquote><p>So do you think that doctors and nurses are not paid enough?</p></blockquote><p>That’s an interesting question. In my opinion, the situation is quite different for doctors compared to nurses, so I think it’s a bit of a mixed picture.</p><p>Generally speaking, I believe doctors are <strong>relatively</strong> well-paid. Their job requires many years of difficult study and highly specialized skills to <strong>diagnose</strong> complex illnesses and perform treatments. Because of this high level of expertise, their salaries usually reflect the importance and difficulty of their work. So, for the most part, I would say doctors are paid enough.</p><p>However, I feel the situation is often different for nurses. While they also work incredibly hard and are essential for patient care, their role is sometimes seen as more service-oriented. As a result, I don’t think their salaries always <strong>compensate</strong> them fairly for their long hours and the huge amount of physical and emotional pressure they are under. So, in many cases, I do believe that nurses are often not paid enough for the crucial work they do.</p><blockquote><p>[总起句练习]So do you think that doctors and nurses are not paid enough?</p></blockquote><p><strong>Main Opening Sentences:</strong></p><ol><li>That’s an interesting question. In my opinion, the situation is quite different for doctors compared to nurses.</li><li>When it comes to their salaries, I think it’s a bit of a mixed picture, depending on the profession.</li><li>To be honest, my view is that we need to look at doctors and nurses separately to answer that question fairly.</li></ol><p><strong>First Point (About Doctors’ Pay):</strong></p><ol><li><strong>Generally speaking,</strong> I believe doctors are relatively well-paid due to their specialized skills.</li><li><strong>If we first consider doctors,</strong> their salaries usually reflect the many years of difficult study they undertake.</li><li><strong>For the most part,</strong> I would say doctors are paid enough because their high level of expertise is recognized.</li></ol><p><strong>Second Point (About Nurses’ Pay):</strong></p><ol><li><strong>However,</strong> I feel the situation is often different for nurses, who might be underpaid.</li><li><strong>The issue with nurses’ salaries,</strong> I think, is that they don’t always compensate them fairly for their long hours.</li><li><strong>In contrast,</strong> a nurse’s role is sometimes seen as more service-oriented, so their pay doesn’t always match the huge pressure they are under.</li></ol><blockquote><p>So how do today’s people keep healthy?</p></blockquote><p>Well, I think people nowadays use a variety of ways to keep healthy, but two main areas seem to be the most popular: physical exercise and paying close attention to diet.</p><p>Firstly, physical activity has become a huge trend. A lot of people, especially the younger generation, choose to go to the gym, <strong>doing</strong> a mix of <strong>aerobic</strong> exercise like running, and <strong>anaerobic</strong> exercise like weight training. For them, this has become a very popular and effective way not only to stay fit but also to release stress from work or study.</p><p>Secondly, besides exercise, many people now <strong>put more emphasis on</strong> their diet. They are becoming more conscious about what they eat, often choosing more fresh vegetables and healthy foods over things that are too oily or sugary. I think this is because more people are starting to believe in the old saying, “<strong>you are what you eat</strong>.” They understand that a healthy diet is fundamental to preventing diseases and maintaining good health in the long run.</p><blockquote><p>[总起句练习]So how do today’s people keep healthy?</p></blockquote><p><strong>Main Opening Sentences:</strong></p><ol><li>Well, I think people nowadays use a variety of ways to keep healthy, but two main areas seem to be the most popular.</li><li>From what I’ve observed, modern approaches to health generally focus on two key aspects: exercise and diet.</li><li>There are many methods, of course, but I believe physical activity and nutrition are the primary ways people try to stay fit today.</li></ol><p><strong>First Point (About Exercise):</strong></p><ol><li><strong>Firstly,</strong> physical activity has become a huge trend, especially among the younger generation.</li><li><strong>One popular method</strong> is going to the gym for a mix of aerobic and anaerobic exercise.</li><li><strong>A major way people stay fit</strong> is by engaging in regular exercise, which also helps them to release stress.</li></ol><p><strong>Second Point (About Diet):</strong></p><ol><li><strong>Secondly,</strong> besides exercise, many people now put more emphasis on their diet.</li><li><strong>Another key area</strong> is nutrition, with more people becoming conscious about what they eat.</li><li><strong>What’s also very common</strong> is the belief in the saying “you are what you eat,” leading people to choose healthier foods.</li></ol><blockquote><p>Is it difficult to keep healthy?</p></blockquote><p>Yes, I actually think it can be quite difficult for many people to stay healthy in the modern world. It’s not because we don’t know what to do, but because it requires a lot of discipline, especially with exercise and diet.</p><p>Firstly, let’s talk about exercise. For most people, it’s not an easy job to <strong>stick to an exercise plan</strong> consistently. We all have busy lives with work or school, and it’s very easy to feel tired at the end of the day and just skip a workout. It requires real self-control and motivation to keep going week after week, which is a big challenge for many.</p><p>Secondly, there’s the challenge of healthy eating. Nowadays, we are surrounded by tons of unhealthy food options that are easily available and heavily advertised. The problem is that these junk foods are often <strong>delicious yet harmful</strong>. It takes a lot of willpower to choose a healthy salad over a tasty burger and fries, especially when you’re stressed or short on time. This constant temptation makes eating healthy a real struggle.</p><blockquote><p>[总起句练习]Is it difficult to keep healthy?</p></blockquote><p><strong>Main Opening Sentences:</strong></p><ol><li>Yes, I actually think it can be quite difficult for many people to stay healthy in the modern world.</li><li>In my view, staying healthy consistently is a real challenge, mostly because it requires a lot of discipline.</li><li>Although we know what to do, I believe there are a couple of major obstacles that make it hard to stay healthy.</li></ol><p><strong>First Point (Challenge of Exercise):</strong></p><ol><li><strong>Firstly,</strong> let’s talk about exercise; it’s not easy for most people to stick to a plan consistently.</li><li><strong>One of the biggest challenges</strong> is finding the motivation and energy for regular exercise after a long day of work or school.</li><li><strong>For most people,</strong> the difficulty with exercise lies in maintaining self-control week after week.</li></ol><p><strong>Second Point (Challenge of Diet):</strong></p><ol><li><strong>Secondly,</strong> there’s the challenge of healthy eating, especially with so many unhealthy options available.</li><li><strong>Another major hurdle</strong> is the constant temptation of junk food, which is often delicious yet harmful.</li><li><strong>What makes it even harder</strong> is that it takes a lot of willpower to choose healthy food when you’re stressed or busy.</li></ol><blockquote><p>So where can people find informed information about keeping healthy</p></blockquote><p>I think people get information about health from a variety of different <strong>sources</strong> nowadays, but I believe the two most common channels are online platforms and their own friends and family.</p><p>Firstly, a huge amount of information comes from the internet. Many people rely on social media apps like WeChat or RedNote, where they can easily find and read all sorts of health-related articles. Sometimes, the apps even <strong>recommend</strong> health tips to them based on their interests. It’s a very direct and convenient way to access a lot of information quickly.</p><p>Secondly, people also learn <strong>the basics</strong> of staying healthy from their close circle, like their parents and friends. This type of learning is very different; I would say it’s more <strong>gradual and nuanced</strong>. It’s not about reading one specific article, but about observing the healthy habits of people you trust over a long period and picking up their advice day by day. This kind of personal influence can often be more powerful in the long run.</p><blockquote><p>[总起句练习]So where can people find information about keeping healthy?</p></blockquote><p><strong>Main Opening Sentences:</strong></p><ol><li>I think people get information about health from a variety of different sources nowadays.</li><li>When it comes to health information, there are two main channels people typically use: online platforms and their personal circles.</li><li>It seems to me that today’s health information is found in both the digital world and through traditional social interactions.</li></ol><p><strong>First Point (Online Sources):</strong></p><ol><li><strong>Firstly,</strong> a huge amount of information comes from the internet and social media apps.</li><li><strong>The most direct way</strong> people get information is by reading health-related articles and tips online.</li><li><strong>One major source</strong> is online platforms, which offer a convenient and quick way to access health content.</li></ol><p><strong>Second Point (Friends and Family):</strong></p><ol><li><strong>Secondly,</strong> people also learn the basics of staying healthy from their close circle, like parents and friends.</li><li><strong>Another important channel</strong> is personal influence, which is often more gradual and nuanced.</li><li><strong>Beyond the internet,</strong> people’s habits are often shaped by observing the lifestyles of those they trust over a long period.</li></ol><blockquote><p>Do you think it is good for for governments to utilize popular celebrities to help build health awareness</p></blockquote><p>Yes, I think it’s a very good idea. I believe governments should <strong>take advantage of</strong> popular celebrities to help <strong>arouse the public’s health awareness</strong> for a couple of key reasons.</p><p>Firstly, the biggest advantage is their huge <strong>influence</strong>. Famous celebrities often have millions of <strong>followers</strong> on social media who pay close attention to what they do and say. When a government uses these stars to deliver a message about health, it can reach a massive audience, especially young people, much more effectively than a traditional government advertisement could.</p><p>Secondly, these celebrities are often very credible <strong>role models</strong> for a healthy lifestyle. Many of them already <strong>tend to lead</strong> very healthy lives and have a good shape because it’s part of their job. It’s more natural and <strong>persuasive</strong> for people to follow advice from someone who is already a living example of fitness. When a celebrity with great abs tells you to exercise, it can be more convincing than just reading a pamphlet.</p><blockquote><p>[总起句练习] Do you think it is good for governments to utilize popular celebrities to help build health awareness?</p></blockquote><p><strong>Main Opening Sentences:</strong></p><ol><li>Yes, I think it’s a very good and effective idea for several key reasons.</li><li>Absolutely. I believe governments should take advantage of popular celebrities to help arouse the public’s health awareness.</li><li>From a strategic point of view, using celebrities for public health campaigns is a very smart move.</li></ol><p><strong>First Point (Their Influence):</strong></p><ol><li><strong>Firstly,</strong> the biggest advantage is the huge influence that famous celebrities have.</li><li><strong>The main reason this works</strong> is that celebrities can reach a massive audience, especially young people, through social media.</li><li><strong>One key factor</strong> is their incredible reach; a message from a star can be more effective than a traditional advertisement.</li></ol><p><strong>Second Point (Their Credibility as Role Models):</strong></p><ol><li><strong>Secondly,</strong> these celebrities are often very credible role models for a healthy lifestyle.</li><li><strong>What also makes this effective</strong> is that many celebrities already lead healthy lives and have a good shape as part of their job.</li><li><strong>Another point is their persuasiveness;</strong> it’s more convincing to follow health advice from someone who is a living example of fitness.</li></ol><blockquote><p>What can parents do to help improve their children’s health awareness?</p></blockquote><p>Well, I think there are several effective things parents can do to improve their children’s health awareness, mainly in two ways.</p><p>First, and perhaps most importantly, they can be a good <strong>role model</strong>. Children are natural observers and tend to copy their parents’ behavior. If kids see their parents consistently exercising, making healthy food choices, and speaking about health positively, they are much more likely to see these actions as normal and adopt these healthy habits themselves.</p><p>Secondly, parents can <strong>educate</strong> their children more directly. This doesn’t have to be like a boring lecture. For instance, they can take their kids to the gym or sign them up for sports classes to teach them about physical fitness in a fun way. They can also explain the importance of good nutrition, perhaps by discussing real-life <strong>cases</strong> where poor health choices led to negative <strong>consequences</strong>. This helps children learn the necessary <strong>health concepts</strong> and truly understand why these habits are so important.</p><blockquote><p>[总起句练习]What can parents do to help improve their children’s health awareness?</p></blockquote><p><strong>Main Opening Sentences:</strong></p><ol><li>Well, I think there are several effective things parents can do, mainly in two ways.</li><li>I believe parents can play a huge role in improving their children’s health awareness, both indirectly and directly.</li><li>From my perspective, the best approaches for parents involve being a good example and providing active education.</li></ol><p><strong>First Point (Being a Role Model):</strong></p><ol><li><strong>First, and perhaps most importantly,</strong> they can be a good role model for their children.</li><li><strong>One of the most natural ways</strong> is by leading by example, as children tend to copy their parents’ behavior.</li><li><strong>A key strategy</strong> is for parents to consistently make healthy choices themselves, which kids will see as normal.</li></ol><p><strong>Second Point (Direct Education):</strong></p><ol><li><strong>Secondly,</strong> parents can educate their children more directly about health.</li><li><strong>In addition to being a model,</strong> parents should actively involve their kids in healthy activities like sports.</li><li><strong>What’s also crucial</strong> is explaining the “why” behind healthy habits, perhaps by discussing the real-life consequences of poor choices.</li></ol><h1 id="总起句小结">总起句小结</h1><h3 id="第一段：回答主体总起句式-main-opening-sentences">第一段：回答主体总起句式 (Main Opening Sentences)</h3><p>这是回答开头的第一句话，用来直接回应考官问题并确立你的基本立场。</p><ul><li><strong>【句式一：直接表态 + 个人观点】 (Direct Answer + Personal Viewpoint)</strong><ul><li>这是最常用、最清晰的句式。直接用“Yes/No”或一个明确的判断词开头，然后连接 “I think / I believe / In my opinion” 等短语。</li><li><strong>范例:</strong><ol><li><code>Yes, absolutely. In my view, both doctors and nurses are vital to our society...</code></li><li><code>No, not at all. In my opinion, it makes no sense to eliminate the position of nurses...</code></li><li><code>Yes, I actually think it can be quite difficult for many people to stay healthy...</code></li></ol></li></ul></li><li><strong>【句式二：设定讨论范围 + 提出观点】 (Setting a Context + Stating Viewpoint)</strong><ul><li>这种句式更显思辨性，通过一个状语从句或介词短语来限定讨论的背景，然后再给出核心观点。</li><li><strong>范例:</strong><ol><li><code>When it comes to their importance, I believe it's clear that doctors and nurses are both essential...</code></li><li><code>From a strategic point of view, using celebrities for public health campaigns is a very smart move.</code></li><li><code>From what I've observed, modern approaches to health generally focus on two key aspects...</code></li></ol></li></ul></li><li><strong>【句式三：概括性陈述 + 预告结构】 (General Statement + Outlining Structure)</strong><ul><li>用一个比较概括性的句子开头，同时暗示接下来回答的结构（比如将分为两点或多点来谈）。</li><li><strong>范例:</strong><ol><li><code>Well, I think people nowadays use a variety of ways to keep healthy, but two main areas seem to be the most popular...</code></li><li><code>That's an interesting question. In my opinion, the situation is quite different for doctors compared to nurses, so I think it's a bit of a mixed picture.</code></li><li><code>I believe parents can play a huge role... mainly in two ways.</code></li></ol></li></ul></li></ul><h3 id="第二段：第一个论点的总起句式-topic-sentences-for-the-first-point">第二段：第一个论点的总起句式 (Topic Sentences for the First Point)</h3><p>在给出主体观点后，用这句话引出你的第一个具体论点和解释。</p><ul><li><strong>【句式一：经典顺序过渡词】 (Standard Sequential Transitions)</strong><ul><li>最简单、直接且有效的方式，清晰地告诉考官“这是我的第一点”。</li><li><strong>范例:</strong><ol><li><code>Firstly, physical activity has become a huge trend...</code></li><li><code>On one hand, doctors are responsible for the scientific and diagnostic side of medicine.</code></li><li><code>For one thing, nurses are great helpers for doctors...</code></li></ol></li></ul></li><li><strong>【句式二：聚焦核心名词/概念】 (Focusing on the Core Noun/Concept)</strong><ul><li>将你要讨论的核心概念（如“优势”、“原因”、“角色”）直接作为句子的主语，使论点非常突出。</li><li><strong>范例:</strong><ol><li><code>The biggest advantage is their huge influence...</code></li><li><code>The primary contribution of doctors is to act as medical detectives...</code></li><li><code>One of the biggest challenges is finding the motivation for regular exercise...</code></li></ol></li></ul></li><li><strong>【句式三：聚焦讨论主体】 (Focusing on the Subject of Discussion)</strong><ul><li>以你要讨论的人或事物作为开头的介词短语或分句，清晰地界定本段的讨论对象。</li><li><strong>范例:</strong><ol><li><code>Looking at the role of doctors, their main job is to use expert knowledge...</code></li><li><code>If we first consider doctors, their salaries usually reflect the many years of study...</code></li><li><code>For most people, the difficulty with exercise lies in maintaining self-control...</code></li></ol></li></ul></li></ul><h3 id="第三段：第二个论点的总起句式-topic-sentences-for-the-second-point">第三段：第二个论点的总起句式 (Topic Sentences for the Second Point)</h3><p>用这句话引出你的第二个（通常是最后一个）论点，可以与第一点形成对比、补充或递进。</p><ul><li><strong>【句式一：经典补充/对比过渡词】 (Standard Additive/Contrasting Transitions)</strong><ul><li>使用过渡词来表明这是第二个论点，并且可以体现出与第一点之间的逻辑关系。</li><li><strong>范例:</strong><ol><li><code>Secondly, besides exercise, many people now put more emphasis on their diet.</code></li><li><code>On the other hand, nurses are just as essential for providing direct, hands-on patient care.</code></li><li><code>More importantly, nurses provide direct support to patients, both physically and mentally.</code></li></ol></li></ul></li><li><strong>【句式二：强调另一个方面】 (Emphasizing Another Aspect)</strong><ul><li>使用 “another” 或 “what’s also” 等结构来强调这是一个新的、不同的方面。</li><li><strong>范例:</strong><ol><li><code>Another crucial aspect is the emotional comfort and encouragement that nurses offer...</code></li><li><code>Another key area is nutrition, with more people becoming conscious about what they eat.</code></li><li><code>What's also crucial is explaining the &quot;why&quot; behind healthy habits...</code></li></ol></li></ul></li><li><strong>【句式三：使用对比或递进结构】 (Using Contrastive or Progressive Structures)</strong><ul><li>通过明确的对比或递进结构，使第二个论点显得更有深度和思辨性。</li><li><strong>范例:</strong><ol><li><code>However, I feel the situation is often different for nurses, who might be underpaid.</code></li><li><code>In addition to being a model, parents should actively involve their kids in healthy activities...</code></li><li><code>Equally important is the compassionate, hands-on care that nurses provide...</code></li></ol></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;改变世界的发明&quot;&gt;改变世界的发明&lt;/h1&gt;
&lt;h2 id=&quot;part-2&quot;&gt;Part 2&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Describe an invention that has changed the world in a positive way</summary>
      
    
    
    
    <category term="IELTs" scheme="https://blog.lthero.cn/categories/IELTs/"/>
    
    
    <category term="IELTs" scheme="https://blog.lthero.cn/tags/IELTs/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay2数组part02</title>
    <link href="https://blog.lthero.cn/2025/06/25/LeetCodeCampsDay2/"/>
    <id>https://blog.lthero.cn/2025/06/25/LeetCodeCampsDay2/</id>
    <published>2025-06-24T16:12:32.000Z</published>
    <updated>2025-07-08T10:19:51.994Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday2数组part02">LeetCodeCampsDay2数组part02</h1><blockquote><p>同样需要使用快/慢指针/双指针，另外，可以使用前缀和数组、二分查找</p></blockquote><h1 id="209-长度最小的子数组">209. 长度最小的子数组</h1><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">https://leetcode.cn/problems/minimum-size-subarray-sum/</a></p><h2 id="问题">问题</h2><blockquote><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code></p><p>找出该数组中满足其总和大于等于 <code>target</code> 的长度最小的 <strong>子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度**。**如果不存在符合条件的子数组，返回 <code>0</code> 。</p></blockquote><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 4, nums = [1,4,4]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 11, nums = [1,1,1,1,1,1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= target &lt;= 109</code></li><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 104</code></li></ul><p><strong>进阶：</strong></p><ul><li>如果你已经实现 <code>O(n)</code> 时间复杂度的解法, 请尝试设计一个 <code>O(n log(n))</code> 时间复杂度的解法。</li></ul><h2 id="核心思路">核心思路</h2><ol><li>外循环：使用for循环，被遍历对象为快指针(right)，通过 ⁠right 指针扩展窗口</li><li>内循环：当窗口和(the sum of windows) &gt;= ⁠target 时，记录当前窗口长度，并尝试收缩(shrink)窗口以找到更小的子数组</li><li>跳出条件：如果数组为空或没有符合的子数组，⁠min_length 保持为最大值float(‘inf’)时，最终返回 0</li></ol><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        currentSum = <span class="number">0</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># Set the minimumWindows as a positive inf</span></span><br><span class="line">        minimumWindows = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">          <span class="comment"># keep add nums to currentSum</span></span><br><span class="line">            currentSum += nums[right]</span><br><span class="line">            <span class="comment"># if currentSum is bigger than target,</span></span><br><span class="line">            <span class="comment"># try to shrink the minimumWindows from the left to find a smaller currentSum.</span></span><br><span class="line">            <span class="keyword">while</span> currentSum &gt;= target <span class="keyword">and</span> left &lt;= right:</span><br><span class="line">              <span class="comment"># shrink the windows</span></span><br><span class="line">                minimumWindows = <span class="built_in">min</span>(minimumWindows, right - left + <span class="number">1</span>)</span><br><span class="line">                <span class="comment"># remove the leftmost elements from the sum</span></span><br><span class="line">                currentSum -= nums[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> minimumWindows == <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> minimumWindows</span><br></pre></td></tr></table></figure><h2 id="o-nlogn-时间复杂度的解法">O(nlogn)时间复杂度的解法</h2><p>这个解法使用<code>前缀和数组</code>(prefix array)结合<code>二分查找</code>：</p><p>先计算<code>前缀和数组</code>，prefix[i] 表示 nums[0] 到 nums[i-1] 的和</p><p>对于每个右端点 j（对应子数组结束位置），使用二分查找找到第一个子数组和 &gt;= target 的最大右端点。</p><p>时间复杂度：O(n log n)，因为计算前缀和是 O(n)，每个右端点进行一次二分查找是 O(log n)，总共 O(n log n)</p><p>空间复杂度：O(n)，用于存储前缀和数组</p><h2 id="思路">思路</h2><ol><li>使用前缀和数组来快速计算子数组的总和</li><li>我们需要找到一个子区间nums[j…k]，而且sum(nums[j…k]) &gt;= target；而sum(nums[j…k]) = ⁠prefix[k+1] - prefix[j]，于是就有prefix[k+1] - prefix[j] &gt;= target, 于是就有prefix[k+1] &gt;= target + prefix[j]</li><li>使用（变体）二分搜索在前缀和数组中（从prefix[j…k])，找到<strong>第一个大于target + prefix[j]的下标mid</strong>，从而计算最小长度</li></ol><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">L = <span class="built_in">len</span>(nums)</span><br><span class="line">prefix = [<span class="number">0</span>] * (L + <span class="number">1</span>)</span><br><span class="line"><span class="comment"># prefix[1] = nums[0], prefix[2] = nums[1], etc.</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L + <span class="number">1</span>):</span><br><span class="line">    prefix[i] = prefix[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> prefix[L] &lt; target:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(prefix)</span><br><span class="line">minimumWindows = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, L + <span class="number">1</span>):</span><br><span class="line">    <span class="comment"># The need is to find a ⁠nums[j..k] which &gt;= target，the sum of nums[j..k] = ⁠prefix[k+1] - prefix[j]</span></span><br><span class="line">    <span class="comment"># Which means `⁠prefix[k+1] - prefix[j] &gt;= target`, noted by `⁠prefix[k+1] &gt;= prefix[j] + target`</span></span><br><span class="line">    <span class="comment"># Hence, ⁠value = prefix[j] + target is the lowest boundary that satisfied the need</span></span><br><span class="line">    <span class="comment"># value = prefix[j] + target # we can set this result to &#x27;value&#x27; to reduce the repeated calculation.</span></span><br><span class="line">    <span class="keyword">if</span> prefix[j] + target &gt; prefix[L]:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># Find the first value which &gt;= value by using binary search</span></span><br><span class="line">    left, right = j, L</span><br><span class="line">    <span class="keyword">while</span> left != right:</span><br><span class="line">      <span class="comment"># </span></span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> prefix[mid] &gt;= prefix[j] + target:</span><br><span class="line">            right = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">    <span class="comment"># right(or left) is the first index which &gt;= ⁠value in prefix</span></span><br><span class="line">    <span class="comment"># where the right equals to the lowest &#x27;k+1&#x27; making the sum of nums[j..k] &gt;= target</span></span><br><span class="line">    minimumWindows = <span class="built_in">min</span>(minimumWindows, right - j)</span><br><span class="line"><span class="keyword">return</span> minimumWindows</span><br></pre></td></tr></table></figure><h1 id="59-螺旋矩阵-ii">59. 螺旋矩阵 II</h1><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">https://leetcode.cn/problems/spiral-matrix-ii/</a></p><blockquote><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p></blockquote><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[[1,2,3],[8,9,4],[7,6,5]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li></ul><h2 id="思路">思路</h2><p>这题目不考算法，但考编程能力；</p><p>这题目有个关键点是，弄清楚赋值的规律：将上、右、下、左四条边依次赋值，并且每次赋值时，都遵循“左开右闭”原则</p><blockquote><p>比如第一行1-&gt;2-&gt;3，仅赋值1和2），而第二条（3-&gt;4-&gt;5），仅赋值(3-&gt;4);第三条(5-&gt;6-&gt;7)，仅赋值(5-&gt;6)；最后一条(7-&gt;8-&gt;1)，同样仅赋值(7-&gt;8)</p></blockquote><p>这样完成了一个“回”字形赋值</p><h2 id="代码">代码</h2><p>下面代码可以优化成仅用一个offset，因为startX/startY与offset变化方式是一致的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateMatrix</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">      <span class="comment"># startX是指纵向下标</span></span><br><span class="line">        startX = <span class="number">0</span></span><br><span class="line">        <span class="comment"># startY是指横向下标</span></span><br><span class="line">        startY = <span class="number">0</span></span><br><span class="line">        <span class="comment"># offset用来计算开区间</span></span><br><span class="line">        offset = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 左闭右开</span></span><br><span class="line">        nums = [[<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        count = <span class="number">1</span> </span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n//<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(startY, n - offset):</span><br><span class="line">                nums[startX][j] = count</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                <span class="comment"># print(nums)</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startX, n - offset):</span><br><span class="line">                nums[i][n - offset] = count</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                <span class="comment"># print(nums)</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n - offset, startY - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                nums[n - offset][j] = count</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                <span class="comment"># print(nums)</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - offset - <span class="number">1</span>, startX , -<span class="number">1</span>):</span><br><span class="line">                nums[i][j] = count</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                <span class="comment"># print(nums)</span></span><br><span class="line">            startX += <span class="number">1</span></span><br><span class="line">            startY += <span class="number">1</span></span><br><span class="line">            offset += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            nums[n//<span class="number">2</span>][n//<span class="number">2</span>] = count</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday2数组part02&quot;&gt;LeetCodeCampsDay2数组part02&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;同样需要使用快/慢指针/双指针，另外，可以使用前缀和数组、二分查找&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
    <category term="数组" scheme="https://blog.lthero.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
</feed>
