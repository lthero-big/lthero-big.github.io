<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lthero</title>
  
  <subtitle>个人博客</subtitle>
  <link href="https://blog.lthero.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.lthero.cn/"/>
  <updated>2025-08-23T12:48:16.772Z</updated>
  <id>https://blog.lthero.cn/</id>
  
  <author>
    <name>lthero</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCodeCampsDay56</title>
    <link href="https://blog.lthero.cn/2025/08/23/LeetCodeCampsDay56/"/>
    <id>https://blog.lthero.cn/2025/08/23/LeetCodeCampsDay56/</id>
    <published>2025-08-23T12:19:56.000Z</published>
    <updated>2025-08-23T12:48:16.772Z</updated>
    
    <content type="html"><![CDATA[<h1 id="108-冗余的边">108.冗余的边</h1><p>题目描述</p><p>有一个图，它是一棵树，他是拥有 n 个节点（节点编号1到n）和 n - 1 条边的连通无环无向图，例如如图：</p><p><img src="https://file.kamacoder.com/pics/20250325153433.png" alt="img"></p><p>现在在这棵树上的基础上，添加一条边（依然是n个节点，但有n条边），使这个图变成了有环图，如图：</p><p><img src="https://file.kamacoder.com/pics/20250325153510.png" alt="img"></p><p>先请你找出冗余边，删除后，使该图可以重新变成一棵树。</p><p>输入描述</p><p>第一行包含一个整数 N，表示图的节点个数和边的个数。</p><p>后续 N 行，每行包含两个整数 s 和 t，表示图中 s 和 t 之间有一条边。</p><p>输出描述</p><p>输出一条可以删除的边。如果有多个答案，请删除标准输入中最后出现的那条边。</p><p>输入示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure><p>输出示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 3</span><br></pre></td></tr></table></figure><p>提示信息</p><p><img src="https://kamacoder.com/upload/kamacoder.com/image/20240417/20240417110831_73733.png" alt="img"></p><p>图中的 1 2，2 3，1 3 等三条边在删除后都能使原图变为一棵合法的树。但是 1 3 由于是标准输出里最后出现的那条边，所以输出结果为 1 3</p><p>数据范围：</p><p>1 &lt;= N &lt;= 1000.</p><h2 id="并查集思路">并查集思路</h2><p>如何判断哪条边是多余的？</p><p>对输入的边进行遍历，如果这边的两个节点已经在并查集里了，则说明这边就是多余的，可以把这边添加到备选列表；否则，再添加到并查集中</p><h2 id="并查集代码">并查集代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, size</span>):</span><br><span class="line">        self.parent = <span class="built_in">list</span>(<span class="built_in">range</span>(size + <span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 返回u节点的根节点</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, u</span>):</span><br><span class="line">        <span class="keyword">if</span> self.parent[u] != u:</span><br><span class="line">            <span class="comment"># 路径压缩</span></span><br><span class="line">            self.parent[u] = self.find(self.parent[u])</span><br><span class="line">        <span class="keyword">return</span> self.parent[u]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">join</span>(<span class="params">self, u, v</span>):</span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        root_u = self.find(u)</span><br><span class="line">        root_v = self.find(v)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root_u != root_v:</span><br><span class="line">            self.parent[root_v] = root_u</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSame</span>(<span class="params">self, u, v</span>):</span><br><span class="line">        <span class="keyword">return</span> self.find(u) == self.find(v)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    union = UnionFind(n)</span><br><span class="line">    </span><br><span class="line">    res = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        s, t = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        <span class="comment"># 如果节点已经存在并查集中，那就把它添加到候选列表</span></span><br><span class="line">        <span class="keyword">if</span> union.isSame(s, t):</span><br><span class="line">            <span class="comment"># res.append([s, t])</span></span><br><span class="line">            <span class="built_in">print</span>(s, t)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            union.join(s, t)</span><br><span class="line">    <span class="comment"># print(f&quot;&#123;res[-1][0]&#125; &#123;res[-1][1]&#125;&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="扩展">扩展</h2><p>题目要求 “请删除标准输入中最后出现的那条边” ，不少录友疑惑，这代码分明是遇到在同一个根的两个节点立刻就返回了，怎么就求出 最后出现的那条边 了呢。</p><p>有这种疑惑的录友是 认为发现一条冗余边后，后面还可能会有一条冗余边。</p><p>其实并不会。</p><p>题目是在 树的基础上 添加一条边，所以冗余边仅仅是一条。</p><p>到这一条可能靠前出现，可能靠后出现。</p><p>例如，题目输入示例：</p><p>输入示例</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure><p>图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240527110320.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240527110320.png" alt="img"></p><p>输出示例</p><p>1 3</p><p>当我们从前向后遍历，优先让前面的边连上，最后判断冗余边就是 1 3。</p><p>如果我们从后向前便利，优先让后面的边连上，最后判断的冗余边就是 1 2。</p><p>题目要求“请删除标准输入中最后出现的那条边”，所以 1 3 这条边才是我们要求的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;108-冗余的边&quot;&gt;108.冗余的边&lt;/h1&gt;
&lt;p&gt;题目描述&lt;/p&gt;
&lt;p&gt;有一个图，它是一棵树，他是拥有 n 个节点（节点编号1到n）和 n - 1 条边的连通无环无向图，例如如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://file.kamacode</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay55图论part05(并查集)</title>
    <link href="https://blog.lthero.cn/2025/08/23/LeetCodeCampsDay55/"/>
    <id>https://blog.lthero.cn/2025/08/23/LeetCodeCampsDay55/</id>
    <published>2025-08-23T07:19:28.000Z</published>
    <updated>2025-08-23T12:19:36.865Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday55图论part05-并查集">LeetCodeCampsDay55图论part05(并查集)</h1><blockquote><p>包含并查集基础与一个基础题目</p></blockquote><h1 id="并查集理论基础">并查集理论基础</h1><h2 id="背景">背景</h2><p>首先要知道并查集可以解决什么问题呢？</p><p>并查集常用来解决连通性问题。</p><p>大白话就是当我们需要判断两个元素是否在同一个集合里的时候，我们就要想到用并查集。</p><p>并查集主要有两个功能：</p><ul><li>将两个元素添加到一个集合中。</li><li>判断两个元素在不在同一个集合</li></ul><p>接下来围绕并查集的这两个功能来展开讲解。</p><h2 id="原理讲解">原理讲解</h2><p>从代码层面，我们如何将两个元素添加到同一个集合中呢。</p><p>此时有录友会想到：可以把他放到同一个数组里或者set 或者 map 中，这样就表述两个元素在同一个集合。</p><p>那么问题来了，对这些元素分门别类，可不止一个集合，可能是很多集合，成百上千，那么要定义这么多个数组吗？</p><p>有录友想，那可以定义一个二维数组。</p><p>但如果我们要判断两个元素是否在同一个集合里的时候 我们又能怎么办？ 只能把而二维数组都遍历一遍。</p><p>而且每当想添加一个元素到某集合的时候，依然需要把把二维数组都遍历一遍，才知道要放在哪个集合里。</p><p>这仅仅是一个粗略的思路，如果沿着这个思路去实现代码，非常复杂，因为管理集合还需要很多逻辑。</p><p>那么我们来换一个思路来看看。</p><p>我们将三个元素A，B，C （分别是数字）放在同一个集合，其实就是将三个元素连通在一起，如何连通呢。</p><p>只需要用一个一维数组来表示，即：father[A] = B，father[B] = C 这样就表述 A 与 B 与 C连通了（有向连通图）。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将v，u 这条边加入并查集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">    v = <span class="built_in">find</span>(v); <span class="comment">// 寻找v的根</span></span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span>; <span class="comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span></span><br><span class="line">    father[v] = u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能有录友想，这样我可以知道 A 连通 B，因为 A 是索引下标，根据 father[A]的数值就知道 A 连通 B。那怎么知道 B 连通 A呢？</p><p>我们的目的是判断这三个元素是否在同一个集合里，知道 A 连通 B 就已经足够了。</p><p>这里要讲到寻根思路，只要 A ，B，C 在同一个根下就是同一个集合。</p><p>给出A元素，就可以通过 father[A] = B，father[B] = C，找到根为 C。</p><p>给出B元素，就可以通过 father[B] = C，找到根也为为 C，说明 A 和 B 是在同一个集合里。 大家会想第一段代码里find函数是如何实现的呢？其实就是通过数组下标找到数组元素，一层一层寻根过程，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并查集里寻根的过程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == father[u]) <span class="keyword">return</span> u; <span class="comment">// 如果根就是自己，直接返回</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">find</span>(father[u]); <span class="comment">// 如果根不是自己，就根据数组下标一层一层向下找</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何表示 C 也在同一个元素里呢？ 我们需要 father[C] = C，即C的根也为C，这样就方便表示 A，B，C 都在同一个集合里了。</p><p>所以father数组初始化的时候要 father[i] = i，默认自己指向自己。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并查集初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们如何判断两个元素是否在同一个集合里，如果通过 find函数 找到 两个元素属于同一个根的话，那么这两个元素就是同一个集合，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u);</span><br><span class="line">    v = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">return</span> u == v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路径压缩">路径压缩</h2><p>在实现 find 函数的过程中，我们知道，通过递归的方式，不断获取father数组下标对应的数值，最终找到这个集合的根。</p><p>搜索过程像是一个多叉树中从叶子到根节点的过程，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20230602102619.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20230602102619.png" alt="img"></p><p>如果这棵多叉树高度很深的话，每次find函数 去寻找根的过程就要递归很多次。</p><p>我们的目的只需要知道这些节点在同一个根下就可以，所以对这棵多叉树的构造只需要这样就可以了，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20230602103040.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20230602103040.png" alt="img"></p><p>除了根节点其他所有节点都挂载根节点下，这样我们在寻根的时候就很快，只需要一步，</p><p>如果我们想达到这样的效果，就需要 <strong>路径压缩</strong>，将非根节点的所有节点直接指向根节点。 那么在代码层面如何实现呢？</p><p>我们只需要在递归的过程中，让 father[u] 接住 递归函数 find(father[u]) 的返回结果。</p><p>因为 find 函数向上寻找根节点，father[u] 表述 u 的父节点，那么让 father[u] 直接获取 find函数 返回的根节点，这样就让节点 u 的父节点 变成根节点。</p><p>代码如下，注意看注释，路径压缩就一行代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并查集里寻根的过程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == father[u]) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> father[u] = <span class="built_in">find</span>(father[u]); <span class="comment">// 路径压缩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码在C++中，可以用三元表达式来精简一下，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u == father[u] ? u : father[u] = <span class="built_in">find</span>(father[u]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相信不少录友在学习并查集的时候，对上面这三行代码实现的 find函数 很熟悉，但理解上却不够深入，仅仅知道这行代码很好用，不知道这里藏着路径压缩的过程。</p><p>所以对于算法初学者来说，直接看精简代码学习是不太友好的，往往忽略了很多细节。</p><h2 id="代码模板">代码模板</h2><p>那么此时并查集的模板就出来了， 整体模板C++代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">1005</span>; <span class="comment">// n根据题目中节点数量而定，一般比节点数量大一点就好</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; father = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n, <span class="number">0</span>); <span class="comment">// C++里的一种数组结构</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 并查集里寻根的过程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u == father[u] ? u : father[u] = <span class="built_in">find</span>(father[u]); <span class="comment">// 路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u);</span><br><span class="line">    v = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">return</span> u == v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将v-&gt;u 这条边加入并查集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">    v = <span class="built_in">find</span>(v); <span class="comment">// 寻找v的根</span></span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ; <span class="comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span></span><br><span class="line">    father[v] = u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过模板，我们可以知道，并查集主要有三个功能。</p><ol><li>寻找根节点，函数：find(int u)，也就是判断这个节点的祖先节点是哪个</li><li>将两个节点接入到同一个集合，函数：join(int u, int v)，将两个节点连在同一个根节点上</li><li>判断两个节点是否在同一个集合，函数：isSame(int u, int v)，就是判断两个节点是不是同一个根节点</li></ol><h2 id="常见误区">常见误区</h2><p>这里估计有录友会想，模板中的 join 函数里的这段代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">u = <span class="built_in">find</span>(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">v = <span class="built_in">find</span>(v); <span class="comment">// 寻找v的根</span></span><br><span class="line"><span class="keyword">if</span> (u == v) <span class="keyword">return</span> ; <span class="comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span></span><br></pre></td></tr></table></figure><p>与 isSame 函数的实现是不是重复了？ 如果抽象一下呢，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u);</span><br><span class="line">    v = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">return</span> u == v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将v-&gt;u 这条边加入并查集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isSame</span>(u, v)) <span class="keyword">return</span> ; <span class="comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span></span><br><span class="line">    father[v] = u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写可以吗？ 好像看出去没问题，而且代码更精简了。</p><p><strong>其实这么写是有问题的</strong>，在join函数中 我们需要寻找 u 和 v 的根，然后再进行连线在一起，而不是直接 用 u 和 v 连线在一起。</p><p>举一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">join</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">join</span>(<span class="number">3</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>此时构成的图是这样的：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20230525111307.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20230525111307.png" alt="img"></p><p>此时问 1，3是否在同一个集合，我们调用 <code>join(1, 2); join(3, 2);</code> 很明显本意要表示 1，3是在同一个集合。</p><p>但我们来看一下代码逻辑，当我们调用 <code>isSame(1, 3)</code>的时候，find(1) 返回的是1，find(3)返回的是3。 <code>return 1 == 3</code> 返回的是false，代码告诉我们 1 和 3 不在同一个集合，这明显不符合我们的预期，所以问题出在哪里？</p><p>问题出在我们精简的代码上，即 join 函数 一定要先 通过find函数寻根再进行关联。</p><p>如果find函数是这么实现，再来看一下逻辑过程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">    v = <span class="built_in">find</span>(v); <span class="comment">// 寻找v的根</span></span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ; <span class="comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span></span><br><span class="line">    father[v] = u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别将 这两对元素加入集合。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">join</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">join</span>(<span class="number">3</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>当执行<code>join(3, 2)</code>的时候，会先通过find函数寻找 3的根为3，2的根为1 （第一个<code>join(1, 2)</code>，将2的根设置为1），所以最后是将1 指向 3。</p><p>构成的图是这样的：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20230525112101.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20230525112101.png" alt="img"></p><p>因为在join函数里，我们有find函数进行寻根的过程，这样就保证元素 1，2，3在这个有向图里是强连通的。</p><p>此时我们在调用 <code>isSame(1, 3)</code>的时候，find(1) 返回的是3，find(3) 返回的也是3，<code>return 3 == 3</code> 返回的是true，即告诉我们 元素 1 和 元素3 是 在同一个集合里的。</p><h2 id="模拟过程">模拟过程</h2><p>（<strong>凸显途径合并的过程，每一个join都要画图</strong>）</p><p>不少录友在接触并查集模板之后，用起来很娴熟，因为模板确实相对固定，但是对并查集内部数据组织方式以及如何判断是否是同一个集合的原理很模糊。</p><p>通过以上讲解之后，我再带大家一步一步去画一下，并查集内部数据连接方式。</p><p>1、<code>join(1, 8);</code></p><p><img src="https://cdn.lthero.cn/post_images/course/ML20231122112727.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20231122112727.png" alt="img"></p><p>2、<code>join(3, 8);</code></p><p><img src="https://cdn.lthero.cn/post_images/course/ML20231122113857.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20231122113857.png" alt="img"></p><p>有录友可能想，<code>join(3, 8)</code> 在图中为什么 将 元素1 连向元素 3 而不是将 元素 8 连向 元素 3 呢？</p><p>这一点 我在 「常见误区」标题下已经详细讲解了，因为在<code>join(int u, int v)</code>函数里 要分别对 u 和 v 寻根之后再进行关联。</p><p>3、<code>join(1, 7);</code></p><p><img src="https://cdn.lthero.cn/post_images/course/ML20231122114108.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20231122114108.png" alt="img"></p><p>4、<code>join(8, 5);</code></p><p><img src="https://cdn.lthero.cn/post_images/course/ML20231122114847.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20231122114847.png" alt="img"></p><p>这里8的根是3，那么 5 应该指向 8 的根 3，这里的原因，我们在上面「常见误区」已经讲过了。 但 为什么 图中 8 又直接指向了 3 了呢？</p><p><strong>因为路经压缩了</strong></p><p>即如下代码在寻找根的过程中，会有路径压缩，减少 下次查询的路径长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并查集里寻根的过程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u == father[u] ? u : father[u] = <span class="built_in">find</span>(father[u]); <span class="comment">// 路径压缩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、<code>join(2, 9);</code></p><p><img src="https://cdn.lthero.cn/post_images/course/ML20231122115000.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20231122115000.png" alt="img"></p><p>6、<code>join(6, 9);</code></p><p><img src="https://cdn.lthero.cn/post_images/course/ML20231122115404.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20231122115404.png" alt="img"></p><p>这里为什么是 2 指向了 6，因为 9的根为 2，所以用2指向6。</p><p>大家看懂这个有向图后，相信应该知道如下函数的返回值了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">isSame</span>(<span class="number">8</span>, <span class="number">7</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">isSame</span>(<span class="number">7</span>, <span class="number">2</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>返回值分别如下，表示，8 和 7 是同一个集合，而 7 和 2 不是同一个集合。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure><h2 id="拓展">拓展</h2><p>在「路径压缩」讲解中，我们知道如何靠压缩路径来缩短查询根节点的时间。</p><p>其实还有另一种方法：按秩（rank）合并。</p><p>rank表示树的高度，即树中结点层次的最大值。</p><p>例如两个集合（多叉树）需要合并，如图所示：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20230602172250.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20230602172250.png" alt="img"></p><p>树1 rank 为2，树2 rank 为 3。那么合并两个集合，是 树1 合入 树2，还是 树2 合入 树1呢？</p><p>我们来看两个不同方式合入的效果。</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20230602172933.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20230602172933.png" alt="img"></p><p>这里可以看出，树2 合入 树1 会导致整棵树的高度变的更高，而 树1 合入 树2 整棵树的高度 和 树2 保持一致。</p><p>所以在 join函数中如何合并两棵树呢？</p><p>一定是 rank 小的树合入 到 rank大 的树，这样可以保证最后合成的树rank 最小，降低在树上查询的路径长度。</p><p>按秩合并的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">1005</span>; <span class="comment">// n根据题目中节点数量而定，一般比节点数量大一点就好</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; father = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n, <span class="number">0</span>); <span class="comment">// C++里的一种数组结构</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; rank = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n, <span class="number">1</span>); <span class="comment">// 初始每棵树的高度都为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">        rank[i] = <span class="number">1</span>; <span class="comment">// 也可以不写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 并查集里寻根的过程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u == father[u] ? u : <span class="built_in">find</span>(father[u]);<span class="comment">// 注意这里不做路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u);</span><br><span class="line">    v = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">return</span> u == v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将v-&gt;u 这条边加入并查集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">    v = <span class="built_in">find</span>(v); <span class="comment">// 寻找v的根</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rank[u] &lt;= rank[v]) father[u] = v; <span class="comment">// rank小的树合入到rank大的树</span></span><br><span class="line">    <span class="keyword">else</span> father[v] = u;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rank[u] == rank[v] &amp;&amp; u != v) rank[v]++; <span class="comment">// 如果两棵树高度相同，则v的高度+1，因为上面 if (rank[u] &lt;= rank[v]) father[u] = v; 注意是 &lt;=</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以注意到在上面的模板代码中，我是没有做路径压缩的，因为一旦做路径压缩，rank记录的高度就不准了，根据rank来判断如何合并就没有意义。</p><p>也可以在 路径压缩的时候，再去实时修生rank的数值，但这样在代码实现上麻烦了不少，关键是收益很小。</p><p>其实我们在优化并查集查询效率的时候，只用路径压缩的思路就够了，不仅代码实现精简，而且效率足够高。</p><p>按秩合并的思路并没有将树形结构尽可能的扁平化，所以在整理效率上是没有路径压缩高的。</p><p>说到这里可能有录友会想，那在路径压缩的代码中，只有查询的过程 即 find 函数的执行过程中会有路径压缩，如果一直没有使用find函数，是不是相当于这棵树就没有路径压缩，导致查询效率依然很低呢？</p><p>大家可以再去回顾使用路径压缩的 并查集模板，在isSame函数 和 join函数中，我们都调用了 find 函数来进行寻根操作。</p><p>也就是说，无论使用并查集模板里哪一个函数（除了init函数），都会有路径压缩的过程，第二次访问相同节点的时候，这个节点就是直连根节点的，即 第一次访问的时候它的路径就被压缩了。</p><p><strong>所以这里推荐大家直接使用路径压缩的并查集模板就好</strong>，但按秩合并的优化思路我依然给大家讲清楚，有助于更深一步理解并查集的优化过程。</p><h2 id="复杂度分析">复杂度分析</h2><p>这里对路径压缩版并查集来做分析。</p><p>空间复杂度： O(n) ，申请一个father数组。</p><p>关于时间复杂度，如果想精确表达出来需要繁琐的数学证明，就不在本篇讲解范围内了，大家感兴趣可以自己去深入研究。</p><p>这里做一个简单的分析思路。</p><p>路径压缩后的并查集时间复杂度在O(logn)与O(1)之间，且随着查询或者合并操作的增加，时间复杂度会越来越趋于O(1)。</p><p>了解到这个程度对于求职面试来说就够了。</p><p>在第一次查询的时候，相当于是n叉树上从叶子节点到根节点的查询过程，时间复杂度是logn，但路径压缩后，后面的查询操作都是O(1)，而 join 函数 和 isSame函数 里涉及的查询操作也是一样的过程。</p><h2 id="总结">总结</h2><p>本篇我们讲解了并查集的背景、原理、两种优化方式（路径压缩，按秩合并），代码模板，常见误区，以及模拟过程。</p><p>要知道并查集解决什么问题，在什么场景下我们要想到使用并查集。</p><p>接下来进一步优化并查集的执行效率，重点介绍了路径压缩的方式，另一种方法：按秩合并，我们在 「拓展」中讲解。</p><p>通过一步一步的原理讲解，最后给出并查集的模板，所有的并查集题目都在这个模板的基础上进行操作或者适当修改。</p><p>但只给出模板还是不够的，针对大家学习并查集的常见误区，详细讲解了模板代码的细节。</p><p>为了让录友们进一步了解并查集的运行过程，我们再通过具体用例模拟一遍代码过程并画出对应的内部数据连接图（有向图）。</p><p>这里也建议大家去模拟一遍才能对并查集理解的更到位。</p><p>如果对模板代码还是有点陌生，不用担心，接下来我会讲解对应LeetCode上的并查集题目，通过一系列题目练习，大家就会感受到这套模板有多么的好用！</p><h1 id="并查集套路代码-python">并查集套路代码(python)</h1><p>并查集主要有三个功能：</p><ol><li>寻找根节点，函数：find(int u)，也就是判断这个节点的祖先节点是哪个</li><li>将两个节点接入到同一个集合，函数：join(int u, int v)，将两个节点连在同一个根节点上</li><li>判断两个节点是否在同一个集合，函数：isSame(int u, int v)，就是判断两个节点是不是同一个根节点</li></ol><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 并查集搜索</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, size</span>):</span><br><span class="line">        <span class="comment"># 初始化，每个节点（从0到size)的根为自己</span></span><br><span class="line">        self.parent = <span class="built_in">list</span>(<span class="built_in">range</span>(size + <span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, u</span>):</span><br><span class="line">        <span class="keyword">if</span> self.parent[u] != u:</span><br><span class="line">            self.parent[u] = self.find(self.parent[u]) <span class="comment"># 路径压缩</span></span><br><span class="line">            <span class="comment"># return self.find(self.parent[u]) # 不路径压缩</span></span><br><span class="line">        <span class="keyword">return</span> self.parent[u]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">join</span>(<span class="params">self, u, v</span>):</span><br><span class="line">        root_u = self.find(u)</span><br><span class="line">        root_v = self.find(v)</span><br><span class="line">        <span class="comment"># 如果他们的根不同，则将v的根指向u的根</span></span><br><span class="line">        <span class="keyword">if</span> root_u != root_v:</span><br><span class="line">            self.parent[root_v] = root_u</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSame</span>(<span class="params">self, u, v</span>):</span><br><span class="line">        root_u = self.find(u)</span><br><span class="line">        root_v = self.find(v)</span><br><span class="line">        <span class="keyword">return</span> root_u == root_v</span><br></pre></td></tr></table></figure><h1 id="107-寻找存在的路径">107.寻找存在的路径</h1><p>题目描述</p><p>给定一个包含 n 个节点的无向图中，节点编号从 1 到 n （含 1 和 n ）。</p><p>你的任务是判断是否有一条从节点 source 出发到节点 destination 的路径存在。</p><p>输入描述</p><p>第一行包含两个正整数 N 和 M，N 代表节点的个数，M 代表边的个数。</p><p>后续 M 行，每行两个正整数 s 和 t，代表从节点 s 与节点 t 之间有一条边。</p><p>最后一行包含两个正整数，代表起始节点 source 和目标节点 destination。</p><p>输出描述</p><p>输出一个整数，代表是否存在从节点 source 到节点 destination 的路径。如果存在，输出 1；否则，输出 0。</p><p>输入示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 4</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br><span class="line">3 4</span><br><span class="line">1 4</span><br></pre></td></tr></table></figure><p>输出示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>提示信息</p><p><img src="https://kamacoder.com/upload/kamacoder.com/image/20240416/20240416112946_20453.png" alt="img"></p><p>数据范围：</p><p>1 &lt;= M, N &lt;= 100。</p><h2 id="并查集思路">并查集思路</h2><p>本题可以理解为</p><p>若source和destination拥有相同的root，则说明他们之间存在路径</p><p>使用 join(int u, int v)将每条边加入到并查集。</p><p>最后 isSame(int u, int v) 判断是否是同一个根 就可以了。</p><h2 id="并查集代码">并查集代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 并查集搜索</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, size</span>):</span><br><span class="line">        <span class="comment"># 初始化，每个节点（从0到size)的根为自己</span></span><br><span class="line">        self.parent = <span class="built_in">list</span>(<span class="built_in">range</span>(size + <span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, u</span>):</span><br><span class="line">        <span class="keyword">if</span> self.parent[u] != u:</span><br><span class="line">            self.parent[u] = self.find(self.parent[u]) <span class="comment"># 路径压缩</span></span><br><span class="line">            <span class="comment"># return self.find(self.parent[u]) # 不路径压缩</span></span><br><span class="line">        <span class="keyword">return</span> self.parent[u]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">join</span>(<span class="params">self, u, v</span>):</span><br><span class="line">        root_u = self.find(u)</span><br><span class="line">        root_v = self.find(v)</span><br><span class="line">        <span class="comment"># 如果他们的根不同，则将v的根指向u的根</span></span><br><span class="line">        <span class="keyword">if</span> root_u != root_v:</span><br><span class="line">            self.parent[root_v] = root_u</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSame</span>(<span class="params">self, u, v</span>):</span><br><span class="line">        root_u = self.find(u)</span><br><span class="line">        root_v = self.find(v)</span><br><span class="line">        <span class="keyword">return</span> root_u == root_v</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用节点个数初始化UnionFind</span></span><br><span class="line">    union = UnionFind(n)</span><br><span class="line"></span><br><span class="line">    graph = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        u, v = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        union.join(u, v)</span><br><span class="line">    </span><br><span class="line">    source, destination = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    res = union.isSame(source, destination)</span><br><span class="line">    <span class="keyword">if</span> res:</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday55图论part05-并查集&quot;&gt;LeetCodeCampsDay55图论part05(并查集)&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;包含并查集基础与一个基础题目&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;并查集理论基</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay53图论part04</title>
    <link href="https://blog.lthero.cn/2025/08/23/LeetCodeCampsDay53/"/>
    <id>https://blog.lthero.cn/2025/08/23/LeetCodeCampsDay53/</id>
    <published>2025-08-23T05:42:12.000Z</published>
    <updated>2025-08-23T07:18:25.382Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday53图论part04">LeetCodeCampsDay53图论part04</h1><blockquote><p>继续使用深度/广度优先解决图的问题</p><p>其中105是有向图问题</p></blockquote><h1 id="110-字符串接龙">110.字符串接龙</h1><p><a href="https://kamacoder.com/problempage.php?pid=1183">https://kamacoder.com/problempage.php?pid=1183</a></p><p>题目描述</p><p>字典 strList 中从字符串 beginStr 和 endStr 的转换序列是一个按下述规格形成的序列：</p><ol><li>序列中第一个字符串是 beginStr。</li><li>序列中最后一个字符串是 endStr。</li><li>每次转换只能改变一个字符。</li><li>转换过程中的中间字符串必须是字典 strList 中的字符串，且strList里的每个字符串只用使用一次。</li></ol><p>给你两个字符串 beginStr 和 endStr 和一个字典 strList，找到从 beginStr 到 endStr 的最短转换序列中的字符串数目。如果不存在这样的转换序列，返回 0。</p><p>输入描述</p><p>第一行包含一个整数 N，表示字典 strList 中的字符串数量。 第二行包含两个字符串，用空格隔开，分别代表 beginStr 和 endStr。 后续 N 行，每行一个字符串，代表 strList 中的字符串。</p><p>输出描述</p><p>输出一个整数，代表从 beginStr 转换到 endStr 需要的最短转换序列中的字符串数量。如果不存在这样的转换序列，则输出 0。</p><p>输入示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">abc def</span><br><span class="line">efc</span><br><span class="line">dbc</span><br><span class="line">ebc</span><br><span class="line">dec</span><br><span class="line">dfc</span><br><span class="line">yhn</span><br></pre></td></tr></table></figure><p>输出示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>提示信息</p><p>从 startStr 到 endStr，在 strList 中最短的路径为 abc -&gt; dbc -&gt; dec -&gt; def，所以输出结果为 4，如图：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20240529121038.png" alt="img"></p><p>数据范围：</p><p>2 &lt;= N &lt;= 500</p><h2 id="广度优先搜索思路">广度优先搜索思路</h2><p>以示例1为例，从这个图中可以看出 abc 到 def的路线 不止一条，但最短的一条路径上是4个节点。</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20250317105155.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20250317105155.png" alt="img"></p><p>本题难点在于如何将输入变成一个无向图</p><p>第二难点在于求最短路径长度</p><p><strong>解决思路</strong></p><p>从beginStr开始（加入到广度优先遍历队列中）</p><p>从队列中先弹出curS，并对strList字符串遍历，如果curS与strList相差一个字母，则将strList添加到队列，并且记录从beginStr到达strList的步数，随后进行下一轮遍历；</p><p>本题需要有个辅助函数，用来判断两个字符串是否仅相差一个字母</p><h2 id="广度优先搜索代码">广度优先搜索代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判断s1与s2的不同字母是否仅有一个</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">judge</span>(<span class="params">s1, s2</span>):</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    Ls1 = <span class="built_in">len</span>(s1)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Ls1):</span><br><span class="line">        <span class="keyword">if</span> s1[i] != s2[i]:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count == <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    beginStr, endStr = <span class="built_in">input</span>().split()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> beginStr == endStr:</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># </span></span><br><span class="line">    strList = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        strList.append(<span class="built_in">input</span>())</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 使用广度优先搜索</span></span><br><span class="line">    visited = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="comment"># que加入的是当前节点，以及从beginStr到当前节点的步数</span></span><br><span class="line">    que = [[beginStr, <span class="number">1</span>]]</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="keyword">while</span> que:</span><br><span class="line">        curs, step = que.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 如果当前字符串和endStr仅差一个字符，则可以结束了</span></span><br><span class="line">        <span class="keyword">if</span> judge(curs, endStr):</span><br><span class="line">            <span class="built_in">print</span>(step + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 对strList进行遍历，如果未访问过，并且strList[i]和curs仅差距一个字符，则可以遍历这个strList[i]</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> visited[i] == <span class="number">0</span> <span class="keyword">and</span> judge(strList[i], curs):</span><br><span class="line">                visited[i] = <span class="number">1</span></span><br><span class="line">                que.append([strList[i], step + <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h1 id="105-有向图的完全联通">105.有向图的完全联通</h1><p>题目描述</p><p>给定一个有向图，包含 N 个节点，节点编号分别为 1，2，…，N。现从 1 号节点开始，如果可以从 1 号节点的边可以到达任何节点，则输出 1，否则输出 -1。</p><p>输入描述</p><p>第一行包含两个正整数，表示节点数量 N 和边的数量 K。 后续 K 行，每行两个正整数 s 和 t，表示从 s 节点有一条边单向连接到 t 节点。</p><p>输出描述</p><p>如果可以从 1 号节点的边可以到达任何节点，则输出 1，否则输出 -1。</p><p>输入示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 4</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br></pre></td></tr></table></figure><p>输出示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>提示信息</p><p><img src="https://kamacoder.com/upload/kamacoder.com/image/20240415/20240415192546_54466.png" alt="img"></p><p>从 1 号节点可以到达任意节点，输出 1。</p><p><strong>数据范围：</strong></p><p>1 &lt;= N &lt;= 100；<br>1 &lt;= K &lt;= 2000。</p><h2 id="深度优先遍历的思路">深度优先遍历的思路</h2><blockquote><p>本题可以先创建个邻接表，并对每个节点进行访问，最终判断是否存在未访问过的节点</p></blockquote><p>使用深度优先遍历时（其实广度优先遍历也是一样的），需要</p><ol><li>输入输出</li></ol><p>输入应该为（graph, visited, 以及当前节点）</p><p>def dfs(graph, visited, p):</p><ol start="2"><li>终止条件</li></ol><p>dfs有两种写法，这里有一个很重要的逻辑，就是在递归中，<strong>我们是处理当前访问的节点，还是处理下一个要访问的节点</strong>。</p><p>本题中什么叫做处理，就是 visited数组来记录访问过的节点，该节点默认 数组里元素都是false，把元素标记为true就是处理 本节点了。</p><ul><li>如果我们是处理当前访问的节点，当前访问的节点如果是 true ，说明是访问过的节点，那就终止本层递归，如果不是true，我们就把它赋值为true，因为这是我们处理本层递归的节点。</li></ul><p>对应代码为</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">graph, visited, p</span>):</span><br><span class="line">  <span class="comment"># 先判断是否访问过</span></span><br><span class="line"><span class="keyword">if</span> visited[p] == <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 再设置为访问过</span></span><br><span class="line">visited[p] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 后面是单层逻辑</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> graph[p]:</span><br><span class="line">        <span class="keyword">if</span> visited[i] == <span class="number">0</span>:</span><br><span class="line">            dfs(graph, visited, i)</span><br></pre></td></tr></table></figure><ul><li>如果我们是处理下一层访问的节点，而不是当前层。那么就要在 深搜三部曲中第三步：处理目前搜索节点出发的路径的时候对 节点进行处理。这样的话，就不需要终止条件，<code>而是在 搜索下一个节点的时候，直接判断 下一个节点是否是我们要搜的节点。</code></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">graph, visited, p</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> graph[p]:</span><br><span class="line">      <span class="comment"># 判断下一个节点是否被访问过，如果未访问过才去访问</span></span><br><span class="line">        <span class="keyword">if</span> visited[i] == <span class="number">0</span>:</span><br><span class="line">          <span class="comment"># 设置它被访问过</span></span><br><span class="line">            visited[i] = <span class="number">1</span></span><br><span class="line">            dfs(graph, visited, i)</span><br></pre></td></tr></table></figure><ol start="3"><li>单层逻辑</li></ol><p>本题的单层逻辑就是将节点设置为被访问过，不需要进行回溯（因为不用走回头路）</p><p><strong>那什么时候需要回溯操作呢？</strong></p><p>当我们需要搜索一条可行路径的时候，就需要回溯操作了，因为没有回溯，就没法“调头”， 如果不理解的话，去看我写的 <a href="https://www.programmercarl.com/kamacoder/0098.%E6%89%80%E6%9C%89%E5%8F%AF%E8%BE%BE%E8%B7%AF%E5%BE%84.html">0098.所有可达路径</a> 的题解。</p><h2 id="深度优先遍历代码">深度优先遍历代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用深度优先遍历，如果所有节点都能被访问(visited)则输出1，否则输出-1</span></span><br><span class="line"><span class="comment"># graph使用邻接表</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">graph, visited, p</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> graph[p]:</span><br><span class="line">        <span class="keyword">if</span> visited[i] == <span class="number">0</span>:</span><br><span class="line">            visited[i] = <span class="number">1</span></span><br><span class="line">            dfs(graph, visited, i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, k = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置为n+1是因为把0也算进去了，省得对下标进行换算</span></span><br><span class="line">    graph = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># visited记录的是每个节点是否有被访问过</span></span><br><span class="line">    visited = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    visited[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        start, end = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        graph[start].append(end)</span><br><span class="line">    </span><br><span class="line">    dfs(graph, visited, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> visited[i] == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="广度优先搜索">广度优先搜索</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果使用广度优先搜索，</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">graph, path, p</span>):</span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">    que = deque()</span><br><span class="line">    que.append(p)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> que:</span><br><span class="line">        cur = que.popleft()</span><br><span class="line">        path.add(cur)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> graph[cur]:</span><br><span class="line">            que.append(i)</span><br><span class="line">        <span class="comment"># 如果没有下面这步，会死循环</span></span><br><span class="line">        graph[cur] = []</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bfs2</span>(<span class="params">graph, visited, p</span>):</span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">    que = deque()</span><br><span class="line">    que.append(p)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> que:</span><br><span class="line">        cur = que.popleft()</span><br><span class="line">        visited[cur] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> graph[cur]:</span><br><span class="line">            <span class="keyword">if</span> visited[i] == <span class="number">0</span>:</span><br><span class="line">              <span class="comment"># 或者在这儿写visited[i] = 1也可以</span></span><br><span class="line">                que.append(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, k = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置为n+1是因为把0也算进去了，省得对下标进行换算</span></span><br><span class="line">    graph = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        start, end = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        graph[start].append(end)</span><br><span class="line">  </span><br><span class="line">   <span class="comment"># visited记录的是每个节点是否有被访问过</span></span><br><span class="line">    visited = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    visited[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    bfs2(graph, visited, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> visited[i] == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># bfs另一种写法</span></span><br><span class="line">  <span class="comment"># path用来记录被访问过的节点</span></span><br><span class="line">    <span class="comment">#path = set()</span></span><br><span class="line">    <span class="comment">#bfs(graph, path, 1)</span></span><br><span class="line">    <span class="comment">#if path == &#123;i for i in range(1, n + 1)&#125;:</span></span><br><span class="line">    <span class="comment">#    print(1)</span></span><br><span class="line">    <span class="comment">#    return</span></span><br><span class="line">    <span class="comment">#print(-1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h1 id="106-岛屿的周长">106.岛屿的周长</h1><p>题目描述</p><p>给定一个由 1（陆地）和 0（水）组成的矩阵，岛屿是被水包围，并且通过水平方向或垂直方向上相邻的陆地连接而成的。</p><p>你可以假设矩阵外均被水包围。在矩阵中恰好拥有一个岛屿，假设组成岛屿的陆地边长都为 1，请计算岛屿的周长。岛屿内部没有水域。</p><p>输入描述</p><p>第一行包含两个整数 N, M，表示矩阵的行数和列数。之后 N 行，每行包含 M 个数字，数字为 1 或者 0，表示岛屿的单元格。</p><p>输出描述</p><p>输出一个整数，表示岛屿的周长。</p><p>输入示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 5</span><br><span class="line">0 0 0 0 0 </span><br><span class="line">0 1 0 1 0</span><br><span class="line">0 1 1 1 0</span><br><span class="line">0 1 1 1 0</span><br><span class="line">0 0 0 0 0</span><br></pre></td></tr></table></figure><p>输出示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">14</span><br></pre></td></tr></table></figure><p>提示信息</p><p><img src="https://kamacoder.com/upload/kamacoder.com/image/20240416/20240416100952_15971.png" alt="img"></p><p>岛屿的周长为 14。</p><p>数据范围：</p><p>1 &lt;= M, N &lt;= 50。</p><h2 id="广度优先搜索思路">广度优先搜索思路</h2><p>题目明确了岛被水包围，但要考虑岛周围是边界的问题</p><p>计算每块陆地的相邻块，相邻块有几个是水，则有周长就加几</p><p>遍历每一个空格，遇到岛屿则计算其上下左右的空格情况。</p><p>如果该陆地上下左右的空格是有水域，则说明是一条边，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240524115933.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240524115933.png" alt="img"></p><p>陆地的右边空格是水域，则说明找到一条边。</p><p>如果该陆地上下左右的空格出界了，则说明是一条边，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240524120105.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240524120105.png" alt="img"></p><p>该陆地的下边空格出界了，则说明找到一条边。</p><h2 id="广度优先搜索代码">广度优先搜索代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">direction = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>]]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">graph, visited, x, y</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">    que = deque()</span><br><span class="line">    que.append([x, y])</span><br><span class="line">    visited[x][y] = <span class="number">1</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> que:</span><br><span class="line">        curx, cury = que.popleft()</span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> direction:</span><br><span class="line">            nextx = curx + i</span><br><span class="line">            nexty = cury + j</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= nextx &lt; <span class="built_in">len</span>(graph) <span class="keyword">and</span> <span class="number">0</span> &lt;= nexty &lt; <span class="built_in">len</span>(graph[<span class="number">0</span>]):</span><br><span class="line">                <span class="keyword">if</span> graph[nextx][nexty] == <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># print(nextx, nexty)</span></span><br><span class="line">                    res += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> visited[nextx][nexty] == <span class="number">0</span> <span class="keyword">and</span> graph[nextx][nexty] == <span class="number">1</span>:</span><br><span class="line">                    visited[nextx][nexty] = <span class="number">1</span></span><br><span class="line">                    que.append([nextx, nexty])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果出界了，直接就当前海水</span></span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">    graph = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        graph.append(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line">    </span><br><span class="line">    visited = [[<span class="number">0</span>] * m <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">if</span> visited[i][j] == <span class="number">0</span> <span class="keyword">and</span> graph[i][j] == <span class="number">1</span>:</span><br><span class="line">                res = bfs(graph, visited, i, j)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday53图论part04&quot;&gt;LeetCodeCampsDay53图论part04&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;继续使用深度/广度优先解决图的问题&lt;/p&gt;
&lt;p&gt;其中105是有向图问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay52图论part03</title>
    <link href="https://blog.lthero.cn/2025/08/22/LeetCodeCampsDay52/"/>
    <id>https://blog.lthero.cn/2025/08/22/LeetCodeCampsDay52/</id>
    <published>2025-08-22T02:36:08.000Z</published>
    <updated>2025-08-23T07:18:32.402Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday52图论part03">LeetCodeCampsDay52图论part03</h1><h1 id="101-孤岛的总面积">101.孤岛的总面积</h1><h6 id="题目描述">题目描述</h6><p>给定一个由 1（陆地）和 0（水）组成的矩阵，岛屿指的是由水平或垂直方向上相邻的陆地单元格组成的区域，且完全被水域单元格包围。孤岛是那些位于矩阵内部、所有单元格都不接触边缘的岛屿。</p><p>现在你需要计算所有孤岛的总面积，岛屿面积的计算方式为组成岛屿的陆地的总数。</p><h6 id="输入描述">输入描述</h6><p>第一行包含两个整数 N, M，表示矩阵的行数和列数。之后 N 行，每行包含 M 个数字，数字为 1 或者 0。</p><h6 id="输出描述">输出描述</h6><p>输出一个整数，表示所有孤岛的总面积，如果不存在孤岛，则输出 0。</p><h6 id="输入示例">输入示例</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 1 0 0 0</span><br><span class="line">1 1 0 0 0</span><br><span class="line">0 0 1 0 0</span><br><span class="line">0 0 0 1 1</span><br></pre></td></tr></table></figure><h6 id="输出示例">输出示例</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h6 id="提示信息">提示信息</h6><p><img src="https://kamacoder.com/upload/kamacoder.com/image/20240412/20240412113711_58587.png" alt="img"></p><p>在矩阵中心部分的岛屿，因为没有任何一个单元格接触到矩阵边缘，所以该岛屿属于孤岛，总面积为 1。</p><p>数据范围：</p><p>1 &lt;= M, N &lt;= 50。</p><h2 id="思路0">思路0</h2><p>题目要求没有任何一个单元格接触到矩阵边缘，那：从四个边缘出发，将与之相邻的格子都变成海洋（设置为0），随后再统计保留下来为陆地的格子即可</p><p>如图，在遍历地图周围四个边，靠地图四边的陆地，都为绿色，</p><p><img src="https://file1.kamacoder.com/i/algo/20220830104632.png" alt="img"></p><p>在遇到地图周边陆地的时候，将1都变为0，此时地图为这样：</p><p><img src="https://file1.kamacoder.com/i/algo/20220830104651.png" alt="img"></p><p>然后我们再去遍历这个地图，遇到有陆地的地方，去采用深搜或者广搜，边统计所有陆地。</p><h2 id="代码0">代码0</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">direction = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>]]</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将x,y相邻的位置都变成海洋（0)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">graph, x, y</span>):</span><br><span class="line">    que = deque()</span><br><span class="line">    que.append([x, y])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> que:</span><br><span class="line">        curX, curY = que.popleft()</span><br><span class="line">        graph[curX][curY] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> direction:</span><br><span class="line">            nextX = curX + i</span><br><span class="line">            nextY = curY + j</span><br><span class="line">            <span class="keyword">if</span> nextX &lt; <span class="number">0</span> <span class="keyword">or</span> nextY &lt; <span class="number">0</span> <span class="keyword">or</span> nextX &gt;= <span class="built_in">len</span>(graph) <span class="keyword">or</span> nextY &gt;= <span class="built_in">len</span>(graph[<span class="number">0</span>]):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> graph[nextX][nextY] == <span class="number">1</span>:</span><br><span class="line">                que.append([nextX, nextY])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    graph = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        graph.append(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line">    </span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 从上、下开始将相邻格子变成海洋</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">if</span> graph[<span class="number">0</span>][i] == <span class="number">1</span>:</span><br><span class="line">            bfs(graph, <span class="number">0</span>, i)</span><br><span class="line">        <span class="keyword">if</span> graph[n - <span class="number">1</span>][i] == <span class="number">1</span>:</span><br><span class="line">            bfs(graph, n - <span class="number">1</span>, i)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 从左、右开始将相邻格子变成海洋</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> graph[i][<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">            bfs(graph, i, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> graph[i][m - <span class="number">1</span>] == <span class="number">1</span>:</span><br><span class="line">            bfs(graph, i, m - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> graph[i][j] == <span class="number">1</span>:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="广度优先搜索思路一">广度优先搜索思路一</h2><p>我的思路是，对每个格子遍历，如果这个格子搜索到的相邻格子是边缘位置，则将它标记，并最终将整个区域返回-1；否则就返回实际的面积值；实际取所有返回值的最大值</p><h2 id="广度优先搜索思路二">广度优先搜索思路二</h2><ul><li>时间复杂度O(M * N)</li><li>空间复杂度O(M * N)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果某个岛在边缘上则直接返回-1</span></span><br><span class="line"><span class="comment"># 否则才计算这个岛的面积</span></span><br><span class="line"></span><br><span class="line">direction = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">graph, visited, x, y</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="comment"># </span></span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">    que = deque()</span><br><span class="line">    que.append([x, y])</span><br><span class="line"></span><br><span class="line">    area = <span class="number">1</span></span><br><span class="line">    flag = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> que:</span><br><span class="line">        curX, curY = que.popleft()</span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> direction:</span><br><span class="line">            nextX = curX + i</span><br><span class="line">            nextY = curY + j</span><br><span class="line">            <span class="keyword">if</span> nextX &lt; <span class="number">0</span> <span class="keyword">or</span> nextY &lt; <span class="number">0</span> <span class="keyword">or</span> nextX &gt;= <span class="built_in">len</span>(graph) <span class="keyword">or</span> nextY &gt;= <span class="built_in">len</span>(graph[<span class="number">0</span>]):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> graph[nextX][nextY] == <span class="number">1</span> <span class="keyword">and</span> visited[nextX][nextY] == <span class="number">2</span>:</span><br><span class="line">                flag = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> graph[nextX][nextY] == <span class="number">1</span> <span class="keyword">and</span> visited[nextX][nextY] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> nextX == <span class="number">0</span> <span class="keyword">or</span> nextY == <span class="number">0</span> <span class="keyword">or</span> nextX == <span class="built_in">len</span>(graph) - <span class="number">1</span> <span class="keyword">or</span> nextY == <span class="built_in">len</span>(graph[<span class="number">0</span>]) - <span class="number">1</span>:</span><br><span class="line">                    visited[nextX][nextY] = <span class="number">2</span></span><br><span class="line">                    flag = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    visited[nextX][nextY] = <span class="number">1</span></span><br><span class="line">                    area += <span class="number">1</span></span><br><span class="line">                que.append([nextX, nextY])</span><br><span class="line">    <span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> area</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    graph = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        graph.append(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line">    </span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    visited = [[<span class="number">0</span>] * m <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> visited[i][j] == <span class="number">0</span> <span class="keyword">and</span> graph[i][j] == <span class="number">1</span>:</span><br><span class="line">                visited[i][j] = <span class="number">1</span></span><br><span class="line">                res += <span class="built_in">max</span>(bfs(graph, visited, i, j), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h1 id="102-沉没孤岛">102.沉没孤岛</h1><h6 id="题目描述">题目描述</h6><p>给定一个由 1（陆地）和 0（水）组成的矩阵，岛屿指的是由水平或垂直方向上相邻的陆地单元格组成的区域，且完全被水域单元格包围。孤岛是那些位于矩阵内部、所有单元格都不接触边缘的岛屿。</p><p>现在你需要将所有孤岛“沉没”，即将孤岛中的所有陆地单元格（1）转变为水域单元格（0）。</p><h6 id="输入描述">输入描述</h6><p>第一行包含两个整数 N, M，表示矩阵的行数和列数。</p><p>之后 N 行，每行包含 M 个数字，数字为 1 或者 0，表示岛屿的单元格。</p><h6 id="输出描述">输出描述</h6><p>输出将孤岛“沉没”之后的岛屿矩阵。 注意：每个元素后面都有一个空格</p><h6 id="输入示例">输入示例</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 1 0 0 0</span><br><span class="line">1 1 0 0 0</span><br><span class="line">0 0 1 0 0</span><br><span class="line">0 0 0 1 1</span><br></pre></td></tr></table></figure><h6 id="输出示例">输出示例</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 1 0 0 0</span><br><span class="line">1 1 0 0 0</span><br><span class="line">0 0 0 0 0</span><br><span class="line">0 0 0 1 1</span><br></pre></td></tr></table></figure><h6 id="提示信息">提示信息</h6><p><img src="https://kamacoder.com/upload/kamacoder.com/image/20240412/20240412144356_69900.png" alt="img"></p><p>将孤岛沉没。</p><p><img src="https://kamacoder.com/upload/kamacoder.com/image/20240412/20240412144445_89755.png" alt="img"></p><p>数据范围：</p><p>1 &lt;= M, N &lt;= 50。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从上、下、左、右开始将与边缘格子相邻的格子保持为陆地</span></span><br><span class="line"><span class="comment"># 将孤岛变成海洋</span></span><br><span class="line"></span><br><span class="line">direction = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">graph, x, y</span>):</span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">    que = deque()</span><br><span class="line">    que.append([x, y])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> que:</span><br><span class="line">        curx, cury = que.popleft()</span><br><span class="line">        <span class="comment"># 设置为2表示可以被保留</span></span><br><span class="line">        graph[curx][cury] = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> direction:</span><br><span class="line">            nextx = curx + i</span><br><span class="line">            nexty = cury + j</span><br><span class="line">            <span class="keyword">if</span> nextx &lt; <span class="number">0</span> <span class="keyword">or</span> nexty &lt; <span class="number">0</span> <span class="keyword">or</span> nextx &gt;= <span class="built_in">len</span>(graph) <span class="keyword">or</span> nexty &gt;= <span class="built_in">len</span>(graph[<span class="number">0</span>]):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> graph[nextx][nexty] == <span class="number">1</span>:</span><br><span class="line">                que.append([nextx, nexty])</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    graph = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        graph.append(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 从上、下两行开始</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">if</span> graph[<span class="number">0</span>][i] == <span class="number">1</span>:</span><br><span class="line">            bfs(graph, <span class="number">0</span>, i)</span><br><span class="line">        <span class="keyword">if</span> graph[n - <span class="number">1</span>][i] == <span class="number">1</span>:</span><br><span class="line">            bfs(graph, n - <span class="number">1</span>, i)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 从左、右两列开始</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> graph[i][<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">            bfs(graph, i, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> graph[i][m - <span class="number">1</span>] == <span class="number">1</span>:</span><br><span class="line">            bfs(graph, i, m - <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">if</span> graph[i][j] == <span class="number">1</span>:</span><br><span class="line">                graph[i][j] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> graph[i][j] == -<span class="number">1</span>:</span><br><span class="line">                graph[i][j] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> graph:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> line:</span><br><span class="line">            <span class="built_in">print</span>(i, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="103-水流问题">103 水流问题</h1><p><a href="https://kamacoder.com/problempage.php?pid=1175">https://kamacoder.com/problempage.php?pid=1175</a></p><p>题目描述</p><p>现有一个 N × M 的矩阵，每个单元格包含一个数值，这个数值代表该位置的相对高度。矩阵的左边界和上边界被认为是第一组边界，而矩阵的右边界和下边界被视为第二组边界。</p><p>矩阵模拟了一个地形，当雨水落在上面时，水会根据地形的倾斜向低处流动，但只能从较高或等高的地点流向较低或等高并且相邻（上下左右方向）的地点。我们的目标是确定那些单元格，从这些单元格出发的水可以达到第一组边界和第二组边界。</p><p>输入描述</p><p>第一行包含两个整数 N 和 M，分别表示矩阵的行数和列数。</p><p>后续 N 行，每行包含 M 个整数，表示矩阵中的每个单元格的高度。</p><p>输出描述</p><p>输出共有多行，每行输出两个整数，用一个空格隔开，表示可达第一组边界和第二组边界的单元格的坐标，输出顺序任意。</p><p>输入示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 5</span><br><span class="line">1 3 1 2 4</span><br><span class="line">1 2 1 3 2</span><br><span class="line">2 4 7 2 1</span><br><span class="line">4 5 6 1 1</span><br><span class="line">1 4 1 2 1</span><br></pre></td></tr></table></figure><p>输出示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0 4</span><br><span class="line">1 3</span><br><span class="line">2 2</span><br><span class="line">3 0</span><br><span class="line">3 1</span><br><span class="line">3 2</span><br><span class="line">4 0</span><br><span class="line">4 1</span><br></pre></td></tr></table></figure><p>提示信息</p><p><img src="https://kamacoder.com/upload/kamacoder.com/image/20240418/20240418103946_19439.png" alt="img"></p><p>图中的蓝色方块上的雨水既能流向第一组边界，也能流向第二组边界。所以最终答案为所有蓝色方块的坐标。</p><p>数据范围：</p><p>1 &lt;= M, N &lt;= 100。</p><h2 id="搜索思路">搜索思路</h2><p>一个比较直白的想法，其实就是 遍历每个点，然后看这个点 能不能同时到达第一组边界和第二组边界。</p><p>至于遍历方式，可以用dfs，也可以用bfs，以下用dfs来举例。</p><p>这种思路很直白，但很明显，以上代码超时了。 来看看时间复杂度。</p><p>遍历每一个节点，是 m * n，遍历每一个节点的时候，都要做深搜，深搜的时间复杂度是： m * n</p><p>那么整体时间复杂度 就是 O(m^2 * n^2) ，这是一个四次方的时间复杂度。</p><p>那么我们可以 <code>反过来想，从第一组边界上的节点 逆流而上，将遍历过的节点都标记上</code>。</p><p>同样从第二组边界的边上节点 逆流而上，将遍历过的节点也标记上。</p><p>然后<strong>两方都标记过的节点就是既可以流向第一组边界也可以流向第二组边界的节点</strong>。</p><p>从第一组边界边上节点出发，如图： （图中并没有把所有遍历的方向都画出来，只画关键部分）</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20250304174747.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20250304174747.png" alt="img"></p><p>从第二组边界上节点出发，如图： （图中并没有把所有遍历的方向都画出来，只画关键部分）</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20250304174801.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20250304174801.png" alt="img"></p><p>最后，我们得到两个方向交界的这些节点，就是我们最后要求的节点。</p><h2 id="深度优先搜索代码">深度优先搜索代码</h2><p>那么本题整体的时间复杂度其实是： 2 * n * m + n * m ，所以最终时间复杂度为 O(n * m) 。</p><p>空间复杂度为：O(n * m) 这个就不难理解了。开了几个 n * m 的数组</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">firstborder = <span class="built_in">set</span>()</span><br><span class="line">secondborder = <span class="built_in">set</span>()</span><br><span class="line">direction = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">graph, visited, border, x, y</span>):</span><br><span class="line">    <span class="keyword">if</span> visited[x][y] == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    visited[x][y] = <span class="number">1</span></span><br><span class="line">    border.add((x, y))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> direction:</span><br><span class="line">        nextx = x + i</span><br><span class="line">        nexty = y + j</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt;= nextx &lt; <span class="built_in">len</span>(graph) <span class="keyword">and</span> <span class="number">0</span> &lt;= nexty &lt; <span class="built_in">len</span>(graph[<span class="number">0</span>]) <span class="keyword">and</span> <span class="built_in">int</span>(graph[x][y]) &lt;= <span class="built_in">int</span>(graph[nextx][nexty]):</span><br><span class="line">            dfs(graph, visited, border, nextx, nexty)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">global</span> firstborder, secondborder</span><br><span class="line"></span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">    graph = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        graph.append(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line">    </span><br><span class="line">    visited = [[<span class="number">0</span>] * m <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># 从第一边界（第一列）和从第一边界（第一行）出发</span></span><br><span class="line">        dfs(graph, visited, firstborder, i, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        dfs(graph, visited, firstborder, <span class="number">0</span>, i)</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    visited = [[<span class="number">0</span>] * m <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># 第二边界（最后一列）和第二边界（最后一行）出发</span></span><br><span class="line">        dfs(graph, visited, secondborder, i, m - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        dfs(graph, visited, secondborder, n - <span class="number">1</span>, i)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    res = firstborder &amp; secondborder</span><br><span class="line">    <span class="comment"># 最后统计同时出现在firstborder和secondborder里的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x, y <span class="keyword">in</span> res:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;x&#125;</span> <span class="subst">&#123;y&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="广度优先思路">广度优先思路</h2><p>只有写法和深度优先不太一样，注意将visited的判断放在while循环内</p><h2 id="广度优先代码">广度优先代码</h2><p>那么本题整体的时间复杂度其实是： 2 * n * m + n * m ，所以最终时间复杂度为 O(n * m) 。</p><p>空间复杂度为：O(n * m) 这个就不难理解了。开了几个 n * m 的数组</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">graph, visited, border, x, y</span>):</span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">    que = deque()</span><br><span class="line">    que.append([x, y])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> que:</span><br><span class="line">        curx, cury = que.popleft()</span><br><span class="line">        <span class="keyword">if</span> visited[curx][cury] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        visited[curx][cury] = <span class="number">1</span></span><br><span class="line">        border.add((curx, cury))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> direction:</span><br><span class="line">            nextx = curx + i</span><br><span class="line">            nexty = cury + j</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= nextx &lt; <span class="built_in">len</span>(graph) <span class="keyword">and</span> <span class="number">0</span> &lt;= nexty &lt; <span class="built_in">len</span>(graph[<span class="number">0</span>]) <span class="keyword">and</span> <span class="built_in">int</span>(graph[curx][cury]) &lt;= <span class="built_in">int</span>(graph[nextx][nexty]):</span><br><span class="line">                que.append([nextx, nexty])</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">global</span> firstborder, secondborder</span><br><span class="line"></span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">    graph = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        graph.append(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line">    </span><br><span class="line">    visited = [[<span class="number">0</span>] * m <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># 从第一边界（第一列）和从第一边界（第一行）出发</span></span><br><span class="line">        bfs(graph, visited, firstborder, i, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        bfs(graph, visited, firstborder, <span class="number">0</span>, i)</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    visited = [[<span class="number">0</span>] * m <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># 第二边界（最后一列）和第二边界（最后一行）出发</span></span><br><span class="line">        bfs(graph, visited, secondborder, i, m - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        bfs(graph, visited, secondborder, n - <span class="number">1</span>, i)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    res = firstborder &amp; secondborder</span><br><span class="line">    <span class="comment"># 最后统计同时出现在firstborder和secondborder里的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x, y <span class="keyword">in</span> res:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;x&#125;</span> <span class="subst">&#123;y&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h1 id="104-建造最大岛屿">104.建造最大岛屿</h1><p><a href="https://kamacoder.com/problempage.php?pid=1176">https://kamacoder.com/problempage.php?pid=1176</a></p><p>题目描述</p><p>给定一个由 1（陆地）和 0（水）组成的矩阵，你最多可以将矩阵中的一格水变为一块陆地，在执行了此操作之后，矩阵中最大的岛屿面积是多少。</p><p>岛屿面积的计算方式为组成岛屿的陆地的总数。岛屿是被水包围，并且通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设矩阵外均被水包围。</p><p>输入描述</p><p>第一行包含两个整数 N, M，表示矩阵的行数和列数。之后 N 行，每行包含 M 个数字，数字为 1 或者 0，表示岛屿的单元格。</p><p>输出描述</p><p>输出一个整数，表示最大的岛屿面积。</p><p>输入示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 1 0 0 0</span><br><span class="line">1 1 0 0 0</span><br><span class="line">0 0 1 0 0</span><br><span class="line">0 0 0 1 1</span><br></pre></td></tr></table></figure><p>输出示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><p>提示信息</p><p><img src="https://kamacoder.com/upload/kamacoder.com/image/20240415/20240415145559_94626.png" alt="img"></p><p>对于上面的案例，有两个位置可将 0 变成 1，使得岛屿的面积最大，即 6。</p><p><img src="https://kamacoder.com/upload/kamacoder.com/image/20240415/20240415145650_61097.png" alt="img"></p><p>数据范围：</p><p>1 &lt;= M, N &lt;= 50。</p><h2 id="搜索代码">搜索代码</h2><p>其实每次深搜遍历计算最大岛屿面积，我们都做了很多重复的工作。</p><p>只要用一次深搜把每个岛屿的面积记录下来就好。</p><p>第一步：一次遍历地图，得出各个岛屿的面积，并做编号记录。可以使用map记录，key为岛屿编号，value为岛屿面积</p><p>第二步：再遍历地图，遍历0的方格（因为要将0变成1），并统计该1（由0变成的1）周边岛屿面积，将其相邻面积相加在一起，遍历所有 0 之后，就可以得出 选一个0变成1 之后的最大面积。</p><p>拿如下地图的岛屿情况来举例： （1为陆地）</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20220829104834.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20220829104834.png" alt="img"></p><p>第一步，则遍历地图，并将岛屿的编号和面积都统计好，过程如图所示：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20220829105644.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20220829105644.png" alt="img"></p><p>这个过程时间复杂度 n * n 。可能有录友想：分明是两个for循环下面套这一个dfs，时间复杂度怎么回事 n * n呢？</p><p>其实大家可以仔细看一下代码，<strong>n * n这个方格地图中，每个节点我们就遍历一次，并不会重复遍历</strong>。</p><p>第二步过程如图所示：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20220829105249.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20220829105249.png" alt="img"></p><p>也就是遍历每一个0的方格，并统计其相邻岛屿面积，最后取一个最大值。</p><p>这个过程的时间复杂度也为 n * n。</p><p>所以整个解法的时间复杂度，为 n * n + n * n 也就是 n^2。</p><p>当然这里还有一个优化的点，就是 可以不用 visited数组，因为有mark来标记，所以遍历过的grid[i][j]是不等于1的。</p><h2 id="广度优先代码">广度优先代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 技巧解题</span></span><br><span class="line"><span class="comment"># 先把所有岛屿面积求出来，并且给这个岛屿进行编号（需要修改graph里这个岛屿块数值），并记录这个编号岛屿的面积（放在字典里）</span></span><br><span class="line"><span class="comment"># 再遍历所有海洋（假设把当前海洋变成陆地），并且计算当前这块海洋相邻的岛屿总面积，就能找到一个最合适变成陆地的海洋块</span></span><br><span class="line"></span><br><span class="line">direction = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># bfs的目的是计算每个岛屿的面积，以及将岛屿“涂色”，同一个岛屿将拥有相同的编号</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">graph, visited, x, y, number</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">    area = <span class="number">1</span></span><br><span class="line">    que = deque()</span><br><span class="line">    que.append([x, y])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> que:</span><br><span class="line">        curx, cury = que.popleft()</span><br><span class="line">        <span class="comment"># 进行岛屿编号</span></span><br><span class="line">        graph[curx][cury] = number</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> direction:</span><br><span class="line">            nextx = curx + i</span><br><span class="line">            nexty = cury + j</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span>&lt;= nextx &lt; <span class="built_in">len</span>(graph) <span class="keyword">and</span> <span class="number">0</span>&lt;= nexty &lt; <span class="built_in">len</span>(graph[<span class="number">0</span>]) <span class="keyword">and</span> visited[nextx][nexty] == <span class="number">0</span> <span class="keyword">and</span> graph[nextx][nexty] == <span class="number">1</span>:</span><br><span class="line">              <span class="comment"># 注意计算面积的位置</span></span><br><span class="line">                visited[nextx][nexty] = <span class="number">1</span></span><br><span class="line">                area += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                que.append([nextx, nexty])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> area</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">    graph = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        graph.append(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line">    </span><br><span class="line">    number = <span class="number">1</span></span><br><span class="line">    <span class="comment"># res为最大岛屿面积</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    table = <span class="built_in">dict</span>()</span><br><span class="line">    visited = [[<span class="number">0</span>] * (m) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="comment"># 第一次遍历，将岛屿编号并且记录最大面积</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">if</span> graph[i][j] != <span class="number">0</span> <span class="keyword">and</span> visited[i][j] == <span class="number">0</span>:</span><br><span class="line">                number += <span class="number">1</span></span><br><span class="line">                temp  = bfs(graph, visited, i, j, number)</span><br><span class="line">                res = <span class="built_in">max</span>(res, temp)</span><br><span class="line">                table[number] = temp</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 第二次遍历，只针对海洋进行操作</span></span><br><span class="line">    <span class="comment"># 对海洋块的周围岛屿进行计算，注意某一个海洋块，有可能被同一个编号的岛屿包围，所以不要重复添加某个岛屿</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="comment"># 如果为海洋</span></span><br><span class="line">            <span class="keyword">if</span> graph[x][y] == <span class="number">0</span>:</span><br><span class="line">                temp = <span class="number">1</span></span><br><span class="line">                <span class="comment"># 记录是否已经添加过某个岛屿</span></span><br><span class="line">                added = <span class="built_in">set</span>()</span><br><span class="line">                <span class="keyword">for</span> i, j <span class="keyword">in</span> direction:</span><br><span class="line">                    nextx = x + i</span><br><span class="line">                    nexty = y + j</span><br><span class="line">                    <span class="keyword">if</span> <span class="number">0</span>&lt;= nextx &lt; <span class="built_in">len</span>(graph) <span class="keyword">and</span> <span class="number">0</span>&lt;= nexty &lt; <span class="built_in">len</span>(graph[<span class="number">0</span>]) <span class="keyword">and</span> graph[nextx][nexty] != <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">if</span> graph[nextx][nexty] <span class="keyword">not</span> <span class="keyword">in</span> added:</span><br><span class="line">                            temp += table[graph[nextx][nexty]]</span><br><span class="line">                            added.add(graph[nextx][nexty])</span><br><span class="line">                <span class="comment"># 求岛屿最大面积</span></span><br><span class="line">                res = <span class="built_in">max</span>(temp, res)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday52图论part03&quot;&gt;LeetCodeCampsDay52图论part03&lt;/h1&gt;
&lt;h1 id=&quot;101-孤岛的总面积&quot;&gt;101.孤岛的总面积&lt;/h1&gt;
&lt;h6 id=&quot;题目描述&quot;&gt;题目描述&lt;/h6&gt;
&lt;p&gt;给定一个由 1（陆</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>服务器上使用Hysteria2配合Proxychain代理</title>
    <link href="https://blog.lthero.cn/2025/08/21/Hysteria2Proxychain/"/>
    <id>https://blog.lthero.cn/2025/08/21/Hysteria2Proxychain/</id>
    <published>2025-08-21T13:37:50.000Z</published>
    <updated>2025-08-21T14:04:48.386Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hysteria2客户端使用教程">Hysteria2客户端使用教程</h1><blockquote><p>本文是在linux服务器上（作为客户端！）使用hysteria2代理，不是在服务器上搭建hysteria2！！！！</p></blockquote><h2 id="客户端安装">客户端安装</h2><p>官方教程：<a href="https://v2.hysteria.network/zh/docs/getting-started/Installation/">https://v2.hysteria.network/zh/docs/getting-started/Installation/</a></p><blockquote><p>但！由于需要用本方法的机器无法直接用代理，所以安装hysteria2最好先将hy2可执行文件下载到电脑上，再上传到服务器上，再使用本地安装</p></blockquote><ol><li>下载可执行文件</li></ol><table><thead><tr><th style="text-align:left">文件</th><th style="text-align:left">架构</th><th style="text-align:left">注意</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://download.hysteria.network/app/latest/hysteria-linux-amd64">hysteria-linux-amd64</a></td><td style="text-align:left">x86-64</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://download.hysteria.network/app/latest/hysteria-linux-amd64-avx">hysteria-linux-amd64-avx</a></td><td style="text-align:left">x86-64</td><td style="text-align:left">需要 AVX 指令集</td></tr><tr><td style="text-align:left"><a href="https://download.hysteria.network/app/latest/hysteria-linux-386">hysteria-linux-386</a></td><td style="text-align:left">x86</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://download.hysteria.network/app/latest/hysteria-linux-arm">hysteria-linux-arm</a></td><td style="text-align:left">ARMv7</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://download.hysteria.network/app/latest/hysteria-linux-armv5">hysteria-linux-armv5</a></td><td style="text-align:left">ARMv5</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://download.hysteria.network/app/latest/hysteria-linux-arm64">hysteria-linux-arm64</a></td><td style="text-align:left">ARM64</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://download.hysteria.network/app/latest/hysteria-linux-s390x">hysteria-linux-s390x</a></td><td style="text-align:left">s390x</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://download.hysteria.network/app/latest/hysteria-linux-mipsle">hysteria-linux-mipsle</a></td><td style="text-align:left">MIPS</td><td style="text-align:left">小端序</td></tr><tr><td style="text-align:left"><a href="https://download.hysteria.network/app/latest/hysteria-linux-mipsle-sf">hysteria-linux-mipsle-sf</a></td><td style="text-align:left">MIPS</td><td style="text-align:left">小端序，无硬件浮点支持</td></tr><tr><td style="text-align:left"><a href="https://download.hysteria.network/app/latest/hysteria-linux-riscv64">hysteria-linux-riscv64</a></td><td style="text-align:left">RISC-V 64</td><td style="text-align:left"></td></tr></tbody></table><ol start="2"><li>使用本地文件安装的命令，/path/to/hysteria-linux-amd64是可执行文件路径</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash &lt;(curl -fsSL https://get.hy2.sh/) --<span class="built_in">local</span> /path/to/hysteria-linux-amd64</span><br></pre></td></tr></table></figure><ol start="3"><li>如果连<code>curl -fsSL https://get.hy2.sh/</code>都会卡住，那就先把脚本上传到服务器，再本地执行这脚本，<code>假如脚本名字为hy2.sh</code></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash hy2.sh --<span class="built_in">local</span> /path/to/hysteria-linux-amd64</span><br></pre></td></tr></table></figure><h2 id="客户端本文教程">客户端本文教程</h2><p>官方教程：<a href="https://v2.hysteria.network/zh/docs/getting-started/Client/">https://v2.hysteria.network/zh/docs/getting-started/Client/</a></p><h3 id="前提条件">前提条件</h3><ul><li>一个能连接的 Hysteria 服务器</li></ul><h3 id="创建配置文件">创建配置文件</h3><p>假设你已经将可执行文件下载到了一个目录中，名字是 <code>hysteria-linux-amd64-avx</code>。在同目录下创建一个 <code>config.yaml</code> 文件。</p><blockquote><p><strong>注意</strong>： 部分配置项值可能和 YAML 语法冲突。 例如， 类似于 <code>[2001:db8::1]:443</code> 的 IPv6 地址+端口会导致配置文件解析失败。 只需将值放在 <code>&quot;&quot;</code> 中写成 <code>&quot;[2001:db8::1]:443&quot;</code> 即可解决这类问题。</p></blockquote><p><strong>请务必根据你的服务器设置和需求替换这些值。</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span> <span class="string">xx.xxx.xx.xx:1122</span> <span class="comment"># 服务器ip和端口</span></span><br><span class="line"><span class="attr">auth:</span> <span class="string">xxxxx</span>  <span class="comment"># 输入密码</span></span><br><span class="line"></span><br><span class="line"><span class="attr">bandwidth:</span></span><br><span class="line">  <span class="attr">up:</span> <span class="number">200</span> <span class="string">mbps</span>  </span><br><span class="line">  <span class="attr">down:</span> <span class="number">200</span> <span class="string">mbps</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">tls:</span></span><br><span class="line">  <span class="attr">sni:</span> <span class="string">bing.com</span>  <span class="comment"># 输入伪装域名</span></span><br><span class="line">  <span class="attr">insecure:</span> <span class="literal">true</span>  <span class="comment"># 根据服务端进行配置，自签证书则为true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">socks5:</span></span><br><span class="line">  <span class="attr">listen:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:1080</span></span><br><span class="line"><span class="attr">http:</span></span><br><span class="line">  <span class="attr">listen:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8080</span></span><br></pre></td></tr></table></figure><h2 id="运行客户端">运行客户端</h2><p>通过以下命令启动客户端：</p><p><strong>默认文件名（config.yaml）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./hysteria-linux-amd64-avx</span><br></pre></td></tr></table></figure><p>或者！或者！或者！或者！或者！或者！</p><p><strong>自定义文件名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./hysteria-linux-amd64-avx -c whatever.yaml</span><br></pre></td></tr></table></figure><blockquote><p><strong>提示：</strong> 你也可以使用 <code>./hysteria-linux-amd64-avx client</code>，但由于客户端是默认模式，所以这部分可以省略。</p></blockquote><p>如果你看到日志显示 “connected to server” 且没有错误，恭喜 🎉！你已成功部署了一个 Hysteria 客户端。</p><blockquote><p>后续可以使用systemctl添加个服务，来管理hysteria自动启动</p></blockquote><h1 id="proxychains搭建使用教程">proxychains搭建使用教程</h1><p>拥有v2ray后，再搭配proxychains，从而让各种linux上软件可以访问外网</p><h2 id="一-debian安装">一、Debian安装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install proxychains4 -y</span><br></pre></td></tr></table></figure><h2 id="二-centos安装">二、Centos安装</h2><h3 id="1-有epel源">1、有epel源</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y proxychains-ng</span><br></pre></td></tr></table></figure><h2 id="自行编译">自行编译</h2><h4 id="1-下载源码">(1)下载源码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://ghproxy.com/https://github.com/rofl0r/proxychains-ng.git</span><br></pre></td></tr></table></figure><h4 id="2-编译和安装">(2)编译和安装</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apt install gcc</span><br><span class="line">cd proxychains-ng</span><br><span class="line">./configure --prefix=/usr --sysconfdir=/etc</span><br><span class="line">make </span><br><span class="line">make install</span><br><span class="line">make install-config</span><br><span class="line">cd .. &amp;&amp; rm -rf proxychains-ng</span><br></pre></td></tr></table></figure><h4 id="3-查看proxychains是否安装">(3)查看proxychains是否安装</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">which proxychains4</span><br></pre></td></tr></table></figure><h2 id="三-修改配置文件">三、修改配置文件</h2><p>已经准备好了一个可用的socks代理，<code>上面的hysteria2就行，它的socks端口是1080</code></p><p>安装后默认配置文件在<code>/etc/proxychains4.conf</code></p><p>proxychains-ng支持多种代理模式：</p><ul><li>dynamic_chain ：按照代理列表顺序自动选取可用代理</li><li>strict_chain ：按照代理列表顺序使用代理，所有代理必须可用</li><li>round_robin_chain ：轮询模式，自动跳过不可用代理</li><li>random_chain ：随机模式</li></ul><p>我们只需要编辑proxychains的配置文件，将scosks代理的ip，端口，用户名，密码填进去即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/proxychains4.conf </span><br><span class="line"><span class="comment">#直接划到最后并添加下面的内容</span></span><br><span class="line"><span class="comment">#使用hysteria2默认的本地代理，本地ip和端口要和上面的对应上</span></span><br><span class="line">socks5 127.0.0.1 1080</span><br></pre></td></tr></table></figure><h2 id="四-使用">四、使用</h2><p>只需要使用代理的命令前加上proxychains就可以了，比如</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 curl cip.cc</span><br></pre></td></tr></table></figure><p>我们可以看到IP已经变成socks代理的IP</p><p>当然，也可以直接输入</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 bash</span><br></pre></td></tr></table></figure><p>这样就能新建一个具有代理功能的新终端，不需要在每条命令前都加proxychains了</p><p><code>甚至可以添加个alias,把proxychains4别称为proxy</code></p><p>操作如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br><span class="line"><span class="comment"># 添加下面这行，其中proxy是别称</span></span><br><span class="line"><span class="built_in">alias</span> proxy=<span class="string">&#x27;proxychains4&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;hysteria2客户端使用教程&quot;&gt;Hysteria2客户端使用教程&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;本文是在linux服务器上（作为客户端！）使用hysteria2代理，不是在服务器上搭建hysteria2！！！！&lt;/p&gt;
&lt;/blockquote&gt;
</summary>
      
    
    
    
    <category term="折腾" scheme="https://blog.lthero.cn/categories/%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="折腾" scheme="https://blog.lthero.cn/tags/%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay51图论part02</title>
    <link href="https://blog.lthero.cn/2025/08/14/LeetCodeCampsDay51/"/>
    <id>https://blog.lthero.cn/2025/08/14/LeetCodeCampsDay51/</id>
    <published>2025-08-14T04:44:48.000Z</published>
    <updated>2025-08-14T06:10:38.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday51图论part02">LeetCodeCampsDay51图论part02</h1><blockquote><p>包含深度优先搜索和广度优先搜索的基础代码</p></blockquote><h1 id="99-岛屿数量">99. 岛屿数量</h1><p><a href="https://kamacoder.com/problempage.php?pid=1171">https://kamacoder.com/problempage.php?pid=1171</a></p><p>题目描述</p><p>给定一个由 1（陆地）和 0（水）组成的矩阵，你需要计算岛屿的数量。岛屿由水平方向或垂直方向上相邻的陆地连接而成，并且四周都是水域。你可以假设矩阵外均被水包围。</p><p>输入描述</p><p>第一行包含两个整数 N, M，表示矩阵的行数和列数。</p><p>后续 N 行，每行包含 M 个数字，数字为 1 或者 0。</p><p>输出描述</p><p>输出一个整数，表示岛屿的数量。如果不存在岛屿，则输出 0。</p><p>输入示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 1 0 0 0</span><br><span class="line">1 1 0 0 0</span><br><span class="line">0 0 1 0 0</span><br><span class="line">0 0 0 1 1</span><br></pre></td></tr></table></figure><p>输出示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p>提示信息</p><p><img src="https://kamacoder.com/upload/kamacoder.com/image/20240411/20240411153209_67737.png" alt="img"></p><p>根据测试案例中所展示，岛屿数量共有 3 个，所以输出 3。</p><p><strong>数据范围：</strong></p><p>1 &lt;= N, M &lt;= 50</p><h2 id="图论思路">图论思路</h2><p>注意题目中每座岛屿只能由<strong>水平方向和/或竖直方向上</strong>相邻的陆地连接形成。</p><p>也就是说斜角度链接是不算了， 例如示例二，是三个岛屿，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20220726094200.png" alt="图一"></p><p><img src="https://file1.kamacoder.com/i/algo/20220726094200.png" alt="图一"></p><p>这道题题目是 DFS，BFS，并查集，基础题目。</p><p>本题思路，是用遇到一个没有遍历过的节点陆地，计数器就加一，然后把该节点陆地所能遍历到的陆地都标记上。</p><p>在遇到标记过的陆地节点和海洋节点的时候直接跳过。 这样计数器就是最终岛屿的数量。</p><p>那么如何把节点陆地所能遍历到的陆地都标记上呢，就可以使用 DFS，BFS或者并查集</p><h2 id="深度优先dfs代码">深度优先DFS代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">direction = [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>],[-<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,-<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">graph, visited, x, y</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">  <span class="comment"># 注意，仅探索x,y的上、下、左、右相邻的区域</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        nextX = x + direction[i][<span class="number">0</span>]</span><br><span class="line">        nextY = y + direction[i][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> nextX&lt;<span class="number">0</span> <span class="keyword">or</span> nextX&gt;=<span class="built_in">len</span>(graph) <span class="keyword">or</span> nextY&lt;<span class="number">0</span> <span class="keyword">or</span> nextY &gt;= <span class="built_in">len</span>(graph[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> visited[nextX][nextY] == <span class="number">0</span> <span class="keyword">and</span> graph[nextX][nextY] == <span class="number">1</span>:</span><br><span class="line">            visited[nextX][nextY] = <span class="number">1</span></span><br><span class="line">            dfs(graph, visited, nextX, nextY)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">    table = []</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        table.append(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    visited = [[<span class="number">0</span>] * (m) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">if</span> visited[i][j] == <span class="number">0</span> <span class="keyword">and</span> table[i][j] == <span class="number">1</span>:</span><br><span class="line">                visited[i][j] == <span class="number">1</span></span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 把i,j附近相邻的区域（上、下、左、右相邻位置）全部标记为1（已经探索过）</span></span><br><span class="line">                dfs(table, visited, i, j)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>上面的dfs代码没有直接写终止条件，也可以直接写终止条件</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">direction = [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>],[-<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,-<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">graph, visited, x, y</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">  <span class="comment"># 表示 如果当前节点已经被访问或者本身不可达，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> visited[x][y] == <span class="number">1</span> <span class="keyword">or</span> graph[x][y] == <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 记录为访问过</span></span><br><span class="line">    visited[x][y] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment"># 注意，仅探索x,y的上、下、左、右相邻的区域</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        nextX = x + direction[i][<span class="number">0</span>]</span><br><span class="line">        nextY = y + direction[i][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> nextX&lt;<span class="number">0</span> <span class="keyword">or</span> nextX&gt;=<span class="built_in">len</span>(graph) <span class="keyword">or</span> nextY&lt;<span class="number">0</span> <span class="keyword">or</span> nextY &gt;= <span class="built_in">len</span>(graph[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        dfs(graph, visited, nextX, nextY)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">    table = []</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        table.append(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    visited = [[<span class="number">0</span>] * (m) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">if</span> visited[i][j] == <span class="number">0</span> <span class="keyword">and</span> table[i][j] == <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># visited[i][j] == 1， 注意这种先判断终止条件的写法不需要在前面将当前位置设置已经去过</span></span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 把i,j附近相邻的区域（上、下、左、右相邻位置）全部标记为1（已经探索过）</span></span><br><span class="line">                dfs(table, visited, i, j)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>在二叉树里，深度优先搜索和前、中、后序遍历可以对应上</p><p>而广度优先遍历则可以和层序遍历对应上</p><h2 id="广搜的过程">广搜的过程</h2><p>上面我们提过，BFS是一圈一圈的搜索过程，但具体是怎么一圈一圈来搜呢。</p><p>我们用一个方格地图，假如每次搜索的方向为 上下左右（不包含斜上方），那么给出一个start起始位置，那么BFS就是从四个方向走出第一步。</p><p><img src="https://file1.kamacoder.com/i/algo/20220825104505.png" alt="图一"></p><p>如果加上一个end终止位置，那么使用BFS的搜索过程如图所示：</p><p><img src="https://file1.kamacoder.com/i/algo/20220825102653.png" alt="图二"></p><p>我们从图中可以看出，从start起点开始，是一圈一圈，向外搜索，方格编号1为第一步遍历的节点，方格编号2为第二步遍历的节点，第四步的时候我们找到终止点end。</p><p>正是因为BFS一圈一圈的遍历方式，所以一旦遇到终止点，那么一定是一条最短路径。</p><p>而且地图还可以有障碍，如图所示：</p><p><img src="https://file1.kamacoder.com/i/algo/20220825103900.png" alt="图三"></p><p>在第五步，第六步 我只把关键的节点染色了，其他方向周边没有去染色，大家只要关注关键地方染色的逻辑就可以。</p><p>从图中可以看出，如果添加了障碍，我们是第六步才能走到end终点。</p><p>只要BFS只要搜到终点一定是一条最短路径，大家可以参考上面的图，自己再去模拟一下</p><h2 id="代码框架">代码框架</h2><p>大家应该好奇，这一圈一圈的搜索过程是怎么做到的，是放在什么容器里，才能这样去遍历。</p><p>很多网上的资料都是直接说用队列来实现。</p><p>其实，我们仅仅需要一个容器，能保存我们要遍历过的元素就可以，<strong>那么用队列，还是用栈，甚至用数组，都是可以的</strong>。</p><p><strong>用队列的话，就是保证每一圈都是一个方向去转，例如统一顺时针或者逆时针</strong>。</p><p>因为队列是先进先出，加入元素和弹出元素的顺序是没有改变的。</p><p><strong>如果用栈的话，就是第一圈顺时针遍历，第二圈逆时针遍历，第三圈有顺时针遍历</strong>。</p><p>因为栈是先进后出，加入元素和弹出元素的顺序改变了。</p><p>那么广搜需要注意 转圈搜索的顺序吗？ 不需要！</p><p>所以用队列，还是用栈都是可以的，但大家都习惯用队列了，<strong>所以下面的讲解用我也用队列来讲，只不过要给大家说清楚，并不是非要用队列，用栈也可以</strong>。</p><h2 id="广度优先bfs代码">广度优先BFS代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">direction = [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>],[-<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,-<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 广搜索用队列会方便一些，但使用栈也可以</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">graph, visited, x, y</span>):</span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">    que = deque()</span><br><span class="line">    que.append([x, y])</span><br><span class="line">    visited[x][y] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> que:</span><br><span class="line">        curX, curY = que.popleft()</span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> direction:</span><br><span class="line">            nextX = curX + i</span><br><span class="line">            nextY = curY + j</span><br><span class="line">            <span class="keyword">if</span> nextX&lt;<span class="number">0</span> <span class="keyword">or</span> nextX&gt;=<span class="built_in">len</span>(graph) <span class="keyword">or</span> nextY&lt;<span class="number">0</span> <span class="keyword">or</span> nextY &gt;= <span class="built_in">len</span>(graph[<span class="number">0</span>]):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> visited[nextX][nextY] == <span class="number">0</span> <span class="keyword">and</span> graph[nextX][nextY] == <span class="number">1</span>:</span><br><span class="line">                visited[nextX][nextY] = <span class="number">1</span></span><br><span class="line">                que.append([nextX, nextY])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">    table = []</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        table.append(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    visited = [[<span class="number">0</span>] * (m) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">if</span> visited[i][j] == <span class="number">0</span> <span class="keyword">and</span> table[i][j] == <span class="number">1</span>:</span><br><span class="line">                visited[i][j] == <span class="number">1</span></span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">                bfs(table, visited, i, j)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h1 id="100-岛屿的最大面积">100. 岛屿的最大面积</h1><p>题目描述</p><p>给定一个由 1（陆地）和 0（水）组成的矩阵，计算岛屿的最大面积。岛屿面积的计算方式为组成岛屿的陆地的总数。岛屿由水平方向或垂直方向上相邻的陆地连接而成，并且四周都是水域。你可以假设矩阵外均被水包围。</p><p>输入描述</p><p>第一行包含两个整数 N, M，表示矩阵的行数和列数。后续 N 行，每行包含 M 个数字，数字为 1 或者 0，表示岛屿的单元格。</p><p>输出描述</p><p>输出一个整数，表示岛屿的最大面积。如果不存在岛屿，则输出 0。</p><p>输入示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 1 0 0 0</span><br><span class="line">1 1 0 0 0</span><br><span class="line">0 0 1 0 0</span><br><span class="line">0 0 0 1 1</span><br></pre></td></tr></table></figure><p>输出示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>提示信息</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240412103942_51284.png" alt="img"></p><p><img src="https://kamacoder.com/upload/kamacoder.com/image/20240412/20240412103942_51284.png" alt="img"></p><p>样例输入中，岛屿的最大面积为 4。</p><p>数据范围：</p><p>1 &lt;= M, N &lt;= 50。</p><h2 id="深度优先思路">深度优先思路</h2><p>和上面题目很像，但这次是求每个小岛的面积，也那在对每个小岛开始遍历时，需要在dfs函数里统计相邻块的面积</p><p>就是搜索每个岛屿上“1”的数量，然后取一个最大的。</p><h2 id="深度优先dfs代码">深度优先DFS代码</h2><ul><li>时间复杂度O(m + n)</li><li>空间复杂度O(m + n)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">direction = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">graph, visited, x: <span class="built_in">int</span>, y: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    area = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> direction:</span><br><span class="line">        nextX = x + i</span><br><span class="line">        nextY = y + j</span><br><span class="line">        <span class="comment"># 如果下一个节点不可达，直接跳过</span></span><br><span class="line">        <span class="keyword">if</span> nextX &lt; <span class="number">0</span> <span class="keyword">or</span> nextY &lt; <span class="number">0</span> <span class="keyword">or</span> nextX &gt;= <span class="built_in">len</span>(graph) <span class="keyword">or</span> nextY &gt;= <span class="built_in">len</span>(graph[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> graph[nextX][nextY] == <span class="number">1</span> <span class="keyword">and</span> visited[nextX][nextY]== <span class="number">0</span>:</span><br><span class="line">            visited[nextX][nextY] = <span class="number">1</span></span><br><span class="line">            area += dfs(graph, visited, nextX, nextY)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> area</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    graph = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        graph.append(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line">    </span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    visited = [[<span class="number">0</span>] * m <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">if</span> graph[i][j] == <span class="number">1</span> <span class="keyword">and</span> visited[i][j] == <span class="number">0</span>:</span><br><span class="line">                visited[i][j] = <span class="number">1</span></span><br><span class="line">                <span class="comment"># 搜索每个岛屿上“1”的数量，然后取一个最大的。</span></span><br><span class="line">                res = <span class="built_in">max</span>(dfs(graph, visited, i, j), res)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="深度优先代码2">深度优先代码2</h2><ul><li>时间复杂度O(m + n)</li><li>空间复杂度O(m + n)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">direction = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs2</span>(<span class="params">graph, visited, x: <span class="built_in">int</span>, y: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">  <span class="comment"># 注意要写终止条件，并且返回0</span></span><br><span class="line">    <span class="keyword">if</span> graph[x][y] == <span class="number">0</span> <span class="keyword">or</span> visited[x][y] == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 单层逻辑</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 当前位置记录为已经去过</span></span><br><span class="line">    visited[x][y] = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 初始化面积为1</span></span><br><span class="line">    area = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> direction:</span><br><span class="line">        nextX = x + i</span><br><span class="line">        nextY = y + j</span><br><span class="line">        <span class="comment"># 如果越界则跳过</span></span><br><span class="line">        <span class="keyword">if</span> nextX &lt; <span class="number">0</span> <span class="keyword">or</span> nextY &lt; <span class="number">0</span> <span class="keyword">or</span> nextX &gt;= <span class="built_in">len</span>(graph) <span class="keyword">or</span> nextY &gt;= <span class="built_in">len</span>(graph[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># 将面积增加</span></span><br><span class="line">        area += dfs2(graph, visited, nextX, nextY)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> area</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    graph = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        graph.append(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line">    </span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    visited = [[<span class="number">0</span>] * m <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">if</span> graph[i][j] == <span class="number">1</span> <span class="keyword">and</span> visited[i][j] == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># visited[i][j] = 1 </span></span><br><span class="line">                <span class="comment"># 搜索每个岛屿上“1”的数量，然后取一个最大的。</span></span><br><span class="line">                res = <span class="built_in">max</span>(dfs2(graph, visited, i, j), res)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="广度优先代码">广度优先代码</h2><ul><li>时间复杂度O(m + n)</li><li>空间复杂度O(m + n)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">graph, visited, x: <span class="built_in">int</span>, y: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">    que = deque()</span><br><span class="line">    que.append([x, y])</span><br><span class="line"></span><br><span class="line">    area = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> que:</span><br><span class="line">        curX, curY = que.popleft()</span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> direction:</span><br><span class="line">            nextX = curX + i</span><br><span class="line">            nextY = curY + j</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> nextX &lt; <span class="number">0</span> <span class="keyword">or</span> nextY &lt; <span class="number">0</span> <span class="keyword">or</span> nextX &gt;= <span class="built_in">len</span>(graph) <span class="keyword">or</span> nextY &gt;= <span class="built_in">len</span>(graph[<span class="number">0</span>]):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> graph[nextX][nextY] == <span class="number">1</span> <span class="keyword">and</span> visited[nextX][nextY] == <span class="number">0</span>:</span><br><span class="line">                area += <span class="number">1</span></span><br><span class="line">                visited[nextX][nextY] = <span class="number">1</span></span><br><span class="line">                que.append([nextX,nextY])</span><br><span class="line">    <span class="keyword">return</span> area</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    graph = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        graph.append(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line">    </span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    visited = [[<span class="number">0</span>] * m <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">if</span> graph[i][j] == <span class="number">1</span> <span class="keyword">and</span> visited[i][j] == <span class="number">0</span>:</span><br><span class="line">                visited[i][j] = <span class="number">1</span></span><br><span class="line">                <span class="comment"># 搜索每个岛屿上“1”的数量，然后取一个最大的。</span></span><br><span class="line">                res = <span class="built_in">max</span>(bfs(graph, visited, i, j), res)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday51图论part02&quot;&gt;LeetCodeCampsDay51图论part02&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;包含深度优先搜索和广度优先搜索的基础代码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;99-岛屿数量&quot;&gt;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay50图论part01</title>
    <link href="https://blog.lthero.cn/2025/08/13/LeetCodeCampsDay50/"/>
    <id>https://blog.lthero.cn/2025/08/13/LeetCodeCampsDay50/</id>
    <published>2025-08-13T15:40:25.000Z</published>
    <updated>2025-08-23T06:28:08.817Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday50图论part01">LeetCodeCampsDay50图论part01</h1><blockquote><p>图论基础</p></blockquote><h1 id="图的基本概念">图的基本概念</h1><p>二维坐标中，两点可以连成线，多个点连成的线就构成了图。</p><p>当然图也可以就一个节点，甚至没有节点（空图）</p><h3 id="图的种类">图的种类</h3><p>整体上一般分为 有向图 和 无向图。</p><p>有向图是指 图中边是有方向的：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240510195737.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240510195737.png" alt="img"></p><p>无向图是指 图中边没有方向：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240510195451.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240510195451.png" alt="img"></p><p>加权有向图，就是图中边是有权值的，例如：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240510195821.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240510195821.png" alt="img"></p><p>加权无向图也是同理。</p><h3 id="度">度</h3><p>无向图中有几条边连接该节点，该节点就有几度。</p><p>例如，该无向图中，节点4的度为5，节点6的度为3。</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240511115029.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240511115029.png" alt="img"></p><p>在有向图中，每个节点有出度和入度。</p><p>出度：从该节点出发的边的个数。</p><p>入度：指向该节点边的个数。</p><p>例如，该有向图中，节点3的入度为2，出度为1，节点1的入度为0，出度为2。</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240511115235.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240511115235.png" alt="img"></p><h2 id="连通性">连通性</h2><p>在图中表示节点的连通情况，我们称之为连通性。</p><h3 id="连通图">连通图</h3><p>在无向图中，任何两个节点都是可以到达的，我们称之为连通图 ，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240511102351.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240511102351.png" alt="img"></p><p>如果有节点不能到达其他节点，则为非连通图，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240511102449.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240511102449.png" alt="img"></p><p>节点1 不能到达节点4。</p><h3 id="强连通图">强连通图</h3><p>在有向图中，任何两个节点是可以相互到达的，我们称之为 强连通图。</p><p>这里有录友可能想，这和无向图中的连通图有什么区别，不是一样的吗？</p><p>我们来看这个有向图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240511104531.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240511104531.png" alt="img"></p><p>这个图是强连通图吗？</p><p>初步一看，好像这节点都连着呢，但这不是强连通图，节点1 可以到节点5，但节点5 不能到 节点1 。</p><p>强连通图是在有向图中<strong>任何两个节点是可以相互到达</strong></p><p>下面这个有向图才是强连通图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240511113101.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240511113101.png" alt="img"></p><h3 id="连通分量">连通分量</h3><p>在无向图中的极大连通子图称之为该图的一个连通分量。</p><p>只看概念大家可能不理解，我来画个图：</p><p><img src="https://file1.kamacoder.com/i/algo/20240511111559.png" alt="img"></p><p>该无向图中 节点1、节点2、节点5 构成的子图就是 该无向图中的一个连通分量，该子图所有节点都是相互可达到的。</p><p>同理，节点3、节点4、节点6 构成的子图 也是该无向图中的一个连通分量。</p><p>那么无向图中 节点3 、节点4 构成的子图 是该无向图的联通分量吗？</p><p>不是！</p><p>因为必须是极大联通子图才能是连通分量，所以 必须是节点3、节点4、节点6 构成的子图才是连通分量。</p><p>在图论中，连通分量是一个很重要的概念，例如岛屿问题（后面章节会有专门讲解）其实就是求连通分量。</p><h3 id="强连通分量"><a href="https://www.programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F">#</a>强连通分量</h3><p>在有向图中极大强连通子图称之为该图的强连通分量。</p><p>如图：</p><p><img src="https://file1.kamacoder.com/i/algo/20240511112951.png" alt="img"></p><p>节点1、节点2、节点3、节点4、节点5 构成的子图是强连通分量，因为这是强连通图，也是极大图。</p><p>节点6、节点7、节点8 构成的子图 不是强连通分量，因为这不是强连通图，节点8 不能达到节点6。</p><p>节点1、节点2、节点5 构成的子图 也不是 强连通分量，因为这不是极大图。</p><h2 id="图的构造"><a href="https://www.programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%9B%BE%E7%9A%84%E6%9E%84%E9%80%A0">#</a>图的构造</h2><p>我们如何用代码来表示一个图呢？</p><p>一般使用邻接表、邻接矩阵 或者用类来表示。</p><p>主要是 朴素存储、邻接表和邻接矩阵。</p><p>关于朴素存储，这是我自创的名字，因为这种存储方式，就是将所有边存下来。</p><p>例如图：</p><p><img src="https://file1.kamacoder.com/i/algo/20240511112951.png" alt="img"></p><p>图中有8条边，我们就定义 8 * 2的数组，即有n条边就申请n * 2，这么大的数组：</p><p><img src="https://file1.kamacoder.com/i/algo/20250110114348.png" alt="img"></p><p>数组第一行：6 7，就表示节点6 指向 节点7，以此类推。</p><p>当然可以不用数组，用map，或者用 类 到可以表示出 这种边的关系。</p><p>这种表示方式的好处就是直观，把节点与节点之间关系很容易展现出来。</p><p>但如果我们想知道 节点1 和 节点6 是否相连，我们就需要把存储空间都枚举一遍才行。</p><p>这是明显的缺点，同时，我们在深搜和广搜的时候，都不会使用这种存储方式。</p><p>因为 搜索中，需要知道 节点与其他节点的链接情况，而这种朴素存储，都需要全部枚举才知道链接情况。</p><p>在图论章节的后面文章讲解中，我会举例说明的。大家先有个印象。</p><h3 id="邻接矩阵"><a href="https://www.programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5">#</a>邻接矩阵</h3><p>邻接矩阵 使用 二维数组来表示图结构。 邻接矩阵是从节点的角度来表示图，有多少节点就申请多大的二维数组。</p><p>例如： grid[2][5] = 6，表示 节点 2 连接 节点5 为有向图，节点2 指向 节点5，边的权值为6。</p><p>如果想表示无向图，即：grid[2][5] = 6，grid[5][2] = 6，表示节点2 与 节点5 相互连通，权值为6。</p><p>如图：</p><p><img src="https://file1.kamacoder.com/i/algo/20240222110025.png" alt="img"></p><p>在一个 n （节点数）为8 的图中，就需要申请 8 * 8 这么大的空间。</p><p>图中有一条双向边，即：grid[2][5] = 6，grid[5][2] = 6</p><p>这种表达方式（邻接矩阵） 在 边少，节点多的情况下，会导致申请过大的二维数组，造成空间浪费。</p><p>而且在寻找节点连接情况的时候，需要遍历整个矩阵，即 n * n 的时间复杂度，同样造成时间浪费。</p><p>邻接矩阵的优点：</p><ul><li>表达方式简单，易于理解</li><li>检查任意两个顶点间是否存在边的操作非常快</li><li>适合稠密图，在边数接近顶点数平方的图中，邻接矩阵是一种空间效率较高的表示方法。</li></ul><p>缺点：</p><ul><li>遇到稀疏图，会导致申请过大的二维数组造成空间浪费 且遍历 边 的时候需要遍历整个n * n矩阵，造成时间浪费</li></ul><h3 id="邻接表"><a href="https://www.programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E9%82%BB%E6%8E%A5%E8%A1%A8">#</a>邻接表</h3><p>邻接表 使用 数组 + 链表的方式来表示。 邻接表是从边的数量来表示图，有多少边 才会申请对应大小的链表。</p><p>邻接表的构造如图：</p><p><img src="https://file1.kamacoder.com/i/algo/20240223103713.png" alt="img"></p><p>这里表达的图是：</p><ul><li>节点1 指向 节点3 和 节点5</li><li>节点2 指向 节点4、节点3、节点5</li><li>节点3 指向 节点4</li><li>节点4指向节点1</li></ul><p>有多少边 邻接表才会申请多少个对应的链表节点。</p><p>从图中可以直观看出 使用 数组 + 链表 来表达 边的连接情况 。</p><p>邻接表的优点：</p><ul><li>对于稀疏图的存储，只需要存储边，空间利用率高</li><li>遍历节点连接情况相对容易</li></ul><p>缺点：</p><ul><li>检查任意两个节点间是否存在边，效率相对低，需要 O(V)时间，V表示某节点连接其他节点的数量。</li><li>实现相对复杂，不易理解</li></ul><p><strong>以上大家可能理解比较模糊，没关系</strong>，因为大家还没做过图论的题目，对于图的表达没有概念。</p><p>这里我先不给出具体的实现代码，大家先有个初步印象，在后面算法题实战中，我还会讲到具体代码实现，等带大家做算法题，写了代码之后，自然就理解了。</p><h2 id="图的遍历方式"><a href="https://www.programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F">#</a>图的遍历方式</h2><p>图的遍历方式基本是两大类：</p><ul><li>深度优先搜索（dfs）</li><li>广度优先搜索（bfs）</li></ul><p>在讲解二叉树章节的时候，其实就已经讲过这两种遍历方式。</p><p>二叉树的递归遍历，是dfs 在二叉树上的遍历方式。</p><p>二叉树的层序遍历，是bfs 在二叉树上的遍历方式。</p><p>dfs 和 bfs 一种搜索算法，可以在不同的数据结构上进行搜索，在二叉树章节里是在二叉树这样的数据结构上搜索。</p><p>而在图论章节，则是在图（邻接表或邻接矩阵）上进行搜索</p><h1 id="797-所有可能的路径">797. 所有可能的路径</h1><p><a href="https://leetcode.cn/problems/all-paths-from-source-to-target/">https://leetcode.cn/problems/all-paths-from-source-to-target/</a></p><p>给你一个有 <code>n</code> 个节点的 <strong>有向无环图（DAG）</strong>，请你找出从节点 <code>0</code> 到节点 <code>n-1</code> 的所有路径并输出（<strong>不要求按特定顺序</strong>）</p><p><code>graph[i]</code> 是一个从节点 <code>i</code> 可以访问的所有节点的列表（即从节点 <code>i</code> 到节点 <code>graph[i][j]</code>存在一条有向边）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/28/all_1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：graph = [[1,2],[3],[3],[]]</span><br><span class="line">输出：[[0,1,3],[0,2,3]]</span><br><span class="line">解释：有两条路径 0 -&gt; 1 -&gt; 3 和 0 -&gt; 2 -&gt; 3</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/28/all_2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：graph = [[4,3,1],[3,2,4],[3],[4],[]]</span><br><span class="line">输出：[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == graph.length</code></li><li><code>2 &lt;= n &lt;= 15</code></li><li><code>0 &lt;= graph[i][j] &lt; n</code></li><li><code>graph[i][j] != i</code>（即不存在自环）</li><li><code>graph[i]</code> 中的所有元素 <strong>互不相同</strong></li><li>保证输入为 <strong>有向无环图（DAG）</strong></li></ul><h2 id="邻接矩阵的图代码">邻接矩阵的图代码</h2><p>因为leetcode给的输入是邻接表，为了使用邻接矩阵作为输入，需要使用ACM模式（即自己处理输入数据）</p><ul><li>时间复杂度O(N)</li><li>空间复杂度O(N)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">graph, x: <span class="built_in">int</span>, n: <span class="built_in">int</span>, path: <span class="built_in">list</span>, result: <span class="built_in">list</span></span>):</span><br><span class="line">    <span class="comment"># 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> x == n:</span><br><span class="line">        <span class="comment"># 这里需要使用path的copy版，或者使用path.copy()</span></span><br><span class="line">        result.append(path.copy())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 表示x起点，i终点</span></span><br><span class="line">            <span class="keyword">if</span> graph[x][i] == <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 遍历下一个</span></span><br><span class="line">                path.append(i)</span><br><span class="line">                dfs(graph, i, n, path, result)</span><br><span class="line">                <span class="comment"># 回溯</span></span><br><span class="line">                path.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">    graph = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="comment"># 读取起点、终点</span></span><br><span class="line">        s, t = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        <span class="comment"># 设置起点、终点</span></span><br><span class="line">        graph[s][t] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    result = <span class="built_in">list</span>()</span><br><span class="line">    dfs(graph, <span class="number">1</span>, n, [<span class="number">1</span>], result)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> result:</span><br><span class="line">        <span class="built_in">print</span>(-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> path <span class="keyword">in</span> result:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, path)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="邻接表图代码">邻接表图代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(N)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.res = <span class="built_in">list</span>()</span><br><span class="line">        self.path = [<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self, graph, x: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="comment"># 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> x == n:</span><br><span class="line">            self.res.append(self.path.copy())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> graph[x]:</span><br><span class="line">                self.path.append(i)</span><br><span class="line">                self.dfs(graph, i, n)</span><br><span class="line">                self.path.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">allPathsSourceTarget</span>(<span class="params">self, graph: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        n = <span class="built_in">len</span>(graph)</span><br><span class="line">        self.dfs(graph, <span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday50图论part01&quot;&gt;LeetCodeCampsDay50图论part01&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;图论基础&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;图的基本概念&quot;&gt;图的基本概念&lt;/h1&gt;
&lt;p&gt;二维</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay49单调栈part02</title>
    <link href="https://blog.lthero.cn/2025/08/12/LeetCodeCampsDay49/"/>
    <id>https://blog.lthero.cn/2025/08/12/LeetCodeCampsDay49/</id>
    <published>2025-08-12T06:49:03.000Z</published>
    <updated>2025-08-12T08:22:37.246Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday49单调栈part02">LeetCodeCampsDay49单调栈part02</h1><blockquote></blockquote><h1 id="42-接雨水">42. 接雨水</h1><p><a href="https://leetcode.cn/problems/trapping-rain-water/">https://leetcode.cn/problems/trapping-rain-water/</a></p><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出：6</span><br><span class="line">解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [4,2,0,3,2,5]</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><code>1 &lt;= n &lt;= 2 * 104</code></li><li><code>0 &lt;= height[i] &lt;= 105</code></li></ul><h2 id="单调栈思路">单调栈思路</h2><p>和使用双指针按列求解不同，使用单调栈需要按行求解</p><ol><li>首先单调栈是按照行方向来计算雨水，如图：</li></ol><p><img src="https://cdn.lthero.cn/post_images/course/ML20210223092629946.png" alt="42.接雨水2"></p><p><img src="https://file1.kamacoder.com/i/algo/20210223092629946.png" alt="42.接雨水2"></p><p>知道这一点，后面的就可以理解了。</p><ol><li>使用单调栈内元素的顺序</li></ol><p>从大到小还是从小到大呢？</p><p>从栈头（元素从栈头弹出）到栈底的顺序应该是从小到大的顺序。</p><p>因为一旦发现添加的柱子高度大于栈头元素了，此时就出现凹槽了，栈头元素就是凹槽底部的柱子，栈头第二个元素就是凹槽左边的柱子，而添加的元素就是凹槽右边的柱子。</p><p>如图：</p><p><img src="https://file1.kamacoder.com/i/algo/2021022309321229.png" alt="42.接雨水4"></p><p>关于单调栈的顺序给大家一个总结： <a href="https://programmercarl.com/0739.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.html">739. 每日温度</a>中求一个元素右边第一个更大元素，单调栈就是递增的，<a href="https://programmercarl.com/0084.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.html">84.柱状图中最大的矩形</a>求一个元素右边第一个更小元素，单调栈就是递减的。</p><ol><li>遇到相同高度的柱子怎么办。</li></ol><p>遇到相同的元素，更新栈内下标，就是将栈里元素（旧下标）弹出，将新元素（新下标）加入栈中。</p><p>例如 5 5 1 3 这种情况。如果添加第二个5的时候就应该将第一个5的下标弹出，把第二个5添加到栈中。</p><p><strong>因为我们要求宽度的时候 如果遇到相同高度的柱子，需要使用最右边的柱子来计算宽度</strong>。</p><p>如图所示：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20210223094619398.png" alt="42.接雨水5"></p><p><img src="https://file1.kamacoder.com/i/algo/20210223094619398.png" alt="42.接雨水5"></p><ol><li>栈里要保存什么数值</li></ol><p>使用单调栈，也是通过 长 * 宽 来计算雨水面积的。</p><p>长就是通过柱子的高度来计算，宽是通过柱子之间的下标来计算，</p><p>那么栈里有没有必要存一个pair&lt;int, int&gt;类型的元素，保存柱子的高度和下标呢。</p><p>其实不用，栈里就存放下标就行，想要知道对应的高度，通过height[stack.top()] 就知道弹出的下标对应的高度了。</p><p>所以栈的定义如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="built_in">int</span>&gt; st; <span class="comment"># 存着下标，计算的时候用下标对应的柱子高度</span></span><br></pre></td></tr></table></figure><p>明确了如上几点，我们再来看处理逻辑。</p><h4 id="单调栈处理逻辑">单调栈处理逻辑</h4><p>以下操作过程其实和 <a href="https://programmercarl.com/0739.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.html">739. 每日温度</a>也是一样的，建议先做 <a href="https://programmercarl.com/0739.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.html">739. 每日温度</a>。</p><p>以下逻辑主要就是三种情况</p><ul><li>情况一：当前遍历的元素（柱子）高度小于栈顶元素的高度 height[i] &lt; height[st.top()]</li><li>情况二：当前遍历的元素（柱子）高度等于栈顶元素的高度 height[i] == height[st.top()]</li><li>情况三：当前遍历的元素（柱子）高度大于栈顶元素的高度 height[i] &gt; height[st.top()]</li></ul><p>先将下标0的柱子加入到栈中，<code>st.push(0);</code>。 栈中存放我们遍历过的元素，所以先将下标0加进来。</p><p>然后开始从下标1开始遍历所有的柱子，<code>for (int i = 1; i &lt; height.size(); i++)</code>。</p><p>如果当前遍历的元素（柱子）高度小于栈顶元素的高度，就把这个元素加入栈中，因为栈里本来就要保持从小到大的顺序（从栈头到栈底）。</p><p>代码如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (height[i] &lt; height[st.top()])  st.push(i);</span><br></pre></td></tr></table></figure><p>如果当前遍历的元素（柱子）高度等于栈顶元素的高度，要跟更新栈顶元素，因为遇到相相同高度的柱子，需要使用最右边的柱子来计算宽度。</p><p>代码如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (height[i] == height[st.top()]) &#123; // 例如 5 5 1 7 这种情况</span><br><span class="line">  st.pop();</span><br><span class="line">  st.push(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前遍历的元素（柱子）高度大于栈顶元素的高度，此时就出现凹槽了，如图所示：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML2021022309321229-20230310123027977.png" alt="42.接雨水4"></p><p><img src="https://file1.kamacoder.com/i/algo/2021022309321229-20230310123027977.png" alt="42.接雨水4"></p><p>取栈顶元素，将栈顶元素弹出，这个就是凹槽的底部，也就是中间位置，下标记为mid，对应的高度为height[mid]（就是图中的高度1）。</p><p>此时的栈顶元素st.top()，就是凹槽的左边位置，下标为st.top()，对应的高度为height[st.top()]（就是图中的高度2）。</p><p>当前遍历的元素i，就是凹槽右边的位置，下标为i，对应的高度为height[i]（就是图中的高度3）。</p><p>此时大家应该可以发现其实就是<strong>栈顶和栈顶的下一个元素以及要入栈的元素，三个元素来接水！</strong></p><p>那么雨水高度是 min(凹槽左边高度, 凹槽右边高度) - 凹槽底部高度，代码为：<code>int h = min(height[st.top()], height[i]) - height[mid];</code></p><p>雨水的宽度是 凹槽右边的下标 - 凹槽左边的下标 - 1（因为只求中间宽度），代码为：<code>int w = i - st.top() - 1 ;</code></p><p>当前凹槽雨水的体积就是：<code>h * w</code>。</p><h2 id="单调栈代码">单调栈代码</h2><ul><li>时间复杂度O(N^2）</li><li>空间复杂度O(N)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        stack = <span class="built_in">list</span>()</span><br><span class="line">        stack.append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        L = <span class="built_in">len</span>(height)</span><br><span class="line">        sumOfRain = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L):</span><br><span class="line">            <span class="keyword">if</span> height[i] &lt; height[stack[-<span class="number">1</span>]]:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> height[i] == height[stack[-<span class="number">1</span>]]:</span><br><span class="line">                    stack.pop()</span><br><span class="line">                    stack.append(i)</span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> height[i] &gt; height[stack[-<span class="number">1</span>]]:</span><br><span class="line">                    j = stack.pop()</span><br><span class="line">                    <span class="keyword">if</span> stack:</span><br><span class="line">                        h = <span class="built_in">min</span>(height[stack[-<span class="number">1</span>]], height[i]) - height[j]</span><br><span class="line">                        w = i - stack[-<span class="number">1</span>] - <span class="number">1</span></span><br><span class="line">                        sumOfRain += h * w</span><br><span class="line">                stack.append(i)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sumOfRain</span><br></pre></td></tr></table></figure><h1 id="84-柱状图中最大的矩形">84. 柱状图中最大的矩形</h1><p><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">https://leetcode.cn/problems/largest-rectangle-in-histogram/</a></p><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：heights = [2,1,5,6,2,3]</span><br><span class="line">输出：10</span><br><span class="line">解释：最大的矩形为图中红色区域，面积为 10</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： heights = [2,4]</span><br><span class="line">输出： 4</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= heights.length &lt;=105</code></li><li><code>0 &lt;= heights[i] &lt;= 104</code></li></ul><h2 id="单调栈思路">单调栈思路</h2><h3 id="题目分析">题目分析</h3><p>本题是要找每个柱子左右两边第一个小于该柱子的柱子，所以从栈头（元素从栈头弹出）到栈底的顺序应该是从大到小的顺序！</p><p>我来举一个例子，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20230221165730.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20230221165730.png" alt="img"></p><p>只有栈里从大到小的顺序，才能保证栈顶元素找到左右两边第一个小于栈顶元素的柱子。</p><p>所以本题单调栈的顺序正好与接雨水反过来。</p><p>此时大家应该可以发现其实就是<strong>栈顶和栈顶的下一个元素以及要入栈的三个元素组成了我们要求最大面积的高度和宽度</strong></p><p>首先来说末尾为什么要加元素0？</p><p>如果数组本身就是升序的，例如[2,4,6,8]，那么入栈之后 都是单调递减，一直都没有走 情况三 计算结果的哪一步，所以最后输出的就是0了。 如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20230221163936.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20230221163936.png" alt="img"></p><p>那么结尾加一个0，就会让栈里的所有元素，走到情况三的逻辑。</p><p>开头为什么要加元素0？</p><p>如果数组本身是降序的，例如 [8,6,4,2]，在 8 入栈后，6 开始与8 进行比较，此时我们得到 mid（8），right（6），但是得不到 left。</p><p>（mid、left，right 都是对应版本一里的逻辑）</p><p>因为 将 8 弹出之后，栈里没有元素了，那么为了避免空栈取值，直接跳过了计算结果的逻辑。</p><p>之后又将6 加入栈（此时8已经弹出了），然后 就是 4 与 栈口元素 6 进行比较，周而复始，那么计算的最后结果result就是0。 如图所示：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20230221164533.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20230221164533.png" alt="img"></p><p>所以我们需要在 height数组前后各加一个元素0。</p><h2 id="单调栈代码">单调栈代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestRectangleArea</span>(<span class="params">self, heights: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        stack = <span class="built_in">list</span>()</span><br><span class="line">        stack.append(<span class="number">0</span>)</span><br><span class="line">        heights.insert(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        heights.append(<span class="number">0</span>)</span><br><span class="line">        L = <span class="built_in">len</span>(heights)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L):</span><br><span class="line">            <span class="keyword">if</span> heights[i] &gt; heights[stack[-<span class="number">1</span>]]:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">elif</span> heights[i] == heights[stack[-<span class="number">1</span>]]:</span><br><span class="line">                stack.pop()</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">while</span> stack  <span class="keyword">and</span> heights[i] &lt; heights[stack[-<span class="number">1</span>]]:</span><br><span class="line">                    mid = stack.pop()</span><br><span class="line">                    <span class="keyword">if</span> stack:</span><br><span class="line">                        left = stack[-<span class="number">1</span>]</span><br><span class="line">                        h = heights[mid]</span><br><span class="line">                        </span><br><span class="line">                        w = i - left - <span class="number">1</span></span><br><span class="line">                        res = <span class="built_in">max</span>(res, h * w)</span><br><span class="line">                stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday49单调栈part02&quot;&gt;LeetCodeCampsDay49单调栈part02&lt;/h1&gt;
&lt;blockquote&gt;&lt;/blockquote&gt;
&lt;h1 id=&quot;42-接雨水&quot;&gt;42. 接雨水&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;htt</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay48单调栈part01</title>
    <link href="https://blog.lthero.cn/2025/08/11/LeetCodeCampsDay48/"/>
    <id>https://blog.lthero.cn/2025/08/11/LeetCodeCampsDay48/</id>
    <published>2025-08-11T09:21:13.000Z</published>
    <updated>2025-08-11T14:36:59.904Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday48单调栈part01">LeetCodeCampsDay48单调栈part01</h1><blockquote><p>初识单调栈</p></blockquote><h1 id="单调栈">单调栈</h1><blockquote><p>什么时候用单调栈呢？</p></blockquote><p><strong>通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了</strong>。时间复杂度为O(n)。</p><p>如果暴力求解，比如两层for循环，时间复杂度是O(n^2)</p><blockquote><p>那么单调栈的原理是什么呢？为什么时间复杂度是O(n)就可以找到每一个元素的右边第一个比它大的元素位置呢？</p></blockquote><p><strong>单调栈的本质是空间换时间</strong>，因为在遍历的过程中需要用一个栈来记录右边第一个比当前元素高的元素，优点是整个数组只需要遍历一次。</p><p><strong>更直白来说，就是用一个栈来记录我们遍历过的元素</strong>，因为我们遍历数组的时候，我们不知道之前都遍历了哪些元素，以至于遍历一个元素找不到是不是之前遍历过一个更小的，所以我们需要用一个容器（这里用单调栈）来记录我们遍历过的元素。</p><p>在使用单调栈的时候首先要明确如下几点：</p><ol><li>单调栈里存放的元素是什么？</li></ol><p>单调栈里<code>只需要存放元素的下标i就可以了</code>，如果需要使用对应的元素，直接<code>T[i]</code>就可以获取。</p><ol><li>单调栈里元素是递增呢？ 还是递减呢？</li></ol><p><strong>注意以下讲解中，顺序的描述为 从栈头到栈底的顺序</strong>，因为单纯的说从左到右或者从前到后，不说栈头朝哪个方向的话，大家一定比较懵。</p><p>使用单调栈主要有三个判断条件。</p><ul><li>当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况</li><li>当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况</li><li>当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况</li></ul><p><strong>把这三种情况分析清楚了，也就理解透彻了</strong>。</p><p>接下来我们用temperatures = [73, 74, 75, 71, 71, 72, 76, 73]为例来逐步分析，输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p><hr><p>首先先将第一个遍历元素加入单调栈</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20210219124434172.jpg" alt="739.每日温度1"></p><p><img src="https://file1.kamacoder.com/i/algo/20210219124434172.jpg" alt="739.每日温度1"></p><hr><p>加入T[1] = 74，因为T[1] &gt; T[0]（当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况）。</p><p>我们要保持一个递增单调栈（从栈头到栈底），所以将T[0]弹出，T[1]加入，此时result数组可以记录了，result[0] = 1，即T[0]右面第一个比T[0]大的元素是T[1]。</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20210219124504299.jpg" alt="739.每日温度2"></p><p><img src="https://file1.kamacoder.com/i/algo/20210219124504299.jpg" alt="739.每日温度2"></p><hr><p>加入T[2]，同理，T[1]弹出</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20210219124527361.jpg" alt="739.每日温度3"></p><p><img src="https://file1.kamacoder.com/i/algo/20210219124527361.jpg" alt="739.每日温度3"></p><hr><p>加入T[3]，T[3] &lt; T[2] （当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况），加T[3]加入单调栈。</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20210219124610761.jpg" alt="739.每日温度4"></p><p><img src="https://file1.kamacoder.com/i/algo/20210219124610761.jpg" alt="739.每日温度4"></p><hr><p>加入T[4]，T[4] == T[3] （当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况），此时依然要加入栈，不用计算距离，因为我们要求的是右面第一个大于本元素的位置，而不是大于等于！</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20210219124633444.jpg" alt="739.每日温度5"></p><p><img src="https://file1.kamacoder.com/i/algo/20210219124633444.jpg" alt="739.每日温度5"></p><hr><p>加入T[5]，T[5] &gt; T[4] （当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况），将T[4]弹出，同时计算距离，更新result</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20210219124700567.jpg" alt="739.每日温度6"></p><p><img src="https://file1.kamacoder.com/i/algo/20210219124700567.jpg" alt="739.每日温度6"></p><hr><p>T[4]弹出之后， T[5] &gt; T[3] （当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况），将T[3]继续弹出，同时计算距离，更新result</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20210219124726613.jpg" alt="739.每日温度7"></p><p><img src="https://file1.kamacoder.com/i/algo/20210219124726613.jpg" alt="739.每日温度7"></p><hr><p>直到发现T[5]小于T[st.top()]，终止弹出，将T[5]加入单调栈</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20210219124807715.jpg" alt="739.每日温度8"></p><p><img src="https://file1.kamacoder.com/i/algo/20210219124807715.jpg" alt="739.每日温度8"></p><hr><p>加入T[6]，同理，需要将栈里的T[5]，T[2]弹出</p><p><img src="https://cdn.lthero.cn/post_images/course/ML2021021912483374.jpg" alt="739.每日温度9"></p><p><img src="https://file1.kamacoder.com/i/algo/2021021912483374.jpg" alt="739.每日温度9"></p><hr><p>同理，继续弹出</p><p><img src="https://cdn.lthero.cn/post_images/course/ML2021021912490098.jpg" alt="739.每日温度10"></p><p><img src="https://file1.kamacoder.com/i/algo/2021021912490098.jpg" alt="739.每日温度10"></p><hr><p>此时栈里只剩下了T[6]</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20210219124930156.jpg" alt="739.每日温度11"></p><p><img src="https://file1.kamacoder.com/i/algo/20210219124930156.jpg" alt="739.每日温度11"></p><hr><p>加入T[7]， T[7] &lt; T[6] 直接入栈，这就是最后的情况，result数组也更新完了。</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20210219124957216.jpg" alt="739.每日温度12"></p><p><img src="https://file1.kamacoder.com/i/algo/20210219124957216.jpg" alt="739.每日温度12"></p><p>此时有同学可能就疑惑了，那result[6] , result[7]怎么没更新啊，元素也一直在栈里。</p><p>其实定义result数组的时候，就应该直接初始化为0，如果result没有更新，说明这个元素右面没有更大的了，也就是为0。</p><p>以上在图解的时候，已经把，这三种情况都做了详细的分析。</p><ul><li>情况一：当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况</li><li>情况二：当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况</li><li>情况三：当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况</li></ul><p>通过以上过程，大家可以自己再模拟一遍，就会发现：只有单调栈递增（从栈口到栈底顺序），就是求右边第一个比自己大的，单调栈递减的话，就是求右边第一个比自己小的。</p><h1 id="739-每日温度">739. 每日温度</h1><p><a href="https://leetcode.cn/problems/daily-temperatures/">https://leetcode.cn/problems/daily-temperatures/</a></p><p>给定一个整数数组 <code>temperatures</code> ，表示每天的温度，返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是指对于第 <code>i</code> 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: temperatures = [73,74,75,71,69,72,76,73]</span><br><span class="line">输出: [1,1,4,2,1,1,0,0]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: temperatures = [30,40,50,60]</span><br><span class="line">输出: [1,1,1,0]</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: temperatures = [30,60,90]</span><br><span class="line">输出: [1,1,0]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= temperatures.length &lt;= 105</code></li><li><code>30 &lt;= temperatures[i] &lt;= 100</code></li></ul><h2 id="单调栈思路">单调栈思路</h2><p>使用单调栈，栈底元素是最大的</p><p>先将第一个元素入栈，栈内记录这个元素的下标</p><p>从第二个元素开始遍历，如果num[i]小于栈Top元素则直接入栈</p><p>如果num[i]大于栈Top元素则将栈Top弹出，并且res[j]=i-j（假设j为栈Top元素的值)，表示第j天右边第一个更大的元素是（i-j)天后</p><h2 id="单调栈代码">单调栈代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dailyTemperatures</span>(<span class="params">self, temperatures: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]: </span><br><span class="line">        stack = <span class="built_in">list</span>()</span><br><span class="line">        stack.append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        L = <span class="built_in">len</span>(temperatures)</span><br><span class="line">        res = [<span class="number">0</span>] * L</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L):</span><br><span class="line">            <span class="comment"># 如果temper[i]更小，直接添加进入</span></span><br><span class="line">            <span class="keyword">if</span> temperatures[i] &lt;= temperatures[stack[-<span class="number">1</span>]]:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果temper[i]更大，先将栈中小于temper[i]的都弹出来</span></span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> temperatures[i] &gt; temperatures[stack[-<span class="number">1</span>]]:</span><br><span class="line">                    j = stack.pop()</span><br><span class="line">                    res[j] = i - j</span><br><span class="line">                stack.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="496-下一个更大元素-i">496. 下一个更大元素 I</h1><p><a href="https://leetcode.cn/problems/next-greater-element-i/">https://leetcode.cn/problems/next-greater-element-i/</a></p><p><code>nums1</code> 中数字 <code>x</code> 的 <strong>下一个更大元素</strong> 是指 <code>x</code> 在 <code>nums2</code> 中对应位置 <strong>右侧</strong> 的 <strong>第一个</strong> 比 <code>x</code> 大的元素。</p><p>给你两个 <strong>没有重复元素</strong> 的数组 <code>nums1</code> 和 <code>nums2</code> ，下标从 <strong>0</strong> 开始计数，其中<code>nums1</code> 是 <code>nums2</code> 的子集。</p><p>对于每个 <code>0 &lt;= i &lt; nums1.length</code> ，找出满足 <code>nums1[i] == nums2[j]</code> 的下标 <code>j</code> ，并且在 <code>nums2</code> 确定 <code>nums2[j]</code> 的 <strong>下一个更大元素</strong> 。如果不存在下一个更大元素，那么本次查询的答案是 <code>-1</code> 。</p><p>返回一个长度为 <code>nums1.length</code> 的数组 <code>ans</code> 作为答案，满足 <code>ans[i]</code> 是如上所述的 <strong>下一个更大元素</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [4,1,2], nums2 = [1,3,4,2].</span><br><span class="line">输出：[-1,3,-1]</span><br><span class="line">解释：nums1 中每个值的下一个更大元素如下所述：</span><br><span class="line">- 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。</span><br><span class="line">- 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。</span><br><span class="line">- 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [2,4], nums2 = [1,2,3,4].</span><br><span class="line">输出：[3,-1]</span><br><span class="line">解释：nums1 中每个值的下一个更大元素如下所述：</span><br><span class="line">- 2 ，用加粗斜体标识，nums2 = [1,2,3,4]。下一个更大元素是 3 。</span><br><span class="line">- 4 ，用加粗斜体标识，nums2 = [1,2,3,4]。不存在下一个更大元素，所以答案是 -1 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000</code></li><li><code>0 &lt;= nums1[i], nums2[i] &lt;= 104</code></li><li><code>nums1</code>和<code>nums2</code>中所有整数 <strong>互不相同</strong></li><li><code>nums1</code> 中的所有整数同样出现在 <code>nums2</code> 中</li></ul><p>**进阶：**你可以设计一个时间复杂度为 <code>O(nums1.length + nums2.length)</code> 的解决方案吗？</p><h2 id="单调栈思路">单调栈思路</h2><p>线索1、nums2里所有数字不同</p><p>线索2、nums1是nums2子集</p><p>问题可以变成：先求nums2里的每个元素的下一更大元素（使用单调栈）</p><p>再想办法把nums1和nums2映射，可以考虑桶排序（因为本题目的数字范围不大），如果数字范围大，则需要使用map进行映射</p><h2 id="单调栈代码-普通">单调栈代码（普通）</h2><ul><li>时间复杂度O(N * M)</li><li>空间复杂度O(M)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextGreaterElement</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        stack = <span class="built_in">list</span>()</span><br><span class="line">        stack.append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        L2 = <span class="built_in">len</span>(nums2)</span><br><span class="line">        biggerNums2 = [-<span class="number">1</span>] * <span class="number">10000</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L2):</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> nums2[i] &lt;= nums2[stack[-<span class="number">1</span>]]:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> nums2[stack[-<span class="number">1</span>]] &lt; nums2[i]:</span><br><span class="line">                    j = stack.pop()</span><br><span class="line">                    biggerNums2[nums2[j]] = nums2[i]</span><br><span class="line">                stack.append(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">            res.append(biggerNums2[i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>或者使用python自带的index函数，直接调用nums1.index(nums2[stack[-1]])</p><h2 id="单调栈代码-优化">单调栈代码（优化）</h2><ul><li>时间复杂度O(N * M)</li><li>空间复杂度O(M)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextGreaterElement</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        stack = <span class="built_in">list</span>()</span><br><span class="line">        stack.append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        L2 = <span class="built_in">len</span>(nums2)</span><br><span class="line">        <span class="comment"># 默认值都为-1</span></span><br><span class="line">        res = [-<span class="number">1</span>] * <span class="built_in">len</span>(nums1)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L2):</span><br><span class="line">            <span class="comment"># 如果新数字小于栈顶值，就无脑添加进来</span></span><br><span class="line">            <span class="keyword">if</span> nums2[i] &lt;= nums2[stack[-<span class="number">1</span>]]:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> nums2[stack[-<span class="number">1</span>]] &lt; nums2[i]:</span><br><span class="line">                    <span class="keyword">if</span> nums2[stack[-<span class="number">1</span>]] <span class="keyword">in</span> nums1:</span><br><span class="line">                        <span class="comment"># 找到nums2[i]在nums1对应下标</span></span><br><span class="line">                        index = nums1.index(nums2[stack[-<span class="number">1</span>]])</span><br><span class="line">                        <span class="comment"># 添加到答案组里</span></span><br><span class="line">                        res[index] = nums2[i]</span><br><span class="line">                    <span class="comment"># 注意这个pop操作，不论nums2[stack[-1]]是否在nums1都要执行</span></span><br><span class="line">                    stack.pop()</span><br><span class="line">                stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="503-下一个更大元素-ii">503. 下一个更大元素 II</h1><p><a href="https://leetcode.cn/problems/next-greater-element-ii/">https://leetcode.cn/problems/next-greater-element-ii/</a></p><p>给定一个循环数组 <code>nums</code> （ <code>nums[nums.length - 1]</code> 的下一个元素是 <code>nums[0]</code> ），返回 <em><code>nums</code> 中每个元素的 <strong>下一个更大元素</strong></em> 。</p><p>数字 <code>x</code> 的 <strong>下一个更大的元素</strong> 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 <code>-1</code> 。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,1]</span><br><span class="line">输出: [2,-1,2]</span><br><span class="line">解释: 第一个 1 的下一个更大的数是 2；</span><br><span class="line">数字 2 找不到下一个更大的数； </span><br><span class="line">第二个 1 的下一个最大的数需要循环搜索，结果也是 2。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3,4,3]</span><br><span class="line">输出: [2,3,4,-1,4]</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li></ul><h2 id="单调栈思路">单调栈思路</h2><p>找下一个更大的元素，可以使用单调栈</p><p>单调递减栈，栈底是整个栈最大值</p><p>stack初始化添加下标0</p><p>从下标1开始遍历（进行循环遍历一次，从1到(1+len(nums))），若nums[i]大于stack[-1]（指栈顶值）则将栈顶值弹出，并且res[j] = nums[i]（j表示栈顶值元素在nums里的下标值）</p><p>如果nums[i]小于stack[-1]，则直接将nums[i]添加进去</p><h2 id="单调栈代码">单调栈代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextGreaterElements</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        stack = <span class="built_in">list</span>()</span><br><span class="line">        stack.append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = [-<span class="number">1</span>] * L</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span> * L):</span><br><span class="line">            <span class="keyword">if</span> nums[i % L] &lt;= nums[stack[-<span class="number">1</span>]]:</span><br><span class="line">                stack.append(i % L)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> nums[i % L] &gt; nums[stack[-<span class="number">1</span>]]:</span><br><span class="line">                    j = stack.pop()</span><br><span class="line">                    res[j] = nums[i % L]</span><br><span class="line">                stack.append(i % L)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday48单调栈part01&quot;&gt;LeetCodeCampsDay48单调栈part01&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;初识单调栈&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;单调栈&quot;&gt;单调栈&lt;/h1&gt;
&lt;blockqu</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay46动态规划part13</title>
    <link href="https://blog.lthero.cn/2025/08/11/LeetCodeCampsDay46/"/>
    <id>https://blog.lthero.cn/2025/08/11/LeetCodeCampsDay46/</id>
    <published>2025-08-11T02:12:26.000Z</published>
    <updated>2025-08-11T07:48:41.402Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday46动态规划part13">LeetCodeCampsDay46动态规划part13</h1><blockquote><p>使用dp解决回文串和回文序列问题</p></blockquote><h1 id="647-回文子串">647. 回文子串</h1><p><a href="https://leetcode.cn/problems/palindromic-substrings/">https://leetcode.cn/problems/palindromic-substrings/</a></p><p>给你一个字符串 <code>s</code> ，请你统计并返回这个字符串中 <strong>回文子串</strong> 的数目。</p><p><strong>回文字符串</strong> 是正着读和倒过来读一样的字符串。</p><p><strong>子字符串</strong> 是字符串中的由连续字符组成的一个序列。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aaa&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 由小写英文字母组成</li></ul><h2 id="普通思路">普通思路</h2><p>本题和前面写过的26. 单词拆分有点像</p><p>需要将s拆分成长度为1、2、…L的子串，做法：使用双指针，i作为子串结尾位置；j作为子串起点位置，从而对所有子串进行判断是否为回文串；</p><p>比如s= ‘abc’，将得到a, ab, b, abc, bc, c 再对每个子串判断是否为回文串（调用个函数即可）</p><p><strong>但这种写法会超时，因为有太多的重复内容被反复计算</strong></p><p>所以需要有dp的方法来判断回文串</p><h2 id="普通代码-超时">普通代码（超时）</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countSubstrings</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">isLegal</span>(<span class="params">s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            left = <span class="number">0</span></span><br><span class="line">            right = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                <span class="keyword">if</span> s[left] != s[right]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        L = <span class="built_in">len</span>(s)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                <span class="comment"># print(s[j: i])</span></span><br><span class="line">                <span class="keyword">if</span> isLegal(s[j: i]):</span><br><span class="line">                    res += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="动态规划思路">动态规划思路</h2><p>一个更好的思路，把问题拆成子问题</p><p>比如为了判断abcba是否为子串，可以先判断bcb是否为子串-&gt;判断c是否为子串</p><p>所以问题可以变成</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20230102170752.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20230102170752.png" alt="img"></p><p>同时使用两个指针遍历，和普通思路一样，也需要将s拆分成长度为1、2、…L的子串s[j: i]（左闭右闭）</p><ul><li>如果长度为1，即s[j]==s[i]且j==i，那一定是回文，令dp[j][i]=1</li><li>如果长度为2，即s[j]==s[i]且j+1==i，也是回文，令dp[j][i]=1</li><li>如果长度大于2，比如abcba，即s[j]==s[i]=a，且j+1&lt;i，此时需要判断s[j+1:i-1]（左闭右闭）这一段(bcb)是否为回文串，如果bcb已经是回文串（即令dp[j + 1][i - 1]=1），那s[j:i]（左闭右闭），也是回文，令dp[j][i]=1；否则就不是回文</li></ul><p>反之</p><ul><li>如果s[j]!=s[i]，那一定不是回文串</li></ul><h2 id="动态规划代码">动态规划代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countSubstrings</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 下面使用动态规划解决</span></span><br><span class="line">        L = <span class="built_in">len</span>(s)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        dp = [[<span class="literal">False</span>] * (L + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(L + <span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># 全部初始化为False即可</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i + <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># print(s[j - 1], s[i - 1])</span></span><br><span class="line">                <span class="keyword">if</span> s[j - <span class="number">1</span>] == s[i - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">if</span> j == i:</span><br><span class="line">                        <span class="comment"># 同一个字符且位置相同</span></span><br><span class="line">                        res += <span class="number">1</span></span><br><span class="line">                        dp[j][i] = <span class="literal">True</span>    </span><br><span class="line">                    <span class="keyword">elif</span> j + <span class="number">1</span> == i:</span><br><span class="line">                        <span class="comment"># 相邻两个字符</span></span><br><span class="line">                        res += <span class="number">1</span></span><br><span class="line">                        dp[j][i] = <span class="literal">True</span>    </span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="comment"># j与i之间有其它字符，此时要判断s[j+1: i-1]（左闭右闭）是否为回文，如果它也是回文，才能说明s[j: i]（左闭右闭）是回文</span></span><br><span class="line">                        <span class="keyword">if</span> dp[j + <span class="number">1</span>][i - <span class="number">1</span>]:</span><br><span class="line">                            dp[j][i] = <span class="literal">True</span> </span><br><span class="line">                            res += <span class="number">1</span>                   </span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>注意这里的遍历顺序，最好是i从后向前遍历，因为在状态转换时需要使用dp[i + 1][j - 1]</p><p>所以i的范围从[L-1, 0]而j的范围从[i, L-1]，而dp的含义还是s[j-1,i+1]这段字符串是否为回文</p><h2 id="代码改进">代码改进</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面使用动态规划解决</span></span><br><span class="line">L = <span class="built_in">len</span>(s)</span><br><span class="line">res = <span class="number">0</span></span><br><span class="line">dp = [[<span class="literal">False</span>] * (L) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(L)]</span><br><span class="line"><span class="comment"># 全部初始化为False即可</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, L):</span><br><span class="line">        <span class="comment"># print(s[j - 1], s[i - 1])</span></span><br><span class="line">        <span class="keyword">if</span> s[j] == s[i]:</span><br><span class="line">            <span class="keyword">if</span> j == i:</span><br><span class="line">                <span class="comment"># 同一个字符且位置相同</span></span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">                dp[i][j] = <span class="literal">True</span>    </span><br><span class="line">            <span class="keyword">elif</span> j - <span class="number">1</span> == i:</span><br><span class="line">                <span class="comment"># 相邻两个字符</span></span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">                dp[i][j] = <span class="literal">True</span>    </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># j与i之间有其它字符，此时要判断s[j+1: i-1]（左闭右闭）是否为回文，如果它也是回文，才能说明s[j: i]（左闭右闭）是回文</span></span><br><span class="line">                <span class="keyword">if</span> dp[i + <span class="number">1</span>][j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = <span class="literal">True</span> </span><br><span class="line">                    res += <span class="number">1</span>                   </span><br><span class="line"><span class="comment"># print(dp)</span></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="516-最长回文子序列">516. 最长回文子序列</h1><p><a href="https://leetcode.cn/problems/longest-palindromic-subsequence/">https://leetcode.cn/problems/longest-palindromic-subsequence/</a></p><p>给你一个字符串 <code>s</code> ，找出其中最长的回文子序列，并返回该序列的长度。</p><p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;bbbab&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：一个可能的最长回文子序列为 &quot;bbbb&quot; 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;cbbd&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：一个可能的最长回文子序列为 &quot;bb&quot; 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由小写英文字母组成</li></ul><h2 id="动态规划思路">动态规划思路</h2><p>注意这题是回文子序列（不要求连续）</p><p>仍然可以使用dp数组做，和647. 回文子串思路相似</p><ol><li>dp下标与含义</li></ol><p>dp[i][j]表示s[i:j]（左闭右闭）的最长的回文子序列长度</p><ol start="2"><li>递推公式</li></ol><p>在判断回文子串的题目中，关键逻辑就是看s[i]与s[j]是否相同。</p><p>如果s[i]与s[j]相同，那么<strong>dp[i][j] = dp[i + 1][j - 1] + 2</strong></p><p>如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20210127151350563.jpg" alt="516.最长回文子序列"></p><p><img src="https://file1.kamacoder.com/i/algo/20210127151350563.jpg" alt="516.最长回文子序列"></p><p>如果不相同，说明s[i]和s[j]的同时加入 并不能增加[i,j]区间回文子序列的长度，<strong>那么分别加入s[i]、s[j]看看哪一个可以组成最长的回文子序列。</strong></p><p>加入s[j]的回文子序列长度为dp[i + 1][j]。</p><p>加入s[i]的回文子序列长度为dp[i][j - 1]。</p><p>那么dp[i][j]一定是取最大的，即：dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20210127151420476.jpg" alt="516.最长回文子序列1"></p><p><img src="https://file1.kamacoder.com/i/algo/20210127151420476.jpg" alt="516.最长回文子序列1"></p><ol start="3"><li>初始化</li></ol><p>首先要考虑当i 和j 相同的情况，从递推公式：dp[i][j] = dp[i + 1][j - 1] + 2; 可以看出 递推公式是计算不到 i 和j相同时候的情况。</p><p>所以需要手动的将i==j的情况全部初始化为1，其它值初始化为0</p><blockquote><p>当然，也可以不手动初始化，但需要在s[i]==s[j]时，手动添加判断条件，如果i==j则赋值为1；而且j - 1==i时需要手动赋值为2</p></blockquote><ol start="4"><li>遍历顺序</li></ol><p>从递归公式中，可以看出，dp[i][j] 依赖于 dp[i + 1][j - 1] ，dp[i + 1][j] 和 dp[i][j - 1]，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20230102172155.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20230102172155.png" alt="img"></p><p><strong>所以遍历i的时候一定要从下到上遍历，这样才能保证下一行的数据是经过计算的</strong>。</p><h2 id="动态规划代码">动态规划代码</h2><ul><li>时间复杂度O(N^2)</li><li>空间复杂度O(N^2)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindromeSubseq</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># dp下标与含义</span></span><br><span class="line">        <span class="comment"># dp[i][j]表示s[j:i]（左闭右闭）的最长回文子序列</span></span><br><span class="line"></span><br><span class="line">        L = <span class="built_in">len</span>(s)</span><br><span class="line">        dp = [[<span class="number">0</span>] * L <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(L)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, L):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                    <span class="keyword">if</span> i == j:</span><br><span class="line">                        dp[i][j] = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> j - <span class="number">1</span> == i:</span><br><span class="line">                        dp[i][j] = <span class="number">2</span></span><br><span class="line">                    <span class="keyword">elif</span> dp[i + <span class="number">1</span>][j - <span class="number">1</span>] != <span class="number">0</span>:</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j - <span class="number">1</span>], dp[i + <span class="number">1</span>][j])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="动态规划代码二">动态规划代码二</h2><p>手动初始化</p><ul><li>时间复杂度O(N^2)</li><li>空间复杂度O(N^2)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindromeSubseq</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># dp下标与含义</span></span><br><span class="line">        <span class="comment"># dp[i][j]表示s[j:i]（左闭右闭）的最长回文子序列</span></span><br><span class="line"></span><br><span class="line">        L = <span class="built_in">len</span>(s)</span><br><span class="line">        dp = [[<span class="number">0</span>] * L <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(L)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对角线全为1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">            dp[i][i] = <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, L):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j - <span class="number">1</span>], dp[i + <span class="number">1</span>][j])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday46动态规划part13&quot;&gt;LeetCodeCampsDay46动态规划part13&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;使用dp解决回文串和回文序列问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;647-回文子串&quot;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay45动态规划part12</title>
    <link href="https://blog.lthero.cn/2025/08/08/LeetCodeCampsDay45/"/>
    <id>https://blog.lthero.cn/2025/08/08/LeetCodeCampsDay45/</id>
    <published>2025-08-08T08:09:11.000Z</published>
    <updated>2025-08-08T08:52:05.826Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday45动态规划part12">LeetCodeCampsDay45动态规划part12</h1><blockquote><p>下面几个子序列的题目都需要使用二维dp，而且关于两个字符串删除问题</p><p>并且都需要扩展dp的大小为dp(len(t1)+1, len(t2)+1)，第一行、第一列往往需要填充</p><p>所有涉及到两个字符串的dp问题，都有相似的状态转移过程</p><p>其中text1[i - 1] == text2[j - 1]，dp[i][j]</p><p>以及text1[i - 1] != text2[j - 1]，dp[i][j]</p><p>而dp[i][j]只能从dp[i - 1][j - 1]、dp[i - 1][j]、dp[i][j - 1]三种状态转移过来，只要能找到不同条件下状态转移的过程就好解决了</p></blockquote><h1 id="115-不同的子序列">115. 不同的子序列</h1><p><a href="https://leetcode.cn/problems/distinct-subsequences/">https://leetcode.cn/problems/distinct-subsequences/</a></p><p>给你两个字符串 <code>s</code> 和 <code>t</code> ，统计并返回在 <code>s</code> 的 <strong>子序列</strong> 中 <code>t</code> 出现的个数。</p><p>测试用例保证结果在 32 位有符号整数范围内。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;rabbbit&quot;, t = &quot;rabbit&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">如下所示, 有 3 种可以从 s 中得到 &quot;rabbit&quot; 的方案。</span><br><span class="line">rabbbit</span><br><span class="line">rabbbit</span><br><span class="line">rabbbit</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;babgbag&quot;, t = &quot;bag&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">如下所示, 有 5 种可以从 s 中得到 &quot;bag&quot; 的方案。 </span><br><span class="line">babgbag</span><br><span class="line">babgbag</span><br><span class="line">babgbag</span><br><span class="line">babgbag</span><br><span class="line">babgbag</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length, t.length &lt;= 1000</code></li><li><code>s</code> 和 <code>t</code> 由英文字母组成</li></ul><h2 id="动态规划代码">动态规划代码</h2><ol><li>dp下标与含义</li></ol><p>dp[i][j]表示s[i - 1]和t[j - 1]，dp[i][j]出现的个数</p><ol start="2"><li>递推公式</li></ol><p>这一类两个字符串的问题，一般都要按相等与不相等两种情况进行讨论；</p><p>并且，一定要注意，哪个字符串是被删除对象，<strong>被删除对象往往放在纵向遍历；</strong></p><p>当s[i - 1] 与 t[j - 1]相等时，dp[i][j]可以有两部分组成。</p><p>一部分是用s[i - 1]来匹配，那么个数为dp[i - 1][j - 1]。即不需要考虑当前s子串和t子串的最后一位字母，所以只需要 dp[i-1][j-1]。</p><p>一部分是不用s[i - 1]来匹配，个数为dp[i - 1][j]。</p><p>例如： s：bagg 和 t：bag ，s[3] = g 和 t[2] = g是相同的，但是字符串s也可以不用s[3]来匹配，即用s[0]s[1]s[2]组成的bag。当然也可以用s[3]来匹配，即：s[0]s[1]s[3]组成的bag。</p><table><thead><tr><th></th><th>None</th><th>b</th><th>a</th><th>g</th></tr></thead><tbody><tr><td>None</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>b</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td>a</td><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>g</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>g</td><td>0</td><td>1</td><td>1</td><td>2</td></tr></tbody></table><ul><li><p>如果s[i - 1] == t[j - 1]，则dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]；</p><ul><li>解释：如果两个字符相等（当前为s[i - 1]和t[j - 1]子串），则s和t各退一步，对比前s[i - 2]和前t[j - 2]子串，所以dp[i - 1][j - 1] 需要被加上；</li><li>此外，s需要额外退一步，即只对比前s[i - 2]和前t[j - 1]子串，比如当遍历到s[3]=g(第二个),t[2]=g，此时s[2]=g也是满足情况的（对应结果放在dp[2][2]），这个情况的结果也要被考虑进去，<code>这一步才是能计算出多种方案的关键步骤</code></li></ul></li><li><p>如果s[i - 1] != t[j - 1]，则dp[i][j] = dp[i - 1][j]</p><ul><li>解释：相当于在不相等时，s了退一步，即只对比前s[i - 2]和前t[j - 1]子串， <code>前s[i - 2]个字符</code>（对应dp[i - 1][j]） 的结果就是dp[i][j]的结果，比如s[1] = a，t[0] = b，他俩不相等，此时就去对比s[0] = b和t[0] = b，所以dp[1][0] = dp[0][0]</li></ul></li></ul><p><img src="https://file1.kamacoder.com/i/algo/20221222165412.png" alt="img"></p><p><img src="https://cdn.lthero.cn/post_images/course/ML20221222165412.png" alt="img"></p><ol start="3"><li>初始化</li></ol><p>dp = [[0] * (len(s) + 1) for _ in range(len(s) + 1)]</p><p>第一列都初始化为1，第一行全为0</p><ol start="4"><li>遍历顺序</li></ol><p>纵向遍历t，横向遍历s</p><h2 id="动态规划代码">动态规划代码</h2><ul><li>时间复杂度O(N*M)</li><li>空间复杂度O(N*M)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numDistinct</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"></span><br><span class="line">        Ls = <span class="built_in">len</span>(s)</span><br><span class="line">        Lt = <span class="built_in">len</span>(t)</span><br><span class="line"></span><br><span class="line">        dp = [[<span class="number">0</span>] * (Lt + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(Ls + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Ls):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, Ls + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, Lt + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j]</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br><span class="line">        </span><br></pre></td></tr></table></figure><h1 id="583-两个字符串的删除操作">583. 两个字符串的删除操作</h1><p><a href="https://leetcode.cn/problems/delete-operation-for-two-strings/">https://leetcode.cn/problems/delete-operation-for-two-strings/</a></p><p>给定两个单词 <code>word1</code> 和 <code>word2</code> ，返回使得 <code>word1</code> 和 <code>word2</code> <strong>相同</strong>所需的<strong>最小步数</strong>。</p><p><strong>每步</strong> 可以删除任意一个字符串中的一个字符。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: word1 = &quot;sea&quot;, word2 = &quot;eat&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 第一步将 &quot;sea&quot; 变为 &quot;ea&quot; ，第二步将 &quot;eat &quot;变为 &quot;ea&quot;</span><br></pre></td></tr></table></figure><p><strong>示例  2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = &quot;leetcode&quot;, word2 = &quot;etco&quot;</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= word1.length, word2.length &lt;= 500</code></li><li><code>word1</code> 和 <code>word2</code> 只包含小写英文字母</li></ul><h2 id="动态规划思路一">动态规划思路一</h2><blockquote><p>题目可以修改成，找到最大公共子串长度x（这里的子串不用连续），结果是len(w1) - x + len(w2) - x</p></blockquote><p>本题和<a href="https://programmercarl.com/1143.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.html">动态规划：1143.最长公共子序列</a>基本相同</p><ol><li>dp下标与含义</li></ol><p>dp[i][j] 为w1[i - 1], w2[j - 1]的最大公共子串长度</p><ol start="2"><li>递推公式</li></ol><p>如果w1[i - 1]和w2[j - 1]相等，则dp[i][j] = dp[i - 1][j - 1] + 1，表示w1和w2各退一步，上一个字符的结果加一即可</p><p>如果w1[i - 1]和w2[j - 1]不相等，dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])，表示需要分成两种情况：</p><ul><li>让w1退一步，使用w1[i - 2]和w2[j - 1]的结果</li><li>让w2退一步，使用w1[i - 1]和w2[j - 2]的结果</li><li>当然，为了求最大公共子串长度，所以取两者最大值</li></ul><ol start="3"><li>初始化</li></ol><p>dp = [[0] * (len(word2) + 1) for _ in range(len(word1) + 1)]</p><p>第一行、第一列全为0</p><ol start="4"><li>遍历顺序</li></ol><p>纵向对word1, 横向对word2</p><h2 id="动态规划代码一">动态规划代码一</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDistance</span>(<span class="params">self, word1: <span class="built_in">str</span>, word2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"></span><br><span class="line">        Lw1 = <span class="built_in">len</span>(word1)</span><br><span class="line">        Lw2 = <span class="built_in">len</span>(word2)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (Lw2 + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(Lw1 + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, Lw1 + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, Lw2 + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i - <span class="number">1</span>] ==word2[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Lw1 + Lw2 - <span class="number">2</span> * dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="动态规划思路二">动态规划思路二</h2><p>本题和<a href="https://programmercarl.com/0115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.html">动态规划：115.不同的子序列</a>相比，其实就是两个字符串都可以删除了，情况虽说复杂一些，但整体思路是不变的。</p><p>这次是<strong>两个字符串可以相互删了</strong>，这种题目也知道用动态规划的思路来解，动规五部曲，分析如下：</p><ol><li>确定dp数组（dp table）以及下标的含义</li></ol><p>dp[i][j]：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。</p><ol start="2"><li>递推公式</li></ol><p>当word1[i - 1] 与 word2[j - 1]相同的时候，dp[i][j] = dp[i - 1][j - 1];</p><p>当word1[i - 1] 与 word2[j - 1]不相同的时候，有三种情况：</p><p>情况一：删word1[i - 1]，最少操作次数为dp[i - 1][j] + 1</p><p>情况二：删word2[j - 1]，最少操作次数为dp[i][j - 1] + 1</p><p>情况三：同时删word1[i - 1]和word2[j - 1]，操作的最少次数为dp[i - 1][j - 1] + 2</p><p>那最后当然是<code>取最小值</code>，所以当word1[i - 1] 与 word2[j - 1]不相同的时候，递推公式：dp[i][j] = min({dp[i - 1][j - 1] + 2, dp[i - 1][j] + 1, dp[i][j - 1] + 1});</p><p>因为 dp[i][j - 1] + 1 = dp[i - 1][j - 1] + 2，</p><p>所以递推公式可简化为：dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1;</p><ol start="3"><li>dp数组如何初始化</li></ol><p>从递推公式中，可以看出来，dp[i][0] 和 dp[0][j]是一定要初始化的。</p><p>dp[i][0]：word2为空字符串，以i-1为结尾的字符串word1要删除多少个元素，才能和word2相同呢，很明显dp[i][0] = i。</p><p>dp[0][j]的话同理</p><ol start="4"><li>确定遍历顺序</li></ol><p>从递推公式 dp[i][j] = min(dp[i - 1][j - 1] + 2, min(dp[i - 1][j], dp[i][j - 1]) + 1); 和dp[i][j] = dp[i - 1][j - 1]可以看出dp[i][j]都是根据左上方、正上方、正左方推出来的。</p><p>所以遍历的时候一定是从上到下，从左到右，这样保证dp[i][j]可以根据之前计算出来的数值进行计算。</p><ol start="5"><li>举例推导dp数组</li></ol><p>以word1:“sea”，word2:&quot;eat&quot;为例，推导dp数组状态图如下：</p><p><img src="https://file1.kamacoder.com/i/algo/20210714101750205.png" alt="583.两个字符串的删除操作1"></p><h1 id="72-编辑距离">72. 编辑距离</h1><p><a href="https://leetcode.cn/problems/edit-distance/">https://leetcode.cn/problems/edit-distance/</a></p><p>给你两个单词 <code>word1</code> 和 <code>word2</code>， <em>请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</em> 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">horse -&gt; rorse (将 &#x27;h&#x27; 替换为 &#x27;r&#x27;)</span><br><span class="line">rorse -&gt; rose (删除 &#x27;r&#x27;)</span><br><span class="line">rose -&gt; ros (删除 &#x27;e&#x27;)</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">intention -&gt; inention (删除 &#x27;t&#x27;)</span><br><span class="line">inention -&gt; enention (将 &#x27;i&#x27; 替换为 &#x27;e&#x27;)</span><br><span class="line">enention -&gt; exention (将 &#x27;n&#x27; 替换为 &#x27;x&#x27;)</span><br><span class="line">exention -&gt; exection (将 &#x27;n&#x27; 替换为 &#x27;c&#x27;)</span><br><span class="line">exection -&gt; execution (插入 &#x27;u&#x27;)</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= word1.length, word2.length &lt;= 500</code></li><li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li></ul><h2 id="动态规划思路">动态规划思路</h2><ol><li>dp下标与含义：</li></ol><p>dp[i][j] 表示把w1[i - 1]转成w2[j - 1]的最小操作数</p><ol start="2"><li>递推公式</li></ol><p>如果相等dp[i][j]=dp[i - 1][j - 1]</p><p>如果不相等，则需要有：1.删除 2.增加 3.替换操作</p><p>其中，删除操作有两种可能</p><p>1.1 删除word1里的一个字，即保留word1[i - 2]和word2[j - 1]，dp[i][j] = dp[i - 1][j] + 1</p><p>1.2 删除word2里的一个字，即保留word1[i - 1]和word2[j - 2]，dp[i][j] = dp[i][j - 1] + 1</p><p>而增加，对word1增加，可以看成对word2删除，所以公式和上面一样</p><p>而替换操作，由于不增加不减少，dp[i][j] = dp[i - 1][j - 1] + 1，只要在word1[i - 2]和word2[j - 2]基础上添加一次操作即可</p><p>所以</p><p>dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])</p><blockquote><p>PS： 这种二维dp[i][j]，一共只有三个方向能转移到dp[i][j]，所以在什么条件下，怎么进行转移才是重点</p></blockquote><ol start="3"><li>初始化</li></ol><p>dp = [[0] * (len(word2) + 1) for _ in range(len(word1) + 1)]</p><p>那么dp[i][0] 和 dp[0][j] 表示什么呢？</p><p>dp[i][0] ：以下标i-1为结尾的字符串word1，和空字符串word2，最近编辑距离为dp[i][0]。</p><p>那么dp[i][0]就应该是i，对word1里的元素全部做删除操作，即：dp[i][0] = i;</p><p>同理dp[0][j] = j;</p><ol start="4"><li>遍历顺序</li></ol><p>注意word1是被操作对象，所以纵向遍历word1，横向遍历word2</p><p>从左到右、从上到下遍历</p><h2 id="动态规划代码">动态规划代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDistance</span>(<span class="params">self, word1: <span class="built_in">str</span>, word2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        </span><br><span class="line">        Lw1 = <span class="built_in">len</span>(word1)</span><br><span class="line">        Lw2 = <span class="built_in">len</span>(word2)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (Lw2 + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(Lw1 + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Lw1 + <span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(Lw2 + <span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = j</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, Lw1 + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, Lw2 + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday45动态规划part12&quot;&gt;LeetCodeCampsDay45动态规划part12&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;下面几个子序列的题目都需要使用二维dp，而且关于两个字符串删除问题&lt;/p&gt;
&lt;p&gt;并且都需要扩展dp的大</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay44动态规划part11</title>
    <link href="https://blog.lthero.cn/2025/08/07/LeetCodeCampsDay44/"/>
    <id>https://blog.lthero.cn/2025/08/07/LeetCodeCampsDay44/</id>
    <published>2025-08-07T03:17:28.000Z</published>
    <updated>2025-08-08T08:45:57.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday44动态规划part11">LeetCodeCampsDay44动态规划part11</h1><blockquote><p>下面几个子序列的题目都需要使用二维dp，一个维度给text1另一个给text2</p><p>并且都需要扩展dp的大小为dp(len(t1)+1, len(t2)+1)，第一行、第一列往往需要填充</p><p>所有涉及到两个字符串的dp问题，都有相似的状态转移过程</p><p>其中text1[i - 1] == text2[j - 1]，dp[i][j]</p><p>以及text1[i - 1] != text2[j - 1]，dp[i][j]</p><p>而dp[i][j]只能从dp[i - 1][j - 1]、dp[i - 1][j]、dp[i][j - 1]三种状态转移过来，只要能找到不同条件下状态转移的过程就好解决了</p></blockquote><h1 id="1143-最长公共子序列">1143. 最长公共子序列</h1><p><a href="https://leetcode.cn/problems/longest-common-subsequence/">https://leetcode.cn/problems/longest-common-subsequence/</a></p><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p><p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li></ul><p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; </span><br><span class="line">输出：3  </span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：最长公共子序列是 &quot;abc&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：两个字符串没有公共子序列，返回 0 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= text1.length, text2.length &lt;= 1000</code></li><li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成。</li></ul><h2 id="动态规划思路">动态规划思路</h2><ol><li>dp下标与含义</li></ol><p>dp[i][j]表示text1里前i - 1个字符与text2里前j - 1个字符的最长公共子序列长度</p><ol start="2"><li>递推公式</li></ol><p>可以看出来，有三个方向可以转移到dp[i][j]</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20210204115139616.jpg" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20210204115139616.jpg" alt="img"></p><p>如果text2[i - 1] == text1[j - 1], 则dp[i][j] = dp[i - 1][j - 1] + 1</p><p>如果不相等,  则dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])</p><p>假如t1 = “ezupkr”，t2 = “ubmrapg”，我们仅看前几个字符，当前的dp数组如下</p><table><thead><tr><th></th><th>None</th><th>e</th><th>z</th><th>u</th></tr></thead><tbody><tr><td>None</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>u</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>b</td><td>0</td><td>0</td><td>0</td><td>1</td></tr></tbody></table><p>当两个字符相等时：dp[1][3] = dp[0][2] + 1 = 0 + 1 = 1，我们此时只用关心在<strong>t1里&quot;u&quot;和t2里的&quot;u&quot;</strong>，把这两个子串看成一个新的题目，新题目的dp’数组如下</p><table><thead><tr><th></th><th>None</th><th>u</th></tr></thead><tbody><tr><td>None</td><td>0</td><td>0</td></tr><tr><td>u</td><td>0</td><td>1</td></tr></tbody></table><p>dp’[1][1]对应新题目里的u位置，dp’[1][1]=dp’[0][0]+1，不用管dp’[0][0]对应的字符是什么；</p><p>当两个字符不相等时：比如t1=b, t2=u时，dp[2][3] = max(dp[2][2], dp[1][3])</p><p>​dp[2][2]的情况可以理解成把t1=ez, t2=ub，求这新题目的最大序列数</p><p>​dp[1][3]的情况可以理解成把t1=ezu, t2=u，求这新题目的最大序列数</p><p>dp[2][3]此时相等于求“t1=ez, t2=ub”和“t1=ezu, t2=u”这两种情况的最大值</p><ol start="3"><li>遍历顺序</li></ol><p>纵向遍历t2，横向遍历t1，反之也行</p><ol start="4"><li>初始化</li></ol><p>dp[len(t1) + 1][len(t2) + 1]，并且全部初始化为0</p><ol start="5"><li>举例</li></ol><p>以输入：text1 = “abcde”, text2 = “ace” 为例，dp状态如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20210210150215918.jpg" alt="1143.最长公共子序列1"></p><p><img src="https://file1.kamacoder.com/i/algo/20210210150215918.jpg" alt="1143.最长公共子序列1"></p><p>本题目还有个特性：不能交叉，</p><p>举例t1 = abcde, t2 = ec，最终结果应该是1而不是2，即必须按顺序来；如果t1里的c和t2里的c对应了，再让t1里的e和t2里的e对应，就出来了交叉（和1035. 不相交的钱是相似的思路）</p><table><thead><tr><th></th><th>None</th><th>e</th><th>c</th></tr></thead><tbody><tr><td>None</td><td>0</td><td>0</td><td>0</td></tr><tr><td>a</td><td>0</td><td>0</td><td>0</td></tr><tr><td>b</td><td>0</td><td>0</td><td>0</td></tr><tr><td>c</td><td>0</td><td>0</td><td>1</td></tr><tr><td>d</td><td>0</td><td>0</td><td>1</td></tr><tr><td>e</td><td>0</td><td>1</td><td>1</td></tr></tbody></table><h2 id="动态规划代码">动态规划代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestCommonSubsequence</span>(<span class="params">self, text1: <span class="built_in">str</span>, text2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 本题可能和139.单词拆分、300. 最长递增子序列 有点儿像，</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># dp下标与含义：dp[i][j]表示text1里前i - 1个字符与text2里前j - 1个字符的最长公共子序列长度</span></span><br><span class="line">        <span class="comment"># 因为dp的第一行第一列会被填写为0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 递推公式</span></span><br><span class="line">        <span class="comment"># 如果text2[i - 1] == text1[j - 1]</span></span><br><span class="line">        <span class="comment"># 则dp[i][j] = dp[i - 1][j - 1] + 1</span></span><br><span class="line">        <span class="comment"># 如果不相等</span></span><br><span class="line">        <span class="comment"># 则dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历顺序</span></span><br><span class="line">        <span class="comment"># 纵向遍历t2，横向遍历t1，反之也行</span></span><br><span class="line"></span><br><span class="line">        L1 = <span class="built_in">len</span>(text1)</span><br><span class="line">        L2 = <span class="built_in">len</span>(text2)</span><br><span class="line"></span><br><span class="line">        dp = [[<span class="number">0</span>] * (L1 + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(L2 + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L2 + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L1 + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> text2[i - <span class="number">1</span>] == text1[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 注意这个取值需要同时取两者最大</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 比如t1 = &quot;ezupkr&quot;，t2 = &quot;ubmrapg&quot;时包含令dp[i][j] = dp[i - 1][j]的情况</span></span><br><span class="line">                    <span class="comment"># 而t1 = &quot;abcde&quot;， t2 = &quot;ace&quot;包含令dp[i][j] = dp[i][j - 1]的情况</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j])</span><br><span class="line">            res = <span class="built_in">max</span>(res, dp[i][j])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="1035-不相交的线">1035. 不相交的线</h1><p><a href="https://leetcode.cn/problems/uncrossed-lines/">https://leetcode.cn/problems/uncrossed-lines/</a></p><p>在两条独立的水平线上按给定的顺序写下 <code>nums1</code> 和 <code>nums2</code> 中的整数。</p><p>现在，可以绘制一些连接两个数字 <code>nums1[i]</code> 和 <code>nums2[j]</code> 的直线，这些直线需要同时满足：</p><ul><li><code>nums1[i] == nums2[j]</code></li><li>且绘制的直线不与任何其他连线（非水平线）相交。</li></ul><p>请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。</p><p>以这种方法绘制线条，并返回可以绘制的最大连线数。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2019/04/26/142.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,4,2], nums2 = [1,2,4]</span><br><span class="line">输出：2</span><br><span class="line">解释：可以画出两条不交叉的线，如上图所示。 </span><br><span class="line">但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums1.length, nums2.length &lt;= 500</code></li><li><code>1 &lt;= nums1[i], nums2[j] &lt;= 2000</code></li></ul><h2 id="动态规划思路">动态规划思路</h2><p>这题目和<code>1143.最长公共子序列</code> 代码完全一样，解决思路也是一样的；</p><p>这里说直线无法交叉也是<code>1143.最长公共子序列</code> 拥有的性质，说明在字符串text1中 找到一个与字符串text2相同的子序列，<strong>且这个子序列不能改变相对顺序</strong></p><p>举例t1 = abcde, t2 = ec，最终结果应该是1而不是2，因为公共子序列必须按顺序来；</p><p>如果t1里的c和t2里的c对应了，再让t1里的e和t2里的e对应，就出来了交叉</p><table><thead><tr><th></th><th>None</th><th>e</th><th>c</th></tr></thead><tbody><tr><td>None</td><td>0</td><td>0</td><td>0</td></tr><tr><td>a</td><td>0</td><td>0</td><td>0</td></tr><tr><td>b</td><td>0</td><td>0</td><td>0</td></tr><tr><td>c</td><td>0</td><td>0</td><td>1</td></tr><tr><td>d</td><td>0</td><td>0</td><td>1</td></tr><tr><td>e</td><td>0</td><td>1</td><td>1</td></tr></tbody></table><p>回到本题目，直线不能相交，这就是说明在字符串nums1中 找到一个与字符串nums2相同的子序列，且这个子序列不能改变相对顺序，只要相对顺序不改变，连接相同数字的直线就不会相交。</p><p>拿示例一nums1 = [1,4,2], nums2 = [1,2,4]为例，相交情况如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20210914145158.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20210914145158.png" alt="img"></p><p>其实也就是说nums1和nums2的最长公共子序列是[1,4]，长度为2。 这个公共子序列指的是相对顺序不变（即数字4在字符串nums1中数字1的后面，那么数字4也应该在字符串nums2数字1的后面）</p><p>这么分析完之后，大家可以发现：<strong>本题说是求绘制的最大连线数，其实就是求两个字符串的最长公共子序列的长度！</strong></p><ol><li>dp下标与含义</li></ol><p>dp[i][j]表示nums1[i - 1]与nums2[j - 1]最多的不相交线数（按顺序的公共子序列数）</p><ol start="2"><li>递推公式</li></ol><p>可以看出来，有三个方向可以转移到dp[i][j]</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20210204115139616.jpg" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20210204115139616.jpg" alt="img"></p><p>如果text2[i - 1] == text1[j - 1], 则dp[i][j] = dp[i - 1][j - 1] + 1</p><p>如果不相等,  则dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])</p><ol start="3"><li>初始化</li></ol><p>dp[len(nums1) + 1][len(nusm2) + 1]，并且全部初始化为0</p><ol start="4"><li>遍历顺序</li></ol><p>纵向遍历t1，横向遍历t2，反之也行</p><h2 id="动态规划代码">动态规划代码</h2><ul><li>时间复杂度O(N*M)</li><li>空间复杂度O(N*M)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxUncrossedLines</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 本题和1143最长公共子序列是一样的思路，代码也基础一样</span></span><br><span class="line">        <span class="comment"># 在</span></span><br><span class="line"></span><br><span class="line">        L1 = <span class="built_in">len</span>(nums1)</span><br><span class="line">        L2 = <span class="built_in">len</span>(nums2)</span><br><span class="line"></span><br><span class="line">        dp = [[<span class="number">0</span>] * (L2 + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(L1 + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L1 + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L2 + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">            res = <span class="built_in">max</span>(res, dp[i][j])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="53-最大子数组和">53. 最大子数组和</h1><p><a href="https://leetcode.cn/problems/maximum-subarray/">https://leetcode.cn/problems/maximum-subarray/</a></p><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong>是数组中的一个连续部分。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,4,-1,7,8]</span><br><span class="line">输出：23</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p>**进阶：**如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p><h2 id="动态规划思路">动态规划思路</h2><p>使用一维数组</p><ol><li>dp下标与含义：</li></ol><p>dp[i][0]表示拿第i个数字的最大和，dp[i][1]表示不拿第i个数字的最大和</p><ol start="2"><li>递推公式</li></ol><p>如果拿第i个数字 dp[i][0] = max(dp[i - 1][0], dp[i - 1][1]) + nums[i]</p><p>如果不拿第i个数字 dp[i][1] = 0   （因为本题要求连续子数组，如果不要求连续，dp[i][1] = max(dp[i - 1][0], dp[i - 1][1])）</p><ol start="3"><li>初始化</li></ol><p>dp = [[0] * 2 for _ in range(len(nums) + 1)]</p><p>并且全部初始化为0</p><ol start="4"><li>遍历顺序</li></ol><p>纵向nums， 横向只有0/1两个状态</p><blockquote><p>其实和贪心算法的思路也是相似的，因为dp[i - 1][1]恒定为0，每次在拿时会判断：如果当前dp[i - 1][0]小于0，则直接取0，再加上nums[i]</p></blockquote><h2 id="动态规划代码">动态规划代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(N)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [[<span class="number">0</span>] * <span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(L + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        res = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L + <span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]) + nums[i - <span class="number">1</span>]</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="number">0</span> <span class="comment"># 可以不写</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, dp[i][<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>由于dp[i][1]恒定为0，所以dp也可以仅用一个状态</p><p>优化后代码</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [<span class="number">0</span>] * (L + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        res = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L + <span class="number">1</span>):</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], <span class="number">0</span>) + nums[i - <span class="number">1</span>]</span><br><span class="line">            res = <span class="built_in">max</span>(res, dp[i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="392-判断子序列">392. 判断子序列</h1><p><a href="https://leetcode.cn/problems/is-subsequence/">https://leetcode.cn/problems/is-subsequence/</a></p><p>给定字符串 <strong>s</strong> 和 <strong>t</strong> ，判断 <strong>s</strong> 是否为 <strong>t</strong> 的子序列。</p><p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，<code>&quot;ace&quot;</code>是<code>&quot;abcde&quot;</code>的一个子序列，而<code>&quot;aec&quot;</code>不是）。</p><p><strong>进阶：</strong></p><p>如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p><p><strong>致谢：</strong></p><p>特别感谢 <a href="https://leetcode.com/pbrother/">@pbrother </a>添加此问题并且创建所有测试用例。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abc&quot;, t = &quot;ahbgdc&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;axc&quot;, t = &quot;ahbgdc&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 100</code></li><li><code>0 &lt;= t.length &lt;= 10^4</code></li><li>两个字符串都只由小写字符组成。</li></ul><h2 id="动态规划思路">动态规划思路</h2><ol><li>dp下标与定义</li></ol><p>dp[i][j]表示s里前s[j - 1]字符是t[i - 1]的子序列，dp[i][j]只为T/F</p><ol start="2"><li>递推公式</li></ol><p>如果t[i - 1] == s[j - 1]并且dp[i - 1][j - 1]为True，则dp[i][j]=True</p><p>否则dp[i][j] = dp[i - 1][j]</p><ol start="3"><li>初始化</li></ol><p>dp = [[False] * (Ls + 1) for _ in range(Lt + 1)]</p><p>由递推公式知，我们需要一行、一列空表示空字符串</p><p>但让第一列为True，表示如果s=None时一定是t的子序列</p><ol start="4"><li>遍历顺序</li></ol><p>纵向遍历t，横向遍历s</p><ol start="5"><li>举例，</li></ol><p>s = abc, t = ahbgdc</p><p>​      None  a   b  c</p><p>None    T   F   F  F</p><p>a      T   T   F  F</p><p>h      T   T   F  F</p><p>b      T   T   T  F</p><p>g      T   T   T  F</p><p>d      T   T   T  F</p><p>c      T   T   T  T</p><h2 id="动态规划代码">动态规划代码</h2><ul><li>时间复杂度O(N * M)</li><li>空间复杂度O(N * M)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSubsequence</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        Ls = <span class="built_in">len</span>(s)</span><br><span class="line">        Lt = <span class="built_in">len</span>(t)</span><br><span class="line">        dp = [[<span class="literal">False</span>] * (Ls + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(Lt + <span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># 第一列初始化为True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Lt + <span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, Lt + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, Ls + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[j - <span class="number">1</span>] == t[i - <span class="number">1</span>] <span class="keyword">and</span> dp[i - <span class="number">1</span>][j - <span class="number">1</span>] <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">                    dp[i][j] = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># </span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday44动态规划part11&quot;&gt;LeetCodeCampsDay44动态规划part11&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;下面几个子序列的题目都需要使用二维dp，一个维度给text1另一个给text2&lt;/p&gt;
&lt;p&gt;并且都需要</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay43动态规划part10</title>
    <link href="https://blog.lthero.cn/2025/08/07/LeetCodeCampsDay43/"/>
    <id>https://blog.lthero.cn/2025/08/07/LeetCodeCampsDay43/</id>
    <published>2025-08-06T16:13:37.000Z</published>
    <updated>2025-08-07T03:09:43.681Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday43动态规划part10">LeetCodeCampsDay43动态规划part10</h1><blockquote><p>使用动态规划解决子序列问题</p><p>非连续子序列可以看成模板，而连续子序列只是非连续子序列的特例</p><p>最长重复子序列需要使用二维dp（每个维度对应一个数组序列）</p></blockquote><h1 id="300-最长递增子序列">300. 最长递增子序列</h1><p><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">https://leetcode.cn/problems/longest-increasing-subsequence/</a></p><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [10,9,2,5,3,7,101,18]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,0,3,2,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [7,7,7,7,7,7,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2500</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p><strong>进阶：</strong></p><ul><li>你能将算法的时间复杂度降低到 <code>O(n log(n))</code> 吗?</li></ul><h2 id="动态规划思路">动态规划思路</h2><p>本是和139.单词拆分有点儿像，</p><ol><li>dp数组下标与含义：</li></ol><p>dp[i]表示第i位置的最长递增子序列长度</p><ol start="2"><li>递推公式</li></ol><p>需要有两个指针，一个i指向每个数字；另一个j范围[0～i)，包含0不包含i，j指向0到nums[i - 1]之间的数字；</p><p>如果nums[i]大于nums[j]，则dp[i]可以考虑更新其结果为：dp[i]（上一轮的结果）与dp[j]+1中的最大值</p><p>dp[i] = max(dp[i], dp[j] + 1)</p><p>因为本题目不要求连续，所以可以从 让j从[0～i)（包含0不包含i）中抽数字</p><ol start="3"><li>dp初始化</li></ol><p>全部初始化为1</p><ol start="4"><li>遍历顺序</li></ol><p>先用i遍历数字，再用j遍历[0～i)，包含0不包含i</p><h2 id="动态规划代码">动态规划代码</h2><ul><li>时间复杂度: O(n^2)</li><li>空间复杂度: O(n)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 使用dp数组做</span></span><br><span class="line">        <span class="comment"># dp数组下标与含义：dp[i][0]表示将字符i装入的最长长度，dp[i][1]表示将字符i不装入的最长长度</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 递推公式</span></span><br><span class="line">        <span class="comment"># dp[i] = max(dp[i], dp[j] + 1)</span></span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> L &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> L</span><br><span class="line">        dp = [<span class="number">1</span>] * L</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> dp[i] &gt; res:</span><br><span class="line">                res = dp[i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="674-最长连续递增序列">674. 最长连续递增序列</h1><p><a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">https://leetcode.cn/problems/longest-continuous-increasing-subsequence/</a></p><p>给定一个未经排序的整数数组，找到最长且 <strong>连续递增的子序列</strong>，并返回该序列的长度。</p><p><strong>连续递增的子序列</strong> 可以由两个下标 <code>l</code> 和 <code>r</code>（<code>l &lt; r</code>）确定，如果对于每个 <code>l &lt;= i &lt; r</code>，都有 <code>nums[i] &lt; nums[i + 1]</code> ，那么子序列 <code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code> 就是连续递增子序列。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,5,4,7]</span><br><span class="line">输出：3</span><br><span class="line">解释：最长连续递增序列是 [1,3,5], 长度为3。</span><br><span class="line">尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 </span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,2,2,2,2]</span><br><span class="line">输出：1</span><br><span class="line">解释：最长连续递增序列是 [2], 长度为1。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li></ul><h2 id="动态规划思路">动态规划思路</h2><p>本题目与300.最长递增子序列不同点在于本题要求连续，</p><ol><li>dp数组下标与含义：</li></ol><p>dp[i]表示第i位置的最长连续递增子序列长度</p><ol start="2"><li>递推公式</li></ol><blockquote><p>因为本题目要求连续，“连续”意味着在使用j遍历时的起点需要修改成i - 1</p></blockquote><p>需要有两个指针，一个i指向每个数字；另一个j的范围是[i - 1～i)，包含i - 1不包含i，j指向0到nums[i - 1]之间的数字；</p><p>如果nums[i]大于nums[j]，则dp[i]可以考虑更新其结果为：dp[i]（上一轮的结果）与dp[j]+1中的最大值</p><p>dp[i] = max(dp[i], dp[j] + 1)</p><p>或者更直接一点儿</p><p>dp[i] = max(dp[i], dp[i - 1] + 1)</p><ol start="3"><li>dp初始化</li></ol><p>全部初始化为1</p><ol start="4"><li>遍历顺序</li></ol><p>先用i遍历数字，再用j遍历[i - 1～i)，包含i - 1不包含i</p><h2 id="动态规划代码">动态规划代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(N)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findLengthOfLCIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 使用dp解决</span></span><br><span class="line">        <span class="comment"># dp下标与含义：dp[i]表示数字nums[i]的最长连续子序列长度</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 递推公式</span></span><br><span class="line">        <span class="comment"># 如果nums[i] &gt; nums[i - 1]</span></span><br><span class="line">        <span class="comment"># dp[i] = max(dp[i], dp[i - 1]+1)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 或者写成通用公式</span></span><br><span class="line">        <span class="comment"># 令j的遍历范围为[i - 1, i)，不包含i</span></span><br><span class="line">        <span class="comment"># 递推公式为</span></span><br><span class="line">        <span class="comment"># dp[i] = max(dp[i], dp[j] + 1)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 初始化全为1</span></span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [<span class="number">1</span>] * L</span><br><span class="line"></span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i - <span class="number">1</span>, i):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[i - <span class="number">1</span>]:</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">            res = <span class="built_in">max</span>(dp[i], res)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="718-最长重复子数组">718. 最长重复子数组</h1><p><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">https://leetcode.cn/problems/maximum-length-of-repeated-subarray/</a></p><p>给两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>两个数组中 <strong>公共的</strong> 、长度最长的子数组的长度</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]</span><br><span class="line">输出：3</span><br><span class="line">解释：长度最长的公共子数组是 [3,2,1] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li><li><code>0 &lt;= nums1[i], nums2[i] &lt;= 100</code></li></ul><h2 id="动态规划思路">动态规划思路</h2><ol><li>dp下标与定义，</li></ol><p>dp[i][j] ：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为dp[i][j]。</p><p>（特别注意： “以下标i - 1为结尾的A” 标明一定是 以A[i-1]为结尾的字符串 ）</p><ol start="2"><li>递推公式</li></ol><p>如果nums1[i] == nums2[j]，则dp[i][j] = dp[i - 1][j - 1] + 1</p><p>如果不相等，则dp[i][j]就是0，因为<strong>它打破了连续性</strong></p><ol start="3"><li>初始化</li></ol><p>dp[len(nums2) + 1][len(nums1) + 1], dp的必须强行添加一行一列，并且dp[i][0]和dp[0][j]全为0</p><p>因为<code>dp[i][j] = dp[i - 1][j - 1]</code>决定了i, j只能从下标1开始</p><ol start="4"><li>遍历顺序</li></ol><p>纵向对nums2，横向对nums1；把过来也行，但遍历顺序必须和dp初始化顺序一致</p><ol start="5"><li>举例</li></ol><p><img src="https://cdn.lthero.cn/post_images/course/ML2021011215282060-20230310134554486.jpg" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/2021011215282060-20230310134554486.jpg" alt="img"></p><p>以下所有非零值都由其位置的左上角加一得到的</p><table><thead><tr><th></th><th>x</th><th>0</th><th>1</th><th>1</th><th>1</th><th>1</th></tr></thead><tbody><tr><td>x</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>2</td><td>1</td><td>1</td><td>1</td></tr><tr><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>2</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><h2 id="动态规划代码">动态规划代码</h2><ul><li>时间复杂度O(N*M)</li><li>空间复杂度O(N*M)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findLength</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># dp[i][j] ：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为dp[i][j]。 </span></span><br><span class="line">        <span class="comment"># （特别注意： “以下标i - 1为结尾的A” 标明一定是 以A[i-1]为结尾的字符串 ）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 递推公式</span></span><br><span class="line">        <span class="comment"># 如果nums1[i] == nums2[j]，则dp[i][j] = dp[i - 1][j - 1] + 1</span></span><br><span class="line">        <span class="comment"># 如果不相等，则dp[i][j]就是0，因为它打破了连续性</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化</span></span><br><span class="line">        <span class="comment"># dp[len(nums2) + 1][len(nums1) + 1]</span></span><br><span class="line">        <span class="comment"># 并且第一列、第一行初始化为0</span></span><br><span class="line">        <span class="comment"># 其它值也初始化为0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历顺序，纵向对nums2，横向对nums1</span></span><br><span class="line"></span><br><span class="line">        L1 = <span class="built_in">len</span>(nums1)</span><br><span class="line">        L2 = <span class="built_in">len</span>(nums2)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (L1 + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(L2 + <span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="comment"># </span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L2 + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L1 + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums2[i - <span class="number">1</span>] == nums1[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                res = <span class="built_in">max</span>(res, dp[i][j])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday43动态规划part10&quot;&gt;LeetCodeCampsDay43动态规划part10&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;使用动态规划解决子序列问题&lt;/p&gt;
&lt;p&gt;非连续子序列可以看成模板，而连续子序列只是非连续子序列的特例&lt;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay42动态规划part09</title>
    <link href="https://blog.lthero.cn/2025/08/06/LeetCodeCampsDay42/"/>
    <id>https://blog.lthero.cn/2025/08/06/LeetCodeCampsDay42/</id>
    <published>2025-08-06T09:26:37.000Z</published>
    <updated>2025-08-06T12:40:34.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday42动态规划part09">LeetCodeCampsDay42动态规划part09</h1><blockquote><p>买卖股票的另类问题</p></blockquote><h1 id="309-买卖股票的最佳时机含冷冻期">309. 买卖股票的最佳时机含冷冻期</h1><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/</a></p><p>给定一个整数数组<code>prices</code>，其中第 <code>prices[i]</code> 表示第 <code>i</code> 天的股票价格 。</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><ul><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li></ul><p>**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: prices = [1,2,3,0,2]</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: prices = [1]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 5000</code></li><li><code>0 &lt;= prices[i] &lt;= 1000</code></li></ul><h2 id="动态规划思路">动态规划思路</h2><ol><li>dp定义与含义</li></ol><p>根据状态转移图，需要定义一个包含四个状态的dp数组</p><p>状态0：表示买入</p><p>状态1：表示已经卖出，但还没买入</p><p>状态2：表示当天卖出</p><p>状态3：冷冻期</p><p>dp[i][j]表示在第i天的状态j下的最多金额数</p><p>状态转移表如下</p><p><img src="https://cdn.lthero.cn/post_images/course/ML518d5baaf33f4b2698064f8efb42edbf.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/518d5baaf33f4b2698064f8efb42edbf.png" alt="img"></p><ol start="2"><li>递推公式</li></ol><p>状态0：有三种状态可以转移到状态0</p><p>如果不买入新股票</p><p>​        如果是从状态0（买入当天），则dp[i][0] = dp[i - 1][0]</p><p>如果买入新股票</p><p>​        如果是从状态1（当天卖出），则dp[i][0] = dp[i - 1][1] - prices[i]</p><p>​        如果是从状态3（冷冻期），则dp[i][0] = dp[i - 1][3] - prices[i]</p><p>状态1：有两种状态可以转移到状态1</p><p>​        如果从状态1：dp[i][1] = dp[i - 1][1]</p><p>​        如果从状态3：dp[i][1] = dp[i - 1][3]</p><p>状态2：只有一种状态可以转移到状态2</p><p>​        dp[i][2] = dp[i - 1][0] + prices[i]</p><p>状态3：只有一种状态可以转移到状态3</p><p>​        dp[i][3] = dp[i - 1][2]</p><ol start="3"><li>dp初始化</li></ol><p>​        dp[0][0]初始化为-prices[0], dp[0][1]初始化为0， dp[0][2]初始化为0（dp[0][0] + prices[0]），dp[0][3]初始化为0</p><ol start="4"><li>遍历顺序</li></ol><p>​        i范围(1, n) 遍历每天</p><ol start="5"><li>举例</li></ol><p><img src="https://cdn.lthero.cn/post_images/course/ML2021032317451040.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/2021032317451040.png" alt="img"></p><p>最后结果是取 状态二，状态三，和状态四的最大值，不少同学会把状态四忘了，状态四是冷冻期，最后一天如果是冷冻期也可能是最大值。</p><h2 id="动态规划代码">动态规划代码</h2><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"></span><br><span class="line">        L = <span class="built_in">len</span>(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>] * <span class="number">4</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(L)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>((dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i], dp[i - <span class="number">1</span>][<span class="number">3</span>] - prices[i]))</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>] )</span><br><span class="line">            dp[i][<span class="number">2</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]</span><br><span class="line">            dp[i][<span class="number">3</span>] = dp[i - <span class="number">1</span>][<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回最后一天里最大利润，因为不确定哪个值会是最大的，所以直接返回状态1，2，3里最大的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[-<span class="number">1</span>][<span class="number">1</span>:])</span><br></pre></td></tr></table></figure><h1 id="714-买卖股票的最佳时机含手续费">714. 买卖股票的最佳时机含手续费</h1><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/</a></p><p>给定一个整数数组 <code>prices</code>，其中 <code>prices[i]</code>表示第 <code>i</code> 天的股票价格 ；整数 <code>fee</code> 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p>**注意：**这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [1, 3, 2, 8, 4, 9], fee = 2</span><br><span class="line">输出：8</span><br><span class="line">解释：能够达到的最大利润:  </span><br><span class="line">在此处买入 prices[0] = 1</span><br><span class="line">在此处卖出 prices[3] = 8</span><br><span class="line">在此处买入 prices[4] = 4</span><br><span class="line">在此处卖出 prices[5] = 9</span><br><span class="line">总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [1,3,7,5,10,3], fee = 3</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 5 * 104</code></li><li><code>1 &lt;= prices[i] &lt; 5 * 104</code></li><li><code>0 &lt;= fee &lt; 5 * 104</code></li></ul><h2 id="动态规划思路">动态规划思路</h2><p>本题在<code>122. 买卖股票最佳时机II</code> 基础上实现，<strong>只要在卖出时减去fee即可</strong></p><ol><li>dp下标与含义</li></ol><p>dp[i][0]表示买入</p><p>dp[i][1]表示卖出</p><ol start="2"><li>递推公式</li></ol><p>第i天， <strong>考虑</strong>买入</p><p>​如果不买入第i天的股票，则dp[i][0] = dp[i - 1][0]</p><p>​如果买入第i天的股票， 则dp[i][0] = dp[i - 1][1] - prices[i]</p><p>​所以dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i])</p><p>第i天，<strong>考虑</strong>卖出</p><p>​如果不卖出持有的股票，则dp[i][1] = dp[i - 1][1]</p><p>​如果卖出持有的股票，则dp[i][1] = dp[i - 1][0] + prices[i]（或者dp[i][0] + prices[i] )</p><p>​所以dp[i][1] = max(dp[i - 1][1], dp[i][0] + prices[i])</p><ol start="3"><li>初始化</li></ol><p>将第一天的dp[0][0]初始化为-prices[0]，因为先买第一支股票，并且第一次买初始化资金为0</p><ol start="4"><li>遍历顺序</li></ol><p>i从第1天到第n天</p><h2 id="动态规划代码">动态规划代码</h2><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>], fee: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 每次在卖的时候把手续费算上</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 每次只能卖一只股票，但不限制次数，使用两个状态即可</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># dp下标与含义，dp[i][0]表示买入，dp[i][1]表示卖出</span></span><br><span class="line">        L = <span class="built_in">len</span>(prices)</span><br><span class="line"></span><br><span class="line">        dp = [[<span class="number">0</span>] * <span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(L)]</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L):</span><br><span class="line">            <span class="comment"># 买入</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i])</span><br><span class="line">            <span class="comment"># 卖出时需要减去费用</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i][<span class="number">0</span>] + prices[i]  - fee)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h1 id="股票问题总结">股票问题总结</h1><ul><li><a href="https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html">动态规划：121.买卖股票的最佳时机</a></li><li><a href="https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html">动态规划：122.买卖股票的最佳时机II</a></li><li><a href="https://programmercarl.com/0123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.html">动态规划：123.买卖股票的最佳时机III</a></li><li><a href="https://programmercarl.com/0188.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV.html">动态规划：188.买卖股票的最佳时机IV</a></li><li><a href="https://programmercarl.com/0309.%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F.html">动态规划：309.最佳买卖股票时机含冷冻期</a></li><li><a href="https://programmercarl.com/0714.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html">动态规划：714.买卖股票的最佳时机含手续费</a></li></ul><h2 id="卖股票的最佳时机">卖股票的最佳时机</h2><p>动态规划：121.买卖股票的最佳时机，<strong>股票只能买卖一次，问最大利润</strong>。</p><p>【贪心解法】</p><p>取最左最小值，取最右最大值，那么得到的差值就是最大利润，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> low = INT_MAX;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            low = <span class="built_in">min</span>(low, prices[i]);  <span class="comment">// 取最左最小价格</span></span><br><span class="line">            result = <span class="built_in">max</span>(result, prices[i] - low); <span class="comment">// 直接取最大区间利润</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>【动态规划】</p><ul><li>dp[i][0] 表示第i天持有股票所得现金。</li><li>dp[i][1] 表示第i天不持有股票所得现金。</li></ul><p>如果第i天持有股票即dp[i][0]， 那么可以由两个状态推出来</p><ul><li>第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1][0]</li><li>第i天买入股票，所得现金就是买入今天的股票后所得现金即：-prices[i] 所以dp[i][0] = max(dp[i - 1][0], -prices[i]);</li></ul><p>如果第i天不持有股票即dp[i][1]， 也可以由两个状态推出来</p><ul><li>第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1][1]</li><li>第i天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：prices[i] + dp[i - 1][0] 所以dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);</li></ul><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本一</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(len, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] -= prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], -prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], prices[i] + dp[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><p>使用滚动数组，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本二</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>)); <span class="comment">// 注意这里只开辟了一个2 * 2大小的二维数组</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] -= prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i % <span class="number">2</span>][<span class="number">0</span>] = <span class="built_in">max</span>(dp[(i - <span class="number">1</span>) % <span class="number">2</span>][<span class="number">0</span>], -prices[i]);</span><br><span class="line">            dp[i % <span class="number">2</span>][<span class="number">1</span>] = <span class="built_in">max</span>(dp[(i - <span class="number">1</span>) % <span class="number">2</span>][<span class="number">1</span>], prices[i] + dp[(i - <span class="number">1</span>) % <span class="number">2</span>][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[(len - <span class="number">1</span>) % <span class="number">2</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="买卖股票的最佳时机ii">买卖股票的最佳时机II</h2><p><a href="https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html">动态规划：122.买卖股票的最佳时机II </a>可以多次买卖股票，问最大收益。</p><p>【贪心解法】</p><p>收集每天的正利润便可，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            result += <span class="built_in">max</span>(prices[i] - prices[i - <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p>【动态规划】</p><p>dp数组定义：</p><ul><li>dp[i][0] 表示第i天持有股票所得现金</li><li>dp[i][1] 表示第i天不持有股票所得最多现金</li></ul><p>如果第i天持有股票即dp[i][0]， 那么可以由两个状态推出来</p><ul><li>第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1][0]</li><li>第i天买入股票，所得现金就是昨天不持有股票的所得现金减去 今天的股票价格 即：dp[i - 1][1] - prices[i]</li></ul><p><strong>注意这里和 121. 买卖股票的最佳时机 唯一不同的地方，就是推导dp[i][0]的时候，第i天买入股票的情况</strong>。</p><p>在121. 买卖股票的最佳时机 中，因为股票全程只能买卖一次，所以如果买入股票，那么第i天持有股票即dp[i][0]一定就是 -prices[i]。</p><p>而本题，因为一只股票可以买卖多次，所以当第i天买入股票的时候，<code>所持有的现金可能有之前买卖过的利润</code>。</p><p>代码如下：（注意代码中的注释，标记了和121.买卖股票的最佳时机唯一不同的地方）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(len, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] -= prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]); <span class="comment">// 注意这里是和121. 买卖股票的最佳时机唯一不同的地方。</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="买卖股票的最佳时机iii">买卖股票的最佳时机III</h2><p><a href="https://programmercarl.com/0123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.html">动态规划：123.买卖股票的最佳时机III </a>最多买卖两次，问最大收益。</p><p>【动态规划】</p><p>一天一共就有五个状态，</p><ol><li>没有操作</li><li>第一次买入</li><li>第一次卖出</li><li>第二次买入</li><li>第二次卖出</li></ol><p>dp[i][j]中 i表示第i天，j为 [0 - 4] 五个状态，dp[i][j]表示第i天状态j所剩最大现金。</p><p>达到dp[i][1]状态，有两个具体操作：</p><ul><li>操作一：第i天买入股票了，那么dp[i][1] = dp[i-1][0] - prices[i]</li><li>操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i][1] = dp[i - 1][1]</li></ul><p>dp[i][1] = max(dp[i-1][0] - prices[i], dp[i - 1][1]);</p><p>同理dp[i][2]也有两个操作：</p><ul><li>操作一：第i天卖出股票了，那么dp[i][2] = dp[i - 1][1] + prices[i]</li><li>操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i][2] = dp[i - 1][2]</li></ul><p>所以dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2])</p><p>同理可推出剩下状态部分：</p><p>dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);</p><p>dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本一</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">3</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">2</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">3</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">3</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">4</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">4</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n × 5)</li></ul><p>当然，大家可以看到力扣官方题解里的一种优化空间写法，我这里给出对应的C++版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本二</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">5</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">3</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dp[<span class="number">1</span>] = <span class="built_in">max</span>(dp[<span class="number">1</span>], dp[<span class="number">0</span>] - prices[i]);</span><br><span class="line">            dp[<span class="number">2</span>] = <span class="built_in">max</span>(dp[<span class="number">2</span>], dp[<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[<span class="number">3</span>] = <span class="built_in">max</span>(dp[<span class="number">3</span>], dp[<span class="number">2</span>] - prices[i]);</span><br><span class="line">            dp[<span class="number">4</span>] = <span class="built_in">max</span>(dp[<span class="number">4</span>], dp[<span class="number">3</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p><strong>这种写法看上去简单，其实思路很绕，不建议大家这么写，这么思考，很容易把自己绕进去！</strong> 对于本题，把版本一的写法研究明白，足以！</p><h2 id="买卖股票的最佳时机iv">买卖股票的最佳时机IV</h2><p><a href="https://programmercarl.com/0188.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV.html">动态规划：188.买卖股票的最佳时机IV </a>最多买卖k笔交易，问最大收益。</p><p>使用二维数组 dp[i][j] ：第i天的状态为j，所剩下的最大现金是dp[i][j]</p><p>j的状态表示为：</p><ul><li>0 表示不操作</li><li>1 第一次买入</li><li>2 第一次卖出</li><li>3 第二次买入</li><li>4 第二次卖出</li><li>…</li></ul><p><strong>除了0以外，偶数就是卖出，奇数就是买入</strong>。</p><ol><li>确定递推公式</li></ol><p>达到dp[i][1]状态，有两个具体操作：</p><ul><li>操作一：第i天买入股票了，那么dp[i][1] = dp[i - 1][0] - prices[i]</li><li>操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i][1] = dp[i - 1][1]</li></ul><p>dp[i][1] = max(dp[i - 1][0] - prices[i], dp[i - 1][1]);</p><p>同理dp[i][2]也有两个操作：</p><ul><li>操作一：第i天卖出股票了，那么dp[i][2] = dp[i - 1][1] + prices[i]</li><li>操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i][2] = dp[i - 1][2]</li></ul><p>dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2])</p><p>同理可以类比剩下的状态，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span> * k - <span class="number">1</span>; j += <span class="number">2</span>) &#123;</span><br><span class="line">    dp[i][j + <span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j + <span class="number">1</span>], dp[i - <span class="number">1</span>][j] - prices[i]);</span><br><span class="line">    dp[i][j + <span class="number">2</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j + <span class="number">2</span>], dp[i - <span class="number">1</span>][j + <span class="number">1</span>] + prices[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (prices.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span> * k + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; <span class="number">2</span> * k; j += <span class="number">2</span>) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span> * k - <span class="number">1</span>; j += <span class="number">2</span>) &#123;</span><br><span class="line">                dp[i][j + <span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j + <span class="number">1</span>], dp[i - <span class="number">1</span>][j] - prices[i]);</span><br><span class="line">                dp[i][j + <span class="number">2</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j + <span class="number">2</span>], dp[i - <span class="number">1</span>][j + <span class="number">1</span>] + prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">2</span> * k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然有的解法是定义一个三维数组dp[i][j][k]，第i天，第j次买卖，k表示买还是卖的状态，从定义上来讲是比较直观。但感觉三维数组操作起来有些麻烦，直接用二维数组来模拟三维数组的情况，代码看起来也清爽一些。</p><h2 id="最佳买卖股票时机含冷冻期">最佳买卖股票时机含冷冻期</h2><p><a href="https://programmercarl.com/0309.%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F.html">动态规划：309.最佳买卖股票时机含冷冻期 </a>可以多次买卖但每次卖出有冷冻期1天。</p><p>相对于<a href="https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html">动态规划：122.买卖股票的最佳时机II </a>，本题加上了一个冷冻期。</p><p>在<a href="https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html">动态规划：122.买卖股票的最佳时机II </a>中有两个状态，持有股票后的最多现金，和不持有股票的最多现金。本题则可以花费为四个状态</p><p>dp[i][j]：第i天状态为j，所剩的最多现金为dp[i][j]。</p><p>具体可以区分出如下四个状态：</p><ul><li>状态一：买入股票状态（今天买入股票，或者是之前就买入了股票然后没有操作）</li><li>卖出股票状态，这里就有两种卖出股票状态<ul><li>状态二：两天前就卖出了股票，度过了冷冻期，一直没操作，今天保持卖出股票状态</li><li>状态三：今天卖出了股票</li></ul></li><li>状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！</li></ul><p>达到买入股票状态（状态一）即：dp[i][0]，有两个具体操作：</p><ul><li>操作一：前一天就是持有股票状态（状态一），dp[i][0] = dp[i - 1][0]</li><li>操作二：今天买入了，有两种情况<ul><li>前一天是冷冻期（状态四），dp[i - 1][3] - prices[i]</li><li>前一天是保持卖出股票状态（状态二），dp[i - 1][1] - prices[i]</li></ul></li></ul><p>所以操作二取最大值，即：max(dp[i - 1][3], dp[i - 1][1]) - prices[i]</p><p>那么dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3], dp[i - 1][1]) - prices[i]);</p><p>达到保持卖出股票状态（状态二）即：dp[i][1]，有两个具体操作：</p><ul><li>操作一：前一天就是状态二</li><li>操作二：前一天是冷冻期（状态四）</li></ul><p>dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);</p><p>达到今天就卖出股票状态（状态三），即：dp[i][2] ，只有一个操作：</p><ul><li>操作一：昨天一定是买入股票状态（状态一），今天卖出</li></ul><p>即：dp[i][2] = dp[i - 1][0] + prices[i];</p><p>达到冷冻期状态（状态四），即：dp[i][3]，只有一个操作：</p><ul><li>操作一：昨天卖出了股票（状态三）</li></ul><p>p[i][3] = dp[i - 1][2];</p><p>综上分析，递推代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">3</span>]- prices[i], dp[i - <span class="number">1</span>][<span class="number">1</span>]) - prices[i];</span><br><span class="line">dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>]);</span><br><span class="line">dp[i][<span class="number">2</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line">dp[i][<span class="number">3</span>] = dp[i - <span class="number">1</span>][<span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>整体代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">4</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] -= prices[<span class="number">0</span>]; <span class="comment">// 持股票</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">3</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]) - prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line">            dp[i][<span class="number">3</span>] = dp[i - <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[n - <span class="number">1</span>][<span class="number">3</span>],<span class="built_in">max</span>(dp[n - <span class="number">1</span>][<span class="number">1</span>], dp[n - <span class="number">1</span>][<span class="number">2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="买卖股票的最佳时机含手续费">买卖股票的最佳时机含手续费</h2><p><a href="https://programmercarl.com/0714.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html">动态规划：714.买卖股票的最佳时机含手续费 </a>可以多次买卖，但每次有手续费。</p><p>相对于<a href="https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html">动态规划：122.买卖股票的最佳时机II </a>，本题只需要在计算卖出操作的时候减去手续费就可以了，代码几乎是一样的。</p><p>唯一差别在于递推公式部分，所以本篇也就不按照动规五部曲详细讲解了，主要讲解一下递推公式部分。</p><p>这里重申一下dp数组的含义：</p><p>dp[i][0] 表示第i天持有股票所省最多现金。 dp[i][1] 表示第i天不持有股票所得最多现金</p><p>如果第i天持有股票即dp[i][0]， 那么可以由两个状态推出来</p><ul><li>第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1][0]</li><li>第i天买入股票，所得现金就是昨天不持有股票的所得现金减去 今天的股票价格 即：dp[i - 1][1] - prices[i]</li></ul><p>所以：dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);</p><p>在来看看如果第i天不持有股票即dp[i][1]的情况， 依然可以由两个状态推出来</p><ul><li>第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1][1]</li><li>第i天卖出股票，所得现金就是按照今天股票价格卖出后所得现金，<strong>注意这里需要有手续费了</strong>即：dp[i - 1][0] + prices[i] - fee</li></ul><p>所以：dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee);</p><p><strong>本题和<a href="https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html">动态规划：122.买卖股票的最佳时机II </a>的区别就是这里需要多一个减去手续费的操作</strong>。</p><p>以上分析完毕，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices, <span class="type">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] -= prices[<span class="number">0</span>]; <span class="comment">// 持股票</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i] - fee);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[n - <span class="number">1</span>][<span class="number">0</span>], dp[n - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday42动态规划part09&quot;&gt;LeetCodeCampsDay42动态规划part09&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;买卖股票的另类问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;309-买卖股票的最佳时机含冷冻</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay41动态规划part08</title>
    <link href="https://blog.lthero.cn/2025/08/06/LeetCodeCampsDay41/"/>
    <id>https://blog.lthero.cn/2025/08/06/LeetCodeCampsDay41/</id>
    <published>2025-08-06T03:27:48.000Z</published>
    <updated>2025-08-06T12:27:56.928Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday41动态规划part08">LeetCodeCampsDay41动态规划part08</h1><blockquote><p>股票问题从入门到通关</p></blockquote><h1 id="121-买卖股票的最佳时机">121. 买卖股票的最佳时机</h1><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/</a></p><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [7,6,4,3,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 105</code></li><li><code>0 &lt;= prices[i] &lt;= 104</code></li></ul><h2 id="动态规划思路">动态规划思路</h2><ol><li>dp数组含义</li></ol><p>dp[i][0]表示第i天<strong>持有股票</strong>所得最多现金</p><p>dp[i][1]表示第i天<strong>没有股票</strong>所得最多现金</p><ol start="2"><li>递推公式</li></ol><p>如果第i天持有股票，则需要判断持有的股票是否有更低的买入价格（其中-prices[i]就是成本价格dp[i][0]）</p><p><code>dp[i][0] = max(dp[i - 1][0], -prices[i])  </code></p><ul><li>dp[i - 1][0]是之前买了股票后剩下的钱，-prices[i]是买了当日股票剩下的钱</li></ul><p>如果第i天没有股票，则那天要卖股票</p><p><code>dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]) </code></p><ul><li>dp[i - 1][1] 是之前卖股票更挣钱，而dp[i - 1][0] + prices[i] 今天的行情不错，股票卖掉，血赚prices[i]块钱, dp[i-1][0]是我用低价买入花的钱（这里将dp[i - 1][0]换成dp[i][0]也可以，并且可能更好理解）</li></ul><ol start="3"><li>初始化</li></ol><p>仅将第0天的持有股票初始化为-prices[0]，表示无论如何一定要买一支股票</p><ol start="4"><li>遍历顺序</li></ol><p>遍历顺序，i遍历卖出时间（范围1到n）</p><h2 id="动态规划代码">动态规划代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        L = <span class="built_in">len</span>(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (<span class="number">2</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(L)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(dp)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], -prices[i])</span><br><span class="line">            <span class="comment"># 这里将dp[i - 1][0] + prices[i]改成dp[i][0]也可以，可以把dp[i][0]理解成当天的投入成本、prices[i]是当天卖价，dp[i][1]是当天利润</span></span><br><span class="line">            <span class="comment"># 为了将当天利润最大化，比较前一天利润与当天利润，取最大值</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i][<span class="number">0</span>] + prices[i])</span><br><span class="line">        <span class="built_in">print</span>(dp)</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h1 id="122-买卖股票的最佳时机-ii">122. 买卖股票的最佳时机 II</h1><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/</a></p><p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p><p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p><p>返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [7,1,5,3,6,4]</span><br><span class="line">输出：7</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。</span><br><span class="line">随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3。</span><br><span class="line">最大总利润为 4 + 3 = 7 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [1,2,3,4,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。</span><br><span class="line">最大总利润为 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [7,6,4,3,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 3 * 104</code></li><li><code>0 &lt;= prices[i] &lt;= 104</code></li></ul><h2 id="动态规划思路一">动态规划思路一</h2><p>需要有双指针，一个j指向某支股票买入天数，另一个i遍历所有售出天数；</p><h2 id="动态规划代码一">动态规划代码一</h2><p>通过 200 / 202 个通过的测试用例</p><p>超时了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># dp[i] = max(dp[i - 1], dp[j] + prices[i] - prices[j])</span></span><br><span class="line">        L = <span class="built_in">len</span>(prices)</span><br><span class="line">        dp = [<span class="number">0</span>] * (L + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], dp[j] + prices[i] - prices[j])</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(dp)</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">2</span>]</span><br></pre></td></tr></table></figure><h2 id="动态规划思路二">动态规划思路二</h2><p>本题和[121. 买卖股票的最佳时机的唯一区别是本题股票可以<code>买卖多次了</code>（注意只有一只股票，所以再次购买前要出售掉之前的股票）</p><p><strong>在动规五部曲中，这个区别主要是体现在递推公式上，其他都和<a href="https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html">121. 买卖股票的最佳时机</a>一样的</strong>。</p><ol><li>dp数组含义</li></ol><p>dp[i][0]表示第i天<strong>持有股票</strong>所得最多现金</p><p>dp[i][1]表示第i天<strong>没有股票</strong>所得最多现金</p><ol start="2"><li>递推公式</li></ol><p>如果第i天持有股票，则需要判断持有的股票是否有更低的买入价格（其中-prices[i]就是成本价格dp[i][0]）</p><p><code>dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i])</code></p><ul><li>dp[i - 1][0]是之前买了股票后剩下的钱，dp[i - 1][1] - prices[i]是前一次卖了股票后剩下的钱，去买当日股票剩下的钱，还是看哪次剩下的钱更多</li></ul><p>如果第i天没有股票，则那天要卖股票</p><p><code>dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])</code></p><ul><li>dp[i - 1][1] 是之前卖股票更挣钱，而dp[i - 1][0] + prices[i] 今天的行情不错，股票卖掉，血赚prices[i]块钱, dp[i-1][0]是我用低价买入花的钱（这里将dp[i - 1][0]换成dp[i][0]也可以，并且可能更好理解）</li></ul><ol start="3"><li>初始化</li></ol><p>仅将第0天的持有股票初始化为-prices[0]，表示无论如何一定要买一支股票</p><p>dp[0][0] = -prices[0]</p><p>dp[0][1] = 0 (表示第一天剩下0元)</p><ol start="4"><li>遍历顺序</li></ol><p>遍历顺序，i遍历卖出时间（范围1到n）</p><h2 id="动态规划代码二">动态规划代码二</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        L = <span class="built_in">len</span>(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (<span class="number">2</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(L)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L):</span><br><span class="line">            <span class="comment"># 因为一只股票可以买卖多次，所以当第i天买入股票的时候，所持有的现金可能有之前买卖过的利润。</span></span><br><span class="line">            <span class="comment"># 那么第i天持有股票即dp[i][0]，如果是第i天买入股票，所得现金就是 &quot;昨天不持有股票的所得现金 减去 今天的股票价格&quot; 即：dp[i - 1][1] - prices[i]。</span></span><br><span class="line">            <span class="comment"># dp[i - 1][1]理解成前一天卖出股票后剩下的所有钱</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i])</span><br><span class="line">            <span class="comment"># 这里的dp[i][0]理解成第i天买入股票后剩下的所有钱</span></span><br><span class="line">            <span class="comment"># 使用dp[i - 1][0]也是可以的</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i][<span class="number">0</span>] + prices[i])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>把这里的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i])</span><br></pre></td></tr></table></figure><p>修改成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][0] = max(dp[i - 1][0], 0 - prices[i])</span><br></pre></td></tr></table></figure><p>则变成了只能一只股票只买卖一次的情况</p><h1 id="123-买卖股票的最佳时机-iii">123. 买卖股票的最佳时机 III</h1><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/</a></p><p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p><p>**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [3,3,5,0,0,3,1,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。</span><br><span class="line">     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [1,2,3,4,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   </span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   </span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [7,6,4,3,1] </span><br><span class="line">输出：0 </span><br><span class="line">解释：在这个情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 105</code></li><li><code>0 &lt;= prices[i] &lt;= 105</code></li></ul><h2 id="动态规划思路">动态规划思路</h2><p>本题和[121. 买卖股票的最佳时机的唯一区别是本题股票可以最多操作两次，指可以买两支不同的股票</p><p>在动规五部曲中，这个区别主要是体现在递推公式上</p><ol><li>dp数组含义</li></ol><p>dp[i][0]表示第i天<strong>第一次操作持有股票</strong>所得最多现金，<code>表示第i天才开始第一次操作，在此之前的天不进行任何操作！</code></p><p>dp[i][1]表示第i天<strong>第一次操作没有股票</strong>所得最多现金</p><p>dp[i][2]表示第i天<strong>第二次操作持有股票</strong>所得最多现金</p><p>dp[i][3]表示第i天<strong>第二次操作没有股票</strong>所得最多现金</p><ol start="2"><li>递推公式</li></ol><p>第i天，第一次买入，则需要判断持有的股票是否有更低的买入价格（其中-prices[i]就是成本价格dp[i][0]）</p><p><code>dp[i][0] = max(dp[i - 1][1], - prices[i])</code></p><ul><li>dp[i - 1][0]是之前买了股票后剩下的钱，- prices[i]是买当日股票剩下的钱，不管是第几天，只要是第一次操作，初始的钱一定为0啊</li></ul><p>第i天，第一次卖出</p><p><code>dp[i][1] = max(dp[i - 1][2], dp[i][0] + prices[i])</code></p><ul><li>dp[i - 1][2] 是之前的i-1天卖股票挣的钱</li><li>dp[i - 1][1] + prices[i] 表示今天的行情不错，股票卖掉，血赚prices[i]块钱, dp[i-1][0]是我用低价买入花的钱（这里将dp[i - 1][0]换成dp[i][0]也可以，并且可能更好理解，表示当天买了股票后剩下的钱）</li></ul><p>第i天，第二次买入，</p><p><code>dp[i][2] = max(dp[i - 1][3], dp[i - 1][1] - prices[i])</code></p><ul><li>dp[i - 1][3]是之前买了股票后剩下的钱</li><li>dp[i - 1][1] - prices[i]是买当日股票剩下的钱，其中dp[i - 1][1]为第i-1天的第二次操作后剩下的钱</li></ul><p>第i天，第二次卖出</p><p><code>dp[i][3] = max(dp[i - 1][4], dp[i][2] + prices[i])</code></p><ul><li>dp[i - 1][4] 是之前的i-1天第二次操作后挣的钱</li><li>dp[i - 1][2] + prices[i] 表示今天的行情不错，股票卖掉，血赚prices[i]块钱, dp[i-1][2]是我用低价买入花的钱（这里将dp[i - 1][2]换成dp[i][2]也可以，并且可能更好理解，表示当天买了股票后剩下的钱）</li></ul><ol start="3"><li>初始化</li></ol><p>仅将第0天的持有股票初始化为-prices[0]，表示无论如何一定要买一支股票</p><ol start="4"><li>遍历顺序</li></ol><p>遍历顺序，i遍历卖出时间（范围1到n）</p><h2 id="动态规划代码">动态规划代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 和前两题目相比，本题一共可以买、卖再次</span></span><br><span class="line">        <span class="comment"># 所以dp数组的状态则不是只有一次买入&amp;卖出两种状态</span></span><br><span class="line">        <span class="comment"># 而dp数组应该有4种状态</span></span><br><span class="line">        <span class="comment">#  1 第一次买入  2、第一次卖出   3、 第二次买入   4、 第二次不卖出</span></span><br><span class="line">        <span class="comment"># 而dp[i][j] 的i表示第i天而j表示上面提到的四种状态，而dp[i][j]表示第i天第j状态的最大现金</span></span><br><span class="line"></span><br><span class="line">        dp = [[<span class="number">0</span>] * <span class="number">4</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices))]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 递推公式</span></span><br><span class="line">        <span class="comment"># 第i天第一次买入, </span></span><br><span class="line">        <span class="comment">#  dp[i][0] = max(dp[i - 1][0], - prices[i])</span></span><br><span class="line">        <span class="comment"># 第i天第一次卖出，</span></span><br><span class="line">        <span class="comment">#  dp[i][1] = max(dp[i - 1][1], dp[i][0] + prices[i])</span></span><br><span class="line">        <span class="comment"># 第i天第二次买入</span></span><br><span class="line">        <span class="comment">#  dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] - prices[i])</span></span><br><span class="line">        <span class="comment"># 第i天第二次卖出</span></span><br><span class="line">        <span class="comment">#  dp[i][3] = max(dp[i - 1][3], dp[i][2] + prices[i])</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># dp初始化</span></span><br><span class="line">        <span class="comment"># dp[0][0]为-prices[0]，dp[0][1]为0，dp[0][2]为-prices[0]，dp[0][3]为0，</span></span><br><span class="line">        <span class="comment"># 这里的-prices也可以认为刚开始剩下的钱是0，</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">0</span>][<span class="number">2</span>] = -prices[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(prices)):</span><br><span class="line">            <span class="comment"># 表示是买入状态</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], - prices[i])</span><br><span class="line">            <span class="comment"># 表示为卖出状态</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i][<span class="number">0</span>] + prices[i])</span><br><span class="line">            <span class="comment"># </span></span><br><span class="line">            dp[i][<span class="number">2</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">2</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i])</span><br><span class="line">            dp[i][<span class="number">3</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">3</span>], dp[i][<span class="number">2</span>] + prices[i])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h1 id="188-买卖股票的最佳时机-iv">188. 买卖股票的最佳时机 IV</h1><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/</a></p><p>给你一个整数数组 <code>prices</code> 和一个整数 <code>k</code> ，其中 <code>prices[i]</code> 是某支给定的股票在第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <code>k</code> 笔交易。也就是说，你最多可以买 <code>k</code> 次，卖 <code>k</code> 次。</p><p>**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：k = 2, prices = [2,4,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：k = 2, prices = [3,2,6,5,0,3]</span><br><span class="line">输出：7</span><br><span class="line">解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。</span><br><span class="line">     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= k &lt;= 100</code></li><li><code>1 &lt;= prices.length &lt;= 1000</code></li><li><code>0 &lt;= prices[i] &lt;= 1000</code></li></ul><h2 id="动态规划思路">动态规划思路</h2><p>在动规五部曲中，这个区别主要是体现在递推公式上</p><ol><li>dp数组含义</li></ol><p>dp[i][0]表示第i天<strong>第一次操作持有股票</strong>所得最多现金，<code>表示第i天才开始第一次操作，在此之前的天不进行任何操作！</code></p><p>dp[i][1]表示第i天<strong>第一次操作没有股票</strong>所得最多现金</p><p>dp[i][2]表示第i天<strong>第二次操作持有股票</strong>所得最多现金</p><p>dp[i][3]表示第i天<strong>第二次操作没有股票</strong>所得最多现金</p><p>dp[i][4]表示第i天<strong>第三次操作持有股票</strong>所得最多现金</p><p>……</p><p>数组开的大小为dp[len(prices)][ 2 * k]， 因为每次操作都有买入与卖出两种类型</p><ol start="2"><li>递推公式</li></ol><p>第i天，第一次<strong>考虑</strong>买入</p><p><code>dp[i][j] = max(dp[i - 1][j], - prices[i])</code></p><ul><li>dp[i - 1][j]是上一次买了股票后剩下的钱</li><li>-prices[i]是买当日股票剩下的钱，不管是第几天，如果是第一次买入，则初始资金一定为0</li><li>只要比较下两者剩下的钱，就知道第i天是否适合作为第一次买入</li></ul><p>第i天，非第一次<strong>考虑</strong>买入</p><p><code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] - prices[i])</code></p><ul><li>dp[i - 1][0]是上一次买了股票后剩下的钱</li><li>dp[i - 1][j - 1] - prices[i]是买当日股票剩下的钱，如果不是第一次买入，则初始资金为上一次卖出后的钱dp[i - 1][j - 1（i-1为上一次，j-1为卖出）</li><li>只要比较下两者剩下的钱，就知道第i天是否适合作为非第一次买入</li></ul><p>第i天，<strong>考虑</strong>卖出</p><p><code>dp[i][j] = max(dp[i - 1][j], dp[i][j - 1] + prices[i])</code></p><ul><li>dp[i-1][j]为上一次卖出剩下的钱</li><li>dp[i][j - 1] + prices[i]为本次卖出剩下的钱，这里换成dp[i - 1][j - 1] 也是正确的，则表示用上一次买入后剩下的钱加上这次卖出，得到了第i天第j次卖出后剩下的钱</li><li>只要比较下两者剩下的钱，就知道第i天是否适合卖出，如果不卖出则继续保持dp[i-1][j]的金额</li></ul><ol start="3"><li>初始化</li></ol><p>仅将第0天的持有股票初始化为-prices[0]，表示无论如何一定要买一支股票</p><ol start="4"><li>遍历顺序</li></ol><p>遍历顺序，i遍历卖出时间（范围1到n），j遍历操作的次数（范围从0到2k-1）</p><p>如果j是偶数则是买入操作，再判断是否是第一次买入</p><p>如果j是奇数则是卖出操作，</p><h2 id="动态规划代码">动态规划代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, k: <span class="built_in">int</span>, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        L = <span class="built_in">len</span>(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>] * <span class="number">2</span> * k <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(L)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span> * k):</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                dp[<span class="number">0</span>][i] = -prices[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span> * k):</span><br><span class="line">                <span class="comment"># 买入操作</span></span><br><span class="line">                <span class="keyword">if</span> j % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                  <span class="comment"># 如果是第一次买入，则初始资金一定为0</span></span><br><span class="line">                    <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">                      <span class="comment"># dp[i-1][j]为上一次买入剩下的钱，-prices[i]为本次买入剩下的钱</span></span><br><span class="line">                        dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], -prices[i])</span><br><span class="line">                    <span class="comment"># 如果不是第一次买入，则初始资金为上一次卖出后的钱（i-1为上一次，j-1为卖出）</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                      <span class="comment"># dp[i-1][j]为上一次买入剩下的钱，dp[i - 1][j - 1]-prices[i]为本次买入剩下的钱</span></span><br><span class="line">                        dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] - prices[i])</span><br><span class="line">                <span class="comment"># 卖出操作</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                  <span class="comment"># dp[i-1][j]为上一次卖出剩下的钱， dp[i][j - 1] + prices[i]为本次卖出剩下的钱</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>] + prices[i])</span><br><span class="line">        <span class="built_in">print</span>(dp)</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday41动态规划part08&quot;&gt;LeetCodeCampsDay41动态规划part08&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;股票问题从入门到通关&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;121-买卖股票的最佳时机&quot;&gt;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay39动态规划part07</title>
    <link href="https://blog.lthero.cn/2025/08/05/LeetCodeCampsDay39/"/>
    <id>https://blog.lthero.cn/2025/08/05/LeetCodeCampsDay39/</id>
    <published>2025-08-05T14:34:09.000Z</published>
    <updated>2025-08-06T02:37:43.213Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday39动态规划part07">LeetCodeCampsDay39动态规划part07</h1><blockquote></blockquote><h1 id="198-打家劫舍">198. 打家劫舍</h1><p><a href="https://leetcode.cn/problems/house-robber/">https://leetcode.cn/problems/house-robber/</a></p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[2,7,9,3,1]</span><br><span class="line">输出：12</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。</span><br><span class="line">     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 400</code></li></ul><h2 id="动态规划思路">动态规划思路</h2><p>明显是个01背包问题</p><ol><li><p>dp数组[i]表示拿到第i家后一共有dp[i]金额</p></li><li><p>递推公式：每家只有能拿和不能拿，如果能拿，则dp[i]=dp[i - 2] + val[i]；如果不能拿则dp[i]=dp[i-1]；所以需要判断拿与不拿的最大值</p></li><li><p>初始化，dp[n + 1]全初始化为0，但dp[1]初始化为nums[0]，因为至少需要抢一家吧；（其实可以把dp[2]也初始化了，赋值为nums[1]，但也可以不做，在遍历时会自动赋值的）</p></li><li><p>遍历顺序，只用一层循环，只遍历每家</p></li><li><p>举例：</p></li><li><p>nums = [   2, 7, 9,  3,  1]</p><p>dp   = [0, 2, 0, 0,  0,  0]</p><p>dp   = [0, 2, 7, 11, 11, 12]</p></li></ol><h2 id="动态规划代码">动态规划代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 01背包问题，</span></span><br><span class="line">        <span class="comment"># dp数组[i]表示拿到第i家后一共有dp[i]金额</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 递推公式：</span></span><br><span class="line">        <span class="comment"># 每家只有能拿和不能拿，如果能拿，则dp[i]=max(dp[i-1], dp[i - 2] + val[i])</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># dp初始化</span></span><br><span class="line">        <span class="comment"># dp[n + 1]，刚开始全部初始化为0</span></span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [<span class="number">0</span>] * (L + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">1</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 遍历顺序: 只遍历物品就可以了吧</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, L + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 注意i-1才对应nums的下标</span></span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i - <span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 举例</span></span><br><span class="line">        <span class="comment"># nums = [   2, 7, 9,  3,  1]</span></span><br><span class="line">        <span class="comment"># dp   = [0, 2, 0, 0,  0,  0]</span></span><br><span class="line">        <span class="comment"># dp   = [0, 2, 7, 11, 11, 12]</span></span><br></pre></td></tr></table></figure><h1 id="213-打家劫舍-ii">213. 打家劫舍 II</h1><p><a href="https://leetcode.cn/problems/house-robber-ii/">https://leetcode.cn/problems/house-robber-ii/</a></p><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，今晚能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,3,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li></ul><h2 id="动态规划思路">动态规划思路</h2><p>这道题目和<a href="https://programmercarl.com/0198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.html">198.打家劫舍 (opens new window)</a>是差不多的，唯一区别就是成环了。</p><p>对于一个数组，成环的话主要有如下三种情况：</p><ul><li>情况一：考虑不包含首尾元素</li></ul><p><img src="https://cdn.lthero.cn/post_images/course/ML20210129160748643-20230310134000692.jpg" alt="213.打家劫舍II"></p><p><img src="https://file1.kamacoder.com/i/algo/20210129160748643-20230310134000692.jpg" alt="213.打家劫舍II"></p><ul><li>情况二：考虑包含首元素，不包含尾元素</li></ul><p><img src="https://cdn.lthero.cn/post_images/course/ML20210129160821374-20230310134003961.jpg" alt="213.打家劫舍II1"></p><p><img src="https://file1.kamacoder.com/i/algo/20210129160821374-20230310134003961.jpg" alt="213.打家劫舍II1"></p><ul><li>情况三：考虑包含尾元素，不包含首元素</li></ul><p><img src="https://cdn.lthero.cn/post_images/course/ML20210129160842491-20230310134008133.jpg" alt="213.打家劫舍II2"></p><p><img src="https://file1.kamacoder.com/i/algo/20210129160842491-20230310134008133.jpg" alt="213.打家劫舍II2"></p><p><strong>注意我这里用的是&quot;考虑&quot;</strong>，例如情况三，虽然是考虑包含尾元素，但不一定要选尾部元素！ 对于情况三，取nums[1] 和 nums[3]就是最大的。</p><blockquote><p>而情况二 和 情况三 都包含了情况一了，所以只考虑情况二和情况三就可以了。</p></blockquote><p>分析到这里，本题其实比较简单了。</p><p>剩下的和<a href="https://programmercarl.com/0198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.html">198.打家劫舍</a>就是一样的了。</p><h2 id="动态规划代码">动态规划代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 本题注意是围成一圈表示首尾相接，例如nums=[1, 2, 3]如果拿了3则不能拿1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 本题可以套用普通的打家I</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            L = <span class="built_in">len</span>(nums)</span><br><span class="line">            dp = [<span class="number">0</span>] * (L + <span class="number">1</span>)</span><br><span class="line">            dp[<span class="number">1</span>] = nums[<span class="number">0</span>]</span><br><span class="line">            <span class="comment"># 遍历顺序: 只遍历物品就可以了吧</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, L + <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 注意i-1才对应nums的下标</span></span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i - <span class="number">1</span>])</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        res1 = foo(nums[<span class="number">0</span>:-<span class="number">1</span>])</span><br><span class="line">        res2 = foo(nums[<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(res1, res2)</span><br></pre></td></tr></table></figure><h1 id="337-打家劫舍-iii">337. 打家劫舍 III</h1><p><a href="https://leetcode.cn/problems/house-robber-iii/">https://leetcode.cn/problems/house-robber-iii/</a></p><p>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 <code>root</code> 。</p><p>除了 <code>root</code> 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 <strong>两个直接相连的房子在同一天晚上被打劫</strong> ，房屋将自动报警。</p><p>给定二叉树的 <code>root</code> 。返回 <em><strong>在不触动警报的情况下</strong> ，小偷能够盗取的最高金额</em> 。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/10/rob1-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [3,2,3,null,3,null,1]</span><br><span class="line">输出: 7 </span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/10/rob2-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [3,4,5,1,3,null,1]</span><br><span class="line">输出: 9</span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 4 + 5 = 9</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树的节点数在 <code>[1, 104]</code> 范围内</li><li><code>0 &lt;= Node.val &lt;= 104</code></li></ul><h2 id="动态规划思路">动态规划思路</h2><blockquote><p>这道题目算是树形dp的入门题目，因为是在树上进行状态转移，我们在讲解二叉树的时候说过递归三部曲，那么下面我以递归三部曲为框架，其中融合动规五部曲的内容来进行讲解</p></blockquote><ol><li>确定递归函数的参数和返回值</li></ol><p>这里我们要求一个节点 偷与不偷的两个状态所得到的金钱，那么返回值就是一个长度为2的数组。</p><p>参数为当前节点，代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">robTree</span> (node: TreeNode) -&gt; <span class="type">Tuple</span>[<span class="built_in">int</span>]:</span><br></pre></td></tr></table></figure><p>其实这里的返回数组就是dp数组。</p><p>所以dp数组（dp table）以及下标的含义：<code>下标为0记录不偷该节点所得到的的最大金钱，下标为1记录偷该节点所得到的的最大金钱。</code></p><p>长度为2的数组怎么标记树中每个节点的状态呢？</p><p><strong>别忘了在递归的过程中，系统栈会保存每一层递归的参数</strong>。</p><ol start="2"><li>确定终止条件</li></ol><p>在遍历的过程中，如果遇到空节点的话，很明显，无论偷还是不偷都是0，所以就返回</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (cur == NULL) return vector&lt;int&gt;&#123;0, 0&#125;;</span><br></pre></td></tr></table></figure><p>这也相当于dp数组的初始化</p><ol start="3"><li>确定遍历顺序</li></ol><p>首先明确的是使用后序遍历。 因为要通过递归函数的返回值来做下一步计算。</p><p>通过递归左节点，得到左节点偷与不偷的金钱。</p><p>通过递归右节点，得到右节点偷与不偷的金钱。</p><p>代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下标0：不偷，下标1：偷</span></span><br><span class="line"><span class="comment"># 先遍历左、右子树</span></span><br><span class="line">resLeft = self.foo(node.left)</span><br><span class="line">resRight = self.foo(node.right)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li>确定单层递归的逻辑</li></ol><p>如果是偷当前节点，那么左右孩子就不能偷，val1 = cur-&gt;val + left[0] + right[0]; （<strong>如果对下标含义不理解就再回顾一下dp数组的含义</strong>）</p><p>如果不偷当前节点，那么左右孩子就可以偷，至于到底偷不偷一定是选一个最大的，所以：val2 = max(left[0], left[1]) + max(right[0], right[1]);</p><p>最后当前节点的状态就是(val1, val2); 即：{不偷当前节点得到的最大金钱，偷当前节点得到的最大金钱}</p><p>代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 再遍历中节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不偷root节点，则再考虑左、右子树分别的最大值</span></span><br><span class="line">val1 = <span class="built_in">max</span>(resLeft[<span class="number">0</span>], resLeft[<span class="number">1</span>]) + <span class="built_in">max</span>(resRight[<span class="number">0</span>], resRight[<span class="number">1</span>])</span><br><span class="line"><span class="comment">#  偷root节点，则不偷左、右子树</span></span><br><span class="line">val2 = node.val + resLeft[<span class="number">0</span>] + resRight[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (val1, val2)</span><br></pre></td></tr></table></figure><ol start="5"><li>举例推导dp数组</li></ol><p>以示例1为例，dp数组状态如下：（<strong>注意用后序遍历的方式推导</strong>）</p><p><img src="https://file1.kamacoder.com/i/algo/20230203110031.png" alt="img"></p><p><strong>最后头结点就是 取下标0 和 下标1的最大值就是偷得的最大金钱</strong>。</p><h2 id="动态规划代码">动态规划代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self, node: TreeNode</span>) -&gt; (<span class="built_in">int</span>):</span><br><span class="line">        <span class="comment"># 空节点则返回金额（0， 0）表示偷或不偷都是0</span></span><br><span class="line">        <span class="comment"># 定义dp[0]为不偷，dp[1]为偷</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 使用后序遍历</span></span><br><span class="line">        resLeft = self.foo(node.left)</span><br><span class="line">        resRight = self.foo(node.right)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># root节点处理子树</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 不偷root节点，则再考虑左、右子树分别的最大值</span></span><br><span class="line">        val1 = <span class="built_in">max</span>(resLeft[<span class="number">0</span>], resLeft[<span class="number">1</span>]) + <span class="built_in">max</span>(resRight[<span class="number">0</span>], resRight[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 偷root节点，则不偷左、右子树</span></span><br><span class="line">        val2 = node.val + resLeft[<span class="number">0</span>] + resRight[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (val1, val2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res = self.foo(root)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(res)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday39动态规划part07&quot;&gt;LeetCodeCampsDay39动态规划part07&lt;/h1&gt;
&lt;blockquote&gt;&lt;/blockquote&gt;
&lt;h1 id=&quot;198-打家劫舍&quot;&gt;198. 打家劫舍&lt;/h1&gt;
&lt;p&gt;&lt;a hre</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay38动态规划part06</title>
    <link href="https://blog.lthero.cn/2025/08/05/LeetCodeCampsDay38/"/>
    <id>https://blog.lthero.cn/2025/08/05/LeetCodeCampsDay38/</id>
    <published>2025-08-05T13:25:37.000Z</published>
    <updated>2025-08-05T14:35:53.376Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday38动态规划part06">LeetCodeCampsDay38动态规划part06</h1><blockquote><p>最小个数问题：零钱兑换、完全平方数</p><p>求排列问题：单词拆分</p></blockquote><h1 id="322-零钱兑换">322. 零钱兑换</h1><p><a href="https://leetcode.cn/problems/coin-change/">https://leetcode.cn/problems/coin-change/</a></p><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p><p>你可以认为每种硬币的数量是无限的。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [1, 2, 5], amount = 11</span><br><span class="line">输出：3 </span><br><span class="line">解释：11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [2], amount = 3</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [1], amount = 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= coins.length &lt;= 12</code></li><li><code>1 &lt;= coins[i] &lt;= 231 - 1</code></li><li><code>0 &lt;= amount &lt;= 104</code></li></ul><h2 id="动态规划思路">动态规划思路</h2><p>完全背包、装满到target的最小物品数量的问题</p><ol><li><p>dp定义与下标含义，dp[i][j]表示用物品0~i装满到j的最少物品个数</p></li><li><p>递推公式：凑足总额为j - coins[i]的最少个数为dp[j - coins[i]]，那么只需要加上一个钱币coins[i]即dp[j - coins[i]] + 1就是dp[j]（考虑coins[i]）所以dp[j] 要取所有 dp[j - coins[i]] + 1 中最小的。</p><p>递推公式：dp[i][j] = min(dp[i - 1][j], dp[i][j - coins[i]] + 1)</p></li><li><p>初始化：dp的大小：dp[len(coins)][amount + 1]，并且全部初始化为无穷大；再对第一行、第一列进行初始化； 第一行，如果j能整除coins[0]，则需要j//coins[0]个，否则初始化为0；第一列，全部为0</p></li><li><p>遍历顺序：先物品再容量，如果coins[i] &gt; j，则dp[i][j] = dp[i - 1][j]；否则dp[i][j] = min(dp[i - 1][j], dp[i][j - coins[i]] + 1)</p></li><li><p>举例</p><p>0, 1, 2, 3, 4, 5, 6</p><p>1  0, 1, 2, 3, 4, 5, 6</p><p>2  0, 1, 1, 2, 2, 3, 3</p></li></ol><h2 id="动态规划代码">动态规划代码</h2><ul><li>时间复杂度: O(n * amount)，其中 n 为 coins 的长度</li><li>空间复杂度: O(amount)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">coinChange</span>(<span class="params">self, coins: <span class="type">List</span>[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 完全背包、装满到target的最小物品数量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># dp定义与下标含义，dp[i][j]表示用物品0~i装满到j的最少物品个数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 递推公式：</span></span><br><span class="line">        <span class="comment"># 1，2，5， target = 11</span></span><br><span class="line">        <span class="comment"># 原始：dp[i][j] = max(dp[i - 1][j], dp[i][j - weight[i]] + val[i])</span></span><br><span class="line">        <span class="comment"># </span></span><br><span class="line">        <span class="comment"># 刚开始的想法，错误的</span></span><br><span class="line">        <span class="comment"># val = j // coins[i]</span></span><br><span class="line">        <span class="comment"># remain = j % coins[i]</span></span><br><span class="line">        <span class="comment"># dp[i][j] = min(dp[i - 1][j], dp[i][remain] + val)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 纠正后的想法，正确的</span></span><br><span class="line">        <span class="comment"># dp[i][j] = min(dp[i - 1][j], dp[i][j - coins[i]] + 1)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化</span></span><br><span class="line">        <span class="comment"># dp的大小：dp[len(coins)][amount + 1]</span></span><br><span class="line">        Lc = <span class="built_in">len</span>(coins)</span><br><span class="line">        dp = [[<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * (amount + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(Lc)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对第一行，第一列进行初始化，其它位置初始化为0</span></span><br><span class="line">        <span class="comment"># 第一行，如果j能整除coins[0]，则需要j//coins[0]个，否则初始化为0</span></span><br><span class="line">        <span class="comment"># 第一列，全部为0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(amount + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> coins[<span class="number">0</span>] &lt;= j <span class="keyword">and</span>  j % coins[<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">                dp[<span class="number">0</span>][j] = j // coins[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Lc):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历顺序，先物品再容量</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, Lc):</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(amount + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> coins[i] &gt; j:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j]</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - coins[i]] + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> dp[-<span class="number">1</span>][-<span class="number">1</span>] != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>):</span><br><span class="line">            <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]  </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 举例</span></span><br><span class="line">        <span class="comment">#    0, 1, 2, 3, 4, 5, 6</span></span><br><span class="line">        <span class="comment"># 1  0, 1, 2, 3, 4, 5, 6</span></span><br><span class="line">        <span class="comment"># 2  0, 1, 1, 2, 2, 3, 3</span></span><br><span class="line">        <span class="comment"># </span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 本题也可以使用贪心算法</span></span><br></pre></td></tr></table></figure><h1 id="279-完全平方数">279. 完全平方数</h1><p><a href="https://leetcode.cn/problems/perfect-squares/">https://leetcode.cn/problems/perfect-squares/</a></p><p>给你一个整数 <code>n</code> ，返回 <em>和为 <code>n</code> 的完全平方数的最少数量</em> 。</p><p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 12</span><br><span class="line">输出：3 </span><br><span class="line">解释：12 = 4 + 4 + 4</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 13</span><br><span class="line">输出：2</span><br><span class="line">解释：13 = 4 + 9</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 104</code></li></ul><h2 id="动态规划思路">动态规划思路</h2><p>和题目和322. 零钱兑换基本一样，完全平方数就是物品（可以无限件使用），凑个正整数n就是背包，问凑满这个<strong>背包最少有多少物品</strong></p><p>物品应该只遍历完全平方数（我这里先求出了完全平方数的物品列表item）</p><ol><li><p>数组与下标定义，dp[i][j]表示物品（完全平方数) 从0到i，构成完全平方数j的最小数量</p></li><li><p>递推公式：dp[i][j] = min(dp[i - 1][j], dp[i][j - item(i)] + 1);  卡哥说：dp[j] 可以由dp[j - i * i]推出， dp[j - i * i] + 1 便可以凑成dp[j]。 此时我们要选择最小的dp[j]，所以递推公式：dp[j] = min(dp[j - i * i] + 1, dp[j]);</p></li><li><p>初始化：dp[n][n + 1]全初始化为float(‘inf’)， 第一行（数字1），构成从0到n，如果j大于数字1则为j//i，第一列全是0</p></li><li><p>遍历顺序，先物品再容量</p></li><li><p>0, 1, 2, 3, 4, 5, 6, 7, 8,</p></li></ol><p>1  0, 1, 2, 3, 4, 5, 6, 7, 8</p><p>4  0, 1, 2, 3, 1, 2, 3, 4, 2</p><h2 id="动态规划代码">动态规划代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numSquares</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 完全平方数就是物品（可以无限件使用），凑个正整数n就是背包，问凑满这个背包最少有多少物品？</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># dp数组与下标定义，dp[i][j]表示物品（完全平方数) 从0到i，构成完全平方数j的最小数量</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 完全背包问题递推公式</span></span><br><span class="line">        <span class="comment"># 原公式：dp[i][j] = max(dp[i - 1][j] , dp[i][j - weight[i]] + val[i])</span></span><br><span class="line">        <span class="comment"># 本题公式</span></span><br><span class="line">        <span class="comment"># dp[i][j] = min(dp[i - 1][j], dp[i][j - i] + 1)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># dp初始化</span></span><br><span class="line">        <span class="comment"># dp[n][n + 1]全初始化为float(&#x27;inf&#x27;)</span></span><br><span class="line">        <span class="comment"># 第一行（数字1），构成从0到n，如果j大于数字1则为j//i</span></span><br><span class="line">        <span class="comment"># 第一列全是0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#    0, 1, 2, 3, 4, 5, 6, 7, 8, </span></span><br><span class="line">        <span class="comment"># 1  0, 1, 2, 3, 4, 5, 6, 7, 8</span></span><br><span class="line">        <span class="comment"># 4  0, 1, 2, 3, 1, 2, 3, 4, 2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 物品应该只遍历完全平方数</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getSquartList</span>(<span class="params">n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">            res = <span class="built_in">list</span>()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">int</span>(n ** <span class="number">0.5</span>) + <span class="number">1</span>):</span><br><span class="line">                res.append(i * i)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">        items = getSquartList(n)</span><br><span class="line">        L = <span class="built_in">len</span>(items)</span><br><span class="line"></span><br><span class="line">        dp = [[<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(L)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 行初始化</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 列初始化</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> j &gt;= <span class="number">1</span>:</span><br><span class="line">                dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &lt; items[i]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - items[i]] + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="动态规划代码精简">动态规划代码精简</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numSquares</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">int</span>(n ** <span class="number">0.5</span>) + <span class="number">1</span>):  <span class="comment"># 遍历物品</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i * i, n + <span class="number">1</span>):  <span class="comment"># 遍历背包</span></span><br><span class="line">                <span class="comment"># 更新凑成数字 j 所需的最少完全平方数数量</span></span><br><span class="line">                dp[j] = <span class="built_in">min</span>(dp[j - i * i] + <span class="number">1</span>, dp[j])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><h1 id="139-单词拆分">139. 单词拆分</h1><p><a href="https://leetcode.cn/problems/word-break/">https://leetcode.cn/problems/word-break/</a></p><p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 <code>s</code> 则返回 <code>true</code>。</p><p>**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;leetcode&quot; 可以由 &quot;leet&quot; 和 &quot;code&quot; 拼接成。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;applepenapple&quot; 可以由 &quot;apple&quot; &quot;pen&quot; &quot;apple&quot; 拼接成。</span><br><span class="line">     注意，你可以重复使用字典中的单词。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 300</code></li><li><code>1 &lt;= wordDict.length &lt;= 1000</code></li><li><code>1 &lt;= wordDict[i].length &lt;= 20</code></li><li><code>s</code> 和 <code>wordDict[i]</code> 仅由小写英文字母组成</li><li><code>wordDict</code> 中的所有字符串 <strong>互不相同</strong></li></ul><h2 id="动态规划思路">动态规划思路</h2><p>把字符串s当成一个背包，wordDict就是物品，看能否刚好装满这个背包（每个物品可以使用多次），<code>完全背包能否装满的问题</code></p><ol><li>dp含义与下标：dp[i][j]，使用物品0~i组成一个长度为j的字符串，如果能组成就是true；如果使用一维dp，则dp[j]组成一个长度为j的字符串，如果能组成就是true</li><li>递推公式：本题里被遍历的对象是s里的每个字符，如s=applepenapple，则遍历：a, ap, app, appl, apple, applep…；需要双指针，一个i用来遍历每个字符，另一个j用来记录一个完整单词的起点；比如当前遍历到i='e’而j='p’即pe，再判断当前字段是否在wordDict中，而pe不在wordDict里；当遍历到i='n’而j='p’即pen，但pen在wordDict里，此时再判断dp[j]是否也是True，如果dp[j]为True表示j前面的词是可以被wordDict表示的，随后再令dp[i]=True；否则dp[i]=False</li></ol><table><thead><tr><th></th><th>a</th><th>p</th><th>p</th><th>l</th><th>e</th><th>p</th><th>e</th><th>n</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td><td>j</td><td>i</td><td></td></tr></tbody></table><p>此时的当前字段为’pe’并不在wordDict中，令dp[i]为False</p><table><thead><tr><th></th><th>a</th><th>p</th><th>p</th><th>l</th><th>e</th><th>p</th><th>e</th><th>n</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td><td>j</td><td></td><td>i</td></tr></tbody></table><p>此时的字段’pen’在wordDict中，并且dp[j]为True（指的是p前面的apple词，通常情况下可能是appleapple等词是可以使用wordDict表达的），此时再令dp[i]=True；如果dp[j]为False，令dp[i]为False，表示哪怕pen可以被wordDict表示但前面的词不可以</p><ol start="3"><li><p>dp初始化, dp大小为[False] * (len(s) + 1)，其中第一个为空字符串；而令dp[0]=True，表示空字符串是一定可以被表示的</p></li><li><p>遍历顺序：前面也有题目是<code>组合数/排列数</code></p><ol><li><p>如果问能否是否装满，还有两个子问题：</p><p>1、排列数  – 先遍历背包再遍历物品</p><p>2、组合数  – 先遍历物品再遍历背包</p></li><li><p>求组合数：<a href="https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html">动态规划：518.零钱兑换II</a></p></li><li><p>求排列数：<a href="https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html">动态规划：377. 组合总和 Ⅳ</a>、<a href="https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%89%88%E6%9C%AC.html">动态规划：70. 爬楼梯进阶版（完全背包）</a></p></li><li><p>求最小数：<a href="https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html">动态规划：322. 零钱兑换 </a>、<a href="https://programmercarl.com/0279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.html">动态规划：279.完全平方数</a></p></li></ol></li></ol><h3 id="举例">举例</h3><p>输入</p><p>s =“leetcode”</p><p>wordDict = [“leet”,“code”]</p><p>标准输出</p><p>[True, False, False, False, False, False, False, False, False]</p><p>l</p><p>le</p><p>e</p><p>lee</p><p>ee</p><p>e</p><p>leet 找到第一个词</p><p>[True, False, False, False, True, False, False, False, False]</p><p>eet</p><p>et</p><p>t</p><p>leetc</p><p>eetc</p><p>etc</p><p>tc</p><p>c</p><p>leetco</p><p>eetco</p><p>etco</p><p>tco</p><p>co</p><p>o</p><p>leetcod</p><p>eetcod</p><p>etcod</p><p>tcod</p><p>cod</p><p>od</p><p>d</p><p>leetcode</p><p>eetcode</p><p>etcode</p><p>tcode</p><p>code 找到了第二个词</p><p>[True, False, False, False, True, False, False, False, True]</p><p>ode</p><p>de</p><p>e</p><p>最终输出</p><p>[True, False, False, False, True, False, False, False, True]</p><h2 id="动态规划代码">动态规划代码</h2><ul><li>时间复杂度：O(n^3)，最差情况n^3，最好n^2</li><li>空间复杂度：O(n)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wordBreak</span>(<span class="params">self, s: <span class="built_in">str</span>, wordDict: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 把字符串s当成一个背包，wordDict就是物品，看能否刚好装满这个背包（每个物品可以使用多次），完全背包能否装满的问题</span></span><br><span class="line">        <span class="comment"># dp含义与下标，dp[i][j]，使用物品0~i组成一个长度为j的字符串，如果能组成就是true</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 递推公式</span></span><br><span class="line">        <span class="comment"># 原公式 dp[i][j] = max(dp[i - 1][j], dp[i][j - weight[i]] + val[i])</span></span><br><span class="line">        <span class="comment"># if </span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化</span></span><br><span class="line">        <span class="comment"># dp[0][0] 一定为True</span></span><br><span class="line">        <span class="comment"># 其它值都为False</span></span><br><span class="line">        dp = [<span class="literal">False</span>] * (<span class="built_in">len</span>(s) + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 遍历顺序</span></span><br><span class="line">        <span class="comment"># 如果问能否是否装满，还有两个子问题：</span></span><br><span class="line">        <span class="comment"># 1、排列数  -- 先遍历背包再遍历物品</span></span><br><span class="line">        <span class="comment"># 2、组合数  -- 先遍历物品再遍历背包</span></span><br><span class="line">        <span class="built_in">print</span>(dp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这也可以看成一个双指针？</span></span><br><span class="line">        <span class="comment"># sIndex指针指向新单词起点，fast指针遍历每个字符， fast - sIndex就是一个可能的单词长度</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s) + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># j其实是一个新单词的起点</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                word = s[j: i]</span><br><span class="line">                <span class="built_in">print</span>(word)</span><br><span class="line">                <span class="keyword">if</span> word <span class="keyword">in</span> wordDict <span class="keyword">and</span> dp[j] == <span class="literal">True</span>:</span><br><span class="line">                    <span class="built_in">print</span>(word, j, i)</span><br><span class="line">                    dp[i] = <span class="literal">True</span></span><br><span class="line">        <span class="built_in">print</span>(dp)</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment">#         &quot;&quot;  a , ap, app, appl, apple, applep, applepe, applepen</span></span><br><span class="line">        <span class="comment"># apple    1  0   0   0     0      1     </span></span><br><span class="line">        <span class="comment"># pen</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday38动态规划part06&quot;&gt;LeetCodeCampsDay38动态规划part06&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;最小个数问题：零钱兑换、完全平方数&lt;/p&gt;
&lt;p&gt;求排列问题：单词拆分&lt;/p&gt;
&lt;/blockquote</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay37动态规划part05</title>
    <link href="https://blog.lthero.cn/2025/07/31/LeetCodeCampsDay37/"/>
    <id>https://blog.lthero.cn/2025/07/31/LeetCodeCampsDay37/</id>
    <published>2025-07-31T02:40:41.000Z</published>
    <updated>2025-07-31T13:09:20.601Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday37动态规划part05">LeetCodeCampsDay37动态规划part05</h1><blockquote><p>完全背包问题</p></blockquote><h1 id="完全背包">完全背包</h1><blockquote><p>01背包：每个物品最多只能被拿一次</p><p>完全背包：每个物品可被拿无限次数</p></blockquote><p>举例，背包最大重量为4，物品为：</p><table><thead><tr><th></th><th>重量</th><th>价值</th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td></tr><tr><td>物品1</td><td>3</td><td>20</td></tr><tr><td>物品2</td><td>4</td><td>30</td></tr></tbody></table><p><strong>每件商品都有无限个！</strong></p><p>问背包能背的物品最大价值是多少？</p><ol><li>确定dp数组与下标含义</li></ol><p>先使用较好理解的二维dp数组：dp[i][j]表示从下标为从0到i的物品，每个物品可以取无限次，放进容量为j的背包，价值总和最大是多少</p><ol start="2"><li>确定递推公式</li></ol><p>以dp[1][4]为例，有两种情况，1）放物品1；2）不放物品1</p><p><strong>如果装不下物品1</strong>，那背包的价值是dp[0][4]吗？即 只放物品0 并且容量为4的情况？如下图所示</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20241126112952.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20241126112952.png" alt="img"></p><p>没错，在<strong>装不下放物品1时</strong>的情况与01背包一致；</p><p><strong>如果装得下物品1</strong>，那背包的价值上是max(dp[0][4], dp[0][4 - weight[1]] + val[4]) 吗？</p><p>并不是！在<code>“装得下物品1时”的情况与01背包不同</code> （如下图所示）</p><p>在01背包时，因为物品1只能被装一次，所以我们只会考虑dp[0][4 - weight[1]] + val[4]的结果，<code>而完全背包里，4 - weight[1] 是空出物品1的空间重量，但此时背包里也可能还有物品1</code> ，所以我们需要考虑dp[1][4 - weight[1]]而不是dp[0][4 - weight[1]]</p><p>即：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>4</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>4</mn><mo>−</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>v</mi><mi>a</mi><mi>l</mi><mo stretchy="false">[</mo><mn>4</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">max(dp[0][4], dp[1][4 - weight[1] + val[4])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">4</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mopen">[</span><span class="mord">4</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p><p><img src="https://cdn.lthero.cn/post_images/course/ML20241126113104.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20241126113104.png" alt="img"></p><p>以上过程，抽象化如下：</p><ul><li><strong>放不下物品i</strong>：背包容量为j，里面不放物品i的最大价值是dp[i - 1][j]。</li><li><strong>放得下物品i</strong>：背包誊出物品i的容量后，背包容量为<strong>j - weight[i]</strong>，dp[i][j - weight[i]] 为背包容量为j - weight[i]且不放物品i的最大价值，那么dp[i][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值</li></ul><p>完全背包递推公式： <code>dp[i][j] = max(dp[i - 1][j], dp[i][j - weight[i]] + value[i]);</code></p><p>01背包中递推公式： <code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</code></p><ol start="3"><li>完全背包的dp数组初始化<ol><li>dp是个二维数组，大小为(n, capacity+1), <code>dp = [[0] * (capacity + 1) for _ in range(n)]</code></li><li>（第一列）先考虑容量为0的情况，dp[i][0] 全部设置为0</li><li>（第一行）再考虑物品0的情况，如果背包能放得下物品0， 就一直放：dp[0][j] = dp[0][j - weight[0]] + val[0]</li><li>其它情况，因为其它值都会被覆盖，所以初始化为任意值都可以，初始化为0更方便罢了</li></ol></li></ol><p><img src="https://file1.kamacoder.com/i/algo/20241114161608.png" alt="img"></p><ol start="4"><li>遍历顺序</li></ol><p>对于二维dp背包，可以先遍历物品再容量，也可以先容量再物品</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意从物品1开始，因为物品0已经初始化过了，不要重复遍历物品0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(capacity):</span><br><span class="line">    <span class="comment"># 装不下物品i</span></span><br><span class="line">    <span class="keyword">if</span> j&lt; weight[i]:</span><br><span class="line">      dp[i][j] = dp[i - <span class="number">1</span>][j]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - weight[i]] + val[i])</span><br></pre></td></tr></table></figure><h1 id="携带研究材料-第七期模拟笔试">携带研究材料（第七期模拟笔试）</h1><p><a href="https://kamacoder.com/problempage.php?pid=1052">https://kamacoder.com/problempage.php?pid=1052</a></p><p>题目描述</p><p>小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。他需要带一些研究材料，但是他的行李箱空间有限。这些研究材料包括实验设备、文献资料和实验样本等等，它们各自占据不同的重量，并且具有不同的价值。</p><p>小明的行李箱所能承担的总重量是有限的，问小明应该如何抉择，才能携带最大价值的研究材料，每种研究材料可以选择无数次，并且可以重复选择。</p><p>输入描述</p><p>第一行包含两个整数，n，v，分别表示研究材料的种类和行李所能承担的总重量</p><p>接下来包含 n 行，每行两个整数 wi 和 vi，代表第 i 种研究材料的重量和价值</p><p>输出描述</p><p>输出一个整数，表示最大价值。</p><p>输入示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure><p>输出示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><p>提示信息</p><p>第一种材料选择五次，可以达到最大值。</p><p>数据范围：</p><p>1 &lt;= n &lt;= 10000;<br>1 &lt;= v &lt;= 10000;<br>1 &lt;= wi, vi &lt;= 10^9.</p><h2 id="动态规划思路">动态规划思路</h2><h2 id="二维完全背包动态规划代码">二维完全背包动态规划代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self, n: <span class="built_in">int</span>, capacity: <span class="built_in">int</span>, weight: <span class="built_in">list</span>, val: <span class="built_in">list</span></span>):</span><br><span class="line">        <span class="comment"># 创建dp（二维）</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (capacity + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 递推公式</span></span><br><span class="line">        <span class="comment"># dp[i][j] = max(dp[i - 1][j], dp[i][j - weight[i]] + val[i])</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># dp初始化，对物品一，只要能装下，就一直重复装物品一</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(weight[<span class="number">0</span>], capacity + <span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - weight[<span class="number">0</span>]] + val[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(capacity + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &lt; weight[i]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - weight[i]] + val[i])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 输出dp[-1][-1]</span></span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="built_in">print</span>(dp[n - <span class="number">1</span>][capacity])</span><br><span class="line"></span><br><span class="line">n, capacity = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">weight = <span class="built_in">list</span>()</span><br><span class="line">val = <span class="built_in">list</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    w, v = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    weight.append(w)</span><br><span class="line">    val.append(v)</span><br><span class="line">s = solution()</span><br><span class="line"></span><br><span class="line">s.foo(n, capacity, weight, val)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="一维完全背包思路">一维完全背包思路</h2><p>简直来说就是将二维完全背包压缩，但！<code>在遍历时，对容量的遍历不用从大到小遍历，而必须从小到大遍历</code></p><p>在遍历容量时</p><ol><li>（一维dp）01背包必须从大到小遍历</li><li>（一维、二维dp）完全背包必须<strong>从小到大遍历</strong></li></ol><p>我在<a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E4%B8%80%E7%BB%B4.html">完全背包（一维DP）</a>中讲解了完全背包的两个for循环的先后顺序都是可以的。</p><p><strong>但本题就不行了！</strong></p><p>因为纯完全背包求得装满背包的最大价值是多少，和凑成总和的元素有没有顺序没关系，即：<strong>有顺序也行，没有顺序也行！</strong></p><p>而本题要求凑成总和的<code>组合数</code> ，元素之间明确<code>要求没有顺序</code> 。</p><p>所以纯完全背包是能凑成总和就行，不用管怎么凑的。</p><p>本题是求凑出来的方案个数，且每个方案个数是组合数。</p><p>那么本题，两个for循环的先后顺序可就有说法了。</p><p>我们先来看 外层for循环遍历物品（钱币），内层for遍历背包（金钱总额）的情况。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; coins.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = coins[i]; j &lt;= amount; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] += dp[j - coins[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设：coins[0] = 1，coins[1] = 5。</p><p>那么就是先把1加入计算，然后再把5加入计算，得到的方法数量只有{1, 5}这种情况。而不会出现{5, 1}的情况。</p><p><strong>所以这种遍历顺序中dp[j]里计算的是组合数！</strong></p><p>如果把两个for交换顺序，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= amount; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; coins.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">if</span> (j - coins[i] &gt;= <span class="number">0</span>) dp[j] += dp[j - coins[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>背包容量的<code>每一个值，都是经过 1 和 5 的计算，包含了&#123;1, 5&#125; 和 &#123;5, 1&#125;两种情况</code>。</p><p><strong>此时dp[j]里算出来的就是排列数！</strong></p><p>可能这里很多同学还不是很理解，<strong>建议动手把这两种方案的dp数组数值变化打印出来，对比看一看！（实践出真知）</strong></p><h2 id="一维完全背包动态规划代码">一维完全背包动态规划代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">self, n: <span class="built_in">int</span>, capacity: <span class="built_in">int</span>, weight: <span class="built_in">list</span>, val: <span class="built_in">list</span></span>):</span><br><span class="line">        <span class="comment"># 创建dp（一维）</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (capacity + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 递推公式</span></span><br><span class="line">        <span class="comment"># dp[j] = max([j], dp[j - weight[i]] + val[i])</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># dp初始化，对物品一，只要能装下，就一直重复装物品一</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(weight[<span class="number">0</span>], capacity + <span class="number">1</span>):</span><br><span class="line">            dp[i] = dp[i - weight[<span class="number">0</span>]] + val[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(capacity + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &gt;= weight[i]:</span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + val[i])</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(dp[- <span class="number">1</span>])</span><br></pre></td></tr></table></figure><h1 id="518-零钱兑换-ii">518. 零钱兑换 II</h1><p><a href="https://leetcode.cn/problems/coin-change-ii/">https://leetcode.cn/problems/coin-change-ii/</a></p><p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p><p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。</p><p>假设每一种面额的硬币有无限个。</p><p>题目数据保证结果符合 32 位带符号整数。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：amount = 5, coins = [1, 2, 5]</span><br><span class="line">输出：4</span><br><span class="line">解释：有四种方式可以凑成总金额：</span><br><span class="line">5=5</span><br><span class="line">5=2+2+1</span><br><span class="line">5=2+1+1+1</span><br><span class="line">5=1+1+1+1+1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：amount = 3, coins = [2]</span><br><span class="line">输出：0</span><br><span class="line">解释：只用面额 2 的硬币不能凑成总金额 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：amount = 10, coins = [10] </span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= coins.length &lt;= 300</code></li><li><code>1 &lt;= coins[i] &lt;= 5000</code></li><li><code>coins</code> 中的所有值 <strong>互不相同</strong></li><li><code>0 &lt;= amount &lt;= 5000</code></li></ul><h2 id="动态规划思路">动态规划思路</h2><blockquote><p>本题求的是装满这个背包的物品<code>组合数</code>是多少</p><p>注意，组合数不要求顺序：比如(1,5)和(5,1)是同一组合</p><p>而，排列要求顺序，(1,5)与(5,1)不是同一排列</p></blockquote><p>例如示例一：</p><p>5 = 2 + 2 + 1</p><p>5 = 2 + 1 + 2</p><p>这是一种组合，都是 2 2 1。</p><p>如果问的是排列数，那么上面就是两种排列了。</p><p><strong>组合不强调元素之间的顺序，排列强调元素之间的顺序</strong>。 为什么要介绍这些呢，因为这和下文讲解<code>遍历顺序</code> 息息相关!</p><p>本题目和494.目标和几乎一样，都是求组合数，本题是完全背包而494.是01背包</p><ol><li><p>定义二维dp数值 dp[i][j]：使用 下标为[0, i]的coins[i]能够凑满j（包括j）这么大容量的包，有dp[i][j]种组合方法。</p></li><li><p>递推关系</p></li></ol><p>如果<strong>coins[i] &lt;= j</strong>则</p><p>在，01背包理论基础 ，中二维DP数组的递推公式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])</span><br></pre></td></tr></table></figure><p>在 <a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85.html">完全背包理论基础</a>详细讲解了完全背包二维DP数组的递推公式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max(dp[i - 1][j], dp[i][j - weight[i]] + value[i])</span><br></pre></td></tr></table></figure><p>如果coins[i] &gt; j则</p><p><code>dp[i][j] = dp[i - 1][j]</code></p><p>在<strong>494. 目标和</strong>中详解讲解了装满背包有几种方法，二维DP数组的递推公式： <code>dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]]</code></p><p>所以完全背包里的装满背包有几种方法，二维DP数组的递推公式：<code>dp[i][j] = dp[i - 1][j] + dp[i][j - nums[i]]</code></p><p>区别依然是 <code>dp[i - 1][j - nums[i]]</code> 和 <code>dp[i][j - nums[i]]</code></p><p>稍微解释下吧，dp[i - 1][j]是不带物品i，容量j时的组合方法数，而dp[i][j - nums[i]]是带物品i，容量j的组合方法数，相加才是物品i，容量j的组合方法数</p><ol start="3"><li>初始化</li></ol><p>我的想法：</p><p>将dp[i][0]初始化为1，意义？amount=0，只有一种方式；反过来想，如果令dp[i][0]等于0，后面需要加上dp[i][5 - 5] = 0这种情况时就没有意义了；其它数全初始化为0</p><p>但这样就必须在遍历时从物品0开始</p><p><code>for i in range(len(coins)):</code></p><p>卡哥想法：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240827103507.png" alt="img"></p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240827103507-20250731155030460.png" alt="img"></p><p>把dp的第一行、第一列进行初始化，dp[0][0]初始化为0；</p><p>第一行dp[0][j]，它的含义是用 [物品0] 装满 背包容量为j 的背包，有多少组合；</p><p>如果j可以整除物品0，那么它则有一种组合方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= amount; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (j % coins[<span class="number">0</span>] == <span class="number">0</span>) dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的初始化，在遍历时就必须从物品1开始</p><p><code>for i in range(1, len(coins)):</code></p><p>第一列dp[i][0]，用物品i 装满容量为0的背包，只有一种方法：不装</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Lc):</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure><ol start="4"><li>遍历顺序</li></ol><p>二维数组dp遍历顺序先容量/先物品都可以</p><h2 id="二维动态规划代码">二维动态规划代码</h2><ul><li>时间复杂度O(mn)</li><li>空间复杂度O(mn)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">self, amount: <span class="built_in">int</span>, coins: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 问题转换：完全背包，装成target值，有多少种组合方式？</span></span><br><span class="line">        <span class="comment"># dp[i][j] 表示物品i（金币i）组成金额j的组合方式数。</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># ---正式代码---</span></span><br><span class="line">        Lc = <span class="built_in">len</span>(coins)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (amount + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(Lc)]</span><br><span class="line">        <span class="comment"># 初始化</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Lc):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Lc):</span><br><span class="line">            <span class="comment"># 从</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(amount + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &gt;= coins[i]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - coins[i]]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="377-组合总和-ⅳ">377. 组合总和 Ⅳ</h1><p><a href="https://leetcode.cn/problems/combination-sum-iv/">https://leetcode.cn/problems/combination-sum-iv/</a></p><p>给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p><p>题目数据保证答案符合 32 位整数范围。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3], target = 4</span><br><span class="line">输出：7</span><br><span class="line">解释：</span><br><span class="line">所有可能的组合为：</span><br><span class="line">(1, 1, 1, 1)</span><br><span class="line">(1, 1, 2)</span><br><span class="line">(1, 2, 1)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 1, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br><span class="line">请注意，顺序不同的序列被视作不同的组合。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [9], target = 3</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 200</code></li><li><code>1 &lt;= nums[i] &lt;= 1000</code></li><li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li><li><code>1 &lt;= target &lt;= 1000</code></li></ul><p>**进阶：**如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？</p><h2 id="二维动态规划代码">二维动态规划代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum4</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 完全背包，装满为target的值，问方式数量</span></span><br><span class="line">        <span class="comment"># 这题目与518不同点在于，本题的不同顺序可以看成不同求排列</span></span><br><span class="line">        <span class="comment"># 比如1，1，2与1，2，1就是两种求排列</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># dp二维，dp[i][j]，表示在物品i价值为j的情况下求排列数</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 递推公式：dp[i][j] = dp[i - 1][j] + dp[i][j - nums[i]] + dp[j - nums[i]][i]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># dp初始化，首先，dp维度是(target + 1, len(nums) + 1)</span></span><br><span class="line">        <span class="comment"># </span></span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (target + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(L)]</span><br><span class="line">        <span class="comment"># 且dp[i][0]全为1，除了dp[0][0]必须为0，所以跳过第一行</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(dp)</span><br><span class="line">        <span class="comment"># 遍历顺序，先物品，再容量</span></span><br><span class="line">        <span class="comment"># 这可以跳过第一个</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, target + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">                <span class="built_in">print</span>(dp)</span><br><span class="line">                <span class="keyword">if</span> j &gt;= nums[i]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[-<span class="number">1</span>][j - nums[i]]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="一维动态规划代码">一维动态规划代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">L = <span class="built_in">len</span>(nums)</span><br><span class="line">dp = [<span class="number">0</span>] * (target + <span class="number">1</span>)</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, target + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">        <span class="keyword">if</span> i &gt;= nums[j]:</span><br><span class="line">            dp[i] += dp[i - nums[j]]</span><br><span class="line"><span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday37动态规划part05&quot;&gt;LeetCodeCampsDay37动态规划part05&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;完全背包问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;完全背包&quot;&gt;完全背包&lt;/h1&gt;
&lt;bl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay36动态规划part04</title>
    <link href="https://blog.lthero.cn/2025/07/30/LeetCodeCampsDay36/"/>
    <id>https://blog.lthero.cn/2025/07/30/LeetCodeCampsDay36/</id>
    <published>2025-07-30T05:45:52.000Z</published>
    <updated>2025-07-30T09:12:15.390Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday36动态规划part04">LeetCodeCampsDay36动态规划part04</h1><blockquote><p>01背包，分割等和子集的变式题目</p><p>416.分割等和子集是问：能否将背包装满到target值</p><p>1049.石头：尽量将背包装满到target值，如果装不到，则最小差值是多少</p><p>494.目标和：装满一个到target值，有多少种方法</p><p>474.一和零：装满一个背包，最多有多少物品</p></blockquote><h1 id="1049-最后一块石头的重量-ii">1049. 最后一块石头的重量 II</h1><p><a href="https://leetcode.cn/problems/last-stone-weight-ii/">https://leetcode.cn/problems/last-stone-weight-ii/</a></p><p>有一堆石头，用整数数组 <code>stones</code> 表示。其中 <code>stones[i]</code> 表示第 <code>i</code> 块石头的重量。</p><p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p><ul><li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li><li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li></ul><p>最后，<strong>最多只会剩下一块</strong> 石头。返回此石头 <strong>最小的可能重量</strong> 。如果没有石头剩下，就返回 <code>0</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：stones = [2,7,4,1,8,1]</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，</span><br><span class="line">组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，</span><br><span class="line">组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，</span><br><span class="line">组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：stones = [31,26,33,21,40]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= stones.length &lt;= 30</code></li><li><code>1 &lt;= stones[i] &lt;= 100</code></li></ul><h2 id="动态规划思路">动态规划思路</h2><blockquote><p>如何让这一堆石头相撞后，剩下的石头最小？</p></blockquote><ol><li>极端情况下：当把这一堆石头分成两堆并且两堆体积相等时，剩下的石头为零</li><li>次优解为：两堆体积尽量相似！剩下的石头最小</li></ol><p>这题目之前<code>416.分割等和子集</code>有些像</p><p>可以用一个<strong>背包装石头</strong>，并找一个最小差值：<code>背包的重量</code> 与 <code>剩下石头的重量</code> 差值最小</p><ol><li>使用一维背包，dp背包的下标：石头重量，背包dp[i]含义：背包的重量</li><li>递推公式：dp[j] = max(dp[j], dp[j - stones[i]] + stones[i])，因为重量就是价值，所以weight[i]=val[i]=stones[i]</li><li>dp初始化，一维背包初始化全为零，<strong>背包最大容量设置为sumOfStones也是可以的</strong>，但将在极端情况下，只要让背包装满sumOfStones的一半就可以了，即令dp的长度为<strong>sumOfStones//2</strong></li><li>遍历顺序：行遍历对每个石头遍历，列遍历对背包重量（从大到小遍历，范围[sumOfStones // 2, stones[i]]，保证每个物品只添加一次，这样才是01背包；如果从小到大遍历，就会变成完全背包，指每个物品可以放多次）</li><li>举例</li></ol><p><img src="https://file1.kamacoder.com/i/algo/20210121115805904.jpg" alt="img"></p><h2 id="动态规划代码">动态规划代码</h2><ul><li>时间复杂度：O(m × n) , m是石头总重量（准确的说是总重量的一半），n为石头块数</li><li>空间复杂度：O(m)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lastStoneWeightII</span>(<span class="params">self, stones: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        sumOfStones = <span class="built_in">sum</span>(stones)</span><br><span class="line">        target = sumOfStones // <span class="number">2</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (target+ <span class="number">1</span>)</span><br><span class="line">        L = <span class="built_in">len</span>(stones)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(target, stones[i] - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j - stones[i]] + stones[i])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># # (sumOfStones - dp[target])是一堆，dp[target]是另一堆</span></span><br><span class="line">        <span class="keyword">return</span> sumOfStones - dp[target] - dp[target]</span><br></pre></td></tr></table></figure><h1 id="494-目标和">494. 目标和</h1><p><a href="https://leetcode.cn/problems/target-sum/">https://leetcode.cn/problems/target-sum/</a></p><p>给你一个非负整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p><p>向数组中的每个整数前添加 <code>'+'</code> 或 <code>'-'</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p><ul><li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>'+'</code> ，在 <code>1</code> 之前添加 <code>'-'</code> ，然后串联起来得到表达式 <code>&quot;+2-1&quot;</code> 。</li></ul><p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,1,1,1], target = 3</span><br><span class="line">输出：5</span><br><span class="line">解释：一共有 5 种方法让最终目标和为 3 。</span><br><span class="line">-1 + 1 + 1 + 1 + 1 = 3</span><br><span class="line">+1 - 1 + 1 + 1 + 1 = 3</span><br><span class="line">+1 + 1 - 1 + 1 + 1 = 3</span><br><span class="line">+1 + 1 + 1 - 1 + 1 = 3</span><br><span class="line">+1 + 1 + 1 + 1 - 1 = 3</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1], target = 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 20</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li><li><code>0 &lt;= sum(nums[i]) &lt;= 1000</code></li><li><code>-1000 &lt;= target &lt;= 1000</code></li></ul><h2 id="本题思路">本题思路</h2><p>本题目需要根据nums求target，看似既要求正数又要求负数情况，但实际上，可以将题目转换成只求正数集，一旦得到了正确的正数集，那sum-正数集就是对应的负数集</p><p>令作为正数集的和为targetSum，作为负数集的和（每个数字仍然为正数）为remainSum</p><p>则</p><ol><li><p>targetSum + remainSum = sum</p></li><li><p>targetSum - remainSum = target</p></li></ol><p>targetSum + targetSum - target = sum</p><p>targetSum = (sum + target) // 2</p><p>现在问题变成了：<strong>求有多少种方法装满left，即背包最大容量为left有多少种装法（或有多少种方法装right）</strong></p><h2 id="回溯思路">回溯思路</h2><p>回溯的思路和之前“组合总和”代码相似，但前提也是要把题目转换一个思考方式，不需要真的考虑每次加一个数或减一个数，而是只考虑：</p><p><code>如何获得满足条件的正数集</code></p><h2 id="回溯代码">回溯代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.path = <span class="built_in">list</span>()</span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self, nums, target , currentSum, start</span>):</span><br><span class="line">        <span class="keyword">if</span> currentSum &gt; target:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> currentSum == target:</span><br><span class="line">            self.res += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, L):</span><br><span class="line">            self.path.append(nums[i])</span><br><span class="line">            self.foo(nums, target, currentSum + nums[i], i + <span class="number">1</span>)</span><br><span class="line">            self.path.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findTargetSumWays</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        sumOfnums = <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> sumOfnums &lt; <span class="built_in">abs</span>(target):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (sumOfnums + target) % <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        nums = <span class="built_in">sorted</span>(nums)</span><br><span class="line">        left = (sumOfnums + target) // <span class="number">2</span></span><br><span class="line">        self.foo(nums, left, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="动态规划思路">动态规划思路</h2><p>在确定了动态规划里的targetSum值（对应下面代码里的left），则把问题转成了把背包装满到targetSum的问题</p><ol><li>dp数组下标与含义：dp[j]下标j表示当前背包容量，有dp[j]个方法把背包装满到target</li><li>递推公式：dp[j] = dp[j] + dp[j - nums[i]]</li></ol><p>先只考虑物品0，如图：</p><p><img src="https://file1.kamacoder.com/i/algo/20240808161747.png" alt="img"></p><p>（这里的所有物品，都是题目中的数字1）。</p><p>装满背包容量为0 的方法个数是1，即 放0件物品。</p><p>装满背包容量为1 的方法个数是1，即 放物品0。</p><p>装满背包容量为2 的方法个数是0，目前没有办法能装满容量为2的背包。</p><hr><p>接下来 考虑 物品0 和 物品1，如图：</p><p><img src="https://file1.kamacoder.com/i/algo/20240808162052.png" alt="img"></p><p>装满背包容量为0 的方法个数是1，即 放0件物品。</p><p>装满背包容量为1 的方法个数是2，即 放物品0 或者 放物品1。</p><p>装满背包容量为2 的方法个数是1，即 放物品0 和 放物品1。</p><p>其他容量都不能装满，所以方法是0。</p><hr><p>接下来 考虑 物品0 、物品1 和 物品2 ，如图：</p><p><img src="https://file1.kamacoder.com/i/algo/20240808162533.png" alt="img"></p><p>装满背包容量为0 的方法个数是1，即 放0件物品。</p><p>装满背包容量为1 的方法个数是3，即 放物品0 或者 放物品1 或者 放物品2。</p><p>装满背包容量为2 的方法个数是3，即 放物品0 和 放物品1、放物品0 和 物品2、放物品1 和 物品2。</p><p>装满背包容量为3的方法个数是1，即 放物品0 和 物品1 和 物品2。</p><p>dp[2][2] = 3，即 放物品0 和 放物品1、放物品0 和 物品 2、放物品1 和 物品2， 如图所示，三种方法：</p><p><img src="https://file1.kamacoder.com/i/algo/20240826111946.png" alt="img"></p><p><strong>容量为2 的背包，如果不放 物品2 有几种方法呢</strong>？</p><p>有 dp[1][2] 种方法，即 背包容量为2，只考虑物品0 和 物品1 ，有 dp[1][2] 种方法，如图：</p><p><img src="https://file1.kamacoder.com/i/algo/20240826112805.png" alt="img"></p><p><strong>容量为2 的背包， 如果放 物品2 有几种方法呢</strong>？</p><p>首先 要在背包里 先把物品2的容量空出来， 装满 刨除物品2容量 的背包 有几种方法呢？</p><p>刨除物品2容量后的背包容量为 1。</p><p>此时装满背包容量为1 有 dp[1][1] 种方法，即： 不放物品2，背包容量为1，只考虑物品 0 和 物品 1，有 dp[1][1] 种方法。</p><p>如图：</p><p><img src="https://file1.kamacoder.com/i/algo/20240826113043.png" alt="img"></p><p>有录友可能疑惑，这里计算的是放满 容量为2的背包 有几种方法，那物品2去哪了？</p><p>在上面图中，你把物品2补上就好，同样是两种方法。</p><p>dp[2][2] = 容量为2的背包不放物品2有几种方法 + 容量为2的背包放物品2有几种方法</p><p>所以 dp[2][2] = dp[1][2] + dp[1][1] ，如图：</p><p><img src="https://file1.kamacoder.com/i/algo/20240826113258.png" alt="img"></p><p>以上过程，抽象化如下：</p><ul><li><strong>不放物品i</strong>：即背包容量为j，<strong>里面不放物品i，装满有dp[i - 1][j]中方法。</strong></li><li><strong>放物品i</strong>： 即：先空出物品i的容量，背包容量为（j - 物品i容量），放满背包有 dp[i - 1][j - 物品i容量] 种方法。</li></ul><p>本题中，物品i的容量是nums[i]，价值也是nums[i]。</p><p>递推公式：dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]];</p><p>考到这个递推公式，我们应该注意到，<code>j - nums[i]</code> 作为数组下标，如果 <code>j - nums[i]</code> 小于零呢？</p><p>说明<strong>背包容量装不下</strong> 物品i，所以此时装满背包的方法值 等于 不放物品i的装满背包的方法，即：dp[i][j] = dp[i - 1][j];</p><p>所以递推公式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[i] &gt; j) dp[i][j] = dp[i - <span class="number">1</span>][j]; </span><br><span class="line"><span class="keyword">else</span> dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i - <span class="number">1</span>][j - nums[i]];</span><br></pre></td></tr></table></figure><p>二维DP数组递推公式： <code>dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]];</code></p><p>去掉维度i 之后，递推公式：<code>dp[j] = dp[j] + dp[j - nums[i]]</code> ，即：<code>dp[j] += dp[j - nums[i]]</code></p><p><strong>这个公式在后面在讲解背包解决排列组合问题的时候还会用到！</strong></p><p>以前都是<code>dp[j] = max(dp[j] , dp[j - nums[i]] + xxx)</code>，现在要注意dp的含义是有多少种装包的方法而不是求它的价值</p><h2 id="动态规划代码">动态规划代码</h2><ul><li>时间复杂度：O(n × m)，n为正数个数，m为背包容量</li><li>空间复杂度：O(m)，m为背包容量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">findTargetSumWays</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">       sumOfnums = <span class="built_in">sum</span>(nums)</span><br><span class="line">       <span class="keyword">if</span> sumOfnums &lt; <span class="built_in">abs</span>(target):</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">       <span class="keyword">if</span> (sumOfnums + target) % <span class="number">2</span>:</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">       nums = <span class="built_in">sorted</span>(nums)</span><br><span class="line">       left = (sumOfnums + target) // <span class="number">2</span></span><br><span class="line">       </span><br><span class="line">       L = <span class="built_in">len</span>(nums)</span><br><span class="line">       sumOfnums = <span class="built_in">sum</span>(nums)</span><br><span class="line">       <span class="keyword">if</span> sumOfnums &lt; <span class="built_in">abs</span>(target):</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">       <span class="keyword">if</span> (sumOfnums + target) % <span class="number">2</span>:</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">       left = (sumOfnums + target) // <span class="number">2</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment"># dp下标与含义：下标j为背包容量，有dp[j]个方法装满</span></span><br><span class="line">       dp = [<span class="number">0</span>] * (left + <span class="number">1</span>)</span><br><span class="line">       <span class="comment"># dp初始化，dp[0]初始化为1，装满0的背包有1种方法</span></span><br><span class="line">       dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">       <span class="comment"># 非0下标初始化为0</span></span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">           <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(left, nums[i] - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">               <span class="comment"># 递推公式dp[j] += dp[j - nums[i]]</span></span><br><span class="line">               dp[j] += dp[j - nums[i]]</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> dp[left]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="474-一和零">474. 一和零</h1><p><a href="https://leetcode.cn/problems/ones-and-zeroes/">https://leetcode.cn/problems/ones-and-zeroes/</a></p><p>给你一个二进制字符串数组 <code>strs</code> 和两个整数 <code>m</code> 和 <code>n</code> 。</p><p>请你找出并返回 <code>strs</code> 的最大子集的长度，该子集中 <strong>最多</strong> 有 <code>m</code> 个 <code>0</code> 和 <code>n</code> 个 <code>1</code> 。</p><p>如果 <code>x</code> 的所有元素也是 <code>y</code> 的元素，集合 <code>x</code> 是集合 <code>y</code> 的 <strong>子集</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：strs = [&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;], m = 5, n = 3</span><br><span class="line">输出：4</span><br><span class="line">解释：最多有 5 个 0 和 3 个 1 的最大子集是 &#123;&quot;10&quot;,&quot;0001&quot;,&quot;1&quot;,&quot;0&quot;&#125; ，因此答案是 4 。</span><br><span class="line">其他满足题意但较小的子集包括 &#123;&quot;0001&quot;,&quot;1&quot;&#125; 和 &#123;&quot;10&quot;,&quot;1&quot;,&quot;0&quot;&#125; 。&#123;&quot;111001&quot;&#125; 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：strs = [&quot;10&quot;, &quot;0&quot;, &quot;1&quot;], m = 1, n = 1</span><br><span class="line">输出：2</span><br><span class="line">解释：最大的子集是 &#123;&quot;0&quot;, &quot;1&quot;&#125; ，所以答案是 2 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 600</code></li><li><code>1 &lt;= strs[i].length &lt;= 100</code></li><li><code>strs[i]</code> 仅由 <code>'0'</code> 和 <code>'1'</code> 组成</li><li><code>1 &lt;= m, n &lt;= 100</code></li></ul><h2 id="动态规划思路">动态规划思路</h2><p>本题里的物品只有子串，但背包需要使用二维，其中dp[j][k]表示最多有j个0，有k个1的最大子集的大小为dp[j][k]</p><p>并且，本题的问题是：<code>装满这个背包，最多可以装多少个物品</code>，最终返回值dp[m][n]</p><ol><li>dp数组下标与含义：dp[j][k]表示最多有j个0，有k个1的最大子集的大小为dp[j][k]</li><li>递推公式：与前面的公式不同，对于每个物品strs[i]，比如’11001’，需要先判断它有x个0，有y个1；<ol><li>然后判断dp[j - x][k - y] + 1 与 dp[j][k]的大小，表示如果，如果装得下，则把这个子串’11001’添加进来则会多一个物品</li></ol></li><li>初始化，将dp全部初始化为0</li><li>遍历顺序：先遍历物品，但需要对物品计算每个子串的0&amp;1个数；再遍历背包，按0和1进行两层循环的遍历（因为先遍历0或1都可以，不影响）<ol><li>注意，遍历背包里，仍然需要像回滚dp数组一样，<strong>倒序遍历</strong>，因为虽然这里的dp是二维数组，但它只是<code>两个维度的容量</code></li></ol></li></ol><h2 id="动态规划代码">动态规划代码</h2><ul><li>时间复杂度: O(kmn)，k 为strs的长度</li><li>空间复杂度: O(mn)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMaxForm</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>], m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 使用一个二维dp背包，dp[j][k]表示最多有j个0,k个1的最大子集的大小为dp[j][k]</span></span><br><span class="line">        <span class="comment"># 问，装满这个容器，最多有多少个物品</span></span><br><span class="line">        <span class="comment"># 最终返回dp[m][n]</span></span><br><span class="line">        <span class="comment"># 递推公式(回滚背包)</span></span><br><span class="line">        <span class="comment"># dp[j] = max(dp[j], dp[j - weight[i]] + val[i])</span></span><br><span class="line">        <span class="comment"># 二维dp数组</span></span><br><span class="line">        <span class="comment"># dp[i][j] = max(dp[i][j], dp[i - x][j - y] + 1) ，这里的x,y表示某个子串有x个0，y个1，加1表示把这个子串（物品）添加进来</span></span><br><span class="line">        <span class="comment"># dp初始化</span></span><br><span class="line">        <span class="comment"># dp[0][0]=0, 非零下标也初始化为0</span></span><br><span class="line">        L = <span class="built_in">len</span>(strs)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">            <span class="comment"># 计算strs[i]的0和1个数</span></span><br><span class="line">            x0 = <span class="number">0</span></span><br><span class="line">            y1 = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> strs[i]:</span><br><span class="line">                <span class="keyword">if</span> c == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">                    x0 += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    y1 += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 遍历背包容量，分别遍历0和1，顺序可以颠倒</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m, x0 - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n, y1 - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                    dp[j][k] = <span class="built_in">max</span>(dp[j][k], dp[j - x0][k - y1] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday36动态规划part04&quot;&gt;LeetCodeCampsDay36动态规划part04&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;01背包，分割等和子集的变式题目&lt;/p&gt;
&lt;p&gt;416.分割等和子集是问：能否将背包装满到target值</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay35动态规划part03</title>
    <link href="https://blog.lthero.cn/2025/07/29/LeetCodeCampsDay35/"/>
    <id>https://blog.lthero.cn/2025/07/29/LeetCodeCampsDay35/</id>
    <published>2025-07-29T06:24:42.000Z</published>
    <updated>2025-07-29T13:50:15.024Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday35动态规划part03">LeetCodeCampsDay35动态规划part03</h1><blockquote><p>背包问题/01背包/一维dp数组与二维dp数组的执行区别</p></blockquote><h1 id="背包问题">背包问题</h1><p>背包问题可以分成01背包/完全背包/多重背包与分组背包；</p><p>不过搞定01背包与完全背包就可以了</p><p><img src="https://file1.kamacoder.com/i/algo/20210117171307407.png" alt="img"></p><h2 id="01背包">01背包</h2><p>有n件物品和一个最多能背重量为w 的背包。</p><p>第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p>这是标准的背包问题，以至于很多同学看了这个自然就会想到背包，甚至都不知道暴力的解法应该怎么解了。</p><p>这样其实是没有从底向上去思考，而是习惯性想到了背包，那么暴力的解法应该是怎么样的呢？</p><p>每一件物品其实只有两个状态，<code>取或者不取</code> ，所以可以使用<strong>回溯法搜索</strong>出所有的情况，那么时间复杂度就是O(2^n)，这里的n表示物品数量。</p><p><strong>所以暴力的解法是指数级别的时间复杂度。进而才需要动态规划的解法来进行优化！</strong></p><p>在下面的讲解中，我举一个例子：</p><p>背包最大重量为4。</p><p>物品为：</p><table><thead><tr><th></th><th>重量</th><th>价值</th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td></tr><tr><td>物品1</td><td>3</td><td>20</td></tr><tr><td>物品2</td><td>4</td><td>30</td></tr></tbody></table><p>问背包能背的物品最大价值是多少？</p><p>以下讲解和图示中出现的数字都是以这个例子为例。</p><p>（为了方便表述，下面描述 统一用 容量为XX的背包，放下容量（重量）为XX的物品，物品的价值是XX）</p><h3 id="二维数组01背包">二维数组01背包</h3><ol><li>先确定dp数组下标与数组含义</li></ol><p>因为我们需要同时表示 物品 &amp; 背包容量，所以dp[i][j]里的i表示物品i，而j表示当前背包容量为j，注意如果背包capacity为4，但dp数组的长度需要开到5，因为包含重量为0的情况</p><p><img src="https://file1.kamacoder.com/i/algo/20210110103003361.png" alt="img"></p><p>动态规划的思路是根据子问题的求解推导出整体的最优解</p><p>先把物品0放在背包里</p><p><img src="https://file1.kamacoder.com/i/algo/20240730113455.png" alt="img"></p><p>背包容量为0，放不下物品0，此时背包里的价值为0。</p><p>背包容量为1，可以放下物品0，此时背包里的价值为15.</p><p>背包容量为2，依然可以放下物品0 （注意 01背包里物品只有一个），此时背包里的价值为15。</p><p>以此类推。</p><p>再看把物品1 放入背包：</p><p><img src="https://file1.kamacoder.com/i/algo/20240730114228.png" alt="img"></p><p>背包容量为 0，放不下物品0 或者物品1，此时背包里的价值为0。</p><p>背包容量为 1，只能放下物品0，背包里的价值为15。</p><p>背包容量为 2，只能放下物品0，背包里的价值为15。</p><p>背包容量为 3，上一行同一状态，背包只能放物品0，这次也可以选择物品1了，背包可以放<code>物品1 </code> <strong>或者</strong> <code>物品0</code> ，物品1价值更大，背包里的价值为20</p><p>背包容量为 4，上一行同一状态，背包只能放物品0，这次也可以选择物品1了，背包可以放下<code>物品0</code> <strong>和</strong> <code>物品1</code> ，背包价值为35</p><ol start="2"><li>对于递推公式，首先我们要明确有哪些方向可以推导出 dp[i][j]。</li></ol><p>这里我们dp[1][4]的状态来举例：</p><p>求取 dp[1][4] 有两种情况：</p><ol><li>放物品1</li><li>还是不放物品1</li></ol><p>如果不放物品1， 那么背包的价值应该是 dp[0][4] 即 容量为4的背包，只放物品0的情况。</p><p><img src="https://file1.kamacoder.com/i/algo/20240730174246.png" alt="img"></p><p>如果放物品1， <strong>那么背包要先留出物品1的容量</strong>，目前容量是4，物品1 的容量（就是物品1的重量）为3，此时背包剩下容量为1。</p><p>容量为1，只考虑放物品0 的最大价值是 dp[0][1]，这个值我们之前就计算过。</p><p>所以 放物品1 的情况 = dp[0][1] + 物品1 的价值，推导方向如图：</p><p><img src="https://file1.kamacoder.com/i/algo/20240730174436.png" alt="img"></p><p>两种情况，分别是放物品1 和 不放物品1，我们要取最大值（毕竟求的是最大价值）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[1][4] = max(dp[0][4], dp[0][1] + 物品1 的价值)</span><br></pre></td></tr></table></figure><p>以上过程，抽象化如下：</p><ul><li><strong>不放物品i</strong>：背包容量为j，里面不放物品i的最大价值是dp[i - 1][j]。</li><li><strong>放物品i</strong>：背包空出物品i的容量后，背包容量为j - weight[i]，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]且不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值</li></ul><p>递归公式： <code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</code></p><ol start="3"><li>dp数组初始化</li></ol><p>首先从dp[i][j]的定义出发，如果背包容量j为0的话，即dp[i][0]，无论是选取哪些物品，背包价值总和一定为0。如图：</p><p><img src="https://file1.kamacoder.com/i/algo/2021011010304192.png" alt="img"></p><p>状态转移方程 <code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</code> 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。</p><p>dp[0][j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。</p><p>那么很明显当 <code>j &lt; weight[0]</code>的时候，dp[0][j] 应该是 0，因为背包容量比编号0的物品重量还小。</p><p>当<code>j &gt;= weight[0]</code>时，dp[0][j] 应该是value[0]，因为背包容量放足够放编号0物品。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里是正序遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> j = weight[<span class="number">0</span>]; j &lt;= bagweight; j++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][j] = value[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://file1.kamacoder.com/i/algo/20210110103109140.png" alt="img"></p><p>而其实位置的dp数据初始化为什么都可以，因为它们会在计算时被直接覆盖掉，所以全部初始化为0</p><ol start="4"><li>遍历顺序</li></ol><p>明显有两个维度 ：物品个数 与 背包容量，我们先遍历物品个数再遍历背包容量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// weight数组的大小 就是物品个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= bagweight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://file1.kamacoder.com/i/algo/202101101032124.png" alt="img"></p><p>先遍历背包容量再物品个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// weight数组的大小 就是物品个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= bagweight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://file1.kamacoder.com/i/algo/20210110103244701.png" alt="img"></p><p>虽然两个for循环遍历的次序不同，但是dp[i][j]所需要的数据就是左上角，根本不影响dp[i][j]公式的推导！</p><p>但先遍历物品再遍历背包这个顺序更好理解。</p><p><strong>其实背包问题里，两个for循环的先后循序是非常有讲究的，理解遍历顺序其实比理解推导公式难多了</strong>。</p><ol start="5"><li>举例推导dp数组</li></ol><p>这里在把基本信息给出来：</p><table><thead><tr><th></th><th>重量</th><th>价值</th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td></tr><tr><td>物品1</td><td>3</td><td>20</td></tr><tr><td>物品2</td><td>4</td><td>30</td></tr></tbody></table><p><img src="https://file1.kamacoder.com/i/algo/20210118163425129.jpg" alt="img"></p><p>从物品1开始遍历，背包容量从0开始遍历</p><p>0&lt;weight[1]: dp[1][0] = dp[0][0] = 15</p><p>1&lt;weight[1]: dp[1][1] = dp[0][1] = 15</p><p>2&lt;weight[1]: dp[1][2] = dp[0][2] = 15</p><p>3&gt;=weight[1]: dp[1][3] = max(dp[0][3], dp[0][3 - weight[1]] + val[1]) = 20</p><p>4&gt;=weight[1]: dp[1][4] = max(dp[0][4], dp[0][4 - weight[1]] + val[1]) = 35</p><p>再遍历物品2，仍然从容量0开始遍历</p><h3 id="一维数组01背包">一维数组01背包</h3><p>递推公式如下：<code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + val[i])</code></p><p>可见dp每次会用到上一个物品dp[i-1]的值，而我们完全可以用一个一维数组，表示每个物品在不同背包容量下的最大价值；</p><p><code>dp[j] = max(dp[j], dp[j - weight[i]] + val[i])</code></p><p>max里的的dp[j]和dp[j - weight[i]] 其实是上一个物品i的值，新一个物品i+1的值是最左边的dp[j]</p><blockquote><p>一维数组遍历时与二维数组不同</p></blockquote><p>一维dp数组遍历顺序代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里大家发现和二维dp的写法中，遍历背包的顺序是不一样的！</strong></p><p>二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。</p><p>为什么呢？</p><p><strong>倒序遍历是为了保证物品i只被放入一次！</strong>。但如果一旦正序遍历了，那么物品0就会被重复加入多次！</p><p>举一个例子：物品0的重量weight[0] = 1，价值value[0] = 15</p><p>如果正序遍历</p><p>dp[1] = max(dp[1 - weight[0]] + value[0], dp[1]) = 15</p><p>dp[2] = max(dp[2 - weight[0]] + value[0], dp[2]) = 30（因为value[0]=15,而dp[2 - weight[0]]=15）</p><p>比如下表是在计算dp[2]时的情况</p><table><thead><tr><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>物品0</td><td>0</td><td><code>0</code></td><td>0</td><td>0</td><td>0</td></tr><tr><td>物品1</td><td>0</td><td>15</td><td></td><td></td><td></td></tr></tbody></table><p>在计算dp[2]时，max(dp[2 - weight[0]] + value[0], dp[2]) 里 dp[2 - weight[0]]的本意是拿(物品0, 下标1)的值<code>0</code>，但由于现在是一维数组，所以dp[2 - weight[0]]就成了（物品1，下标1）的值<code>15</code>，由于value[0]也是15，所以dp[2]得到了<code>30</code></p><p>此时dp[2]就已经是30了，<code>意味着物品0，被放入了两次</code>，所以不能正序遍历。</p><p>为什么倒序遍历，就可以保证物品只放入一次呢？</p><p>倒序就是先算dp[2]</p><p>dp[2] = max(dp[2 - weight[0]] + value[0], dp[2]) = 15 （dp数组已经都初始化为0，这里的dp[2]为0，且dp[2-1]也为0）</p><p>dp[1] = max(dp[1 - weight[0]] + value[0], dp[1]) = 15</p><p>所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。</p><blockquote><p><strong>那么问题又来了，为什么二维dp数组遍历的时候不用倒序呢？</strong></p></blockquote><p>因为对于二维dp，dp[i][j]都是<code>通过上一层即dp[i - 1][j]计算而来，本层的dp[i][j]并不会被覆盖！</code>（看刚刚的table例子）</p><p>（如何这里读不懂，大家就要动手试一试了，空想还是不靠谱的，实践出真知！）</p><p><strong>再来看看两个嵌套for循环的顺序，代码中是先遍历物品嵌套遍历背包容量，那可不可以先遍历背包容量嵌套遍历物品呢？</strong></p><p>不可以！</p><p>因为一维dp的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。</p><p><strong>所以一维dp数组的背包在遍历顺序上和二维其实是有很大差异的！</strong>，这一点大家一定要注意。</p><h1 id="携带研究材料-第六期模拟笔试">携带研究材料（第六期模拟笔试）</h1><p>题目描述</p><p>小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。他需要带一些研究材料，但是他的行李箱空间有限。这些研究材料包括实验设备、文献资料和实验样本等等，它们各自占据不同的空间，并且具有不同的价值。</p><p>小明的行李空间为 N，问小明应该如何抉择，才能携带最大价值的研究材料，每种研究材料只能选择一次，并且只有选与不选两种选择，不能进行切割。</p><p>输入描述</p><p>第一行包含两个正整数，第一个整数 M 代表研究材料的种类，第二个正整数 N，代表小明的行李空间。</p><p>第二行包含 M 个正整数，代表每种研究材料的所占空间。</p><p>第三行包含 M 个正整数，代表每种研究材料的价值。</p><p>输出描述</p><p>输出一个整数，代表小明能够携带的研究材料的最大价值。</p><p>输入示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">6 1</span><br><span class="line">2 2 3 1 5 2</span><br><span class="line">2 3 1 5 4 3</span><br></pre></td></tr></table></figure><p>输出示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><p>提示信息</p><p>小明能够携带 6 种研究材料，但是行李空间只有 1，而占用空间为 1 的研究材料价值为 5，所以最终答案输出 5。</p><p>数据范围：<br>1 &lt;= N &lt;= 5000<br>1 &lt;= M &lt;= 5000<br>研究材料占用空间和价值都小于等于 1000</p><h2 id="动态规划思路">动态规划思路</h2><p>dp数组创建，创建个二维背包（简单直观）</p><p>dp下标与含义：dp[i][j]表示物品i以及dp容量j时的背包价值</p><p>递推公式分成放物品i与不放物品i两种情况</p><p>如果不放物品i,则dp[i][j] = dp[i - 1][j]</p><p>如果放物品i， 则dp[i][j] = dp[i - 1][j - weight] + val[i]</p><p>递推公式：dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + val[i])</p><p>dp初始化，dp[i][0]全部为0，遍历dp[0][j]，如果j大于等于weight[0]则赋值为val[0]</p><p>遍历顺序，行遍历对物品，列遍历对背包容量</p><h2 id="二维dp动态规划代码">二维dp动态规划代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calMaxVal</span>(<span class="params">self, n: <span class="built_in">int</span>, capacity: <span class="built_in">int</span>, weight: <span class="built_in">list</span>, val: <span class="built_in">list</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 注意背包容量从0开始到capacity(闭区间)，所以个数为capacity+1</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (capacity + <span class="number">1</span>) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化第一个物品</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(weight[<span class="number">0</span>], capacity + <span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = val[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(capacity + <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 如果j装不下，直接继续上一物品此时的背包状态</span></span><br><span class="line">                <span class="keyword">if</span> j &lt; weight[i]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j]</span><br><span class="line">                <span class="comment"># 如果j能装下</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + val[i])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][capacity]</span><br><span class="line"></span><br><span class="line">n, capacity = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">weight = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split(<span class="string">&quot; &quot;</span>)))</span><br><span class="line">val = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split(<span class="string">&quot; &quot;</span>)))</span><br><span class="line"></span><br><span class="line">s = solution()</span><br><span class="line">res = s.calMaxVal(n, capacity, weight, val)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><h2 id="一维dp动态规划代码">一维dp动态规划代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution2</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calMaxVal</span>(<span class="params">self, n: <span class="built_in">int</span>, capacity: <span class="built_in">int</span>, weight: <span class="built_in">list</span>, val: <span class="built_in">list</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># dp用一维就行，长度是capacity</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (capacity + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 行遍历与列遍历</span></span><br><span class="line">        <span class="comment"># 行遍历物品</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 一维dp要倒序遍历，为了避免 数据污染。</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(capacity, weight[i] - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &gt;= weight[i]:</span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + val[i])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[capacity]</span><br><span class="line"></span><br><span class="line">n, capacity = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">weight = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split(<span class="string">&quot; &quot;</span>)))</span><br><span class="line">val = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split(<span class="string">&quot; &quot;</span>)))</span><br><span class="line"></span><br><span class="line">s2 = solution2()</span><br><span class="line">res2 = s2.calMaxVal(n, capacity, weight, val)</span><br><span class="line"><span class="built_in">print</span>(res2)</span><br></pre></td></tr></table></figure><h1 id="416-分割等和子集">416. 分割等和子集</h1><p><a href="https://leetcode.cn/problems/partition-equal-subset-sum/">https://leetcode.cn/problems/partition-equal-subset-sum/</a></p><p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,5,11,5]</span><br><span class="line">输出：true</span><br><span class="line">解释：数组可以分割成 [1, 5, 5] 和 [11] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,5]</span><br><span class="line">输出：false</span><br><span class="line">解释：数组不能分割成两个元素和相等的子集。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 200</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li></ul><h2 id="动态划分思路">动态划分思路</h2><p>将这个问题抽象成动态规划问题，target看作背包容量，而nums[i]既是重量也是价值</p><p>问题转换：<code>一共n个物品，每个物品选择一个，背包容量为target，能否让总价值也为target（即dp[target] == target）</code> ，其中，target为列表和的一半</p><ol><li><p>dp数组下标与含义：创建一维数组，下标i是weight（也是数字本身），dp[i]值表示当前背包总价值；dp长度： <strong>背包容量为target + 1即可</strong></p></li><li><p>递推公式：倒序遍历，并且dp[j]大于nums[i]，此时dp[j] = max(dp[j], dp[j - nums[i]]+nums[i])</p></li><li><p>初始化：全部为零</p></li><li><p>遍历顺序：物品（nums[i]）顺序遍历；而对于每个背包容量从target倒序遍历，一直到nums[i]（闭区间）</p></li><li><p>举例</p></li><li><p>nums[1, 5, 11, 5]</p></li><li><p>target = 11</p></li><li><p>dp[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</p></li><li></li><li><p><strong>i = 0, nums[0]=1, j = 11</strong></p></li><li><p>dp[11] = max[dp[11], dp[11 - 1] + 1] = 1</p></li><li><p>dp[10] = max[dp[10], dp[10 - 1] + 1] = 1</p></li><li><p>…</p></li><li><p>dp[1] = max[dp[1], dp[1 - 1] + 1] = 1</p></li><li><p>dp[0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]</p></li><li></li><li><p><strong>i = 1, nums[1]=5, j = 11</strong></p></li><li><p>dp[11] = max[dp[11], dp[11 - 5] + 5] = 6</p></li><li><p>dp[10] = max[dp[10], dp[10 - 5] + 5] = 6</p></li><li><p>…</p></li><li><p>dp[5] = max[dp[5], dp[5 - 5] + 5] = 6</p></li><li><p>[0, 1, 1, 1, 1, 5, 6, 6, 6, 6, 6, 6]</p></li><li></li><li><p><strong>i = 2, nums[2]=11, j = 11</strong></p></li><li><p>dp[11] = max[dp[11], dp[11 - 11] + 11] = 11</p></li><li><p>[0, 1, 1, 1, 1, 5, 6, 6, 6, 6, 6, 11]</p></li><li></li><li><p><strong>i = 3, nums[3]=5, j=11</strong></p></li><li><p>dp[11] = max[dp[11], dp[11 - 5] + 5] = max(11, dp[6] + 5) = 11</p></li><li><p>dp[10] = max[dp[10], dp[10 - 5] + 5] = max(6, dp[5] + 5) = 10</p></li><li><p>dp[9] = max[dp[9], dp[9 - 5] + 5] = max(6, dp[4] + 5) = 6</p></li><li><p>…</p></li><li><p>[0, 1, 1, 1, 1, 5, 6, 6, 6, 6, 10, 11]</p></li></ol><h2 id="动态规划代码">动态规划代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">canPartition</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        self.sumOfnums = <span class="built_in">sum</span>(nums)</span><br><span class="line">        self.LOfnums = <span class="built_in">len</span>(nums)</span><br><span class="line">        self.nums = nums</span><br><span class="line">        <span class="keyword">if</span> self.sumOfnums % <span class="number">2</span> != <span class="number">0</span> :</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.target = self.sumOfnums // <span class="number">2</span></span><br><span class="line">        <span class="comment"># 动态规划</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (self.target + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.target, nums[i] - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j - nums[i]]+nums[i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> dp[self.target] == self.target:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="递归思路">递归思路</h2><p>本题目要求将数组分成两个子集，对于任意一个元素，要么在子集A，要么在子集B中</p><p>所以，如果暴力枚举出所有子集，判断两个子集和是否相等（直接判断当前子集和是否等于sum(nums)//2）</p><p>因为每个元素只有“被选中到子集A”和不被选择到子集A；而剩下的元素则可以看到一个子问题，可以考虑使用递归求解</p><p><strong>定义</strong> dfs(i,sum) 表示处理前 i 个元素后的总和为 sum，当前正在抉择第 i 个元素，判断能否凑成目标 target</p><p>第 i 个元素只有 “选或不选” 两种可能，<strong>状态转移</strong> 方程为：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>f</mi><mi>s</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">)</mo><mo>=</mo><mi>d</mi><mi>f</mi><mi>s</mi><mo stretchy="false">(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>∨</mo><mi>d</mi><mi>f</mi><mi>s</mi><mo stretchy="false">(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dfs(i,sum)=dfs(i+1,sum+nums[i]) \lor dfs(i+1,sum)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></span></p><p><strong>递归边界</strong>： i == n表示处理完所有元素，返回失败；或者 sum=target 表示当前子集符合目标，返回成功。</p><p><strong>递归入口</strong>： dfs(0,0)，表示从下标 0 开始搜索，目前总和为 0</p><p>注意，这里使用了@cache装饰器，避免重复搜索，降低时间复杂度。递归的参数只有两个，所以记忆化数组需要两维。</p><blockquote><p>@cache 的作用</p></blockquote><p>备忘录化机制：@cache 会自动为函数的参数组合缓存结果。例如，dfs 函数的参数是 (index, currentSum)，每次调用 dfs(index, currentSum) 时，如果这个参数组合之前已经计算过，结果会直接从缓存中取出，而不会重新执行函数体。</p><p>为什么需要它？ 在递归过程中，可能会多次遇到相同的状态。例如：</p><p>假设数组是 [1, 2, 3]，在不同分支中，可能会多次调用 dfs(2, 3)（即在索引 2 时，当前和为 3）。</p><p>如果不缓存，这些重复的调用会独立计算，导致时间复杂度从 O(1) 或 O(2^n) 级别的子问题中浪费大量时间。</p><p>使用 @cache 后，这些重复状态只计算一次，后续直接返回结果。</p><p>效率提升：这个问题的原始递归复杂度是 O(2^n)，因为有 n 个元素，每个元素两个选择。但通过 @cache，函数会将重叠子问题（overlapping subproblems）缓存起来，实际时间复杂度会降低到接近 O(n * target)，这取决于数组的大小和目标和的大小。更高效，避免了不必要的递归调用。</p><h2 id="递归代码">递归代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">canPartition</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">      self.sumOfnums = <span class="built_in">sum</span>(nums)</span><br><span class="line">      self.LOfnums = <span class="built_in">len</span>(nums)</span><br><span class="line">      self.nums = nums</span><br><span class="line">      <span class="keyword">if</span> self.sumOfnums % <span class="number">2</span> != <span class="number">0</span> :</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">      self.target = self.sumOfnums // <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">      @cache</span></span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">index, currentSum</span>):</span><br><span class="line">          <span class="keyword">if</span> currentSum == self.target:</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">          <span class="keyword">if</span> index == self.LOfnums:</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">          <span class="comment"># 每个数字都有选或不选两种情况</span></span><br><span class="line">          <span class="keyword">return</span> (dfs(index + <span class="number">1</span>, currentSum + nums[index]) <span class="keyword">or</span> dfs(index + <span class="number">1</span>, currentSum))</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h1 id="额外题目">额外题目</h1><h1 id="21-合并两个有序链表">21. 合并两个有序链表</h1><p><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">https://leetcode.cn/problems/merge-two-sorted-lists/</a></p><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [1,2,4], l2 = [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [], l2 = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [], l2 = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>两个链表的节点数目范围是 <code>[0, 50]</code></li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li></ul><h2 id="思路">思路</h2><p>如果使用新空间head，如果list1和list2（指两个具体节点）不为空，则比较两者的值并将较小的值放在head里，并移动较小值所在的链表</p><p>最后再判断如果list1或list2不为空，则将list1或list2接到head里</p><h2 id="链表代码">链表代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">self, list1: <span class="type">Optional</span>[ListNode], list2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="comment"># 双指针</span></span><br><span class="line">        <span class="comment"># 如果需要原地添加（不使用新空间的话，稍微麻烦一点儿）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用新空间</span></span><br><span class="line">        head = ListNode()</span><br><span class="line">        p = head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> list1 <span class="keyword">and</span> list2:</span><br><span class="line">            <span class="keyword">if</span> list1.val &lt; list2.val:</span><br><span class="line">                p.<span class="built_in">next</span> = list1</span><br><span class="line">                list1 = list1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p.<span class="built_in">next</span> = list2</span><br><span class="line">                list2 = list2.<span class="built_in">next</span></span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> list1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            p.<span class="built_in">next</span> = list1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p.<span class="built_in">next</span> = list2</span><br><span class="line">        <span class="keyword">return</span> head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><h1 id="228-汇总区间">228. 汇总区间</h1><p><a href="https://leetcode.cn/problems/summary-ranges/">https://leetcode.cn/problems/summary-ranges/</a></p><p>给定一个  <strong>无重复元素</strong> 的 <strong>有序</strong> 整数数组 <code>nums</code> 。</p><p>区间 <code>[a,b]</code> 是从 <code>a</code> 到 <code>b</code>（包含）的所有整数的集合。</p><p>返回 <em><strong>恰好覆盖数组中所有数字</strong> 的 <strong>最小有序</strong> 区间范围列表</em> 。也就是说，<code>nums</code> 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个区间但不属于 <code>nums</code> 的数字 <code>x</code> 。</p><p>列表中的每个区间范围 <code>[a,b]</code> 应该按如下格式输出：</p><ul><li><code>&quot;a-&gt;b&quot;</code> ，如果 <code>a != b</code></li><li><code>&quot;a&quot;</code> ，如果 <code>a == b</code></li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,2,4,5,7]</span><br><span class="line">输出：[&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]</span><br><span class="line">解释：区间范围是：</span><br><span class="line">[0,2] --&gt; &quot;0-&gt;2&quot;</span><br><span class="line">[4,5] --&gt; &quot;4-&gt;5&quot;</span><br><span class="line">[7,7] --&gt; &quot;7&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,2,3,4,6,8,9]</span><br><span class="line">输出：[&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;]</span><br><span class="line">解释：区间范围是：</span><br><span class="line">[0,0] --&gt; &quot;0&quot;</span><br><span class="line">[2,4] --&gt; &quot;2-&gt;4&quot;</span><br><span class="line">[6,6] --&gt; &quot;6&quot;</span><br><span class="line">[8,9] --&gt; &quot;8-&gt;9&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 20</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li><li><code>nums</code> 中的所有值都 <strong>互不相同</strong></li><li><code>nums</code> 按升序排列</li></ul><h2 id="思路">思路</h2><ol><li>从数组下标0开始向右遍历，如果相邻元素之间差值大于1，则找到了一个区间</li><li>遍历过程中，slow指向区间起点，fast指向区间终点；当找到一个区间时，再分情况将字符串添加到res<ol><li>先创建个temp=str(nums[slow])</li><li>如果nums[slow] != nums[fast]，则再将temp += “-&gt;” + str(nums[fast])</li></ol></li></ol><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">summaryRanges</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="comment"># 用双指针</span></span><br><span class="line">        <span class="comment"># 先动快指针，若fast +1 != i则将slow~fast添加到结果</span></span><br><span class="line">        <span class="comment"># slow = 0</span></span><br><span class="line">        <span class="comment"># fast = 0</span></span><br><span class="line">        <span class="comment"># if len(nums) == 0:</span></span><br><span class="line">        <span class="comment">#     return []</span></span><br><span class="line">        <span class="comment"># # 复制一个值，填充结尾</span></span><br><span class="line">        <span class="comment"># nums.append(nums[-1])</span></span><br><span class="line">        <span class="comment"># L = len(nums)</span></span><br><span class="line">        <span class="comment"># if L == 1:</span></span><br><span class="line">        <span class="comment">#     return [str(nums[0])]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># res = list()</span></span><br><span class="line">        <span class="comment"># def foo(slow, fast, res):</span></span><br><span class="line">        <span class="comment">#     if nums[slow] == nums[fast]:</span></span><br><span class="line">        <span class="comment">#         res.append(str(nums[slow]))</span></span><br><span class="line">        <span class="comment">#     else:</span></span><br><span class="line">        <span class="comment">#         res.append(str(nums[slow]) + &quot;-&gt;&quot; + str(nums[fast]) )</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># for i in range(1, L):</span></span><br><span class="line">        <span class="comment">#     if nums[i] != nums[fast] + 1:</span></span><br><span class="line">        <span class="comment">#         foo(slow, fast, res)</span></span><br><span class="line">        <span class="comment">#         slow = i</span></span><br><span class="line">        <span class="comment">#     fast = i</span></span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        i = <span class="number">0</span> </span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> i &lt; L:</span><br><span class="line">            slow = i</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; L <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>] + <span class="number">1</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            fast = i - <span class="number">1</span></span><br><span class="line">            temp = <span class="built_in">str</span>(nums[slow])</span><br><span class="line">            <span class="keyword">if</span> nums[slow] != nums[fast]:</span><br><span class="line">                temp += <span class="string">&quot;-&gt;&quot;</span> + <span class="built_in">str</span>(nums[fast])</span><br><span class="line">            res.append(temp)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday35动态规划part03&quot;&gt;LeetCodeCampsDay35动态规划part03&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;背包问题/01背包/一维dp数组与二维dp数组的执行区别&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 i</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
</feed>
