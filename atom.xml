<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lthero</title>
  
  <subtitle>个人博客</subtitle>
  <link href="https://blog.lthero.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.lthero.cn/"/>
  <updated>2022-09-23T11:33:21.968Z</updated>
  <id>https://blog.lthero.cn/</id>
  
  <author>
    <name>lthero</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浙江青年大学习自动打卡</title>
    <link href="https://blog.lthero.cn/2022/09/23/WeLearnAutoSign/"/>
    <id>https://blog.lthero.cn/2022/09/23/WeLearnAutoSign/</id>
    <published>2022-09-23T08:03:11.000Z</published>
    <updated>2022-09-23T11:33:21.968Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浙江青年大学习自动打卡">浙江青年大学习自动打卡</h1><blockquote><p>一键打卡工具：<a href="https://sign.lthero.cn/">https://sign.lthero.cn/</a></p></blockquote><p>代码思路：</p><ul><li>每个微信账号有唯一的<strong>openid</strong></li><li>在每次打开青年大学习网页时，后台会根据openid生成<strong>accessToken</strong></li><li>后续的所有与服务器交互的信息，都需要用<strong>accessToken</strong>才能拿到</li><li>只要拿到<strong>个人信息</strong>，再将<strong>个人信息</strong>和<strong>accessToken</strong>提交即可打卡完成</li></ul><p>​</p><p>为什么这样想？</p><ul><li>根据<strong>服务器发来的js文件</strong>推测出的</li></ul><p>​</p><p>打卡流程：</p><ul><li>安卓下载抓包软件 <a href="https://file-1305871479.cos.ap-nanjing.myqcloud.com/file/HttpCanary.apk">httpcanary</a>，安装完成后，1、同意条款  2、允许安装证书  3、root可以跳过</li><li>打开微信大学习，或着在微信进入：<em><a href="https://qczj.h5yunban.com/qczj-youth-learning/signUp.php">https://qczj.h5yunban.com/qczj-youth-learning/signUp.php</a></em> （将这个链接在聊天里面发送即可）。</li><li>进入微信大学习的页面后，再点击<strong>软件httpcanary</strong>右下角小飞机图标开始抓包</li><li>微信里面：点击“立即参与”-&gt;点击“去学习”。随后切到httpcanary，再点击右下角小飞机图标停止抓包。</li><li>httpcanary里面：点击右上角，找到“搜索”，直接搜索“openId”，注意：只要url是<strong><a href="http://qczj.h5yunban.com">qczj.h5yunban.com</a></strong>的包。一般可以在包名为“<a href="http://qczj.h5yunban.com/qczj-youth-learning/cgi-bin/">qczj.h5yunban.com/qczj-youth-learning/cgi-bin/</a><strong>user-api/course/last-info</strong>”的<strong>响应中，找到openId</strong><ul><li>注意：<strong>记录openId</strong>，因为以后没必要再次抓包！！！</li></ul></li><li>得到<strong>openId</strong>后，在config.yml中写入信息【name只是标识作用，目的是方便实现多人打卡】</li></ul><p>​</p><p>文件：config.yml</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">users<span class="punctuation">:</span></span><br><span class="line">  - user<span class="punctuation">:</span></span><br><span class="line">      name<span class="punctuation">:</span> &#x27;张三&#x27;</span><br><span class="line">      openid<span class="punctuation">:</span> &#x27;oO-a2tabkGObaWbIOd4U1Bpaf1l0&#x27;</span><br><span class="line">  - user<span class="punctuation">:</span></span><br><span class="line">      name<span class="punctuation">:</span> &#x27;李四&#x27;</span><br><span class="line">      openid<span class="punctuation">:</span> &#x27;oO-a2t7bkGhdaWbIOd4U1Bpaf1l0&#x27;</span><br></pre></td></tr></table></figure><hr><p>文件：<a href="http://index.py">index.py</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"></span><br><span class="line">getToken_url = <span class="string">&#x27;https://qczj.h5yunban.com/qczj-youth-learning/cgi-bin/login/we-chat/callback&#x27;</span></span><br><span class="line">getUserInfo_url = <span class="string">&#x27;https://qczj.h5yunban.com/qczj-youth-learning/cgi-bin/user-api/course/last-info&#x27;</span></span><br><span class="line">getClass_url = <span class="string">&#x27;https://qczj.h5yunban.com/qczj-youth-learning/cgi-bin/common-api/course/current&#x27;</span></span><br><span class="line">checkin_url = <span class="string">&#x27;https://qczj.h5yunban.com/qczj-youth-learning/cgi-bin/user-api/course/join&#x27;</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/plain&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getYmlConfig</span>(<span class="params">yaml_file=<span class="string">&#x27;config.yml&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(yaml_file, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        file_data = f.read()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dict</span>(yaml.load(file_data, Loader=yaml.FullLoader))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getToken</span>(<span class="params">openId</span>):</span><br><span class="line">    <span class="comment"># 根据openId获得token</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        getToken = requests.get(url=getToken_url, params=openId, headers=headers)</span><br><span class="line">        Token_raw = getToken.text</span><br><span class="line">        Token = re.findall(<span class="string">&#x27;[A-Z0-9]&#123;8&#125;[-][A-Z0-9]&#123;4&#125;[-][A-Z0-9]&#123;4&#125;[-][A-Z0-9]&#123;4&#125;[-][A-Z0-9]&#123;12&#125;&#x27;</span>, Token_raw)[<span class="number">0</span>]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;获取Token为:&#x27;</span> + Token)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;获取Token失败，请检查openId是否正确&#x27;</span>)</span><br><span class="line">    accessToken = &#123;</span><br><span class="line">        <span class="string">&#x27;accessToken&#x27;</span>: Token</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> accessToken</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getinfo</span>(<span class="params">accessToken</span>):</span><br><span class="line">    <span class="comment"># 根据accessToken获得用户信息</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        getUserInfo = requests.get(getUserInfo_url, params=accessToken, headers=headers)</span><br><span class="line">        userInfo = getUserInfo.json()</span><br><span class="line">        cardNo = userInfo[<span class="string">&quot;result&quot;</span>][<span class="string">&quot;cardNo&quot;</span>]</span><br><span class="line">        nid = userInfo[<span class="string">&quot;result&quot;</span>][<span class="string">&quot;nid&quot;</span>]</span><br><span class="line">        getClass = requests.get(getClass_url, params=accessToken, headers=headers)</span><br><span class="line">        Class = getClass.json()</span><br><span class="line">        classId = Class[<span class="string">&quot;result&quot;</span>][<span class="string">&quot;id&quot;</span>]</span><br><span class="line">        infos: <span class="built_in">list</span> = userInfo[<span class="string">&#x27;result&#x27;</span>][<span class="string">&#x27;nodes&#x27;</span>]</span><br><span class="line">        Faculty = [item[<span class="string">&#x27;title&#x27;</span>] <span class="keyword">for</span> item <span class="keyword">in</span> infos]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;签到课程为：&#x27;</span> + classId, <span class="string">&#x27;\n您填写的个人信息为：&#x27;</span> + cardNo, <span class="string">&#x27;\n您的签到所属组织为：&#x27;</span> + <span class="built_in">str</span>(Faculty))</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;获取历史信息失败，请您手动打卡：<span class="subst">&#123;e&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    checkinData = &#123;</span><br><span class="line">        <span class="string">&#x27;course&#x27;</span>: classId,</span><br><span class="line">        <span class="string">&#x27;subOrg&#x27;</span>: <span class="literal">None</span>,</span><br><span class="line">        <span class="string">&#x27;nid&#x27;</span>: nid,</span><br><span class="line">        <span class="string">&#x27;cardNo&#x27;</span>: cardNo</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> checkinData</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">signup</span>(<span class="params">accessToken, checkinData</span>):</span><br><span class="line">    <span class="comment"># 根据token和data完成打卡</span></span><br><span class="line">    checkin = requests.post(checkin_url, params=accessToken, data=json.dumps(checkinData), headers=headers)</span><br><span class="line">    result = checkin.json()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> result[<span class="string">&quot;status&quot;</span>] == <span class="number">200</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;签到成功&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;出现错误，错误码：&#x27;</span> + result[<span class="string">&quot;status&quot;</span>])</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;错误信息：&#x27;</span> + result[<span class="string">&quot;message&quot;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    config = getYmlConfig()</span><br><span class="line">    <span class="keyword">for</span> index, user <span class="keyword">in</span> <span class="built_in">enumerate</span>(config[<span class="string">&#x27;users&#x27;</span>]):</span><br><span class="line">        <span class="built_in">print</span>(user[<span class="string">&#x27;user&#x27;</span>][<span class="string">&#x27;name&#x27;</span>], <span class="string">&#x27;openId为 &#x27;</span>, user[<span class="string">&#x27;user&#x27;</span>][<span class="string">&#x27;openid&#x27;</span>])</span><br><span class="line">        openid = &#123;</span><br><span class="line">            <span class="string">&#x27;appid&#x27;</span>: <span class="string">&#x27;wx56b888a1409a2920&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;openid&#x27;</span>: user[<span class="string">&#x27;user&#x27;</span>][<span class="string">&#x27;openid&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        accesstoken = getToken(openid)</span><br><span class="line">        checkindata = getinfo(accesstoken)</span><br><span class="line">        signup(accesstoken, checkindata)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;===========================================&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后，使用定时任务crontab即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;浙江青年大学习自动打卡&quot;&gt;浙江青年大学习自动打卡&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;一键打卡工具：&lt;a href=&quot;https://sign.lthero.cn/&quot;&gt;https://sign.lthero.cn/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
      
    
    
    
    <category term="自动打卡" scheme="https://blog.lthero.cn/categories/%E8%87%AA%E5%8A%A8%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="自动打卡" scheme="https://blog.lthero.cn/tags/%E8%87%AA%E5%8A%A8%E6%89%93%E5%8D%A1/"/>
    
    <category term="青年大学习" scheme="https://blog.lthero.cn/tags/%E9%9D%92%E5%B9%B4%E5%A4%A7%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>【马克思】《1844年经济学哲学手稿》</title>
    <link href="https://blog.lthero.cn/2022/09/21/Maxism-01/"/>
    <id>https://blog.lthero.cn/2022/09/21/Maxism-01/</id>
    <published>2022-09-21T14:13:41.000Z</published>
    <updated>2022-09-22T06:06:01.079Z</updated>
    
    <content type="html"><![CDATA[<h1 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h1><h2 id="知乎问题"><a href="#知乎问题" class="headerlink" title="知乎问题"></a>知乎问题</h2><p>突然意识自己曾经引以为豪的编程其实是一种工具，这是一种悲哀吗？</p><p><a href="zhihu.com/question/469223256/answer/2100070901">原回答链接</a></p><h3 id="原回答："><a href="#原回答：" class="headerlink" title="原回答："></a>原回答：</h3><p>这种悲哀感的本质，其实就是马克思在《1844年经济学哲学手稿》中提出的“四个异化”（的前三个）：</p><p>1，工人同自己的劳动产品相异化。</p><p>2，工人同自己的劳动相异化。</p><p>3，人同自己的类本质相异化。</p><p>马克思认为人区别于动物的最大特点，就是人本质上就需要“工作”，既“创造性地改造环境”。马克思所说的工作，其实就是后来“马斯洛需求层次理论”中的“自我实现”需求。</p><p>这也是马克思的牛逼之处，理论精髓之一——人的本质就是需要工作、热爱工作的，工作是人之所以为“人”的重要组成部分。</p><p>但是</p><p>资本主义世界的雇佣关系，将工作这个部分严重扭曲了，以至于将“工作”与“人性”剥离开来。在资本主义世界中，无论是宏观角度还是微观角度，工作都与人性割裂开来，甚至让“工作”与“人性”变成了对立的存在。</p><p>所以人们普遍认为，下班才是人生的开始。</p><p>所以人们才需要丰富的夜生活，才需要各种宣泄和放纵。</p><p>而这，也助长了消费主义。</p><p>但是消费带来的快乐，终究只是隔靴搔痒，甚至是饮鸩止渴。消费并不能真正填补人性被剥离的空虚。</p><p>特别是，被剥离的部分（工作，或者说是自我实现）还是人性最重要、最核心、最高级的那一部分……</p><p>这种人性被剥离的悲哀</p><p>就正是你体会到的悲哀</p><p>你引以为豪的时候，是你以自我实现（工作）角度去看待编程，这是人性最高级的展现，当然值得自豪。</p><p>而你悲哀的，是发现编程如此高级的东西，它并不属于你……不仅编程的成果不属于你，编程的动机也不属于你，编程过程附带的精神回报也不属于你，甚至你的自我实现（工作）需求也不属于你了……编程沦落为一种生产商品的工具，甚至其本身也是一种商品。</p><p>你的自我实现，变成了一种交换生存资料的手段。放到马斯洛三角里，这种悲哀体现的更加直观：</p><p><img src="https://pic1.zhimg.com/v2-74d63b76e8df193b34eb70a8973f1745_r.jpg?source=1940ef5c" alt="img"></p><p>这个过程相当于把最高级的需求（自我实现），直接压低到最低级的生理需求（交换生存资料）层次！甚至，资本主义倾向于让你只能交换到“刚好能活着”的生存资料，多余的价值都会被剥削！甚至的甚至，再观察一下其他那些层次的需求，呵，这些东西在职场中都是要一一被打破的东西（职场pua请大伙卷起来！）。资本就是要把你压到只能获得生理需求的水平！</p><p>这实在是太tm悲哀了啊！</p><p>所以马克思也是深感悲哀，才搞出了共产主义。</p><p>而共产主义最本质、最核心的创新，就是要把资本主义剥离出来的人性还给人类，把工作和人性相统一，把每一个人都变成完整的人。</p><p>两百年前的哲学家，就已经从现象看到本质，抽离出一套理论体系，做出了一堆神准的推演和预言，定位了核心问题，并想出了一套解决方案。</p><h2 id="文章出处"><a href="#文章出处" class="headerlink" title="文章出处"></a>文章出处</h2><p><a href="http://theory.people.com.cn/n/2015/0209/c83850-26533173-3.html">原文章链接</a></p><h3 id="节选："><a href="#节选：" class="headerlink" title="节选："></a>节选：</h3><p>马克思在文本中提到的异化劳动的第一个规定是，从生产的结果看，劳动者的劳动和他的劳动产品相异化，即“物的异化”。这个规定是表示，劳动者同自己的劳动产品处于异己的对象性关系之中。劳动作为人的一种活动，本来表现为对对象的占有，是人将其自身的意志和力量客观化于对象中。由于劳动和资本的分离，工人生产的产品越多，资本家拿走的越多并转化为更多的资本，反过来继续统治他、奴役他，但是，工人占有的对象却越少，并越受其对象（即产品）的奴役和统治。</p><p>“劳动对工人来说是外在的东西，也就是说，不属于他的本质；因此，他在自己的劳动中不是肯定自己，而是否定自己，不是感到幸福，而是感到不幸，不是自由地发挥自己的体力和智力，而是使自己的肉体受折磨、精神遭摧残。……他的劳动不是自愿的劳动，而是被迫的强制劳动。因此，这种劳动不是满足一种需要，而只是满足劳动以外的那些需要的一种手段。……他的活动属于别人，这种活动是他自身的丧失。”</p><p>　　“结果是，人（工人）只有在运用自己的动物机能——吃、喝、生殖，至多还有居住、修饰等等——的时候，才觉得自己在自由活动，而在运用人的机能时，觉得自己不过是动物。动物的东西成为人的东西，而人的东西成为动物的东西。”——马克思《1844年经济学哲学手稿》</p><h2 id="自我理解"><a href="#自我理解" class="headerlink" title="自我理解"></a>自我理解</h2><p>如果理解了“自我实现”与“交换生存资料”的区别，便能理解：<a href="https://www.bilibili.com/video/BV1wP411L7sC">视频</a>，里面司机的行为。他是为了自我实现，而不是单纯为了交换生存资料。</p><p>如果司机生活在共产主义的社会，他可能是更乐意的这份工作，对他自己来说，他的工作实现了自我意义，他乐意劳动，而不是为了交换生存资料而劳动。</p><p>我是偏向以“自我实现”为驱动的人，如果给我一份我没兴趣或不喜欢的任务，我的生产积极性不会高，因为这是建立在我为了交换生存资料为目的的任务，这是所有人的自然共性。</p><p>如果公司一味地认为我是劳动力商品，那相应的，我也会以交换生存资料为目的地完成任务，我不会有归属感和团队文化认同感，我只是在机械地完成任务并拿到薪水。</p><p>如果我有了对团队文化的认同感，我能意识到我是这个任务中关键的一环，这任务与我高度利益相关，那我“自我实现”为驱动的动力，并且生产积极性会变得很高，届时我并不在乎我工作是否为了生存资料，而是以自我实现而劳动。【这也许就是许多公司给员工股份的原因】</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;随笔&quot;&gt;&lt;a href=&quot;#随笔&quot; class=&quot;headerlink&quot; title=&quot;随笔&quot;&gt;&lt;/a&gt;随笔&lt;/h1&gt;&lt;h2 id=&quot;知乎问题&quot;&gt;&lt;a href=&quot;#知乎问题&quot; class=&quot;headerlink&quot; title=&quot;知乎问题&quot;&gt;&lt;/a&gt;知乎问题&lt;/h</summary>
      
    
    
    
    <category term="马克思" scheme="https://blog.lthero.cn/categories/%E9%A9%AC%E5%85%8B%E6%80%9D/"/>
    
    
    <category term="马克思" scheme="https://blog.lthero.cn/tags/%E9%A9%AC%E5%85%8B%E6%80%9D/"/>
    
  </entry>
  
  <entry>
    <title>【python爬虫】美拍网图片下载</title>
    <link href="https://blog.lthero.cn/2022/09/12/python-download-meipai/"/>
    <id>https://blog.lthero.cn/2022/09/12/python-download-meipai/</id>
    <published>2022-09-12T12:06:41.000Z</published>
    <updated>2022-09-12T12:20:04.343Z</updated>
    
    <content type="html"><![CDATA[<h1 id="美拍网图片下载"><a href="#美拍网图片下载" class="headerlink" title="美拍网图片下载"></a>美拍网图片下载</h1><blockquote><p>难度不大，网站对f12和右键有限制，但不是大问题。</p><p>网站没有反爬，至少没有给图片加防盗链，下载的图片并不是最高清，但清晰度还可以。</p></blockquote><ul><li>多线程代码直接复制之前的，其它的也大部分是走流程，固定套路</li><li>网站上图片全部为jpg格式，所以无需考虑png格式下载</li><li>唯一需要注意的是，有些图片src链接并不完整，需要自行判断和补全</li></ul><p>网站：<a href="https://4zipai.net/">https://4zipai.net</a></p><p>使用方式：</p><p>先：输入路径 </p><p>后：输入网址,如：’<a href="https://4zipai.net/selfies/202207/139004.html&#39;">https://4zipai.net/selfies/202207/139004.html&#39;</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;Cookie&#x27;</span>: <span class="string">&#x27;_ga=GA1.2.87052855.1662906879; _gid=GA1.2.106606571.1662906879; twk_idm_key=Szy-fmwxLJBDQNQQ_hKZE; TawkConnectionTime=0; twk_uuid_5e23d8f08e78b86ed8aa0035=%7B%22uuid%22%3A%221.101H94883vBguY180oYHfz0VN3Yrx0pdi2oaeD50URIjcHT13XZdZReDZEMwzt5gW4NEYVHRIUmMAPKTQXzgo0tbdNL6fRa2f2JnkKEdjUC5Me7ZTzLZlaEgUmdlaJJk9PBSm4ORF3UQSw%22%2C%22version%22%3A3%2C%22domain%22%3A%224zipai.net%22%2C%22ts%22%3A1662906990942%7D; __cf_bm=v0FGBMppZPUweg7R0uBuFPrQlE71b0ptig4q4MkaeBU-1662906991-0-AcVALr7cJKi1sMQpzf8Zs1DEJ1PojPDd9mLT8fncCrdyiEBznfws9/awsYksUmTA0dbcUfgPxplYWbTz7LfBSmLvl1dQAD4RU0ni6jxBgdSIvn8SxmBZSJkJCI00EuzjOw==&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myThread</span>(threading.Thread):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, url, fileName, file_path</span>):</span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.url = url</span><br><span class="line">        self.file_path = file_path</span><br><span class="line">        self.fileName = fileName</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">open_url</span>(<span class="params">self, url</span>):</span><br><span class="line">        response = requests.get(url, headers)</span><br><span class="line">        <span class="keyword">return</span> response.text</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        img = requests.get(self.url, headers=headers)</span><br><span class="line">        file = self.file_path + <span class="string">&quot;\\&quot;</span> + self.fileName + <span class="string">&quot;.jpg&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(file):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Downloading %s&quot;</span> % self.fileName)</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;%s/%s.jpg&#x27;</span> % (self.file_path, self.fileName), <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(img.content)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(self.file_path + <span class="string">&quot;\\&quot;</span> + self.fileName + <span class="string">&quot; exist&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#x27;https://4zipai.net/selfies/202207/139004.html&#x27;</span></span><br><span class="line">save_path = <span class="built_in">input</span>(<span class="string">&quot;输入要保存的路径文件夹&quot;</span>)</span><br><span class="line">url = <span class="built_in">input</span>(<span class="string">&quot;输入网址&quot;</span>)</span><br><span class="line">rsp = requests.get(url=url, headers=headers)</span><br><span class="line">rsp.encoding=<span class="string">&quot;UTF-8&quot;</span></span><br><span class="line">soup = BeautifulSoup(rsp.text, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line"><span class="comment"># 获得标题名</span></span><br><span class="line">title=soup.find(<span class="string">&#x27;div&#x27;</span>,class_=<span class="string">&quot;item_title&quot;</span>)</span><br><span class="line">save_path=save_path+<span class="string">&#x27;\\&#x27;</span>+ <span class="built_in">str</span>(title.find(<span class="string">&quot;h1&quot;</span>).text).strip(<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="comment"># 创建标题对应目录</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(save_path):</span><br><span class="line">    os.makedirs(save_path)</span><br><span class="line">li = soup.find(class_=<span class="string">&#x27;content_left&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> li.find_all(<span class="string">&#x27;img&#x27;</span>):</span><br><span class="line">    <span class="comment"># 查找图片链接</span></span><br><span class="line">    each_url=<span class="built_in">str</span>(i.get(<span class="string">&#x27;src&#x27;</span>))</span><br><span class="line">    judge = each_url[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> judge == <span class="string">&quot;d&quot;</span>:</span><br><span class="line">        each_url = <span class="string">&quot;https://4zipai.net/&quot;</span> + each_url</span><br><span class="line">    name = <span class="built_in">str</span>(each_url).split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>].split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(name) &gt;= <span class="number">9</span>:</span><br><span class="line">        thread1 = myThread(each_url, name, save_path)</span><br><span class="line">        thread1.start()</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="https://cdn.lthero.cn/post_images/course/Cryptography/image-20220912201020532.png" alt="效果图截图，内容不展示"></p><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><blockquote><p>&#x2F;selfies&#x2F;202208&#x2F;140912.html</p><p>&#x2F;selfies&#x2F;202209&#x2F;142694.html</p><p>&#x2F;selfies&#x2F;201808&#x2F;70879.html</p><p>&#x2F;selfies&#x2F;201804&#x2F;63980.html</p><p>&#x2F;selfies&#x2F;201708&#x2F;48223.html</p><p>&#x2F;selfies&#x2F;201903&#x2F;80767.html</p><p>&#x2F;selfies&#x2F;201804&#x2F;63878.html</p><p>&#x2F;selfies&#x2F;202207&#x2F;139004.html</p><p>&#x2F;selfies&#x2F;202209&#x2F;142301.html</p><p>&#x2F;selfies&#x2F;202209&#x2F;142402.html</p><p>&#x2F;selfies&#x2F;202209&#x2F;142391.html</p><p>&#x2F;selfies&#x2F;202209&#x2F;142416.html</p><p>&#x2F;selfies&#x2F;202208&#x2F;142269.html</p><p>&#x2F;selfies&#x2F;202209&#x2F;142317.html</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;美拍网图片下载&quot;&gt;&lt;a href=&quot;#美拍网图片下载&quot; class=&quot;headerlink&quot; title=&quot;美拍网图片下载&quot;&gt;&lt;/a&gt;美拍网图片下载&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;难度不大，网站对f12和右键有限制，但不是大问题。&lt;/p&gt;
&lt;p&gt;网站没有</summary>
      
    
    
    
    <category term="python" scheme="https://blog.lthero.cn/categories/python/"/>
    
    <category term="爬虫" scheme="https://blog.lthero.cn/categories/python/%E7%88%AC%E8%99%AB/"/>
    
    
    <category term="python" scheme="https://blog.lthero.cn/tags/python/"/>
    
    <category term="爬虫" scheme="https://blog.lthero.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>【hexo更新到GitHub后博客内容未变】</title>
    <link href="https://blog.lthero.cn/2022/08/07/hexo-cant-update/"/>
    <id>https://blog.lthero.cn/2022/08/07/hexo-cant-update/</id>
    <published>2022-08-07T11:02:23.000Z</published>
    <updated>2022-08-07T11:08:45.486Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hexo更新到GitHub后博客内容未变"><a href="#hexo更新到GitHub后博客内容未变" class="headerlink" title="hexo更新到GitHub后博客内容未变"></a>hexo更新到GitHub后博客内容未变</h1><blockquote><p>问题描述：hexo d -g可以将文章上传到github的仓库，但打开网页(<code>github-page</code>)后，<strong>发现内容并未更新</strong></p><p>原因：<strong>github-page对私有仓库不免费</strong></p><p>解决方法：<strong>将仓库设置为公开</strong></p></blockquote><p>过程：我尝试过网上各种方法，清除<code>.deploy_git</code>、<code>hexo clean</code>等，但都无效。我检查了github-pages 的更新状态，一直是 <strong>17 days ago</strong> <code>Active</code>。再联想到“github-page”对私有仓库不是免费的，而我虽然之前一直把项目设置为私有，但我开过github学生包，里面包含免费的私有仓库的权益，但最近学生包过期了，于是就不能使用gihub-page。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;hexo更新到GitHub后博客内容未变&quot;&gt;&lt;a href=&quot;#hexo更新到GitHub后博客内容未变&quot; class=&quot;headerlink&quot; title=&quot;hexo更新到GitHub后博客内容未变&quot;&gt;&lt;/a&gt;hexo更新到GitHub后博客内容未变&lt;/h1&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【linux】学习笔记Chap_26_系统进程管理</title>
    <link href="https://blog.lthero.cn/2022/08/02/linux-learningPathChp26/"/>
    <id>https://blog.lthero.cn/2022/08/02/linux-learningPathChp26/</id>
    <published>2022-08-02T13:15:11.000Z</published>
    <updated>2022-08-02T13:15:35.541Z</updated>
    
    <content type="html"><![CDATA[<h1 id="系统进程管理"><a href="#系统进程管理" class="headerlink" title="系统进程管理"></a>系统进程管理</h1><ul><li>在Unix中，所有信息都由某个文件或程序提供，简单来说，文件只是个输入输出对象，而一个进程才是执行的对象</li></ul><h3 id="本章将搞懂-："><a href="#本章将搞懂-：" class="headerlink" title="本章将搞懂 ："></a>本章将搞懂 ：</h3><ul><li>进程从哪来？进程如何被系统控制？如何控制自己的进程？</li></ul><h2 id="系统如何控制进程"><a href="#系统如何控制进程" class="headerlink" title="系统如何控制进程"></a>系统如何控制进程</h2><ul><li>准确说：<strong>进程是一个被装载到内存的程序</strong>，全部的程序数据、信息也会被放入内存中。</li></ul><p>所有的<strong>进程被内核kernel</strong>管理，当一个进程创建时，内核指定一个 Process ID(identification number)给进程，以便追踪进程信息。</p><ul><li><ul><li>内核会管一个<strong>进程信息表</strong>，由<strong>PID和进程名构成，</strong>有了这个表，<strong>内核将掌握控制进程的必要信息。</strong></li></ul></li></ul><blockquote><p>小型Unix系统可以同时执行100多进程，大Unix可达到上千进程。</p></blockquote><h3 id="Cpu-time"><a href="#Cpu-time" class="headerlink" title="Cpu time"></a>Cpu time</h3><p>先介绍Cpu time, 以前电脑只有一个cpu，而单个cpu要面对不同进程任务，为了雨均沾，给每个进程设置一个cputime 如10毫秒。cpu从 等待执行的进程列表中选出一个进程，让其执行10毫秒，时间一到就选出下一个进程，而上一个进程就要记录当前运行的状态，以便下次再继续。</p><h3 id="System-call"><a href="#System-call" class="headerlink" title="System call"></a><strong>System call</strong></h3><p>当一个程序要执行时，要向内核(kernel)发出一条call，让系统准备不同操作</p><ul><li>最重要的system calls 有<strong>fork exec wait exit</strong></li></ul><h4 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h4><p>fork 用来创建一个当前进程的复制进程，源进程为父进程，复制的进程为子进程</p><h4 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h4><p>wait 可以将进程暂停</p><h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h4><p>exec 可以将当前正在执行的进程改变成其他进程</p><h4 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h4><p>exit 退出当前进程(如，对刚登陆的shell使用，则会退出) shell本身也是个进程，也有PID</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以用echo $$ 查看当前shell的PID</span><br><span class="line">1509615</span><br></pre></td></tr></table></figure><p>kill 用来结另一个进程</p><h2 id="一个进程如何被执行"><a href="#一个进程如何被执行" class="headerlink" title="一个进程如何被执行"></a>一个进程如何被执行</h2><p>Unix有两种命令 内部和外部命令，内部命令是内置在Unix中的，所以不用创建新的进程</p><p>对于外部命令或外部程序，<strong>以下为Unix执行过程</strong></p><p>在shell中输入一个sl命令</p><p>则Unxi会用<strong>fork</strong>(system call ) 创建一个当前进程的复制进程(子进程) ,</p><ul><li>然后将子进程用<strong>exec</strong>将当前进程改变到要执行的外部命令sl</li><li>同时，将父进程用<strong>wait</strong>暂停执行，直到子进程完成.</li></ul><blockquote><p>进入shell后打开文档进行编辑也是这个过程，父进程将等待到vim退出编辑</p></blockquote><ul><li>在子进程结束后，将执行<strong>exit</strong>，然后转到父进程中。<strong>并将子进程所用的文件、内存全部释放</strong>，让其它进程再使用，此时，像子进程这种已经失效的进程成为<strong>Zombie</strong> ,在进程表中仍然保留其信息，当父进程恢复后，可以查看子进程在进程表的信息，随后系统将自动将信息删除。</li></ul><blockquote><p>Q：上面提到了fork 可以创建一份复制进程和一个父进程，但如何辨识两个进程是父还是子进程？</p><p>A：fork对父进程产生一个返回值(return value) 是进程原PID ,对子进程返回0</p></blockquote><h2 id="最初的进程-init"><a href="#最初的进程-init" class="headerlink" title="最初的进程 init"></a>最初的进程 init</h2><blockquote><p>Q：既然所有进程都由fork创建的子进程，那终极父进程是谁？</p><p>A：init进程</p></blockquote><h4 id="unix启动时"><a href="#unix启动时" class="headerlink" title="unix启动时"></a>unix启动时</h4><p>系统会<strong>”手动“</strong>创建一个<strong>特殊进程</strong>（不用fork创建)，并给一个<strong>PID为0</strong>（**#0）<strong>被称为</strong>”空闲进程“**。</p><ul><li>他执行一些重要功能如初始化数据</li><li>随后**#0进程开始分枝(fork)出进程#1**</li></ul><blockquote><p>#1被#0分支出来的，就是init进程，而<strong>init进程会打开系统的控制台并挂载到根文件系统</strong>。</p><p>然后#1运行&#x2F;etc&#x2F;inittab这里的shell脚本，执行脚本过程中，#1<strong>用fork产生子进程</strong>来执行不同命令，如让用户登陆</p></blockquote><ul><li>随后**#0进入无限循环<strong>但</strong>不做任何事**件(名字由来)</li><li>当目前无任何进程时，系统将进入#0进程，并不做任何事。</li></ul><h4 id="综上所述"><a href="#综上所述" class="headerlink" title="综上所述"></a>综上所述</h4><blockquote><p>#0这个空闲进程才是真正的终极父进程，#1 init也是个子进程，但考虑到#0完成任务后就消失了(不做任何事，但进程还运行runing)，因此，将#1称为 在活着的(living) 终极父进程</p></blockquote><p>如果某个父进程在子进程结束前先没了，子进程将变成(orphans)<strong>孤儿</strong>，但<strong>init将领养这个孤儿</strong>，让他继续完成未完成的任务。</p><h2 id="前台和后台进程"><a href="#前台和后台进程" class="headerlink" title="前台和后台进程"></a>前台和后台进程</h2><h3 id="后台进程（background）"><a href="#后台进程（background）" class="headerlink" title="后台进程（background）"></a>后台进程（background）</h3><p>让进程自己运行，不用监看他运行，shell将<strong>不会等待</strong>进程完成，就会<strong>提示输入下一条命令</strong></p><p>后台的进程也被称为<strong>自治进程</strong></p><p>如：</p><p>要对一大堆数据排序，要花较长时间，则可以让进程自己运行，人可以再执行一些其它命令。可以用&amp;(ampersan) 实现，告诉进程让他自己运行不用交互。</p><p>在一般命令后添加一个<code>&amp;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort &lt; file &gt; res &amp; </span><br></pre></td></tr></table></figure><p>如果一行有多个命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(sleep 5;cat /etc/passwd) &amp; #要用括号包起来</span><br></pre></td></tr></table></figure><h3 id="前台进程（foreground）"><a href="#前台进程（foreground）" class="headerlink" title="前台进程（foreground）"></a>前台进程（foreground）</h3><p>shell将<strong>等进程完成后再让输入下一命令</strong></p><h3 id="后台进程注意点"><a href="#后台进程注意点" class="headerlink" title="后台进程注意点"></a>后台进程注意点</h3><ul><li>对于某些需要在进程执行还要输入信息的情况，<strong>如果进程得不到输入，就会一直等待到有输入</strong>，这时可以用：</li></ul><p><code>fg命令</code> 将此<strong>进程移到前台</strong>并输入相关信息</p><ul><li>后台正在的进程会将<strong>输出到监视器</strong>或<strong>指定要某个文件</strong>中(推荐)</li><li>后台进程的<strong>输入会被用&#x2F;dev&#x2F;nul代替</strong>，并且无法用ctrl+c或其它方式中断。当然，可以用<code>kill</code> 来结束后台进程</li></ul><p>当后台进程完成时，shell会发送一条信息如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1] Done ls&gt;temp #表示进程完成</span><br></pre></td></tr></table></figure><p>当然，<strong>shell不会不识相</strong>的突然打断正在进行的工作并发出这条提醒，而在下一次正常提示其它命令信息时<strong>附加这条完成信息</strong></p><ul><li>如<strong>不想要提示信息</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set -o notify 就没了</span><br><span class="line">set +o notify 就有了</span><br></pre></td></tr></table></figure><h2 id="sleep命令-让进程延迟启动"><a href="#sleep命令-让进程延迟启动" class="headerlink" title="sleep命令#让进程延迟启动"></a>sleep命令#让进程延迟启动</h2><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sleep interval[s|m|h|d]   #interval是延迟时间</span><br></pre></td></tr></table></figure><h4 id="如"><a href="#如" class="headerlink" title="如"></a>如</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sleep 5 5秒（默认以秒为单位）</span><br><span class="line">sleep 5m 5分钟</span><br><span class="line">sleep 20;cat /etc/prasswd &amp;    表示在后台等待20秒，随后将passwd复制到屏幕前</span><br></pre></td></tr></table></figure><h2 id="jobs命令-显示全部的工作-1-x2F-2-x2F-3"><a href="#jobs命令-显示全部的工作-1-x2F-2-x2F-3" class="headerlink" title="jobs命令#显示全部的工作 #1&#x2F;#2&#x2F;#3"></a>jobs命令#显示全部的工作 #1&#x2F;#2&#x2F;#3</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps process status #显示全部进程</span><br></pre></td></tr></table></figure><p>ctrl + Z 将当前进程悬挂</p><p>echo $$显示当前shell 的PID</p><p>echo $! 显示上一个被移动到后端的命令</p><h2 id="fg命令-将job移动到前端"><a href="#fg命令-将job移动到前端" class="headerlink" title="fg命令#将job移动到前端"></a>fg命令#将job移动到前端</h2><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><ul><li>fg %[job]</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fg %num #则为通用方法</span><br></pre></td></tr></table></figure><p>若不添加**[job]**则恢复当前正在执行的job（有+）</p><p>或者可以用某个命令开头</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fg %make / fg %m /fg %?game</span><br></pre></td></tr></table></figure><p>再或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fg %+ / fg %-</span><br></pre></td></tr></table></figure><h4 id="常用表"><a href="#常用表" class="headerlink" title="%常用表"></a>%常用表</h4><p>%% 当前job</p><p>%+ 当前job</p><p>%- 之前job</p><p>%n job#n</p><p>%name 用具体名字</p><p>%?name 命令的一部分</p><p>[8]- running make game &gt; res &amp;</p><p>[1]+ running gcc program.c &amp;</p><p>举例：正在执行vim 编辑，突然想查找cal，可以将vim悬挂到后台按ctrl+z，在shell中输入cal 再将vim从后台中fg出来</p><p><code>ctrl+z</code> 后，shell给出一条提示，表示job#1 被停止</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1]+ Stopped vim testf   #表示testf已经停止</span><br></pre></td></tr></table></figure><p><code>fg %或fg %vim</code> 后可以恢复vim testf</p><h2 id="suspend命令-将当前shell悬挂"><a href="#suspend命令-将当前shell悬挂" class="headerlink" title="suspend命令#将当前shell悬挂"></a>suspend命令#将当前shell悬挂</h2><p>按<code>ctrl+z</code> 可以将job悬挂到后台，除了当前shell。如想将当前shell也悬挂，要用suspend</p><h4 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h4><ul><li>将当前shell悬挂，可以快速切换不同的身份</li></ul><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><ul><li>suspend [-f]</li></ul><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><ul><li>在bash shell下开了tcsh</li><li>在tcsh下，可以用suspend悬挂tcsh并bg到原bash</li></ul><h2 id="多任务同时协作"><a href="#多任务同时协作" class="headerlink" title="多任务同时协作"></a>多任务同时协作</h2><h3 id="jobs展示目前执行的"><a href="#jobs展示目前执行的" class="headerlink" title="jobs展示目前执行的"></a>jobs展示目前执行的</h3><h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><ul><li>jobs [-l]</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jobs</span><br><span class="line">[1] Stopped vim testf (被悬挂了)</span><br></pre></td></tr></table></figure><ul><li>jobs -l 可以显示进程PID</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jobs -l</span><br><span class="line">[1]+ 2288 Stopped vim testf</span><br></pre></td></tr></table></figure><ul><li>其中的+表示，current job正在执行的job</li><li>对应的-表示 之前的job</li></ul><h2 id="bg命令-将job移动到后端"><a href="#bg命令-将job移动到后端" class="headerlink" title="bg命令#将job移动到后端"></a>bg命令#将job移动到后端</h2><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><ul><li>bg [%job]</li></ul><p>用法和fg一样，%后可以接数字、命令、命令部分</p><p>bg一般配合<code>ctrl+z</code> 使用，如<strong>在等待某个程序输出时</strong>，此时不能输入命令，按<code>ctrl+z</code> 将进程悬挂，再输入<code>bg</code> 将进程放入后台。</p><h2 id="ps命令-查看进程信息"><a href="#ps命令-查看进程信息" class="headerlink" title="ps命令#查看进程信息"></a>ps命令#查看进程信息</h2><p>（process status） 查看进程信息</p><h4 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h4><ul><li>ps [-aefFly] [-p pid] [-u uid ]</li></ul><h4 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h4><p>显示哪些文件</p><ul><li>-a 将userid与进程相关</li><li>-e (everything)全部的进程包含系统进程</li><li>-p pid 查找指定PID</li><li>-u uid 查找UID</li><li>-t 只显示系统进程</li></ul><p>显示哪些数据</p><ul><li>默认 PID TTY TIME CMD</li><li>常用 -f UID PID PPID C TTY TIME CMD</li><li>-ly  S UID PID PPID C PRI NI RSS SZ WCHAN TTY TIME CMD</li></ul><p>TTY是终端名</p><p>CMD是正在执行的命令</p><p>TIME是使用cpu时间</p><p>PID是当前进程id</p><p>PPID是父进程id</p><p>WCHAN 等待的状态？有wait&#x2F;finish等值</p><p>S 状态 R runing T suspended S waiting</p><p>SZ 物理大小（占用内存情况）</p><p>ps -ef 常用，可以查看全部的进程并包含UID</p><p>使用ps 查找非系统进程，再显示出PID后再用<code>ps -f -p 1234</code> 显示具体信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ps</span><br><span class="line">1548435 pts/0 00:00:00 ps</span><br><span class="line">ps -f -p 1548435</span><br><span class="line">UID PID PPID C STIME TTY TIME CMD</span><br><span class="line">root 1522200 1522175 0 13:44 pts/0 00:00:00 -bash</span><br></pre></td></tr></table></figure><h2 id="top命令-实时监视系统进程"><a href="#top命令-实时监视系统进程" class="headerlink" title="top命令#实时监视系统进程"></a>top命令#实时监视系统进程</h2><h4 id="功能：-1"><a href="#功能：-1" class="headerlink" title="功能："></a>功能：</h4><ul><li>top可以展示系统实时变化的信息</li><li>按h可以查看按键帮助</li></ul><h4 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h4><ul><li>top -d delay -n count [-p pid[,pid]]</li></ul><h4 id="选项-1"><a href="#选项-1" class="headerlink" title="选项"></a>选项</h4><ul><li>-d 1 每隔1秒刷新 &#x2F;0.1s</li><li>-p PID 可以显示某个进程详细信息</li><li>-p -d 1 -p 1,2,3,4,5 可以展示多个PID</li></ul><h2 id="pstree命令"><a href="#pstree命令" class="headerlink" title="pstree命令"></a>pstree命令</h2><h4 id="功能：-2"><a href="#功能：-2" class="headerlink" title="功能："></a>功能：</h4><ul><li>展示进程树</li></ul><blockquote><p>上文提到过 ：每个进程都由其它进程复制的，源进程为父，新进程为子，而且子进程也有PID</p><p>#0被手动创建后，fork出子进程#1，再由#1执行各种操作，产生其它进程#3.4.5</p><p>而这些#3,4,5被称为<strong>守护进程</strong>，任务是等待事件发生并做出反馈</p><p>登陆进程会一直等着用户登陆，一旦用户登陆，登陆进程会创建新进程来执行shell</p><p>而shell又会执行命令，创建新进程</p><p>于是，每个进程便有唯一的父进程，整个进程系统可以用一棵树结构表示</p></blockquote><h4 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h4><ul><li>pstree [-aAcGnpu] [pid|userid]</li></ul><h4 id="选项-2"><a href="#选项-2" class="headerlink" title="选项"></a>选项</h4><ul><li>-p PID 指定PID&#x2F;UID 将展示属于UID的（全部）进程</li><li>-n 按PID排序</li><li>-a 展示整个命令行</li><li>-u 在子进程与父进程不同UID时标记</li></ul><h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><ul><li>用ps或echo $$查出当前shell的PID，再用pstree -p PID查出当前sh的结构</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo $$</span><br><span class="line">1539825</span><br><span class="line">pstree -p 1539825</span><br><span class="line">bash(1522200)---vim(1528516)---bash(1528529)---pstree(1528530)</span><br><span class="line">#可以看到 当前bash下开的命令 vim 后面的bash说明在进行vim后又打开了一个bash</span><br></pre></td></tr></table></figure><h2 id="Unix如何管理文件和进程"><a href="#Unix如何管理文件和进程" class="headerlink" title="Unix如何管理文件和进程"></a>Unix如何管理文件和进程</h2><ul><li>文件有文件系统，有文件树，根是root&#x2F; 每个文件有I-number 查看文件信息时，用ls 只要查看文件的I-node就行</li><li>进程有进程系统，进程树，根是#1 init 每个进程有PID 查看进程时，用ps&#x2F;top 要在进程所在的&#x2F;proc目录下，找到进程对应文件，再从文件中读取出信息</li></ul><blockquote><p>Q:那有什么命令可以打通文件与进程的关系吗？<code>fuser</code></p><p>A:可以列出每个<strong>进程所用到的文件</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find ./ -name &#x27;*.mp3&#x27; &gt;bar 2&gt;/dev/null &amp;   #让find在后台查找全部的mp3 把输出给bar</span><br><span class="line">[1] 2233        #表示当前进程PID</span><br><span class="line">fuser bar       #查询bar文件，可以得到</span><br><span class="line">bar:2233        #说明当前文件被2233进程使用</span><br></pre></td></tr></table></figure><h2 id="kill命令-给job发送一个信号"><a href="#kill命令-给job发送一个信号" class="headerlink" title="kill命令#给job发送一个信号"></a>kill命令#给job发送一个信号</h2><ul><li>给其它进程发送信号</li><li>停止一个进程 对某些进程不能用ctrl+c停止时（如后台进程）</li></ul><h3 id="停止进程"><a href="#停止进程" class="headerlink" title="停止进程"></a>停止进程</h3><h4 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h4><ul><li>kill [-9] PID | jobid</li></ul><h4 id="如-1"><a href="#如-1" class="headerlink" title="如"></a>如</h4><ul><li>kill 2233或像fg&#x2F;bg一样</li><li>kill %vim</li><li>kill %+ 停止当前运行进程</li></ul><p>如果kill也失效 <strong>-9 强制停止</strong>，保证一定会停止</p><p>kill -9 2233 —-但此方法<strong>不会让进程释放使用的资源</strong>，可能会导致文件错误关闭，<strong>要少用</strong></p><h3 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h3><p>kill本来是用于给不同进程发送信号的，但默认下发送结束进程信号，所以被叫做kill</p><h4 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h4><ul><li>kill [-signal] pid | jobid</li></ul><p>使用kill -l可以查看全部的信号</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;系统进程管理&quot;&gt;&lt;a href=&quot;#系统进程管理&quot; class=&quot;headerlink&quot; title=&quot;系统进程管理&quot;&gt;&lt;/a&gt;系统进程管理&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;在Unix中，所有信息都由某个文件或程序提供，简单来说，文件只是个输入输出对象，而一个进程才是执</summary>
      
    
    
    
    <category term="linux" scheme="https://blog.lthero.cn/categories/linux/"/>
    
    
    <category term="linux" scheme="https://blog.lthero.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>【linux】学习笔记Chap_13_Shell_variable</title>
    <link href="https://blog.lthero.cn/2022/08/02/linux-learningPathChp13/"/>
    <id>https://blog.lthero.cn/2022/08/02/linux-learningPathChp13/</id>
    <published>2022-08-02T13:13:32.000Z</published>
    <updated>2022-08-02T13:14:04.072Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【linux】学习笔记Chap-13-Shell-variable"><a href="#【linux】学习笔记Chap-13-Shell-variable" class="headerlink" title="【linux】学习笔记Chap_13_Shell_variable"></a>【linux】学习笔记Chap_13_Shell_variable</h1><h2 id="子进程或子shell"><a href="#子进程或子shell" class="headerlink" title="子进程或子shell"></a>子进程或子shell</h2><p>在登陆后的shell可以作为父shell</p><p>如果输入vi 命令 进入 另一个进程 则称为子进程</p><p>如果输入 bash 也可以创建一个新的shell 也是子sell</p><h3 id="global-and-local-变量"><a href="#global-and-local-变量" class="headerlink" title="global and local 变量"></a>global and local 变量</h3><p>像IGNOREEOF就是全局变量，他们可以用于任何进程 而且变量唯一</p><p>环境变量全部用<strong>大写表示</strong> 一般以<strong>小写命令局部变量</strong>（shell）变量</p><p>全部变量<strong>既是shell 也是 environment 变量</strong>不存在单纯的环境变量</p><p>想比较<strong>单纯shell变量</strong>和<strong>全部变量</strong>可以使用<strong>env</strong></p><p><strong>若只在set中</strong>,<strong>不在env中</strong>就是纯shell变量 （set中变量也比env多）</p><p><strong>两者都在的就是全部变量</strong></p><p>默认创建的变量都是shell变量</p><h2 id="创建环境变量—–export"><a href="#创建环境变量—–export" class="headerlink" title="创建环境变量—–export"></a>创建环境变量—–export</h2><p>export 来创建一个shell + environment 变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lthero=smart</span><br><span class="line">export lthero</span><br></pre></td></tr></table></figure><p>即可生效</p><p>或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lthero=smart;export lthero</span><br></pre></td></tr></table></figure><p>又或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export lthero=smart HOME=&quot;/etc/home&quot;....</span><br></pre></td></tr></table></figure><h2 id="查看环境变量—–env"><a href="#查看环境变量—–env" class="headerlink" title="查看环境变量—–env"></a>查看环境变量—–env</h2><p>env 可以查看全部的默认变量(环境变量)</p><p>用set 可以查看全部的shell 变量</p><h2 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h2><p>unset 删除一个变量</p><p>unset lthero HOME 只能用unset or un-export 删除shell&amp;环境变量</p><h2 id="echo-引号用法"><a href="#echo-引号用法" class="headerlink" title="echo 引号用法"></a>echo 引号用法</h2><p>echo ‘……’单引号内容的$会失效，将只输出$</p><p>“……”双引号内$() 可以起作用 $()表达执行某个命令</p><h3 id="用-连接长内容"><a href="#用-连接长内容" class="headerlink" title="用\连接长内容"></a>用\连接长内容</h3><p>echo test stetz stet \</p><p>test test ……….. \</p><p>可以换行 但内容是相连的，输出<strong>不会有换行</strong></p><h3 id="用引号连接长内容"><a href="#用引号连接长内容" class="headerlink" title="用引号连接长内容"></a>用引号连接长内容</h3><p>echo **’**test stets stet</p><p>etste**’**</p><p>或者用”” 内容会保留输入格式 即<strong>有换行</strong></p><h2 id="命令分类"><a href="#命令分类" class="headerlink" title="命令分类"></a>命令分类</h2><h3 id="internal-builtin）内部原生命令"><a href="#internal-builtin）内部原生命令" class="headerlink" title="internal(builtin）内部原生命令"></a>internal(builtin）内部原生命令</h3><p>shell会查找命令的程序位置再执行</p><h3 id="external外部命令"><a href="#external外部命令" class="headerlink" title="external外部命令"></a>external外部命令</h3><p>shell 会在 PATH这个环境变量中，优先查找外部命令程序位置</p><p>echo $PATH 可以查看全部外部命令存入位置 可以自己再添加 &#x2F;bin:&#x2F;usr&#x2F;bin: …. 用冒号分隔</p><h3 id="type检测命令类型"><a href="#type检测命令类型" class="headerlink" title="type检测命令类型"></a>type检测命令类型</h3><p>可以用type 检测所用命令是否为原生命令</p><p><code>type date time set</code> 一次查三个</p><p>date is &#x2F;bin&#x2F;date</p><p>time is a shell keyword  &#x2F;&#x2F;<strong>time 是keyword</strong> 也是原生在shell<strong>内部的命令</strong></p><p>set is a shell builtin   &#x2F;&#x2F;<strong>原生命令</strong></p><h3 id="命令help"><a href="#命令help" class="headerlink" title="命令help"></a>命令help</h3><p>help 可以列出全部的builtin命令 其中 help也是builtin命令</p><p>对于<strong>内置命令</strong>，可以查看<strong>基本用法</strong></p><p>” help 命令“ 和“命令 –help”一样</p><p>help -s pwd 将只显示其选项 参数</p><p>对于<strong>外置命令，用</strong></p><p>“命令 –help”</p><h2 id="export—-添加自定义路径"><a href="#export—-添加自定义路径" class="headerlink" title="export—-添加自定义路径"></a>export—-添加自定义路径</h2><p>对于已经设置好的PATH 可以用export 添加自己的路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exprot PATH=&quot;$PATH:/usr/bin/myfile&quot;</span><br></pre></td></tr></table></figure><p>其中 myfile 里面可以放入自定义的shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exprot PATH=&quot;/usr/bin/myfile:$PATH&quot;</span><br></pre></td></tr></table></figure><p>此用法将自定义路径<strong>添加到前面</strong></p><p>添加到前面后，如果自己有同名的内置sh文件，shell 会<strong>优先执行自定义</strong>的，再执行内置的</p><h3 id="设置PATH"><a href="#设置PATH" class="headerlink" title="设置PATH"></a>设置PATH</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exprot PATH=&quot;/bin:/usr/bin:/usr/local/bin&quot;....</span><br></pre></td></tr></table></figure><h3 id="设置终端命令符号"><a href="#设置终端命令符号" class="headerlink" title="设置终端命令符号"></a>设置终端命令符号</h3><p>在<code>/root/.bashrc</code> 中添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PS1=&quot;\[\e[33;1m\]\u@\h:\w# \[\e[0m\]&quot;</span><br></pre></td></tr></table></figure><p>32是绿色 33淡黄色</p><p>可以设置命令提示符 成为绿色 \u 命令 user \h hostname \w 是当前全路径 \W 只显示当前路径</p><p><strong>修改后立即生效source &#x2F;etc&#x2F;profile</strong></p><p><a href="https://www.cnblogs.com/kevingrace/p/5985970.html">详细</a></p><p>另外：</p><ul><li><code>vim /etc/motd</code> 可以修改连接上linux对话</li></ul><p>如：Hello,Welcome to Linux!</p><ul><li><code>/etc/profile.d</code> 目录下添加自定义sh脚本将连接到linux时执行</li></ul><h4 id="上面PS1中的用法是一种特殊写法"><a href="#上面PS1中的用法是一种特殊写法" class="headerlink" title="上面PS1中的用法是一种特殊写法"></a>上面PS1中的用法是一种特殊写法</h4><p>\u代表 $USER(环境变量) 当前用户</p><p>\w代表$PWD 当前路径</p><p>\h代表$(hostaname) 主机名</p><p>\d代表date 时间</p><p>@代表time  运行时间</p><p>!代表历史命令</p><h2 id="查看历史记录"><a href="#查看历史记录" class="headerlink" title="查看历史记录"></a>查看历史记录</h2><h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><p>history 将展示全部的历史记录 如果想要运行某条 num是命令编号</p><p>可以<code>!num</code> 将执行那条命令， <code>!!</code> 将自动执行上一条命令</p><h3 id="fc"><a href="#fc" class="headerlink" title="fc"></a>fc</h3><p>fc 将自动调用vim 编辑器修改命令 修改完成并自动r执行</p><p>fc -l 显示历史近20条命令</p><p><code>fc -s num</code> 和 <code>! num</code> 一样 执行指定命令</p><p><code>fc num</code> 将编辑此命令</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;【linux】学习笔记Chap-13-Shell-variable&quot;&gt;&lt;a href=&quot;#【linux】学习笔记Chap-13-Shell-variable&quot; class=&quot;headerlink&quot; title=&quot;【linux】学习笔记Chap_13_Shell_v</summary>
      
    
    
    
    <category term="linux" scheme="https://blog.lthero.cn/categories/linux/"/>
    
    
    <category term="linux" scheme="https://blog.lthero.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>【linux】学习笔记Chap_14_Init_file</title>
    <link href="https://blog.lthero.cn/2022/08/02/linux-learningPathChp14/"/>
    <id>https://blog.lthero.cn/2022/08/02/linux-learningPathChp14/</id>
    <published>2022-08-02T13:12:05.000Z</published>
    <updated>2022-08-07T10:36:17.072Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Init-file"><a href="#Init-file" class="headerlink" title="Init_file"></a>Init_file</h1><blockquote><p>初始文件</p></blockquote><h3 id="命令习惯rc"><a href="#命令习惯rc" class="headerlink" title="命令习惯rc"></a>命令习惯rc</h3><p>run commonds 是一种配置文件，如 .bashrc .exrc</p><p>这些命令后在某个程序启动时自动运行</p><p>作为一个命名习惯， 如 我写了个foo 的程序 那么将<strong>初始化文件</strong></p><p>写作为 <strong>.foorc</strong> (foo 只是随便哪个名字)</p><h2 id="文档编辑器"><a href="#文档编辑器" class="headerlink" title="文档编辑器"></a>文档编辑器</h2><h3 id="nano-和-pico-和-vi"><a href="#nano-和-pico-和-vi" class="headerlink" title="nano 和 pico 和 vi"></a>nano 和 pico 和 vi</h3><p>vi 常用于 CLI 命令行接口</p><p>nano 和 pico 常用于GUI 图形化接口</p><h2 id="Shell-几种形式"><a href="#Shell-几种形式" class="headerlink" title="Shell 几种形式"></a>Shell 几种形式</h2><p>shell 的几种形式 login shell &amp;&amp; non login shell</p><p>交互的划分 interactive shell &amp;&amp; non-interactive shell</p><h3 id="login-shell"><a href="#login-shell" class="headerlink" title="login shell"></a>login shell</h3><p>login 需要用户名密码进入 ，一般的 ssh (secure shell) 登陆都用login shell</p><p>login shell 初始化，会执行 login file 和 环境 file ，顺序如下</p><ol><li>&#x2F;etc&#x2F;profile 这个是全局的配置 不管哪个用户登陆都会读取</li><li>&#x2F;etc&#x2F;profile里面会执行<strong>profile.d文件夹内</strong>的所有sh文件</li><li>&#x2F;root&#x2F;.bash_profile或 &#x2F;root&#x2F;.profile 或 &#x2F;root&#x2F;.bash_login 按顺序找到哪个，就执行哪个，只执行一个<br>这三个文件都会读取 &#x2F;root&#x2F;.bashrc (环境变量文件)</li></ol><h3 id="non-login-shell"><a href="#non-login-shell" class="headerlink" title="non-login shell"></a>non-login shell</h3><p>开non-login shell，例如，在login shell 中</p><ol><li>输入<strong>bash开的新shell</strong></li><li>通过 <strong>su username 开的 shell</strong></li></ol><p>su -username 可以开login shell 不加-开的就是non login shelll</p><h3 id="interactive-shell"><a href="#interactive-shell" class="headerlink" title="interactive shell"></a>interactive shell</h3><p>有交互的 shell 即 等待输入命令并解释执行命令 等待下一个命令</p><h3 id="non-interactive-shell"><a href="#non-interactive-shell" class="headerlink" title="non interactive shell"></a>non interactive shell</h3><p>一般的shell 脚本执行 如 bash hello.sh 即 <strong>不与用户交互 一次性执行脚本,<strong>哪怕sh中</strong>有让用户输入的过程也不是可交互脚本</strong></p><h3 id="echo-查看Shell类型"><a href="#echo-查看Shell类型" class="headerlink" title="echo $-查看Shell类型"></a>echo $-查看Shell类型</h3><p><code>echo $-</code> 可以查看当前是否为交互shell</p><p>输出有“himBH”就是交互shell</p><p>在写shell脚本头部时：</p><p><code>#!bin/bash</code>        是 non login &amp; non interactive shell</p><p><code>#!bin/bash --login</code> 是login non &amp; interactive shell</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Init-file&quot;&gt;&lt;a href=&quot;#Init-file&quot; class=&quot;headerlink&quot; title=&quot;Init_file&quot;&gt;&lt;/a&gt;Init_file&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;初始文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id</summary>
      
    
    
    
    <category term="linux" scheme="https://blog.lthero.cn/categories/linux/"/>
    
    
    <category term="linux" scheme="https://blog.lthero.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>【linux】学习笔记Chap_15_I/O</title>
    <link href="https://blog.lthero.cn/2022/08/02/linux-learningPathChp15/"/>
    <id>https://blog.lthero.cn/2022/08/02/linux-learningPathChp15/</id>
    <published>2022-08-02T13:10:46.000Z</published>
    <updated>2022-08-02T13:11:29.567Z</updated>
    
    <content type="html"><![CDATA[<h1 id="I-x2F-O"><a href="#I-x2F-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h1><h2 id="标准输入"><a href="#标准输入" class="headerlink" title="标准输入"></a>标准输入</h2><p>一旦登陆 系统就设置一个标准输入（从键盘） 标准输出和标准错误到屏幕</p><p>如果想将输出写入文件中</p><h3 id="gt-覆盖写入"><a href="#gt-覆盖写入" class="headerlink" title="&gt;覆盖写入"></a>&gt;覆盖写入</h3><p>用 “ &gt; “符号，如： sort nums &gt; file 这是覆盖写入 如果文件不存在就创建 如果存在就覆盖</p><h3 id="gt-gt-追加写入"><a href="#gt-gt-追加写入" class="headerlink" title="&gt;&gt;追加写入"></a>&gt;&gt;追加写入</h3><p>用 “&gt;&gt;” ，如： sort nums &gt;&gt; file 追加写入 如果不存在就创建 存在就追加</p><h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><p>如果 <strong>不想直接用“&gt;”覆盖</strong> 可以设置<strong>变量“</strong>noclobber”让覆盖写入变成 <strong>“&gt;|”，可以防止误触</strong></p><p><code>set -o noclobber</code> 则生效</p><p>写入 <code>/root/.bashrc</code> 中永远生效</p><h2 id="从文件中读入数据"><a href="#从文件中读入数据" class="headerlink" title="从文件中读入数据"></a>从文件中读入数据</h2><h3 id="lt-读入"><a href="#lt-读入" class="headerlink" title="&lt;读入"></a>&lt;读入</h3><p><code>&lt; file</code>  将file文件输出到某个指令或<code>sort &lt;/etc/passwd</code>  将密码排序后输出到屏幕中</p><p><strong>可以同时读入和写入</strong></p><p><code>sort &lt; rawdata &gt;report</code> 从<strong>rawdata</strong> 读入到sort 再将 sort 的结果 写入到<strong>report</strong></p><p><strong>但读入文件和保存文件不能同一个，否则文件内容清空</strong></p><p>因为，保存时按<strong>覆盖保存，先将文件”A”清空，再将文件”A”（空的）复制到文件”A”中</strong></p><p>sort 命令是原生的 可以对文件内容排序 按数值或字母</p><h2 id="标准输出"><a href="#标准输出" class="headerlink" title="标准输出"></a>标准输出</h2><p>有两种输出 shell 分为方便用户使用 可以将两种输出分开</p><h3 id="stand-out-amp-amp-stand-error"><a href="#stand-out-amp-amp-stand-error" class="headerlink" title="stand out &amp;&amp; stand error"></a>stand out &amp;&amp; stand error</h3><p><code>sort 1 &gt; res_out</code> 代表输出<strong>正确结果</strong> 和 默认 <code>sort &gt; res_out</code> 一样</p><p><code>sort 2 &gt; res_error</code> 输出<strong>错误结果</strong></p><p><code>sort 2 &gt;&gt; res_error</code><strong>追加</strong>写入<strong>错误结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort 0 &lt; res` 就是 stand in 默认用 `sort &lt; res</span><br></pre></td></tr></table></figure><h3 id="“2-gt-amp-1“同时写入正确-amp-错误信息"><a href="#“2-gt-amp-1“同时写入正确-amp-错误信息" class="headerlink" title="“2&gt;&amp;1“同时写入正确&amp;错误信息"></a>“2&gt;&amp;1“同时写入正确&amp;错误信息</h3><p><code>sort 1 &gt;res 2&gt;&amp;1</code> 表示将 正常输出到文件res 中 将错误信息也输出到res中</p><p><code>sort &gt;res 2&gt;&amp;1</code>等同效果</p><p><code>sort &gt;&gt; res 2&gt;&amp;1</code>追加写入</p><p><code>sort &amp;&gt; res</code> 也表示同时写入 <strong>正确和错误输出</strong></p><p><strong>举例</strong></p><ul><li><code>ls Chap_15.txt b &gt; res</code></li></ul><p>b文件不存在，将只会看到 Chap_15的文件消息（只有<strong>正确信息</strong>）</p><ul><li><code>ls Chap_15.txt b &amp;&gt; res</code></li></ul><p>则 res有<strong>Chap_15文件信息</strong>和b文件<strong>不存在的错误信息</strong></p><ul><li><code>ls Chap_15.txt b &gt;res 2 &gt;error</code></li></ul><p>则分开<strong>写入到正确、错误信息</strong></p><h3 id="使用-gt-的例子"><a href="#使用-gt-的例子" class="headerlink" title="使用&gt;的例子"></a>使用&gt;的例子</h3><p>文件名” PEOPLE “包含一些联系人信息</p><p>现在，如果文件包含”Hello” ，就将文件排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep hello people &amp;&amp; sort people &gt; res</span><br></pre></td></tr></table></figure><p>grep “查看内容” “文件名”<strong>成功执行后</strong>再执行 <strong>排序</strong> 再将结果<strong>写入res</strong></p><h2 id="SubSHell"><a href="#SubSHell" class="headerlink" title="SubSHell"></a>SubSHell</h2><h3 id="子shell-amp-amp-父shell"><a href="#子shell-amp-amp-父shell" class="headerlink" title="子shell &amp;&amp; 父shell"></a>子shell &amp;&amp; 父shell</h3><p>当shell 执行一个程序时， shell 是父程序 被执行程序是子程序</p><p>父shell 等着子shell 死亡后 再夺回控制权</p><p>如：在登陆后的shell 中输入 bash 则进入了子shell ,父shell 开始等待</p><p>子shell将继承父shell 的环境，但不会回传出父shell 任何信息，而且不会对父shell 造成影响</p><p><strong>相当于是个虚拟机</strong></p><h3 id="x2F-dev-x2F-null-是个垃圾箱"><a href="#x2F-dev-x2F-null-是个垃圾箱" class="headerlink" title="&#x2F;dev&#x2F;null 是个垃圾箱"></a>&#x2F;dev&#x2F;null 是个垃圾箱</h3><p>如果只要看正常输出，不要错误输出 <code>update 2&gt; /dev/null</code></p><h2 id="Piplines-管道符"><a href="#Piplines-管道符" class="headerlink" title="Piplines 管道符"></a>Piplines 管道符</h2><h3 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h3><ul><li><strong>将命令的标准输出给另一个命令的标准输入</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file1 file2 | grep hello | wc - l</span><br></pre></td></tr></table></figure><p> 在文件1、2里面<strong>找“hello”</strong>并<strong>统计行数</strong></p><ul><li>但Pipline只将前面的<strong>标准输出</strong>作为后面的<strong>“标准输入”，不能实现参数传递</strong></li></ul><h3 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h3><p>cat 命令可以接收文件名作为参数，执行后会显示出文件的内容。但是 cat 命令<strong>不能</strong>直接<strong>从标准输入接收参数</strong>，正如下面的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#cat后面直接指定china.txt参数, 可以展示china.txt文件的内容</span><br><span class="line">[roc@roclinux ~]$ cat china.txt</span><br><span class="line">hello beijing</span><br><span class="line"> </span><br><span class="line">#我们尝试通过标准输入把参数传给cat, 结果却只是显示了文件名而已</span><br><span class="line">[roc@roclinux ~]$ echo china.txt | cat</span><br><span class="line">china.txt</span><br></pre></td></tr></table></figure><ul><li>但可以用 xargs实现传递参数</li></ul><h2 id="xargs-传递参数"><a href="#xargs-传递参数" class="headerlink" title="xargs 传递参数"></a>xargs 传递参数</h2><ul><li>execute arguments的缩写</li></ul><h3 id="功能：-1"><a href="#功能：-1" class="headerlink" title="功能："></a>功能：</h3><ul><li>xargs 会将前一个命令的标准输出转换成命令参数。</li></ul><h3 id="举例：-1"><a href="#举例：-1" class="headerlink" title="举例："></a>举例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[roc@roclinux ~]$ echo china.txt | xargs cat</span><br><span class="line">hello beijing</span><br></pre></td></tr></table></figure><ul><li>xargs 的标准输入中出现的“<strong>换行符、空格、制表符</strong>”都将被<strong>空格</strong>取代。下面来看一个带有换行符的例子：</li></ul><h3 id="空格取代换行符"><a href="#空格取代换行符" class="headerlink" title="空格取代换行符"></a><strong>空格</strong>取代<strong>换行符</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[roc@roclinux ~]$ echo -e &quot;china.txt\njapan.txt&quot;</span><br><span class="line">china.txt</span><br><span class="line">japan.txt</span><br><span class="line"> </span><br><span class="line">#可见, 换行符和空格的作用一样</span><br><span class="line">[roc@roclinux ~]$ echo -e &quot;china.txt\njapan.txt&quot; | xargs cat</span><br><span class="line">hello beijing</span><br><span class="line">hello tokyo</span><br></pre></td></tr></table></figure><ul><li>当命令参数中包含了空格时，情况就会复杂很多，一起来看一个示例。</li></ul><h3 id="参数中包含了空格"><a href="#参数中包含了空格" class="headerlink" title="参数中包含了空格"></a>参数中包含了空格</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#我们创建了3个日志文件, 且故意让文件名称中都含有空格</span><br><span class="line">[roc@roclinux ~]$ for((i=0;i&lt;3;i++)); do touch &quot;test $&#123;i&#125;.log&quot;;done</span><br><span class="line"> </span><br><span class="line">#我们列出创建的文件</span><br><span class="line">[roc@roclinux ~]$ ls -1F</span><br><span class="line">test 0.log</span><br><span class="line">test 1.log</span><br><span class="line">test 2.log</span><br><span class="line"> </span><br><span class="line">#我们来运行xargs命令, 发现报错了 </span><br><span class="line">#-print 指定分隔符 默认为\n</span><br><span class="line">[roc@roclinux ~]$  find . -name &#x27;*.log&#x27; -print | xargs rm</span><br><span class="line">rm: cannot remove ‘./test’: No such file or directory</span><br><span class="line">rm: cannot remove ‘1.log’: No such file or directory</span><br></pre></td></tr></table></figure><p>我们在当前目录中创建了 3 个文件，文件名中间都含有空格。</p><p>但当 find 命令获取到的文件名经过 xargs 传送给 rm 命令时，文件“.&#x2F;test 1.log”就变成了“.&#x2F;test”和“1.log”两个文件了。</p><p>即原本 <strong>3 个文件名刹那间就变成了 6 个文件名</strong>，而这 6 个文件其实并不存在，从而引发了错误。</p><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><ul><li>这个错误的根源就在于 xargs 默认的分隔符是空格，如果我们能将 xargs 的分隔符改成其他符号，问题就迎刃而解了！</li></ul><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><ul><li>xargs 提供了<code>-0</code>选项，允许将 NULL 作为分隔符</li><li>find 命令提供的对应方法是 <code>-print0</code> 选项产生以 NULL 字符作为分隔符的输出</li></ul><p>在文件名之后输出 NULL，而不像 <strong>-print 选项那样输出换行符</strong>（换行符会被 xargs 替换成空格）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@lthero:videos$ find . -name &#x27;*.log&#x27; -print0</span><br><span class="line">./test 1.log./test 0.log./test 2.log</span><br></pre></td></tr></table></figure><p>于是，使用下命令，可以找出包含空格的文件并删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name &#x27;*.log&#x27; -print0 | xargs -0 rm</span><br></pre></td></tr></table></figure><h2 id="Tee"><a href="#Tee" class="headerlink" title="Tee"></a>Tee</h2><p>tee 可以<strong>读一个标准输入</strong>并 <strong>同时复制到标准输出</strong> 和 <strong>文件中</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file1 file2 | tee file3 | grep hello</span><br></pre></td></tr></table></figure><p>cat 读取 file1 file2文件 并给tee 保存在file3中，并输出到标准输出，grep又从标准输出收到信息，再搜索”hello”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file1 file2 file3 | tee file4 file5</span><br></pre></td></tr></table></figure><p>将1\2\3的文件<strong>合并后</strong>复制到4、5中而且内容一样</p><p>默认下 如果文件不在，tee可以创建，存在就覆盖写入</p><p>tee -a 可以追加写入</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;I-x2F-O&quot;&gt;&lt;a href=&quot;#I-x2F-O&quot; class=&quot;headerlink&quot; title=&quot;I&amp;#x2F;O&quot;&gt;&lt;/a&gt;I&amp;#x2F;O&lt;/h1&gt;&lt;h2 id=&quot;标准输入&quot;&gt;&lt;a href=&quot;#标准输入&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="linux" scheme="https://blog.lthero.cn/categories/linux/"/>
    
    
    <category term="linux" scheme="https://blog.lthero.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>【linux】学习笔记Chap_22_强大的Vim编程</title>
    <link href="https://blog.lthero.cn/2022/08/02/linux-learningPathChp22/"/>
    <id>https://blog.lthero.cn/2022/08/02/linux-learningPathChp22/</id>
    <published>2022-08-02T13:08:44.000Z</published>
    <updated>2022-08-07T10:34:58.109Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VIM"><a href="#VIM" class="headerlink" title="VIM"></a>VIM</h1><h4 id="建议全程使用英语输入法"><a href="#建议全程使用英语输入法" class="headerlink" title="建议全程使用英语输入法"></a><strong>建议全程使用英语输入法</strong></h4><ul><li>简介：vim 即 vi improved，现在已经全面替代vi，如果想用vi ，只能用vim -C 唤出vi模式。</li><li>xxxxxxxxxx10 1# 启动frps2sudo systemctl start frps3# 自启动4sudo systemctl enable frps5# 重启应用6sudo systemctl restart frps7# 停止应用8sudo systemctl stop frps9# 查看应用的日志10sudo systemctl status frpsshell</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim flie    #打开文件 可编写</span><br><span class="line">view file 或 vim -R file  #只读文件</span><br></pre></td></tr></table></figure><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>vim 打开文件将进入<strong>命令模式</strong>，此时不能直接编辑文档</p><h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><ul><li>h 向左移动光标</li><li>l (小写的L)向右移动光标</li><li>j 向下移动光标</li><li>k 向上移动光标</li></ul><p><a href="https://cdn.lthero.cn/wp-store/2021/07/1627286989-Snipaste_2021-07-26_09-18-30.png"><img src="https://cdn.lthero.cn/wp-store/2021/07/1627286989-Snipaste_2021-07-26_09-18-30.png" alt="img"></a></p><h3 id="光标跃起"><a href="#光标跃起" class="headerlink" title="光标跃起"></a>光标跃起</h3><p>如果先按一个<strong>数字</strong>，再按<strong>光标移动</strong>对应的四个键，可以指定跳过多少</p><ul><li>0 移动光标到行首</li><li>^ 移动光标到行首</li><li>$ 移动光标到行尾</li><li>w 移动到<strong>下个单词</strong>开始</li><li>e 移动到<strong>下个单词</strong>结尾</li><li>b 移动到<strong>上个单词</strong>开始</li></ul><h3 id="文章跳转"><a href="#文章跳转" class="headerlink" title="文章跳转"></a>文章跳转</h3><ul><li>gg 跳转到文章第一行</li><li>G 跳转到文章最后一行</li><li>10G 转到第10行，numG是第num行</li><li><strong>:10</strong> 也是转到第10行，先使用 <code>：set number</code> 唤出编号（下面有提到）</li></ul><h3 id="文章翻页"><a href="#文章翻页" class="headerlink" title="文章翻页"></a>文章翻页</h3><ul><li>^F 向下 翻页 ctrl+f</li><li>^B 向上 翻页 ctrl+b</li><li>^U 向上 翻半页 ctrl+u</li><li>^D 向下 翻半页 ctrl+d</li></ul><h3 id="设置行号"><a href="#设置行号" class="headerlink" title="设置行号"></a>设置行号</h3><ul><li>：set number 标出行号</li><li>：set nonumber 取消行号</li></ul><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><ul><li>&#x2F; pattern <strong>向下</strong>查找内容（pattern是要查找的文本，以下类同）</li></ul><p>在<strong>命令模式</strong>下，按**&#x2F;<strong>键后：命令行（</strong>屏幕底部<strong>）会显示一个</strong>&#x2F;**字符，随后可以键入想查找的文本，再按回车，vim就会查找下一个匹配的文本。</p><p><strong>如：</strong></p><p><code>/lthero</code> 按下回车后，光标就会跳转到该文本上。此时按<strong>n</strong>就会跳到<strong>下一个</strong>匹配的文本，按<strong>N</strong>会跳到<strong>上一个</strong>匹配的文本。</p><ul><li>? pattern <strong>向上</strong>查找内容（pattern)</li></ul><h3 id="替换与复制"><a href="#替换与复制" class="headerlink" title="替换与复制"></a>替换与复制</h3><ul><li>yy <strong>复制光标所在行</strong></li><li>p <strong>粘贴</strong>剪切版的内容</li></ul><p><strong>全文复制：</strong></p><ul><li>ggyG：将光标移动到文章开头，复制到文章末尾</li><li>Gygg：将光标移动到文章末尾，复制到文章开头</li></ul><p><strong>替换</strong></p><ul><li>r 替换一个字符 。按一个r 替换一个字符</li><li>R 进入<strong>替换模式，将一直替换，</strong>直到按^C退出</li></ul><p><strong>指定行替换(进入输入命令的模式，按shift+:)</strong></p><ul><li><strong>:s&#x2F;pattern&#x2F;replace&#x2F;</strong> 可将光标所在行的<strong>pattern</strong>替换成指定内容(<strong>replace</strong>)，只替换从第一行中的第一个匹配项、</li><li><strong>:s?pattern?replace 则从最后一行开始，</strong>替换<strong>这行第一个</strong>匹配项</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1:Linux Linux Linux</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">:s/Linux/Unix/</span><br><span class="line">#结果</span><br><span class="line">1:Unix Linux Linux</span><br></pre></td></tr></table></figure><ul><li><strong>:<strong>s&#x2F;pattern&#x2F;replace</strong>&#x2F;g</strong> (global) 一整行的pattern全部替换</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1:Linux Linux Linux </span><br><span class="line">~</span><br><span class="line">~ </span><br><span class="line">:s/Linux/Unix/g</span><br><span class="line">#结果 </span><br><span class="line">1:Unix Unix Unix</span><br></pre></td></tr></table></figure><ul><li><strong>:<strong>s&#x2F;pattern&#x2F;replace</strong>&#x2F;gc</strong> (global confirm) 整行替换 替换之前将咨询</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replace with Unix (y/n/a/q/l/^E/^Y)?</span><br></pre></td></tr></table></figure><ul><li><strong>: NUM</strong>s&#x2F;pattern&#x2F;replace**&#x2F;g** 将第NUM行，整行的pattern替换**(如果不加&#x2F;g，还是只换一个）**</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10:Linux Linux Linux </span><br><span class="line">~</span><br><span class="line">~ </span><br><span class="line">:10s/Linux/Unix/g</span><br><span class="line">#结果 </span><br><span class="line">10:Unix Unix Unix</span><br></pre></td></tr></table></figure><ul><li><strong>: N,M</strong>s&#x2F;pattern&#x2F;replace**&#x2F;g** 将<strong>N-M</strong>行内进行替换</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">10:Linux Linux Linux </span><br><span class="line">11:Linux Linux Linux </span><br><span class="line">12:Linux Linux Linux </span><br><span class="line">13:Linux Linux Linux </span><br><span class="line">14:Linux Linux Linux </span><br><span class="line">~</span><br><span class="line">~ </span><br><span class="line">:10,14s/Linux/Unix/g</span><br><span class="line">#结果 </span><br><span class="line">10~14:Unix Unix Unix</span><br></pre></td></tr></table></figure><p><strong>全文替换</strong></p><ul><li>用**.(dote)<strong>代表当前行，</strong>$(dollar)<strong>代表最后一行，</strong>%** 代表在编辑缓存区(已经保存的文章)的<strong>全部行</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:.,$s/pattern/replace/g   全文替换</span><br><span class="line"></span><br><span class="line">:1,.s/pattern/replace/g    第一行到当前行替换</span><br><span class="line"></span><br><span class="line">:1,$s/pattern/replace/g     或者 :%s/pattern/replace/g全文替换</span><br></pre></td></tr></table></figure><h3 id="删除-x2F-剪切"><a href="#删除-x2F-剪切" class="headerlink" title="删除&#x2F;剪切"></a>删除&#x2F;剪切</h3><ul><li>x 删除光标字符，其实会剪切到剪切板上，按p可以恢复(下面有讲到）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">heiQnous #将光标放在Q处 </span><br><span class="line">按x</span><br><span class="line">heinous</span><br></pre></td></tr></table></figure><ul><li>X 删除光标左边字符</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">heiQnous #将光标放在n处 </span><br><span class="line">按X</span><br><span class="line">heinous</span><br></pre></td></tr></table></figure><ul><li>D 从<strong>光标处</strong>删除到<strong>行尾</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Linux Unix PHP MySQL</span><br><span class="line">光标放在H处</span><br><span class="line">按D</span><br><span class="line">Linux Unix P</span><br></pre></td></tr></table></figure><ul><li>dmve (加上方向键<strong>左右</strong>) d左 就等同于X d右 等同于x</li><li>dd 删除（剪切）<strong>一行</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">：10,20d #删除10-20行</span><br><span class="line"> ：1,$d #删除全文</span><br></pre></td></tr></table></figure><ul><li><strong>db</strong> 删除光标前<strong>一个单词</strong></li></ul><p><strong>全文删除：</strong></p><ul><li>ggdG：将光标移动到文章开头，删除到文章末尾</li><li>Gdgg：将光标移动到文章末尾，删除到文章开头</li></ul><h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><ul><li>u 撤销一步</li></ul><h3 id="从删除中恢复-x2F-粘贴"><a href="#从删除中恢复-x2F-粘贴" class="headerlink" title="从删除中恢复&#x2F;粘贴"></a>从删除中恢复&#x2F;粘贴</h3><ul><li>p 将<strong>删除内容</strong>或<strong>剪贴板</strong>内容恢复，恢复到光标<strong>下一行</strong></li></ul><p><strong>#1、2：指行号</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1:Linux Linux Linux</span><br><span class="line">2:Unix Unix Unix</span><br><span class="line">:1d</span><br><span class="line">#将第一行删除</span><br><span class="line">2：Unix Unix Unix</span><br><span class="line">#光标在第一个U</span><br><span class="line">#按p</span><br><span class="line">1:Unix Unix Unix</span><br><span class="line">2:Linux Linux Linux</span><br></pre></td></tr></table></figure><ul><li>P 恢复到光标<strong>上一行</strong></li></ul><h3 id="复制-amp-移动行"><a href="#复制-amp-移动行" class="headerlink" title="复制&amp;移动行"></a>复制&amp;移动行</h3><ul><li><strong>命令：co</strong>(copy)</li></ul><p><strong>:</strong> 5<strong>co</strong>10 复制第5行，插入到<strong>第10行下面</strong></p><p><strong>:</strong> 5**,<strong>10</strong>co<strong>20 复制</strong>5~10行，一同<strong>插入到</strong>第20行下面**</p><ul><li><strong>命令：m</strong>(move)</li></ul><p><strong>:</strong> 5m10 移动第5行，插入到<strong>第10行下面</strong></p><p><strong>:</strong> 4,8m20 移动<strong>4~8</strong>行，一同到<strong>20行下面</strong></p><p><strong>:</strong> 1,.m$ 第一行~当前移动，插入到最后一行</p><h3 id="合并两行"><a href="#合并两行" class="headerlink" title="合并两行"></a>合并两行</h3><p>按大写<strong>J</strong> 将当前行和下一行合并，在合并处会自动留下一个空格</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this is a</span><br><span class="line">short sentence</span><br><span class="line">按J</span><br><span class="line">this is a short sentence</span><br></pre></td></tr></table></figure><h3 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h3><p>进入命令模式后，按冒号，进入执行命令模式</p><p><strong>:!date</strong>，可以在原来的shell中执行命令，并能看到结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[No write since last change]</span><br><span class="line">Mon 26 Jul 2021 03:19:59 PM CST</span><br><span class="line"></span><br><span class="line">Press ENTER or type command to continue  #按return返回</span><br></pre></td></tr></table></figure><p>:!! 执行上一条命令</p><p>:!sh 将暂停vi，打开一个新的shell，<strong>如 !bash</strong></p><h3 id="编辑过程中切换文件"><a href="#编辑过程中切换文件" class="headerlink" title="编辑过程中切换文件"></a>编辑过程中切换文件</h3><ul><li>:e document</li></ul><p>切换新文件时，原先在缓存中的文件就会丢失，所以要保存原文件</p><p>一般地，若未保存，vim不让切换</p><p>用<code>e! document</code> 强制切换</p><h3 id="宏Macros"><a href="#宏Macros" class="headerlink" title="宏Macros"></a>宏Macros</h3><ul><li>:map x commands</li></ul><h4 id="功能"><a href="#功能" class="headerlink" title="功能:"></a>功能:</h4><ul><li>将命令以x代替</li></ul><p>**如:*<em>在每行首添加注释&#x2F;</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:map ^_ I/*&lt;ESC&gt;      #（直接输入&lt;ESC&gt;) 或者 ESC是^[ ，删除是^H</span><br></pre></td></tr></table></figure><p>其中的I是进入到当前行首，</p><p>用unmap取消宏命令</p><ul><li>:unmap x</li></ul><h3 id="将已有文件插入"><a href="#将已有文件插入" class="headerlink" title="将已有文件插入"></a>将已有文件插入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:[line]r file    r是read，表示在line行插入file文件内容</span><br></pre></td></tr></table></figure><ul><li>功能：将file整个讲稿并插入到指定行</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:10r file  #插入第10行</span><br><span class="line">:0r file    #到第一行</span><br><span class="line">:$r file    #到末尾</span><br><span class="line">:r file     #到光标行</span><br></pre></td></tr></table></figure><ul><li>如果不写数字，vim将自动添加<strong>光标所在行</strong></li></ul><h4 id="结合执行命令"><a href="#结合执行命令" class="headerlink" title="结合执行命令"></a><strong>结合执行命令</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:r !ls    #将 ls 结果添加到当前行</span><br><span class="line">:0r !date  #添加时间到文章开头</span><br><span class="line">:0r !whoami #添加作者</span><br></pre></td></tr></table></figure><h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><ul><li>**:**w 写入原文件</li></ul><p>**:**w file 写入新文件</p><ul><li>**:**w! file 覆盖写入已存在文件</li></ul><p>**:**w&gt;&gt; file 追加写入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:10,20w &gt;&gt;file 将10到20行追加写入文件中</span><br><span class="line">:wq 保存并退出 效果等同ZZ,但不等同ctrl+z，ctrl+z是挂起当前进程</span><br></pre></td></tr></table></figure><h3 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h3><ul><li><strong>保存并退出</strong>可以用快捷键<strong>ZZ</strong>，或者**:wq**</li></ul><p>用ZZ为了不误触，导致不小心退出</p><ul><li>注意 强制退出vim</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:q!&lt;Return&gt;</span><br></pre></td></tr></table></figure><ul><li>其中的!（bang）告诉vim <strong>不要管我是否保存了数据</strong>（可能造成丢失）</li></ul><hr><h2 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h2><ul><li><strong>按<ESC>将退出输入模式</strong></li></ul><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><ul><li>按 i 光标处向前插入 I 插入到<strong>行首</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Kankakee 在把光标移动到K上面</span><br><span class="line">输入ibbb</span><br><span class="line">bbbKankakee</span><br></pre></td></tr></table></figure><ul><li>o光标下行插入 O光标上行插入</li><li>a光标处后插入 A插入到行尾</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Kankakee 在把光标移动到K上面</span><br><span class="line">输入ibbb</span><br><span class="line">Kbbbankakee</span><br></pre></td></tr></table></figure><ul><li>**^W(ctrl+w)**删除一个单词</li><li><strong>^U</strong> <strong>(ctrl+u)<strong>或 ^X</strong>(ctrl+x)</strong> 删除一行 （这是在编辑模式中）</li></ul><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><ul><li>s (substitute) 将<strong>光标处字符删除</strong>并进入编辑模式</li><li>C 将<strong>光标</strong>处字符<strong>到结尾</strong>处字符<strong>全部删除</strong> 进入编辑模式</li><li>S 或 <strong>cc</strong> 将整个行全部剪切，并进入编辑模式，而且光标在原来这行。与dd不同，dd只删除不进入编辑</li></ul><h3 id="恢复数据"><a href="#恢复数据" class="headerlink" title="恢复数据"></a>恢复数据</h3><p>若在编辑模式下长时间未保存，并且vim突然中断，那未保存内容将在<strong>隐藏的</strong><strong>.file.swap文件</strong>中</p><ul><li>如ssh连接突然中止，或者电脑关机</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#用命令</span><br><span class="line">vim -r(recover) file</span><br><span class="line">#</span><br><span class="line">可以恢复原有数据</span><br></pre></td></tr></table></figure><ul><li>如果删除隐藏文件，再打开原文件，数据只会显示到<strong>上次保存位置</strong></li><li>所以，先恢复文件，再rm .swap文件</li></ul><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><p>vim 将空行用~代替<br>vim 中不能用(ctrl+c) 如果要输入^C 用ctrl+v ctrl+c 输入^V要输入两次ctrl+v<br>tab键也用ctrl+i代替</p><h2 id="可视区块"><a href="#可视区块" class="headerlink" title="可视区块"></a>可视区块</h2><p>如果想要处理一个区块（以列为单位），如下这种格式：</p><blockquote><p>192.168.1.1 host1.class.net<br>192.168.1.2 host2.class.net<br>192.168.1.3 host3.class.net<br>192.168.1.4 host4.class.net<br>192.168.1.5 host5.class.net<br>192.168.1.6 host6.class.net<br>192.168.1.7 host7.class.net<br>192.168.1.8 host8.class.net<br>192.168.1.9 host9.class.net</p></blockquote><p>如果要把每行的host1再添加到这行末尾，如192.168.1.1 host1.class.net host1，我们可以使用以下命令进行操作</p><p>在一般命令模式下</p><p>v       <strong>字符</strong>选择，会将光标经过的<strong>字符</strong>反白选择</p><p>V       <strong>行</strong>选择，会将光标经过的<strong>行</strong>反白选择</p><p>ctrl+v    块选择，用<strong>矩形方式</strong>选择</p><p>y       将反白选择部分复制</p><p>d       将反白选择部分删除</p><p>p       将复制或删除的部分粘贴</p><p>1、将光标移动太第一行的host1的h上，按ctrl+v ，此时可以看到VISUAL BLOCK的字样<a href="https://cdn.lthero.cn/wp-store/2021/07/1632535027-Snipaste_2021-09-25_09-54-56.png"><img src="https://cdn.lthero.cn/wp-store/2021/07/1632535027-Snipaste_2021-09-25_09-54-56.png" alt="img"></a></p><p>2、将光标移动到最底部分，光标经过的区域会反色</p><p><a href="https://cdn.lthero.cn/wp-store/2021/07/1632535114-Snipaste_2021-09-25_09-58-26.png"><img src="https://cdn.lthero.cn/wp-store/2021/07/1632535114-Snipaste_2021-09-25_09-58-26.png" alt="img"></a></p><p>3、按y进行复制，按下【y】后，反色的区域会不见</p><p>4、将光标移动到第一行的最右边，进入编辑模式，输入两个空格，再进入命令模式，按下【p】后就会粘贴成功</p><p><a href="https://cdn.lthero.cn/wp-store/2021/07/1632535249-Snipaste_2021-09-25_10-00-40.png"><img src="https://cdn.lthero.cn/wp-store/2021/07/1632535249-Snipaste_2021-09-25_10-00-40.png" alt="img"></a></p><h2 id="多窗口功能"><a href="#多窗口功能" class="headerlink" title="多窗口功能"></a>多窗口功能</h2><p>如果有两个文件需要对照修改，总不能同时打开两个shell吧？vim也有划分窗口的功能！！！</p><p>在命令模式下<code>:sp filename</code></p><p>1、如果要在<strong>新窗口</strong>打开<strong>另一个文件</strong>，就写对应的文件名，如果文件<strong>不存在会自动创建</strong>；</p><p><a href="https://cdn.lthero.cn/wp-store/2021/07/1632536380-Snipaste_2021-09-25_10-19-24.png"><img src="https://cdn.lthero.cn/wp-store/2021/07/1632536380-Snipaste_2021-09-25_10-19-24.png" alt="img"></a></p><p>2、filename也可以不写，如仅输入<code>:sp</code> 会在两个窗口打开<strong>同一个文件，而且会同步修改</strong></p><p><a href="https://cdn.lthero.cn/wp-store/2021/07/1632536207-Snipaste_2021-09-25_10-16-13.png"><img src="https://cdn.lthero.cn/wp-store/2021/07/1632536207-Snipaste_2021-09-25_10-16-13.png" alt="img"></a></p><p><a href="https://cdn.lthero.cn/wp-store/2021/07/1632536328-Snipaste_2021-09-25_10-18-38.png"><img src="https://cdn.lthero.cn/wp-store/2021/07/1632536328-Snipaste_2021-09-25_10-18-38.png" alt="img"></a></p><p>此时，可以利用【ctrl+w+j】移动到下面窗口，【ctrl+w+k】移动到上面的窗口</p><h2 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h2><p>平时在用jetbrain全家桶习惯了自动补全，vim其实也有，而且功能强大。<strong>以下按键全部在编辑模式</strong></p><p>1、以扩展名作为语法补充。注意：文件名后缀一定要改成对应的扩展名，如.html&#x2F;.css&#x2F;.c&#x2F;.py</p><blockquote><p>按键：ctrl+x 再按 ctrl+o</p></blockquote><p><a href="https://cdn.lthero.cn/wp-store/2021/07/1632537129-Snipaste_2021-09-25_10-31-11.png"><img src="https://cdn.lthero.cn/wp-store/2021/07/1632537129-Snipaste_2021-09-25_10-31-11.png" alt="img"></a></p><p>在输入&lt;&#x2F;后按【ctrl+x 】和【ctrl+o】后将补全<code>head&gt;</code></p><p>2、以当前编辑的【文件内容文字】作为关键词，自动补全</p><blockquote><p>按键：ctrl+x 再按 ctrl+n</p></blockquote><p><a href="https://cdn.lthero.cn/wp-store/2021/07/1632537335-Snipaste_2021-09-25_10-28-25.png"><img src="https://cdn.lthero.cn/wp-store/2021/07/1632537335-Snipaste_2021-09-25_10-28-25.png" alt="img"></a></p><p>如，当前有三个变量var11，var22，var33，想要输出时，只用在var后按【ctrl+x】和【ctrl+n】即可出现<strong>补全列表</strong></p><p>3、以当前目录内的【文件名】作为关键词</p><blockquote><p>ctrl+x 再按 ctrl+f</p></blockquote><p><a href="https://cdn.lthero.cn/wp-store/2021/07/1632537471-Snipaste_2021-09-25_10-29-18.png"><img src="https://cdn.lthero.cn/wp-store/2021/07/1632537471-Snipaste_2021-09-25_10-29-18.png" alt="img"></a></p><p>如，输入te后，按【ctrl+x】和【ctrl+f】即可出现<strong>当前目录文件名</strong>补全<strong>列表</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;VIM&quot;&gt;&lt;a href=&quot;#VIM&quot; class=&quot;headerlink&quot; title=&quot;VIM&quot;&gt;&lt;/a&gt;VIM&lt;/h1&gt;&lt;h4 id=&quot;建议全程使用英语输入法&quot;&gt;&lt;a href=&quot;#建议全程使用英语输入法&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="linux" scheme="https://blog.lthero.cn/categories/linux/"/>
    
    
    <category term="linux" scheme="https://blog.lthero.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>【Broadcast-Collision】冲突域与广播域</title>
    <link href="https://blog.lthero.cn/2022/07/29/Broadcast-Collision/"/>
    <id>https://blog.lthero.cn/2022/07/29/Broadcast-Collision/</id>
    <published>2022-07-29T06:58:31.000Z</published>
    <updated>2022-07-29T07:06:05.456Z</updated>
    
    <content type="html"><![CDATA[<h1 id="冲突域与广播域"><a href="#冲突域与广播域" class="headerlink" title="冲突域与广播域"></a>冲突域与广播域</h1><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><ul><li>冲突域（物理层）：<br>同一时间内只能有一台设备发送信息的范围。如果有多台设备同时发送信息，就会产生冲突，故称冲突域。</li><li>广播域（数据链路层）：<br>广播帧所能到达的所有的设备的集合。</li></ul><p>关系：<a href="https://so.csdn.net/so/search?q=%E5%86%B2%E7%AA%81%E5%9F%9F&spm=1001.2101.3001.7020">冲突域</a>的范围<strong>小于等于</strong>广播域的范围，一个广播域由若干个冲突域组成！</p><p>隔离及扩展：<br>1、<a href="https://so.csdn.net/so/search?q=%E7%89%A9%E7%90%86%E5%B1%82&spm=1001.2101.3001.7020">物理层</a>的设备（如集线器Hub，中继器）可以扩大冲突域，而不能隔离冲突域，更不能隔离广播域。<br>2、<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82&spm=1001.2101.3001.7020">数据链路层</a>的设备（如交换机）可以隔离冲突域，扩大广播域。<br>3、网络层的设备（如路由器）可以隔离广播域。</p><h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><h3 id="扩大广播域："><a href="#扩大广播域：" class="headerlink" title="扩大广播域："></a>扩大广播域：</h3><p>​假如有二层交换机1号，二层交换机2号。1号交换机光纤连接10台主机，2号交换机光纤连接5台主机。1号交换机与2号交换机用光纤相连。如果1号交换机连接的10台主机中，有一台主机发出广播帧。如果1号交换机没连接2号交换机，那这个广播帧，只能由这10台中的9台收到。现在1号交换机连接了2号交换机，那这个广播帧，可以经过1号交换机转发给2号交换机，2号交换机再转发给它连接的5台主机。于是，这个广播帧可以由9+5&#x3D;14台主机收到。扩大广播域</p><h3 id="隔离冲突域："><a href="#隔离冲突域：" class="headerlink" title="隔离冲突域："></a>隔离冲突域：</h3><p>​目的就是为了“消除碰撞”。还是上面的假设，1号交换机连接了10个主机，而每个主机是通过光纤线直接连接到1号交换机的10个不同的端口。如果这10台主机，用总线方式相连接，一台主机发数据比特，其它的如果也在发，肯定早晚会碰撞，因此才有很多不同的防“碰撞”的协议。而现在，每台主机用线与1号交换机的不同端口连接，相当于每台主机独占了与端口连接的一条线路，每台主机主机随时可以发送数据比特给与这台主机连接的端口。不同主机就算同时发数据比特，也只是同时发给了与它们相连接的不同端口，又因为交换机的每个端口对应一块内存和一个“没有mac地址的网卡”，每块网卡的功能是将收到的数据比特成形成帧，再由交换机查路由转发表将帧转发到其它端口【形成帧后，应该会再形成个队列，交换机按队列次序依次处理每个帧】。隔离冲突域</p><h3 id="隔离广播域："><a href="#隔离广播域：" class="headerlink" title="隔离广播域："></a>隔离广播域：</h3><p>​假设1号交换机再与路由器连接，当路由器的<strong>内网网卡</strong>（接收帧的网卡）收到帧后，会交给网络层模块处理，从中提取出源ip地址、目的ip地址。根据目的ip地址查询路由表，将目的ip与掩码计算后，有两种结果。</p><p>​结果1：若</p><p>​结果2：从<strong>外网网卡</strong>传出去。说明目的ip地址和源ip地址不是同一个子网，比如目的ip是外网web服务器，那路由器才会将根据目的ip查询路由表，找到下一跳的(Gateway)设备ip，再将帧中的目的mac地址改成下一跳的设备对应的mac地址，再从外网网卡传送出去。</p><p>​这就是路由器可以隔离广播域的原因。如果不隔离广播域，那某个子网内某个主机发出的广播帧，会被全球收到（不考虑防火墙等）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;冲突域与广播域&quot;&gt;&lt;a href=&quot;#冲突域与广播域&quot; class=&quot;headerlink&quot; title=&quot;冲突域与广播域&quot;&gt;&lt;/a&gt;冲突域与广播域&lt;/h1&gt;&lt;h2 id=&quot;定义：&quot;&gt;&lt;a href=&quot;#定义：&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="网络" scheme="https://blog.lthero.cn/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="https://blog.lthero.cn/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>【Web-socket】服务器程序</title>
    <link href="https://blog.lthero.cn/2022/07/17/Web-socket-server/"/>
    <id>https://blog.lthero.cn/2022/07/17/Web-socket-server/</id>
    <published>2022-07-17T05:20:54.000Z</published>
    <updated>2022-07-21T06:51:39.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h1><p>linux服务端代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">//手动设置连接台数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONNMAX 1000</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *WorkPath;</span><br><span class="line"><span class="type">int</span> listenfd, clients[CONNMAX];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error</span><span class="params">(<span class="type">char</span> *x)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">startServer</span><span class="params">(<span class="type">char</span> *x)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">respond</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> clientaddr;</span><br><span class="line"><span class="type">socklen_t</span> addrlen;</span><br><span class="line"><span class="type">char</span> c, PORT[<span class="number">6</span>];</span><br><span class="line"><span class="comment">//设置当前路径</span></span><br><span class="line">WorkPath = <span class="built_in">getenv</span>(<span class="string">&quot;PWD&quot;</span>);</span><br><span class="line"><span class="comment">//默认端口</span></span><br><span class="line"><span class="built_in">strcpy</span>(PORT,<span class="string">&quot;10000&quot;</span>);</span><br><span class="line"><span class="comment">// 当前socket标识符下标</span></span><br><span class="line"><span class="type">int</span> slot=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从命令行接收参数</span></span><br><span class="line"><span class="keyword">while</span> ((c = <span class="built_in">getopt</span> (argc, argv, <span class="string">&quot;p:r:&quot;</span>)) != <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">switch</span> (c)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">WorkPath = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(optarg));</span><br><span class="line"><span class="built_in">strcpy</span>(WorkPath,optarg);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line"><span class="built_in">strcpy</span>(PORT,optarg);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line"><span class="built_in">fprintf</span>(stderr,<span class="string">&quot;参数错误\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;服务器开放端口 %s 使用 %s 作为当前路径\n&quot;</span>,PORT,WorkPath);</span><br><span class="line"><span class="comment">// 设置所有的套接字标识符的默认值为-1，代表这个套接字标识号没有没有使用</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;CONNMAX; i++)</span><br><span class="line">clients[i]=<span class="number">-1</span>;</span><br><span class="line"><span class="comment">//先开启服务，执行流程中的1，2，3</span></span><br><span class="line"><span class="built_in">startServer</span>(PORT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 持续接收请求</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//包含addr所指向结构大小的数值，函数返回时包含对等地址(一般为服务器地址)的实际数值</span></span><br><span class="line">addrlen = <span class="built_in">sizeof</span>(clientaddr);</span><br><span class="line"><span class="comment">//4、接收来自客户端的连接请求 accept</span></span><br><span class="line"><span class="comment">//accept函数等待来自客户端的连接请求到达&quot;监听描述符listenfd&quot;----客户端会调用connect函数发送客户端的&quot;套接字地址&quot;【ip:port】</span></span><br><span class="line"><span class="comment">//accpet将客户端的套接字地址填写到clientaddr这个结构中，并返回“已连接描述符connfd”</span></span><br><span class="line">clients[slot] = <span class="built_in">accept</span> (listenfd, (<span class="keyword">struct</span> sockaddr *) &amp;clientaddr, &amp;addrlen);</span><br><span class="line"><span class="comment">//出错返回-1</span></span><br><span class="line"><span class="keyword">if</span> (clients[slot]&lt;<span class="number">0</span>)</span><br><span class="line"><span class="built_in">error</span> (<span class="string">&quot;accept()函数出错，接收失败&quot;</span>);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//accept返回“已连接描述符后”，创建子进程，让子程序完成response。父进程继续监听</span></span><br><span class="line"><span class="keyword">if</span> ( fork()==<span class="number">0</span> )&#123;</span><br><span class="line"><span class="comment">//子进程应该关掉监听描述符【因为继续父进程全部变量】，只保留已连接描述符</span></span><br><span class="line"><span class="built_in">close</span>(listenfd);</span><br><span class="line"><span class="comment">//对连接作出响应</span></span><br><span class="line"><span class="built_in">respond</span>(slot);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-1表示当前位置无描述符，这步用来寻找数组中下一个可用的已连接描述符的位置</span></span><br><span class="line"><span class="keyword">while</span> (clients[slot]!=<span class="number">-1</span>) </span><br><span class="line">slot = (slot+<span class="number">1</span>)%CONNMAX;</span><br><span class="line"><span class="comment">//父进程应该关掉已连接描述符</span></span><br><span class="line"><span class="built_in">close</span>(clients[slot]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务端进程做的“监听准备”</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">startServer</span><span class="params">(<span class="type">char</span> *port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//hits结构可用于提供要产生的套接字类型的信息</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">addrinfo</span> hints, *res, *p;</span><br><span class="line"><span class="comment">// 将hints结构清空</span></span><br><span class="line"><span class="built_in">memset</span> (&amp;hints, <span class="number">0</span>, <span class="built_in">sizeof</span>(hints));</span><br><span class="line"><span class="comment">//使用的协议簇AF_INET=ipv4/AF_INET6=ipv6</span></span><br><span class="line">hints.ai_family = AF_INET;</span><br><span class="line"><span class="comment">//协议类型，设置为流类型</span></span><br><span class="line">hints.ai_socktype = SOCK_STREAM;</span><br><span class="line"><span class="comment">//设置标志为AI_PASSIVE，告诉函数，要产生的套接字，会被服务端当作“监听套接字”。否则默认返回&quot;主动套接字&quot;</span></span><br><span class="line">hints.ai_flags = AI_PASSIVE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将NULL表示得到的套接字地址结构中，ip字段是通配符地址。告诉内核让这个服务器接受发送到此主机的全部请求</span></span><br><span class="line"><span class="comment">//返回结果是个链表，链表包含的是很多套接字地址，存入res中</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">getaddrinfo</span>( <span class="literal">NULL</span>, port, &amp;hints, &amp;res) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">perror</span> (<span class="string">&quot;getaddrinfo() 出错&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、创建 套接字描述符</span></span><br><span class="line"><span class="comment">// 2、将“套接字描述符”与“套接字地址”绑定</span></span><br><span class="line"><span class="keyword">for</span> (p = res; p!=<span class="literal">NULL</span>; p=p-&gt;ai_next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//若成功则返回 套接字描述符，若出错则返回-1</span></span><br><span class="line">listenfd = <span class="built_in">socket</span> (p-&gt;ai_family, p-&gt;ai_socktype, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (listenfd == <span class="number">-1</span>) </span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//将“套接字描述符”与“套接字地址【ip:port】”绑定</span></span><br><span class="line"><span class="comment">//调用bind的函数之后，通过套接字描述符来读取或发送到套接字地址</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">bind</span>(listenfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == <span class="number">0</span>) </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//绑定失败，关掉当前描述符并尝试下一个</span></span><br><span class="line"><span class="built_in">close</span>(listenfd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">perror</span> (<span class="string">&quot;socket() 或 bind()&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放这个链表</span></span><br><span class="line"><span class="built_in">freeaddrinfo</span>(res);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、转换成监听套接字</span></span><br><span class="line"><span class="comment">// 客户端发起的请求是主动实体，默认情况下，内核会认为socket函数创建的描述符是“主动套接字”，默认存在于客户端。但服务端，需要使用listen函数，</span></span><br><span class="line"><span class="comment">//来告诉内核，这个描述符是给服务端用的。</span></span><br><span class="line"><span class="comment">//listen函数将 这个描述符 从主动套接字，变成“监听套接字”。“监听套接字”可以接受客户端的连接请求。</span></span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">listen</span> (listenfd, <span class="number">1000000</span>) != <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;listen()函数转换出错&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务端的响应</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">respond</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//mesg缓冲区用来存放recv函数接收到的数据</span></span><br><span class="line"><span class="type">char</span> mesg[<span class="number">99999</span>], *reqline[<span class="number">3</span>], data_to_send[<span class="number">1024</span>], path[<span class="number">99999</span>];</span><br><span class="line"><span class="comment">//rcvd用来接收copy的字节数</span></span><br><span class="line"><span class="type">int</span> rcMegLen, file, bytes_read;</span><br><span class="line"><span class="built_in">memset</span>( (<span class="type">void</span>*)mesg, (<span class="type">int</span>)<span class="string">&#x27;\0&#x27;</span>, <span class="number">99999</span> );</span><br><span class="line"><span class="comment">//5、从socket中读取字符</span></span><br><span class="line"><span class="comment">//第一个参数指定接收端套接字描述符</span></span><br><span class="line"><span class="comment">//第二个参数缓冲区用来存放recv函数接收到的数据；</span></span><br><span class="line"><span class="comment">//第三个参数指明缓冲区的长度；</span></span><br><span class="line"><span class="comment">//第四个参数一般置0。</span></span><br><span class="line">rcMegLen=<span class="built_in">recv</span>(clients[n], mesg, <span class="number">99999</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//如果recv在copy时出错，那么它返回SOCKET_ERROR</span></span><br><span class="line"><span class="keyword">if</span> (rcMegLen&lt;<span class="number">0</span>) </span><br><span class="line"><span class="built_in">fprintf</span>(stderr,(<span class="string">&quot;无法接收消息\n&quot;</span>));</span><br><span class="line"><span class="comment">//如果recv函数在等待协议接收数据时网络中断了，那么它返回0。</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (rcMegLen==<span class="number">0</span>)    </span><br><span class="line"><span class="built_in">fprintf</span>(stderr,<span class="string">&quot;与客户端的连接意外中断.\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span>    <span class="comment">// 接收到消息</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//打印客户端请求信息</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, mesg);</span><br><span class="line"><span class="comment">//按换行进行切分消息</span></span><br><span class="line">reqline[<span class="number">0</span>] = <span class="built_in">strtok</span> (mesg, <span class="string">&quot; \t\n&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">strncmp</span>(reqline[<span class="number">0</span>], <span class="string">&quot;GET\0&quot;</span>, <span class="number">4</span>)==<span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">reqline[<span class="number">1</span>] = <span class="built_in">strtok</span> (<span class="literal">NULL</span>, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">reqline[<span class="number">2</span>] = <span class="built_in">strtok</span> (<span class="literal">NULL</span>, <span class="string">&quot; \t\n&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strncmp</span>( reqline[<span class="number">2</span>], <span class="string">&quot;HTTP/1.0&quot;</span>, <span class="number">8</span>)!=<span class="number">0</span> &amp;&amp; <span class="built_in">strncmp</span>( reqline[<span class="number">2</span>], <span class="string">&quot;HTTP/1.1&quot;</span>, <span class="number">8</span>)!=<span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">write</span>(clients[n], <span class="string">&quot;HTTP/1.1 400 Bad Request\n&quot;</span>, <span class="number">25</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果url后面不写任何路径，默认为index.html</span></span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">strncmp</span>(reqline[<span class="number">1</span>], <span class="string">&quot;/\0&quot;</span>, <span class="number">2</span>)==<span class="number">0</span> )</span><br><span class="line">reqline[<span class="number">1</span>] = <span class="string">&quot;/index.html&quot;</span>;        </span><br><span class="line"><span class="built_in">strcpy</span>(path, WorkPath);</span><br><span class="line"><span class="built_in">strcpy</span>(&amp;path[<span class="built_in">strlen</span>(WorkPath)], reqline[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;向套接字描述符%d号发送了文件: %s\n&quot;</span>,clients[n], path);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;========================================================\n&quot;</span>);</span><br><span class="line"><span class="comment">//如果文件存在，向客户端发送这个文件，以只读方式打开文件</span></span><br><span class="line"><span class="keyword">if</span> ( (file=<span class="built_in">open</span>(path, O_RDONLY))!=<span class="number">-1</span> )   </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 5.5、向socket写入信息</span></span><br><span class="line"><span class="comment">//第一个参数指定发送端套接字描述符</span></span><br><span class="line">    <span class="comment">//第二个参数指明一个存放应用程序要发送数据的缓冲区</span></span><br><span class="line">    <span class="comment">//第三个参数指明实际要发送的数据的字节数</span></span><br><span class="line">    <span class="comment">//第四个参数一般置0</span></span><br><span class="line"><span class="built_in">send</span>(clients[n], <span class="string">&quot;HTTP/1.1 200 OK\n\n&quot;</span>, <span class="number">17</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//向套接字发送数据</span></span><br><span class="line"><span class="keyword">while</span> ( (bytes_read=<span class="built_in">read</span>(file, data_to_send, <span class="number">1024</span>))&gt;<span class="number">0</span> )</span><br><span class="line"><span class="built_in">write</span> (clients[n], data_to_send, bytes_read);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 否则提示此文件不存在</span></span><br><span class="line"><span class="keyword">else</span>    <span class="built_in">write</span>(clients[n], <span class="string">&quot;HTTP/1.1 404 Not Found\n&quot;</span>, <span class="number">23</span>); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//来禁止套接字上的输入/输出，使用SHUT_RDWR则将同时无法读取和发送数据</span></span><br><span class="line"><span class="built_in">shutdown</span> (clients[n], SHUT_RDWR);       </span><br><span class="line"><span class="comment">//等到客商退出后才会close  </span></span><br><span class="line"><span class="comment">//6、关闭socket</span></span><br><span class="line"><span class="built_in">close</span>(clients[n]);</span><br><span class="line"><span class="comment">//可以重新使用</span></span><br><span class="line">clients[n]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>默认返回的index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>恭喜<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">body</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: antiquewhite;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">./bgimage.jpg</span>)no-repeat;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-size</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">60%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">10%</span> auto <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#f0f0f0</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding</span>: <span class="number">2%</span> <span class="number">5%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-align</span>:center;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">ul</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding-left</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">ul</span> <span class="selector-tag">li</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">line-height</span>: <span class="number">2.3</span></span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">a</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: <span class="number">#20a53a</span></span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>访问成功<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>这是默认index.html<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;socket编程&quot;&gt;&lt;a href=&quot;#socket编程&quot; class=&quot;headerlink&quot; title=&quot;socket编程&quot;&gt;&lt;/a&gt;socket编程&lt;/h1&gt;&lt;p&gt;linux服务端代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight c++</summary>
      
    
    
    
    <category term="网络" scheme="https://blog.lthero.cn/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="https://blog.lthero.cn/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="socket编程" scheme="https://blog.lthero.cn/tags/socket%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>instruction-pointer</title>
    <link href="https://blog.lthero.cn/2022/07/15/instruction-pointer/"/>
    <id>https://blog.lthero.cn/2022/07/15/instruction-pointer/</id>
    <published>2022-07-15T15:17:20.000Z</published>
    <updated>2022-07-15T15:17:36.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一个小程序的分析"><a href="#一个小程序的分析" class="headerlink" title="一个小程序的分析"></a>一个小程序的分析</h1><p><img src="https://cdn.lthero.cn/post_images/course/Cryptography/QQ%E6%88%AA%E5%9B%BE20220715152731.png" alt="QQ截图20220715152731"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一个小程序的分析&quot;&gt;&lt;a href=&quot;#一个小程序的分析&quot; class=&quot;headerlink&quot; title=&quot;一个小程序的分析&quot;&gt;&lt;/a&gt;一个小程序的分析&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.lthero.cn/post_images/co</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【Cs-Postgraduate】考研资料</title>
    <link href="https://blog.lthero.cn/2022/07/15/CS-postgraduate/"/>
    <id>https://blog.lthero.cn/2022/07/15/CS-postgraduate/</id>
    <published>2022-07-15T12:07:04.000Z</published>
    <updated>2022-07-15T12:24:00.598Z</updated>
    
    <content type="html"><![CDATA[<h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><blockquote><p>整理一些相关资料，放本地速度慢，放cdn费用太高，于是大部分放到阿里云</p></blockquote><h1 id="408真题"><a href="#408真题" class="headerlink" title="408真题"></a>408真题</h1><p>阿里云网盘：「408真题」<a href="https://www.aliyundrive.com/s/Hiai1YRGv1z">https://www.aliyundrive.com/s/Hiai1YRGv1z</a> 提取码: mj69 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;资料&quot;&gt;&lt;a href=&quot;#资料&quot; class=&quot;headerlink&quot; title=&quot;资料&quot;&gt;&lt;/a&gt;资料&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;整理一些相关资料，放本地速度慢，放cdn费用太高，于是大部分放到阿里云&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1</summary>
      
    
    
    
    <category term="考研" scheme="https://blog.lthero.cn/categories/%E8%80%83%E7%A0%94/"/>
    
    <category term="408" scheme="https://blog.lthero.cn/categories/%E8%80%83%E7%A0%94/408/"/>
    
    
    <category term="考研" scheme="https://blog.lthero.cn/tags/%E8%80%83%E7%A0%94/"/>
    
    <category term="408" scheme="https://blog.lthero.cn/tags/408/"/>
    
  </entry>
  
  <entry>
    <title>linux-systemctl-service</title>
    <link href="https://blog.lthero.cn/2022/07/13/linux-systemctl-service/"/>
    <id>https://blog.lthero.cn/2022/07/13/linux-systemctl-service/</id>
    <published>2022-07-13T12:51:08.000Z</published>
    <updated>2022-07-13T12:54:41.621Z</updated>
    
    <content type="html"><![CDATA[<h1 id="systemctl创建服务"><a href="#systemctl创建服务" class="headerlink" title="systemctl创建服务"></a>systemctl创建服务</h1><blockquote><p>用frps服务举例</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /lib/systemd/system/frps.<span class="property">service</span></span><br></pre></td></tr></table></figure><p>服务内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=fraps service</span><br><span class="line">After=network.target syslog.target</span><br><span class="line">Wants=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动服务的命令（此处写你的frps的实际安装目录）</span></span><br><span class="line">ExecStart=/your/path/frps -c /your/path/frps.ini</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动frps</span></span><br><span class="line">sudo systemctl start frps</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自启动</span></span><br><span class="line">sudo systemctl enable frps</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启应用</span></span><br><span class="line">sudo systemctl restart frps</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止应用</span></span><br><span class="line">sudo systemctl stop frps</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看应用的日志</span></span><br><span class="line">sudo systemctl status frps</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;systemctl创建服务&quot;&gt;&lt;a href=&quot;#systemctl创建服务&quot; class=&quot;headerlink&quot; title=&quot;systemctl创建服务&quot;&gt;&lt;/a&gt;systemctl创建服务&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;用frps服务举例&lt;/p&gt;</summary>
      
    
    
    
    <category term="linux" scheme="https://blog.lthero.cn/categories/linux/"/>
    
    
    <category term="linux" scheme="https://blog.lthero.cn/tags/linux/"/>
    
    <category term="systemctl管理" scheme="https://blog.lthero.cn/tags/systemctl%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>raspi-car</title>
    <link href="https://blog.lthero.cn/2022/07/08/raspi-car/"/>
    <id>https://blog.lthero.cn/2022/07/08/raspi-car/</id>
    <published>2022-07-08T14:31:21.000Z</published>
    <updated>2022-07-08T15:29:44.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="折腾·树莓派小车"><a href="#折腾·树莓派小车" class="headerlink" title="折腾·树莓派小车"></a>折腾·树莓派小车</h1><h2 id="材料"><a href="#材料" class="headerlink" title="材料"></a>材料</h2><ul><li>智能小车x1 ，淘宝买<code>2WD</code>【包含车子底座、两个电机、两个轮子、电池模块】，20块钱</li><li>电机驱动x1，<code>TB6612FNG直流电机驱动模块</code>，30块钱【只能驱动两个轮子】</li><li>杜邦线若干</li><li>摄像头x1【可选】20块钱</li><li>树莓派4B</li></ul><h1 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h1><h2 id="小车底座安装"><a href="#小车底座安装" class="headerlink" title="小车底座安装"></a>小车底座安装</h2><ul><li>将各个模块安装好，并预留好两个电机的四个线出来</li></ul><p><img src="https://cdn.lthero.cn/post_images/course/Cryptography/2F781D2D7825E3D22F39DE1083AC14BD.jpg" alt="安装小车底座"></p><ul><li>将智能小车底座安装好</li></ul><p><img src="https://cdn.lthero.cn/post_images/course/Cryptography/B094A14D7740AA29588E40BCA41EB625.jpg" alt="小车底座安装好"></p><h2 id="TB6612FNG与树莓派连接"><a href="#TB6612FNG与树莓派连接" class="headerlink" title="TB6612FNG与树莓派连接"></a>TB6612FNG与树莓派连接</h2><blockquote><p>不看原理，直接跳到“<strong>具体接线图</strong>”</p></blockquote><h3 id="TB6612FNG驱动"><a href="#TB6612FNG驱动" class="headerlink" title="TB6612FNG驱动"></a>TB6612FNG驱动</h3><p>TB6612FNG驱动如下图所示</p><p><img src="https://pic2.zhimg.com/v2-059b8a0dcc48ca18f4eb9f5d6755be6d_r.jpg" alt="img"></p><p>接口说明：</p><ol><li>VM：电机驱动电源输入（2.74-10.8V）</li><li>VCC：逻辑电平输入（5.0V）</li><li>AO1和AO2：接直流电机A</li><li>BO2和BO1：接直流电机B</li><li>PWMA：控制电机A的转速</li><li>AIN1和AIN2：控制电机A（停止、正转、反转）</li><li>STBY：正常工作&#x2F;待机状态控制端</li><li>PWMB：控制电机B的转速</li><li>BIN1和BIN2：控制电机B（停止、正转、反转）</li><li>GND：接地</li></ol><p>AIN1和AIN2用于控制电机A停止、正转、反转，真值表如下</p><table><thead><tr><th>AIN1</th><th>0</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>AIN2</td><td>0</td><td>1</td><td>0</td></tr><tr><td>状态</td><td>停止</td><td>正转</td><td>反转</td></tr></tbody></table><p>BIN1和BIN2的真值表同上</p><h3 id="树莓派40PIN引脚对照表"><a href="#树莓派40PIN引脚对照表" class="headerlink" title="树莓派40PIN引脚对照表"></a>树莓派40PIN引脚对照表</h3><p><img src="https://pic3.zhimg.com/v2-04e918076542859bd7b4e8c1743851f6_r.jpg" alt="img"></p><p>树莓派GPIO和TB6612FNG的接线情况如下表</p><table><thead><tr><th>树莓派GPIO接口(BCM编码)</th><th>TB6612FNG驱动接口</th><th>说明</th></tr></thead><tbody><tr><td>27</td><td>STBY</td><td>设置TB6612FNG驱动模块的状态（工作&#x2F;待机）</td></tr><tr><td>18</td><td>PWMA</td><td>基于PWM控制电机A转速</td></tr><tr><td>14</td><td>AIN1</td><td>控制电机A停止、正转、反转</td></tr><tr><td>15</td><td>AIN2</td><td>控制电机A停止、正转、反转</td></tr><tr><td>19</td><td>PWMB</td><td>基于PWM控制电机B转速</td></tr><tr><td>23</td><td>BIN1</td><td>控制电机B停止、正转、反转</td></tr><tr><td>24</td><td>BIN2</td><td>控制电机B停止、正转、反转</td></tr></tbody></table><p>电机驱动和树莓派4B共用一个5V、3A的电源</p><h3 id="具体接线图"><a href="#具体接线图" class="headerlink" title="具体接线图"></a>具体接线图</h3><p><img src="https://pic1.zhimg.com/v2-83ef02efdd8394f597731a0d15f43dc4_r.jpg" alt="img"></p><h2 id="树莓派测试控制电机"><a href="#树莓派测试控制电机" class="headerlink" title="树莓派测试控制电机"></a>树莓派测试控制电机</h2><p>安装好后，树莓派测试电机是否可以被正常控制，前进后退左转右转是否正常</p><p>先安装RPi.GPIO模块，命令如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt<span class="operator">-</span><span class="keyword">get</span> install python3<span class="operator">-</span>rpi.gpio</span><br></pre></td></tr></table></figure><p>安装好后，将下面的代码保存到<code>test.py</code>中，运行测试脚本<code>python3 test.py</code>，如果电机可以运转则正常！！！</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#motorTest.py</span></span><br><span class="line"><span class="comment">#导入 GPIO库</span></span><br><span class="line"><span class="keyword">import</span> RPi.GPIO <span class="keyword">as</span> GPIO</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置 GPIO 模式为 BCM</span></span><br><span class="line">GPIO.setmode(GPIO.BCM)</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义引脚</span></span><br><span class="line">STBY = <span class="number">27</span></span><br><span class="line">PWMA = <span class="number">18</span></span><br><span class="line">AIN1 = <span class="number">14</span></span><br><span class="line">AIN2 = <span class="number">15</span></span><br><span class="line">PWMB = <span class="number">19</span></span><br><span class="line">BIN1 = <span class="number">23</span></span><br><span class="line">BIN2 = <span class="number">24</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置 GPIO 的工作方式</span></span><br><span class="line">GPIO.setup(STBY, GPIO.OUT)</span><br><span class="line">GPIO.setup(PWMA, GPIO.OUT)</span><br><span class="line">GPIO.setup(AIN1, GPIO.OUT)</span><br><span class="line">GPIO.setup(AIN2, GPIO.OUT)</span><br><span class="line">GPIO.setup(PWMB, GPIO.OUT)</span><br><span class="line">GPIO.setup(BIN1, GPIO.OUT)</span><br><span class="line">GPIO.setup(BIN2, GPIO.OUT)</span><br><span class="line">pwma = GPIO.PWM(PWMA,<span class="number">300</span>)</span><br><span class="line">pwmb = GPIO.PWM(PWMB,<span class="number">300</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 前进或后退（大于零前进，小于零后退）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">goForward</span>(<span class="params">speed</span>):</span><br><span class="line">    <span class="keyword">if</span>(speed&gt;=<span class="number">0</span>):</span><br><span class="line">        GPIO.output(AIN1,GPIO.LOW)</span><br><span class="line">        GPIO.output(AIN2,GPIO.HIGH)</span><br><span class="line">        GPIO.output(BIN1,GPIO.LOW)</span><br><span class="line">        GPIO.output(BIN2,GPIO.HIGH)</span><br><span class="line">        pwma.start(speed)</span><br><span class="line">        pwmb.start(speed)</span><br><span class="line">        time.sleep(<span class="number">0.02</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        GPIO.output(AIN2,GPIO.LOW)</span><br><span class="line">        GPIO.output(AIN1,GPIO.HIGH)</span><br><span class="line">        GPIO.output(BIN2,GPIO.LOW)</span><br><span class="line">        GPIO.output(BIN1,GPIO.HIGH)</span><br><span class="line">        pwma.start(-speed)</span><br><span class="line">        pwmb.start(-speed)</span><br><span class="line">        time.sleep(<span class="number">0.02</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 左转或右转（大于零左转，小于零右转）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">turnLeft</span>(<span class="params">speed</span>):</span><br><span class="line">    <span class="keyword">if</span>(speed&gt;=<span class="number">0</span>):</span><br><span class="line">        GPIO.output(AIN2,GPIO.LOW)</span><br><span class="line">        GPIO.output(AIN1,GPIO.HIGH)</span><br><span class="line">        GPIO.output(BIN1,GPIO.LOW)</span><br><span class="line">        GPIO.output(BIN2,GPIO.HIGH)</span><br><span class="line">        pwma.start(speed)</span><br><span class="line">        pwmb.start(speed)</span><br><span class="line">        time.sleep(<span class="number">0.02</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        GPIO.output(AIN1,GPIO.LOW)</span><br><span class="line">        GPIO.output(AIN2,GPIO.HIGH)</span><br><span class="line">        GPIO.output(BIN2,GPIO.LOW)</span><br><span class="line">        GPIO.output(BIN1,GPIO.HIGH)</span><br><span class="line">        pwma.start(-speed)</span><br><span class="line">        pwmb.start(-speed)</span><br><span class="line">        time.sleep(<span class="number">0.02</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">motorStop</span>():</span><br><span class="line">    GPIO.output(AIN1,GPIO.LOW)</span><br><span class="line">    GPIO.output(AIN2,GPIO.LOW)</span><br><span class="line"></span><br><span class="line">GPIO.output(STBY,GPIO.HIGH)</span><br><span class="line"><span class="comment">#以60%的速度前进</span></span><br><span class="line">goForward(<span class="number">60</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#以60%的速度后退</span></span><br><span class="line">goForward(-<span class="number">60</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#左转</span></span><br><span class="line">turnLeft(<span class="number">60</span>)</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#右转</span></span><br><span class="line">turnLeft(-<span class="number">60</span>)</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#停止</span></span><br><span class="line">motorStop()</span><br><span class="line"></span><br><span class="line">pwma.stop()</span><br><span class="line">pwmb.stop()</span><br><span class="line">GPIO.cleanup()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="摄像头安装"><a href="#摄像头安装" class="headerlink" title="摄像头安装"></a>摄像头安装</h2><p>关机、断电、给摄像头安装摄像头。安装好后启动树莓派，输入命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcgencmd get_camera</span><br></pre></td></tr></table></figure><h3 id="检测摄像头"><a href="#检测摄像头" class="headerlink" title="检测摄像头"></a>检测摄像头</h3><ul><li>如果输出以下内容，则可以直接到“<strong>测试摄像头</strong>”</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supported=1 detected=1, libcamera interfaces=0</span><br></pre></td></tr></table></figure><p>​     </p><ul><li>如果输出以下内容，则需要一些设置后，才能使用</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supported=0 detected=0, libcamera interfaces=0</span><br></pre></td></tr></table></figure><hr><h3 id="无法使用摄像头时方法一："><a href="#无法使用摄像头时方法一：" class="headerlink" title="无法使用摄像头时方法一："></a>无法使用摄像头时方法一：</h3><p>先打开树莓派的配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo raspi-config</span><br></pre></td></tr></table></figure><p><img src="https://cdn.lthero.cn/post_images/course/Cryptography/image-20220708231413128.png" alt="image-20220708231413128"></p><p>选择Interface Options：</p><p>再选择Legacy Camera：</p><p><img src="https://pic2.zhimg.com/80/v2-2dbe2dff8833947df79fca7686439989_720w.jpg" alt="img"></p><p>在这个页面回答Yes。</p><p>系统会显示如下信息：</p><p><img src="https://pic4.zhimg.com/80/v2-ea12846c756378c7473c8a14dc3f3b67_720w.jpg" alt="img"></p><p>回到主菜单，点击Finish：</p><p><img src="https://pic4.zhimg.com/80/v2-90ed2316ee7bcf4ba9fd13ce9b2976cf_720w.jpg" alt="img"></p><p>重启树莓派。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><p>​    </p><h3 id="无法使用摄像头时方法二"><a href="#无法使用摄像头时方法二" class="headerlink" title="无法使用摄像头时方法二"></a>无法使用摄像头时方法二</h3><ul><li>将<strong>方法一</strong>中，<code>Legacy Camera</code>再关闭掉，先别重启</li><li>再编辑<code>/boot/config.txt</code>，找到<strong>gpu_men</strong>，设置成128或者更高，我的原来就是128，所以改成了256，然后重启树莓派，可能是显存过低导致的。</li><li><code>start_x=1</code>，并重启树莓派</li></ul><p><img src="https://cdn.lthero.cn/post_images/course/Cryptography/image-20220708231748648.png" alt="image-20220708231748648"></p><p>​    </p><p>​    </p><hr><h3 id="测试摄像头"><a href="#测试摄像头" class="headerlink" title="测试摄像头"></a>测试摄像头</h3><p>打开<code>VNC桌面</code>，将下面代码保存为<code>testcamera.py</code>，并在VNC桌面运行<code>python3 testcamera.py</code>，如果跳出来一个摄像头窗口，则正常！！！</p><p>测试摄像头代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 该程序打开摄像头，显示视频，按q拍摄一张照片并储存下来</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    <span class="comment"># 获得图片</span></span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="comment"># 展示图片</span></span><br><span class="line">    cv2.imshow(<span class="string">&quot;capture&quot;</span>, frame)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="comment"># 存储图片</span></span><br><span class="line">        cv2.imwrite(<span class="string">&quot;camera.jpg&quot;</span>, frame)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ul><li>cv2看之前一篇安装opencv文章</li></ul></blockquote><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>下载:<a href="https://wwd.lanzouy.com/iJp5207kqd9g">https://wwd.lanzouy.com/iJp5207kqd9g</a> 密码:7qp0</p><p>代码下载好后，安装motion【一个将摄像头运行在后台的web服务】</p><p>安装motion</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install motion -y</span><br></pre></td></tr></table></figure><ul><li>编辑&#x2F;etc&#x2F;default&#x2F;motion文件，开启守护进程</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/default/motion</span><br></pre></td></tr></table></figure><ul><li><p>设置<code>start_motion_daemon=yes</code></p></li><li><p>编辑&#x2F;etc&#x2F;motion&#x2F;motion.conf文件</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/motion/motion.conf</span><br></pre></td></tr></table></figure><p>以下仅列出部分配置，详细的配置文档见<a href="http://lavrsen.dk/foswiki/bin/view/Motion/ConfigFileOptions">Motion - Config File Options</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将deamon off 改成 deamon on</span></span><br><span class="line">deamon on</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置视频分辨率</span></span><br><span class="line">width 800</span><br><span class="line">height 600</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">视频帧率</span></span><br><span class="line">framerate 24</span><br><span class="line">stream_maxrate 30</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">允许非本机访问总控制页面</span></span><br><span class="line">webcontrol_localhost off</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">允许非本机查看视频监控</span></span><br><span class="line">stream_localhost off</span><br></pre></td></tr></table></figure><p>启动motion</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start motion</span><br><span class="line">sudo motion</span><br></pre></td></tr></table></figure><p>​     </p><p>安装gpac</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gpac -y</span><br></pre></td></tr></table></figure><p>​          </p><p>安装bottle</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install bottle</span><br></pre></td></tr></table></figure><p>先运行一遍上面步骤中的<code>test.py</code>，命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 test.py</span><br></pre></td></tr></table></figure><p>再安装Start.py，命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 Start.py</span><br></pre></td></tr></table></figure><p>在浏览器中访问树莓派<strong>地址:8088</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;折腾·树莓派小车&quot;&gt;&lt;a href=&quot;#折腾·树莓派小车&quot; class=&quot;headerlink&quot; title=&quot;折腾·树莓派小车&quot;&gt;&lt;/a&gt;折腾·树莓派小车&lt;/h1&gt;&lt;h2 id=&quot;材料&quot;&gt;&lt;a href=&quot;#材料&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="折腾" scheme="https://blog.lthero.cn/categories/%E6%8A%98%E8%85%BE/"/>
    
    <category term="树莓派" scheme="https://blog.lthero.cn/categories/%E6%8A%98%E8%85%BE/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    
    <category term="折腾" scheme="https://blog.lthero.cn/tags/%E6%8A%98%E8%85%BE/"/>
    
    <category term="树莓派" scheme="https://blog.lthero.cn/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title>【openCv &amp; dlib】安装</title>
    <link href="https://blog.lthero.cn/2022/07/04/openCv-dlib/"/>
    <id>https://blog.lthero.cn/2022/07/04/openCv-dlib/</id>
    <published>2022-07-04T14:02:31.000Z</published>
    <updated>2022-07-08T15:05:10.590Z</updated>
    
    <content type="html"><![CDATA[<h2 id="openCV安装（非编译方法）"><a href="#openCV安装（非编译方法）" class="headerlink" title="openCV安装（非编译方法）"></a>openCV安装（非编译方法）</h2><p>1.安装依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libhdf5-dev</span><br><span class="line"></span><br><span class="line">sudo apt-get install libatlas-base-dev</span><br><span class="line"></span><br><span class="line">sudo apt-get install libjasper-dev</span><br><span class="line"></span><br><span class="line">sudo apt-get install libqt4-test</span><br><span class="line"></span><br><span class="line">sudo apt-get install libqtgui4</span><br></pre></td></tr></table></figure><p>需要外网络足够好，可使用pip直接安装</p><ul><li>有两个版本：opencv-contrib-python、opencv-python</li><li>opencv-python：基础内容</li><li>opencv-contrib-python：包含更多高级算法，如果要用人脸识别，直接装<strong>opencv-contrib-python</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip3 install opencv-contrib-python</span><br></pre></td></tr></table></figure><p>安装完成后可以在命令行里输入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ python3</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> dlib</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>没报错即可</p><h2 id="dlib安装（非编译方法）"><a href="#dlib安装（非编译方法）" class="headerlink" title="dlib安装（非编译方法）"></a>dlib安装（非编译方法）</h2><p>1.安装dlib之前，需要先安装dlib的依赖项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install build-essential cmake libgtk-3-dev libboost-all-dev -y</span><br></pre></td></tr></table></figure><p>2.用pip3安装其他dlib运行依赖的库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pip3 install numpy</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pip3 install scipy        <span class="comment">#这一步需会检测numpy的版本，numpy版本需要与python版本相对应，因此，如果报错，大家需要安装错误提示中指定版本的numpy</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这一步需要的时间比较长（30分钟左右）</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pip3 install 先别复制 scikit-image <span class="comment">#这一步总是失败  参考github源码安装说明：</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Debian/Ubuntu: sudo apt-get install python3-skimage</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">OSX: pip install scikit-image</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Anaconda: conda install -c conda-forge scikit-image</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Windows: Download Windows binaries</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">因此换成  sudo apt-get install python-skimage安装成功</span></span><br></pre></td></tr></table></figure><p>3.下载dlib</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/davisking/dlib.git</span><br></pre></td></tr></table></figure><p>4.安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo python3 setup.py install </span><br></pre></td></tr></table></figure><p>安装过程比较长20分钟至少</p><p>5.测试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ python3</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> dlib</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>没报错即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;openCV安装（非编译方法）&quot;&gt;&lt;a href=&quot;#openCV安装（非编译方法）&quot; class=&quot;headerlink&quot; title=&quot;openCV安装（非编译方法）&quot;&gt;&lt;/a&gt;openCV安装（非编译方法）&lt;/h2&gt;&lt;p&gt;1.安装依赖&lt;/p&gt;
&lt;figure</summary>
      
    
    
    
    <category term="python" scheme="https://blog.lthero.cn/categories/python/"/>
    
    
    <category term="python" scheme="https://blog.lthero.cn/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>【今日校园】自动打卡</title>
    <link href="https://blog.lthero.cn/2022/07/04/Fuck-todayStudy/"/>
    <id>https://blog.lthero.cn/2022/07/04/Fuck-todayStudy/</id>
    <published>2022-07-04T03:40:08.000Z</published>
    <updated>2022-07-31T13:26:40.671Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今日校园自动打卡"><a href="#今日校园自动打卡" class="headerlink" title="今日校园自动打卡"></a>今日校园自动打卡</h1><blockquote><p>一键部署脚本已经上线：<a href="https://github.com/lthero-big/TodayStudyAutoSignInstallShell">https://github.com/lthero-big/TodayStudyAutoSignInstallShell</a></p></blockquote><ul><li>目前部署在国内服务器的方式早就失效了，今日校园会检测访问ip是否来自阿里云、腾讯云等，若是，则禁用访问。</li></ul><h2 id="目前可行的方案："><a href="#目前可行的方案：" class="headerlink" title="目前可行的方案："></a>目前可行的方案：</h2><ul><li>本地部署并设置定时任务【使用自己电脑或刷过系统的路由器】</li><li>使用国外服务器主机部署并设置定时任务</li></ul><p>​    </p><p>​    </p><h2 id="国外服务器怎么搞？"><a href="#国外服务器怎么搞？" class="headerlink" title="国外服务器怎么搞？"></a>国外服务器怎么搞？</h2><ul><li>方法1：微软面向学生提供一年的Azure服务器，一直可以领取，如果有学校邮箱的同学可以直接申请，方法网上很多</li><li>方法2：没有学校邮箱的，可以上淘宝花20块买个Azure账号<ul><li>Azure的服务器，领取后里面是100刀，省着用，开5刀一个月的服务器即可。里面只有15GB，不能搭建梯子疯狂用……</li></ul></li><li>方法3：淘宝上花30买个DigitalOcean的账号，里面有100刀可以用，比微软的好处是，流量每个月有2TB，可以搭建梯子<ul><li>搭建梯子方法：<a href="https://blog.lthero.cn/2022/05/20/v2ray-install/">https://blog.lthero.cn/2022/05/20/v2ray-install/</a></li></ul></li><li>方法4：买个github包，里面有DigitalOcean的100刀代金卷、有两年域名可以领取，jetbrain全家桶、termius等<ul><li>推荐上淘宝搜索“<strong>IT黑店</strong>”，他家的github包只要66元，老板人很好，他质保一年</li></ul></li></ul><hr><h1 id="部署流程"><a href="#部署流程" class="headerlink" title="部署流程"></a>部署流程</h1><blockquote><p><strong>一键部署脚本</strong>已经上线：<a href="https://github.com/lthero-big/TodayStudyAutoSignInstallShell">https://github.com/lthero-big/TodayStudyAutoSignInstallShell</a></p><p>以下内容可以全部忽略！！！</p></blockquote><h2 id="1、下载代码"><a href="#1、下载代码" class="headerlink" title="1、下载代码"></a>1、下载代码</h2><p>下载地址:<a href="https://wwd.lanzouy.com/ikq1c07c4z7g">https://wwd.lanzouy.com/ikq1c07c4z7g</a> 密码:c599</p><p>​    </p><h2 id="2、修改配置文件"><a href="#2、修改配置文件" class="headerlink" title="2、修改配置文件"></a>2、修改配置文件</h2><p>在本地下载并解压代码，在本地打开config.yml文件，按自己的需要修改配置文件【如何修改，参考config_demo.yml文件】</p><p>​    </p><h2 id="3、上传到服务器"><a href="#3、上传到服务器" class="headerlink" title="3、上传到服务器"></a>3、上传到服务器</h2><p>修改好文件后，在<strong>本地运行测试</strong>，如果没问题，再上传到服务器</p><p>比如，代码的所有文件上传到<code>/home/codes/fuck-todaystudy/</code>  目录下</p><p>​    </p><h2 id="4、安装依赖库"><a href="#4、安装依赖库" class="headerlink" title="4、安装依赖库"></a>4、安装依赖库</h2><p>服务器上需要安装python，并安装pip</p><p>再根据根据需要的库【在requirement.txt里面】，用pip安装，安装命令：</p><p>【requirement.txt路径根据自己实际放置的路径修改】</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# pip install -r /home/codes/fuck-todaystudy/requirement.txt</span><br></pre></td></tr></table></figure><p>安装好后，再安装pycrypt库【用来加密的】，安装命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# pip install -i https://pypi.douban.com/simple/ pycryptodome </span><br></pre></td></tr></table></figure><p>​    </p><h2 id="5、测试运行"><a href="#5、测试运行" class="headerlink" title="5、测试运行"></a>5、测试运行</h2><p>安装好库后，测试下能否正常运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# python3 /home/codes/fuck-todaystudy/index.py</span><br></pre></td></tr></table></figure><p>在控制台查看运行输出结果，如果没问题再设置定时任务</p><p>​    </p><h2 id="6、设置定时任务"><a href="#6、设置定时任务" class="headerlink" title="6、设置定时任务"></a>6、设置定时任务</h2><blockquote><p>如果用国外服务器，先进行时间同步！将服务器的系统时间时区修改成上海&#x2F;北京时区</p></blockquote><h3 id="步骤1、创建shell脚本"><a href="#步骤1、创建shell脚本" class="headerlink" title="步骤1、创建shell脚本"></a>步骤1、创建shell脚本</h3><p>先创建shell脚本存放的目录，命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# mkdir /home/codes/shell</span><br></pre></td></tr></table></figure><p>再创建脚本，假设脚本路径为 <code>/home/codes/shell/autoSign.sh</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# vim /home/codes/shell/autoSign.sh</span><br></pre></td></tr></table></figure><p>shell脚本里面包含<strong>运行打卡程序的命令</strong>【注意下面路径，修改成实际路径】</p><ul><li>cd &#x2F;home&#x2F;codes&#x2F;fuck-todaystudy&#x2F;：表示进入打卡程序的目录</li><li>python3 &#x2F;home&#x2F;codes&#x2F;fuck-todaystudy&#x2F;index.py： 表示运行打卡程序</li><li>其它的代码是配置环境与输出提示信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin</span><br><span class="line">export PATH</span><br><span class="line">cd /home/codes/fuck-todaystudy/</span><br><span class="line">python3 /home/codes/fuck-todaystudy/index.py</span><br><span class="line">echo &quot;----------------------------------------------------------------------------&quot;</span><br><span class="line">endDate=`date +&quot;%Y-%m-%d %H:%M:%S&quot;`</span><br><span class="line">echo &quot;★[$endDate] Successful&quot;</span><br><span class="line">echo &quot;----------------------------------------------------------------------------&quot;</span><br></pre></td></tr></table></figure><p>​    </p><h3 id="步骤2、运行测试shell脚本"><a href="#步骤2、运行测试shell脚本" class="headerlink" title="步骤2、运行测试shell脚本"></a>步骤2、运行测试shell脚本</h3><p>先给脚本添加权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# chmod +x /home/codes/shell/autoSign.sh</span><br></pre></td></tr></table></figure><p>再运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# bash /home/codes/shell/autoSign.sh</span><br></pre></td></tr></table></figure><p>如果运行成功，同样会输出打卡信息，并在最后，<code>输出当前时间和Successful</code></p><p>​    </p><h3 id="步骤3、定时运行shell脚本"><a href="#步骤3、定时运行shell脚本" class="headerlink" title="步骤3、定时运行shell脚本"></a>步骤3、定时运行shell脚本</h3><p>使用<code>cronta</code>b命令，输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# crontab -e</span><br></pre></td></tr></table></figure><p>第一次运行时，需要选择编辑器类型，选择vim对应的序号即可</p><p>在<code>crontab里面</code>输入以下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 10 * * * /home/codes/shell/autoSign.sh &gt;&gt; /home/lthero/codes/autoSign.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li>3 10 * * * 表示：每天上午10点3分运行上面写好的脚本</li><li><strong>&#x2F;home&#x2F;codes&#x2F;shell&#x2F;autoSign.sh</strong> 表示：上面写好的脚本路径</li><li><strong>&#x2F;home&#x2F;lthero&#x2F;codes&#x2F;autoSign.log 2&gt;&amp;1</strong> 表示：将每次运行的输出，续写到autoSign.log这个日志文件</li></ul><p>​    </p><p>至此，自动打卡部署完成。</p><hr><blockquote><p>测试crontab是否成功方法：假如当前是11点10分，将crontab加一条11点12分运行的命令，到了11点12分后，查看日志文件，检测是否在11点12分有打卡输出信息，如果没问题，再删除这条定时任务即可</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12 11 * * * /home/codes/shell/autoSign.sh &gt;&gt; /home/lthero/codes/autoSign.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;今日校园自动打卡&quot;&gt;&lt;a href=&quot;#今日校园自动打卡&quot; class=&quot;headerlink&quot; title=&quot;今日校园自动打卡&quot;&gt;&lt;/a&gt;今日校园自动打卡&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;一键部署脚本已经上线：&lt;a href=&quot;https://githu</summary>
      
    
    
    
    <category term="python" scheme="https://blog.lthero.cn/categories/python/"/>
    
    
    <category term="python" scheme="https://blog.lthero.cn/tags/python/"/>
    
    <category term="linux" scheme="https://blog.lthero.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>【Python爬虫】二次元涩图&amp;多线程下载</title>
    <link href="https://blog.lthero.cn/2022/07/02/python-download-mul-thread/"/>
    <id>https://blog.lthero.cn/2022/07/02/python-download-mul-thread/</id>
    <published>2022-07-02T10:13:39.000Z</published>
    <updated>2022-08-07T06:33:12.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="下载涩图"><a href="#下载涩图" class="headerlink" title="下载涩图"></a>下载涩图</h1><p>壁纸网址： <a href="https://gelbooru.wjcodes.com/">https://gelbooru.wjcodes.com/</a></p><h2 id="python代码"><a href="#python代码" class="headerlink" title="python代码"></a>python代码</h2><p>已经多线程|可连续下载多页</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">@author=lthero</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;user-agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ,&#x27;origin&#x27;:&#x27;https://gelbooru.wjcodes.com&#x27;,&#x27;referer&#x27;:&#x27;https://gelbooru.wjcodes.com/index.php&#x27;,&quot;cookie &quot;:&#x27;PHPSESSID=tgcjp4rk5umdpljmcidk4oh761; Hm_lvt_1a24c75afab540e93df54d2fbb24adcd=1656466059,1656748509; Hm_lpvt_1a24c75afab540e93df54d2fbb24adcd=1656749708; __cf_bm=6DOkeA0mLqTnobxmLpyUIjz9GMYnvjOkWOb5MGVYSCA-1656749710-0-Ac7iAZjUg9FtBpv/kKQVY1IFv2ydf58sqpGpoQE4Rv1mlcyOG0+4Vea5NHw4h4YQwRuyjbGwgP5qhr5IzcggexF53sXBQbmjKlOqVl0SGydUkho73Fs0nFtuvgO62F1+aQ==&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myThread</span>(threading.Thread):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, url, fileName, file_path</span>):</span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.url = url</span><br><span class="line">        self.file_path = file_path</span><br><span class="line">        self.fileName = fileName</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">open_url</span>(<span class="params">self, url</span>):</span><br><span class="line">        response = requests.get(url, headers)</span><br><span class="line">        <span class="keyword">return</span> response.text</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        img = requests.get(self.url, headers=headers)</span><br><span class="line">        file = self.file_path + <span class="string">&quot;\\&quot;</span> + self.fileName + <span class="string">&quot;.jpg&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(file):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Downloading %s&quot;</span> % self.fileName)</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;%s/%s.jpg&#x27;</span> % (self.file_path, self.fileName), <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(img.content)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(self.file_path + <span class="string">&quot;\\&quot;</span> + self.fileName + <span class="string">&quot; exist&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分页加载的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">picDown</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">open_url</span>(<span class="params">self, url</span>):</span><br><span class="line">        response = requests.get(url, headers)</span><br><span class="line">        <span class="keyword">return</span> response.text</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, url, save_path, pageNum</span>):</span><br><span class="line">        self.starturl = url</span><br><span class="line">        self.save_path = save_path</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(self.save_path):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;目录不存在,已经尝试创建&quot;</span>)</span><br><span class="line">            os.makedirs(self.save_path)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(self.save_path):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;目录不存在,无法创建成功,请重新输入目录&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.pageNum = pageNum</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">int</span>(self.pageNum) &lt;= <span class="number">0</span>:</span><br><span class="line">            self.pageNum = <span class="string">&quot;1&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">int</span>(self.pageNum) &gt;= <span class="number">10</span>:</span><br><span class="line">            self.pageNum = <span class="string">&quot;10&quot;</span></span><br><span class="line">        self.run()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        page = self.starturl.split(<span class="string">&#x27;&amp;&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">        startNum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(page) &lt;= <span class="number">6</span>:</span><br><span class="line">            <span class="comment"># 如果当前p=存在</span></span><br><span class="line">            <span class="comment"># 去除p=后面的数字</span></span><br><span class="line">            startNum += <span class="built_in">int</span>(<span class="built_in">str</span>(page).strip(<span class="string">&quot;&amp;p=&quot;</span>))</span><br><span class="line">            self.starturl = self.starturl[<span class="number">0</span>:-<span class="built_in">int</span>(<span class="built_in">len</span>(page))]+<span class="string">&quot;p=&quot;</span></span><br><span class="line">        <span class="comment"># 当前p=不存在</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.starturl += <span class="string">&quot;?p=&quot;</span></span><br><span class="line">            startNum += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startNum, startNum + <span class="built_in">int</span>(self.pageNum) ):</span><br><span class="line">            soup = BeautifulSoup(self.open_url(self.starturl + <span class="built_in">str</span>(i)), <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">            images = soup.find(<span class="string">&#x27;ul&#x27;</span>, <span class="built_in">id</span>=<span class="string">&#x27;main-list&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> li <span class="keyword">in</span> images.find_all(<span class="string">&#x27;li&#x27;</span>):</span><br><span class="line">                string = li.a[<span class="string">&#x27;onclick&#x27;</span>]</span><br><span class="line">                pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;(https?:[^:&lt;&gt;&quot;]*\/)([^:&lt;&gt;&quot;]*)(\.((png!thumbnail)|(png)|(jpg)|(webp)))&#x27;</span>)</span><br><span class="line">                each_url = pattern.findall(<span class="built_in">str</span>(string))[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">                name = <span class="built_in">str</span>(each_url).split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">2</span>]</span><br><span class="line">                each_url = each_url[<span class="number">0</span>:-<span class="number">1</span>] + <span class="string">&quot;.jpg&quot;</span></span><br><span class="line">                thread1 = myThread(each_url, name, self.save_path)</span><br><span class="line">                thread1.start()</span><br><span class="line">                time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 测试网址</span></span><br><span class="line">    <span class="comment"># https://gelbooru.wjcodes.com/index.php?tag=&amp;p=3</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Author: lthero&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;HomePage: https://blog.lthero.cn&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#x27;&#x27;使用说明:</span></span><br><span class="line"><span class="string">          1.点击右键可以粘贴!</span></span><br><span class="line"><span class="string">          2.先输入网址</span></span><br><span class="line"><span class="string">          3.再输入要保存到的目录完整路径,可以输入中文路径,路径一定要存在</span></span><br><span class="line"><span class="string">          4.如果不输入下面的页数,默认只下载一页</span></span><br><span class="line"><span class="string">          5.一次性最多下载10页[防止ip被封]</span></span><br><span class="line"><span class="string">          &#x27;&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        picDown(url=<span class="built_in">input</span>(<span class="string">&quot;输入要下载的网址: 比如 https://gelbooru.wjcodes.com/index.php?tag=&amp;p=3 请输入: &quot;</span>),</span><br><span class="line">                save_path=<span class="built_in">input</span>(<span class="string">&quot;输入要保存到的目录: &quot;</span>), pageNum=<span class="built_in">input</span>(<span class="string">&quot;要连续下载几页?输入数字即可: &quot;</span>))</span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;全部下载完成!&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="打包程序下载"><a href="#打包程序下载" class="headerlink" title="打包程序下载"></a>打包程序下载</h2><p><a href="https://wwd.lanzouy.com/iBD1f079k2dc">https://wwd.lanzouy.com/iBD1f079k2dc</a><br>密码:h3wj</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;下载涩图&quot;&gt;&lt;a href=&quot;#下载涩图&quot; class=&quot;headerlink&quot; title=&quot;下载涩图&quot;&gt;&lt;/a&gt;下载涩图&lt;/h1&gt;&lt;p&gt;壁纸网址： &lt;a href=&quot;https://gelbooru.wjcodes.com/&quot;&gt;https://gelbooru</summary>
      
    
    
    
    <category term="python" scheme="https://blog.lthero.cn/categories/python/"/>
    
    <category term="爬虫" scheme="https://blog.lthero.cn/categories/python/%E7%88%AC%E8%99%AB/"/>
    
    
    <category term="python" scheme="https://blog.lthero.cn/tags/python/"/>
    
    <category term="壁纸" scheme="https://blog.lthero.cn/tags/%E5%A3%81%E7%BA%B8/"/>
    
    <category term="爬虫" scheme="https://blog.lthero.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="二次元" scheme="https://blog.lthero.cn/tags/%E4%BA%8C%E6%AC%A1%E5%85%83/"/>
    
  </entry>
  
  <entry>
    <title>【存储】存储器结构|缓存</title>
    <link href="https://blog.lthero.cn/2022/07/01/The-Memory-Hierarchy/"/>
    <id>https://blog.lthero.cn/2022/07/01/The-Memory-Hierarchy/</id>
    <published>2022-07-01T07:32:59.000Z</published>
    <updated>2022-07-21T02:06:49.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h1><h1 id="直接映射-1"><a href="#直接映射-1" class="headerlink" title="直接映射"></a>直接映射</h1><p><img src="https://cdn.lthero.cn/post_images/course/Cryptography/image-20220701123652106.png" alt="直接映射宏观图"></p><ul><li><code>组索引位数（set index）</code>表示去cache中的哪个组找</li><li>一个组内可以有一行、可以有多行</li><li>如果一个组内只有一行，找到了组号，再确定下tag号和有效位valid就能知道：数据是否被缓存在cache中。再根据偏移位数，拿出数据即可【一组一行是直接映射】</li><li>如果一组内有多行，找到了组号，还需要顺序<strong>逐个对比tag</strong>和有效位……逐个对比地址的tag号和某行的tag号是否相同，若相同并且有效，再拿数据【一组有多行是组相联】</li></ul><p><img src="https://cdn.lthero.cn/post_images/course/Cryptography/image-20220701123517240.png" alt="组内某行的内部结构"></p><p>可以看到：</p><ul><li>一个组（set）中包含：有效位（valid），<code>标志位数（tag）</code>，一个数据块（Cache block）</li><li>其中如图的Cache block一共有8个格子【0~7号格子】，每一个格子上，可以放一个字节【先不管为啥直接放一个字节】！！！</li></ul><p>所以，一个数据块Cache block一共可以放8个字节</p><p>又因为，0~7这8个数，只要3位二进制就能表示</p><p>所以在<strong>内存地址</strong>的<strong>后三位</strong>叫“Block offset”【叫<code>偏移位数</code>】用来表示用Cache block的<strong>哪个格子</strong>存或取数据</p><p>上面标红的三个值，就是将<code>内存地址划分</code>成的<strong>三个变量</strong></p><p><img src="https://cdn.lthero.cn/post_images/course/Cryptography/image-20220701124454980.png" alt="image-20220701124454980"></p><hr><p>数据块（Cache block）里面的单位是字？还是字节？</p><p>得看具体要求，有的题目写“每个数据块可以放<strong>4字</strong>”，其实就等价于“每个数据块可以放<strong>16字节</strong>”，从而得到B&#x3D;16，<code>偏移位数b=4</code></p><p>说白了，就是懒……像下面题目，浮点数本身就占用<strong>4字节</strong>，一个数据块最大装入<strong>16字节</strong></p><p>大家都提出个共因数4，变成<strong>浮点数1字</strong>，一个数据块最大装入<strong>4字</strong></p><blockquote><p>比如：某个处理器16KiB的cache，包含256个数据块，每个数据块16<code>字</code>。地址宽度32位</p></blockquote><p>可以得到：</p><ul><li>组索引位&#x3D;8【256&#x3D;2^8】</li><li>数据块16字，但有16*4&#x3D;64字节【64&#x3D;2^6】，偏移位&#x3D;6</li><li>标志位&#x3D;32-(8+6)&#x3D;18</li></ul><p>所以内存地址划分为：标志18位（31~14位）—-组索引8位（13~6位）—–偏移6位【块内偏移4位（5~2位） 和 字节2位（1~0位）】</p><p>如果数据块按<code>字</code>划分，只有<code>16字</code>，那只需<code>4位</code>偏移即可。但实际上需要<code>多出2位表示一字四字节</code></p><p>​    </p><h2 id="Cache容量计算"><a href="#Cache容量计算" class="headerlink" title="Cache容量计算"></a>Cache容量计算</h2><blockquote><p>公式：<code>总数据块数</code>*（单个数据块容量+标签位+有效位）</p></blockquote><p>【只要有一个数据块，就对应一个对应的有效（valid）位和标签（tag）位】</p><p>例如：假设64位存储地址，使用直接映射【暗示一组一个数据块】，如果数据大小为16KB，每个数据块4字大小，问cache容量多大【用bit表示】</p><p>解：</p><ul><li>求偏移位数b，因为数据块4字【每个字4字节】，所以每个数据块有16Bytes，B&#x3D;16，<code>偏移位数b=4</code></li><li>数据大小为16KB，则需要16KB&#x2F;16&#x3D;<code>1K个数据块</code>，对应S&#x3D;1K，<code>组索引s=10</code></li><li>。。。。。。。。。。。所以标签位<code>t=64-(10+4)=50位</code></li></ul><p>所以根据公式</p><ul><li>sum&#x3D;1K * (16*8 + 50 + 1) &#x3D;179Kb</li></ul><h2 id="地址映射到cache组号"><a href="#地址映射到cache组号" class="headerlink" title="地址映射到cache组号"></a>地址映射到cache组号</h2><blockquote><p>公式：组号 &#x3D;（数据块地址） mod (cache中组数)</p><p>数据块地址 &#x3D; 字节地址&#x2F;数据块字节数</p></blockquote><p>例如：cache有64个组，每数据块大小为16字节，问字节地址为1200的映射到哪个组号？</p><p>先求数据块地址 &#x3D; 1200 &#x2F; 16 &#x3D;75</p><p>再求组号&#x3D; 75 &#x2F; 64</p><hr><h2 id="抖动与冲突不命中"><a href="#抖动与冲突不命中" class="headerlink" title="抖动与冲突不命中"></a>抖动与冲突不命中</h2><p>P431</p><p>Suppose that <strong>floats</strong> are <strong>4 bytes</strong>, that x is loaded into the 32 bytes of contiguous memory starting at address 0, and that y starts immediately after at address 32. For simplicity, suppose that a block is <strong>16 bytes</strong></p><p>the cache consists of <strong>two sets</strong>, each set has one line, for a total cache size of <strong>32 bytes</strong>. We will assume that the variable sum is actually stored in a CPU register and thus does not require a memory reference. Given these assumptions, each x[i] and y[i] will map to the identical cache set</p><p>题目中没说内存地址长度，<strong>假设为16位</strong>，够长~</p><p>其中cache为2组，所以<code>s=1</code>;每个数据块有16字节，所以<code>b=4</code></p><p>若y从地址32开始，这些数组的映射关系如下：</p><p>​     标志Tag   组索引Set   偏移b               标志Tag      组索引Set         偏移b</p><p>x00      00000    y0   1          0     0000<br>x10      00100    y1   1          0     0100<br>x20      01000    y2   1          0     1000<br>x30      01100    y3   1          0     1100</p><p>x40      10000    y4   1          1     0000<br>x50      10100    y5   1          1     0100<br>x60      11000    y6   1          1     1000<br>x70      11100    y7   1          1     1100</p><blockquote><p>很明显，x[0]~x[3]与y[0]~y[3]会对组0进行争抢</p><p>x[0]未命中后，会将x[0]~x[3]都缓存到cache中的<code>组0</code></p><p>接着轮到y[0]，y[0]未命中后，y[0]~y[3]都缓存到cache中<code>组0</code>，这个操作会覆盖原来的x[0]~x[3]；</p><p>接着轮到x[1]，x[1]未命中后，会将x[0]~x[3]都缓存到cache中的<code>组0</code>，又把y[0]~y[3]覆盖了。</p><p>如此反复下去，只会不断的覆盖原来的数据，<code>不会发生命中</code>，这就是<code>抖动</code></p></blockquote><p>解决方法：定义数组x大小不是x[8]而是x[12]，保证让y[i]与x[i]<strong>不同时映射到同一组</strong></p><hr><p>若y从地址48开始，这些数组的映射关系如下：</p><p>​标志Tag    组索引Set    偏移b                标志Tag      组索引Set       偏移b</p><p>x000      00000    y0   01          1      0000<br>x100      00100    y1   01          1      0100<br>x200      01000    y2   01          1      1000<br>x300      01100    y3   01          1      1100</p><p>x400      10000    y4   10          0      0000<br>x500      10100    y5   10          0      0100<br>x600      11000    y6   10          0      1000<br>x700      11100    y7   10          0      1100</p><p>这样的好处是，将x[0]~x[3]与y[0]~y[3]错开，分别使用不同的组，不会因为争抢同一个组而发布抖动</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>P433</p><p>考虑下面代码，它运行在cache形式为(S,E,B,m)&#x3D;(512,1,32,32)【512个组set，每组一行，一个数据块装32字节，内存地址32位】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">4096</span>];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4096</span>;i++)</span><br><span class="line">sum+=arr[i];</span><br></pre></td></tr></table></figure><p>分析这些内存地址如何在cache中分布</p><p>分析：</p><p>因为一个块装32字节，一组一行【一行对应一个数据块】，所以一组装32字节</p><p>int是4字节，所以一组装32&#x2F;4&#x3D;8个int</p><p>所以全部的arr需要4096&#x2F;8&#x3D;512个组</p><p>解：</p><ul><li>块内32字节，对应B&#x3D;32，<strong>b&#x3D;5</strong>【5位二进制可以表示32个】</li><li>一共512个组，对应S&#x3D;512，<strong>s&#x3D;9</strong></li><li>按公式:t&#x3D;m-(b+s)，所以<strong>t&#x3D;32-(5+9)&#x3D;18</strong></li></ul><p>按直接映射格式：tag <code>18位</code>—-set <code>9位</code>—-块内偏移 <code>5位</code></p><p>将内存32位地址按格式划分，得到下面表格</p><table><thead><tr><th>tag位</th><th>set位</th><th>块内偏移</th><th>内存地址</th><th>组号</th><th>arr下标</th></tr></thead><tbody><tr><td>0000……0【18个0】</td><td>0000 0000 0</td><td>0 0000</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0000……0【18个0】</td><td>0000 0000 0</td><td>0 0100</td><td>4</td><td>0</td><td>1</td></tr><tr><td>0000……0【18个0】</td><td>0000 0000 0</td><td>0 1000</td><td>8</td><td>0</td><td>2</td></tr><tr><td>0000……0【18个0】</td><td>0000 0000 0</td><td>0 1100</td><td>12</td><td>0</td><td>3</td></tr><tr><td>0000……0【18个0】</td><td>0000 0000 0</td><td>1 0000</td><td>16</td><td>0</td><td>4</td></tr><tr><td>0000……0【18个0】</td><td>0000 0000 0</td><td>1 0100</td><td>20</td><td>0</td><td>5</td></tr><tr><td>0000……0【18个0】</td><td>0000 0000 0</td><td>1 1000</td><td>24</td><td>0</td><td>6</td></tr><tr><td>0000……0【18个0】</td><td>0000 0000 0</td><td>1 1100</td><td>28</td><td>0</td><td>7</td></tr><tr><td>0000……0【18个0】</td><td>0000 0000 <code>1</code></td><td>0 0000</td><td>32</td><td><code>1</code></td><td>8</td></tr><tr><td>0000……0【18个0】</td><td>0000 0000 <code>1</code></td><td>0 0100</td><td>36</td><td><code>1</code></td><td>9</td></tr><tr><td>0000……0【18个0】</td><td>0000 0000 <code>1</code></td><td>0 1000</td><td>40</td><td><code>1</code></td><td>10</td></tr><tr><td></td><td>…………</td><td>…………</td><td></td><td></td><td></td></tr><tr><td></td><td>…………</td><td>…………</td><td></td><td></td><td></td></tr><tr><td>0000……0【18个0】</td><td><code>1111 1111 1</code></td><td>1 1100</td><td>16380</td><td><code>511</code></td><td><code>4095</code></td></tr></tbody></table><p>可以看到：</p><ul><li>arr[0]~arr[7]属于<code>组0</code></li><li>arr[8]~arr[15]属于<code>组1</code></li><li>…………</li><li>arr[4088]~arr[4095]属于<code>组511</code>【4096*4得到字节地址x，x再除以数据块字节数32，得到数据块地址y，y再 mod 组数512，得到组号511】</li></ul><p>因为512个组刚好可以装完4096个int，所以tag位始终没变化，如果是arr[65536]呢？</p><p>那么从arr[4096]开始tag就要变成1，并且arr[4096]~arr[4103]与arr[0]~arr[7]<strong>共用</strong><code>组号0</code>，他们两波，通过tag来区分</p><table><thead><tr><th>tag</th><th>set</th><th>偏移</th><th>内存地址</th><th>组号</th><th>arr下标</th></tr></thead><tbody><tr><td>0000 0000 0000 0000 0<code>1</code></td><td>0000 0000 0</td><td>0 0000</td><td>16,384</td><td>512</td><td>4096</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="块、行、组"><a href="#块、行、组" class="headerlink" title="块、行、组"></a>块、行、组</h2><ul><li>block，块，是一个<strong>固定大小</strong>的包，用来<strong>上下两层存储器</strong>之间传输数据</li><li>line，行，人为设定的，cache中的一个空串，行存储了：“块”、“有效位”、“标记位”</li><li>set，组，一行或多行的集合。<ul><li>直接映射一组只有一行；在直接映射里面，组可以等价于行</li><li>组相联或全相联，一组有多行；组和行不能乱用</li></ul></li></ul><p>因为行存储了：“块”、“有效位”、“标记位”。 有时某些场合下，在计算cache容量时，往往忽略了“有效位”和“标记位”，把“行”与“块”就等价了【因为真正存储目标数据的只有“块”】</p><h2 id="偏移位、有效位、标志位"><a href="#偏移位、有效位、标志位" class="headerlink" title="偏移位、有效位、标志位"></a>偏移位、有效位、标志位</h2><ul><li>偏移位，block index，看英文名就很清楚了，它是在block里面用来区分不同数据的下标，因为一“块”可以装入多个字节，就需要用下标来指定，数据被装入到块内哪个部分</li><li>有效位，valid ，当刚开机时，所有的valid都设置为0，避免一些脏数据。</li><li>标志位，tag，用来确定要找的目标数据是否在cache的其中一个依据<ul><li>如果是<code>全相联</code>，就<strong>只能</strong>根据<code>标志位</code>判断数据是否在cache中</li><li>如果是<code>直接映射</code>或<code>组相联</code>，先根据<code>组索引号</code>，找到<strong>对应组</strong>，再判断数据是否在<strong>cache的某个组内</strong></li></ul></li></ul><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="按字节、字、双字、半字寻址"><a href="#按字节、字、双字、半字寻址" class="headerlink" title="按字节、字、双字、半字寻址"></a>按字节、字、双字、半字寻址</h3><p><img src="https://cdn.lthero.cn/post_images/course/Cryptography/image-20220702091117905.png" alt="回答时会用到"></p><ol><li><p>机器<code>字长32位</code>，容量为<code>16MB</code>的DRAM存储器，如果cpu按<code>半字</code>寻址，则请问可以寻址的单元数是？</p><ul><li>这题目可以对照着上图，让每个<strong>超单元</strong>大小为<code>半字</code>，也就是<code>2B=16bit</code>，所以<code>16MB</code>的DRAM存储器需要<code>8M*2B</code>，先不管8M中是否分成8片，但<code>超单元总量</code>是<code>8M</code></li><li>所以：答案为8M&#x3D;2^23</li></ul></li><li><p>机器<code>字长64位</code>，容量为<code>128MB</code>的DRAM存储器，如果cpu按<code>字</code>寻址，则请问可以寻址的单元数是？</p><ul><li>和上面一样，每个<strong>超单元</strong>大小为<code>一个字，</code>也就是<code>8B=64bit</code>，所以<code>128MB</code>的DRAM存储器需要<code>16M*8B</code>，所以<code>超单元总量</code>是<code>16M</code></li><li>所以：答案为16M&#x3D;2^24</li></ul></li></ol><p>通俗的解释：</p><p>字长<code>32位</code>，那就是32bit，就是<code>4B</code>。上面说的按<code>字</code>编址，<code>半字</code>编址，<code>双字</code>编址里面的“字”指的就是这个<code>字长</code>。</p><p>（现在假设内存容量为<code>64MB</code>）</p><ol><li><p>假如按<code>字节</code>编址，那么，一个内存<strong>超单元</strong>大小为<code>一个字节</code>，就是<code>1B=8bit</code>;那么<code>64MB</code>的内存空间需要由<code>64M*1B</code>构成</p><ul><li>所以<code>超单元总量</code>为<code>64M</code>&#x3D;2^26</li><li>寻址范围是0~64M-1（此处注意，不是64-1M而是64M减去1），寻址范围的大小是64M；</li></ul></li><li><p>假如按<code>字</code>编址，那么一个内存<strong>超单元</strong>大小为<code>一个字</code>，就是<code>4B=32bit</code>;那么<code>64MB</code>的内存空间需要由<code>16M*4B</code>构成</p><ul><li>所以<code>超单元总量</code>为<code>16M</code>&#x3D;2^24</li><li>其寻址范围是0~16M-1；寻址范围大小是16M；</li></ul></li><li><p>假如按<code>半字</code>编址那就是半个机器字长，就是<code>2B=16bit</code>；</p></li><li><p>假如按<code>双字</code>编址，那就是<code>8B=64bit</code>；</p></li></ol><h2 id="数据寄存器、地址寄存器"><a href="#数据寄存器、地址寄存器" class="headerlink" title="数据寄存器、地址寄存器"></a>数据寄存器、地址寄存器</h2><p>地址寄存器：用来存放cpu取、存内存单元的<code>地址</code></p><p>数据寄存器：用来存放cpu取、存内存单元的<code>数据</code></p><p>地址寄存器位数：就是超单元总量8M&#x2F;64M……</p><p>数据寄存器位数：超单元自身的大小1B&#x2F;2B&#x2F;3B……</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>机器<code>字长32位</code>，容量为<code>16MB</code>的DRAM存储器，如果cpu按<code>半字</code>寻址，问地址寄存器位数、数据寄存器位数？</p><ul><li>这题目可以对照着上图，让每个<strong>超单元</strong>大小为<code>半字</code>，也就是<code>2B=16bit</code>，所以<code>16MB</code>的DRAM存储器需要<code>8M*2B</code>，先不管8M中是否分成8片，但<code>超单元总量</code>是<code>8M</code></li><li>8M&#x3D;2^23，<strong>23位</strong>就是<strong>地址</strong>寄存器位数</li><li>2B&#x3D;16位，<strong>16位</strong>就是<strong>数据</strong>寄存器位数</li></ul><h3 id="再举例"><a href="#再举例" class="headerlink" title="再举例"></a>再举例</h3><p>机器<code>字长64位</code>，容量为<code>128MB</code>的DRAM存储器，如果cpu按<code>字</code>寻址，问地址寄存器位数、数据寄存器位数？</p><ul><li>和上面一样，每个<strong>超单元</strong>大小为<code>一个字，</code>也就是<code>8B=64bit</code>，所以<code>128MB</code>的DRAM存储器需要<code>16M*8B</code>，所以<code>超单元总量</code>是<code>16M</code></li><li>16M&#x3D;2^24，<strong>24位</strong>就是<strong>地址</strong>寄存器位数</li><li>8B&#x3D;64位，<strong>64位</strong>就是<strong>数据</strong>寄存器位数</li></ul><h1 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h1><p>因为DRAM电荷只能维持1~2ms，人为设置2ms为刷新周期，每隔2ms必须刷新一次全部DRAM芯片的全部单元。</p><p>所谓刷新，就是将单元内数据读出，再重新写回到单元内</p><p>其中，刷新操作有集中刷新、分散刷新、异步刷新</p><p>集中刷新：</p><ul><li>设置一个固定的时间段，在这一时间段内，对全部的DRAM同步地将每个DRAM每个单元刷新</li><li>缺点：此时间段cpu无法访问DRAM</li></ul><p>分散刷新：</p><ul><li>每次对<code>某行</code>进行存取操作后，再对<code>这行</code>进行刷新</li><li>缺点：因为刷新本身就是一次存取操作，所以，cpu每次存取数据时，进行一次存取操作，随后的刷新操作又进行了一遍存取操作。增加了整个访问周期</li></ul><p>异步刷新：</p><ul><li>因为整个DRAM每次只能维持2ms，将<code>2ms/行数</code>，可以就是留给<code>一行的刷新时间t</code>，只要<strong>每一行在自己的t时间内</strong>完成<strong>一行的刷新</strong>即可</li></ul><p>目前常用<strong>“异步刷新”</strong>，因为每行刷新时间有限，所以，<strong>刷新操作刻不容缓</strong></p><blockquote><p>因此：“刷新”操作比“读写”操作有更高优先权，因为<strong>刷新操作</strong>是周期性，强制性完成的；而读写操作才是偶然发生的，读写操作只能在某行“非刷新”期间完成</p></blockquote><h2 id="DRAM单元"><a href="#DRAM单元" class="headerlink" title="DRAM单元"></a>DRAM单元</h2><p><img src="https://cdn.lthero.cn/post_images/course/Cryptography/DRAM%E5%8D%95%E5%85%83.jpg" alt="DRAM单元"></p><h2 id="DRAM超单元"><a href="#DRAM超单元" class="headerlink" title="DRAM超单元"></a>DRAM超单元</h2><p><img src="https://cdn.lthero.cn/post_images/course/Cryptography/DRAM%E8%B6%85%E5%8D%95%E5%85%83.jpg" alt="DRAM超单元"></p><p><img src="https://cdn.lthero.cn/post_images/course/Cryptography/DRAM%E8%B6%85%E5%8D%95%E5%85%832.jpg" alt="DRAM超单元2"></p><h2 id="DRAM芯片-chip"><a href="#DRAM芯片-chip" class="headerlink" title="DRAM芯片(chip)"></a>DRAM芯片(chip)</h2><p><img src="https://cdn.lthero.cn/post_images/course/Cryptography/DRAM%E8%8A%AF%E7%89%87(chip).jpg" alt="DRAM芯片(chip)"></p><h2 id="DRAM模块"><a href="#DRAM模块" class="headerlink" title="DRAM模块"></a>DRAM模块</h2><p><img src="https://cdn.lthero.cn/post_images/course/Cryptography/DRAM%E6%A8%A1%E5%9D%97.jpg" alt="DRAM模块"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;直接映射&quot;&gt;&lt;a href=&quot;#直接映射&quot; class=&quot;headerlink&quot; title=&quot;直接映射&quot;&gt;&lt;/a&gt;直接映射&lt;/h1&gt;&lt;h1 id=&quot;直接映射-1&quot;&gt;&lt;a href=&quot;#直接映射-1&quot; class=&quot;headerlink&quot; title=&quot;直接映射&quot;</summary>
      
    
    
    
    <category term="组成原理" scheme="https://blog.lthero.cn/categories/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    <category term="存储器" scheme="https://blog.lthero.cn/categories/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    
    
    <category term="组成原理" scheme="https://blog.lthero.cn/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    <category term="存储器" scheme="https://blog.lthero.cn/tags/%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>【CS-Books】计算机专业书籍下载</title>
    <link href="https://blog.lthero.cn/2022/06/30/CS-Books/"/>
    <id>https://blog.lthero.cn/2022/06/30/CS-Books/</id>
    <published>2022-06-30T10:17:53.000Z</published>
    <updated>2022-07-24T10:18:05.303Z</updated>
    
    <content type="html"><![CDATA[<h1 id="组成原理"><a href="#组成原理" class="headerlink" title="组成原理"></a>组成原理</h1><h2 id="深入理解计算机系统"><a href="#深入理解计算机系统" class="headerlink" title="深入理解计算机系统"></a>深入理解计算机系统</h2><p>中文【全网最高清扫描版本】：「深入理解计算机系统（第三版）.pdf」</p><p><a href="https://www.aliyundrive.com/s/oj13zay3N3G">https://www.aliyundrive.com/s/oj13zay3N3G</a> 提取码: yl37 </p><p>英文【非扫描版本】：「Computer-Systems-A-Progr…-Perspective-3rd.pdf」</p><p><a href="https://www.aliyundrive.com/s/HumKm99wUCn">https://www.aliyundrive.com/s/HumKm99wUCn</a> 提取码: yl37 </p><p>​    </p><h2 id="计算机硬件软件接口"><a href="#计算机硬件软件接口" class="headerlink" title="计算机硬件软件接口"></a>计算机硬件软件接口</h2><p>英文【非扫描版本】「Computer Organization RISC-V edition.pdf」</p><p><a href="https://www.aliyundrive.com/s/9XpduLwcTUj">https://www.aliyundrive.com/s/9XpduLwcTUj</a> 提取码: yl37 </p><p>​     </p><h2 id="代码大全"><a href="#代码大全" class="headerlink" title="代码大全"></a>代码大全</h2><p>中文【高清扫描版本】：「[代码大全2中文版(完整清晰版)].pdf」</p><p><a href="https://www.aliyundrive.com/s/EMYbBhmnSjY">https://www.aliyundrive.com/s/EMYbBhmnSjY</a> 提取码: yl37 </p><hr><p>​    </p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="Unix-amp-Linux大学教程"><a href="#Unix-amp-Linux大学教程" class="headerlink" title="Unix&amp;Linux大学教程"></a>Unix&amp;Linux大学教程</h2><p>英文【非扫描版本】：「HARLEYHAHN’SGUIDETOUNIXANDLINUX.pdf」</p><p><a href="https://www.aliyundrive.com/s/YhvuxCa81nB">https://www.aliyundrive.com/s/YhvuxCa81nB</a> 提取码: yl37 </p><p>​    </p><h2 id="30天自制操作系统"><a href="#30天自制操作系统" class="headerlink" title="30天自制操作系统"></a>30天自制操作系统</h2><p>中文【非扫描版本】：「30天自制操作系统.pdf」</p><p><a href="https://www.aliyundrive.com/s/3edZG3XDYv1">https://www.aliyundrive.com/s/3edZG3XDYv1</a> 提取码: yl37 </p><h2 id="操作系统概念"><a href="#操作系统概念" class="headerlink" title="操作系统概念"></a>操作系统概念</h2><p>英文【非扫描版本】：「Operating System Concept.pdf」</p><p><a href="https://www.aliyundrive.com/s/YP3gFtAqYRS">https://www.aliyundrive.com/s/YP3gFtAqYRS</a> 提取码: yl37 </p><p>​    </p><hr><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="网络是怎样连接的"><a href="#网络是怎样连接的" class="headerlink" title="网络是怎样连接的"></a>网络是怎样连接的</h2><p>中文【非扫描版本】：「614765 网络是怎样连接的_户根勤.pdf」</p><p><a href="https://www.aliyundrive.com/s/NrZerJXLxCp">https://www.aliyundrive.com/s/NrZerJXLxCp</a> 提取码: yl37 </p><h2 id="图解HTTP"><a href="#图解HTTP" class="headerlink" title="图解HTTP"></a>图解HTTP</h2><p>中文【非扫描版本】：「图解HTTP.pdf」</p><p><a href="https://www.aliyundrive.com/s/pmrEQjcE8jQ">https://www.aliyundrive.com/s/pmrEQjcE8jQ</a> 提取码: yl37 </p><h2 id="HTTP权威指南"><a href="#HTTP权威指南" class="headerlink" title="HTTP权威指南"></a>HTTP权威指南</h2><p>中文【非扫描版本】：「HTTP权威指南.pdf」</p><p><a href="https://www.aliyundrive.com/s/31CcCeP2y93">https://www.aliyundrive.com/s/31CcCeP2y93</a> 提取码: yl37 </p><h2 id="TCP-x2F-IP协议详解三部"><a href="#TCP-x2F-IP协议详解三部" class="headerlink" title="TCP&#x2F;IP协议详解三部"></a>TCP&#x2F;IP协议详解三部</h2><p>中文第一版&amp;英文第一版：「TCP&#x2F;IP协议」等文件</p><p><a href="https://www.aliyundrive.com/s/GFZo3WRYMZ5">https://www.aliyundrive.com/s/GFZo3WRYMZ5</a> 提取码: yl37 </p><h2 id="TCP-x2F-IP协议详解【第一版-amp-英文版】"><a href="#TCP-x2F-IP协议详解【第一版-amp-英文版】" class="headerlink" title="TCP&#x2F;IP协议详解【第一版&amp;英文版】"></a>TCP&#x2F;IP协议详解【第一版&amp;英文版】</h2><p>全网稀有的chm版本！外网也不好找，在海盗湾花了一小时下载好的……</p><p><a href="https://ltherocn2.oss-cn-beijing.aliyuncs.com/media/TCP_IP_v1_passwd_123456.zip">https://ltherocn2.oss-cn-beijing.aliyuncs.com/media/TCP_IP_v1_passwd_123456.zip</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;组成原理&quot;&gt;&lt;a href=&quot;#组成原理&quot; class=&quot;headerlink&quot; title=&quot;组成原理&quot;&gt;&lt;/a&gt;组成原理&lt;/h1&gt;&lt;h2 id=&quot;深入理解计算机系统&quot;&gt;&lt;a href=&quot;#深入理解计算机系统&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="分享" scheme="https://blog.lthero.cn/categories/%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="分享" scheme="https://blog.lthero.cn/tags/%E5%88%86%E4%BA%AB/"/>
    
    <category term="计算机书籍" scheme="https://blog.lthero.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
</feed>
