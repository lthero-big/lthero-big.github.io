<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lthero</title>
  
  <subtitle>个人博客</subtitle>
  <link href="https://blog.lthero.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.lthero.cn/"/>
  <updated>2025-09-04T08:31:12.327Z</updated>
  <id>https://blog.lthero.cn/</id>
  
  <author>
    <name>lthero</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCodeCapmusR2Day02数组问题</title>
    <link href="https://blog.lthero.cn/2025/09/04/LeetCodeCapmusR2Day02/"/>
    <id>https://blog.lthero.cn/2025/09/04/LeetCodeCapmusR2Day02/</id>
    <published>2025-09-04T07:18:15.000Z</published>
    <updated>2025-09-04T08:31:12.327Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>还是用双指针解决问题，不过这次用双指针形成个滑动窗口</p><p>看来数组问题用双指针解决还挺常见</p></blockquote><h1 id="209-长度最小的子数组">209. 长度最小的子数组</h1><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">https://leetcode.cn/problems/minimum-size-subarray-sum/</a></p><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p><p>找出该数组中满足其总和大于等于 <code>target</code> 的长度最小的 <strong>子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度**。**如果不存在符合条件的子数组，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 4, nums = [1,4,4]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 11, nums = [1,1,1,1,1,1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= target &lt;= 109</code></li><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 104</code></li></ul><p><strong>进阶：</strong></p><ul><li>如果你已经实现 <code>O(n)</code> 时间复杂度的解法, 请尝试设计一个 <code>O(n log(n))</code> 时间复杂度的解法。</li></ul><h2 id="代码">代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 子数组需要连续</span></span><br><span class="line">        <span class="comment"># 使用双指针，slow指针用于删除元素，fast指针用来添加元素；若添加后的元素让总sumOfnums大于等于target，则可以进行pop（删除），并保持删除后的sum仍大于等于target</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># sumOfnums = sum(nums)</span></span><br><span class="line">        slow = <span class="number">0</span></span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># if sumOfnums &lt; target:</span></span><br><span class="line">        <span class="comment">#     return 0</span></span><br><span class="line"></span><br><span class="line">        newSum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 循环pop</span></span><br><span class="line">        <span class="keyword">for</span> fast <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">            newSum += nums[fast]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> newSum &gt;= target:</span><br><span class="line">                res = <span class="built_in">min</span>(res, fast - slow + <span class="number">1</span>) </span><br><span class="line">                newSum -= nums[slow]</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">                <span class="comment"># newSum在减掉nums[slow]后，不一定会再大于target，不需要再将res-1</span></span><br><span class="line">                <span class="comment"># res -= 1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 通过让res与inf比较，从而得知是否存在长度最小的子数组满足条件，否则就返回0；</span></span><br><span class="line">        <span class="comment"># 这样的好处是不需要对整个数组求和</span></span><br><span class="line">        <span class="keyword">if</span> res != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>):</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h1 id="59-螺旋矩阵-ii">59. 螺旋矩阵 II</h1><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">https://leetcode.cn/problems/spiral-matrix-ii/</a></p><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[[1,2,3],[8,9,4],[7,6,5]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li></ul><h2 id="代码">代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateMatrix</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 一个大循环</span></span><br><span class="line">        <span class="comment"># 包含四个for循环</span></span><br><span class="line"></span><br><span class="line">        loop, mid = n//<span class="number">2</span>, n//<span class="number">2</span>   <span class="comment">#迭代次数，n为奇数时，矩阵的中心点</span></span><br><span class="line">        index = <span class="number">1</span></span><br><span class="line">        startx, starty = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        nums = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> offset <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, loop + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 第一行</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(starty, n - offset):</span><br><span class="line">                nums[startx][i] = index</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 最后一列</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(startx, n - offset):</span><br><span class="line">                nums[j][n - offset] = index</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 最后一行</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - offset, starty, -<span class="number">1</span>):</span><br><span class="line">                nums[n - offset][i] = index </span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 第一列</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n - offset, startx, -<span class="number">1</span>):</span><br><span class="line">                nums[j][starty] = index</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">            startx += <span class="number">1</span></span><br><span class="line">            starty += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">            nums[mid][mid] = index</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">        </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;还是用双指针解决问题，不过这次用双指针形成个滑动窗口&lt;/p&gt;
&lt;p&gt;看来数组问题用双指针解决还挺常见&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;209-长度最小的子数组&quot;&gt;209. 长度最小的子数组&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;ht</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCapmusR2Day01-数组</title>
    <link href="https://blog.lthero.cn/2025/09/03/LeetCodeCapmusR2Day01/"/>
    <id>https://blog.lthero.cn/2025/09/03/LeetCodeCapmusR2Day01/</id>
    <published>2025-09-03T02:49:07.000Z</published>
    <updated>2025-09-04T03:25:58.330Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecapmusr2day01-数组">LeetCodeCapmusR2Day01-数组</h1><blockquote><p>第二轮刷题，期望是包含指定任务题目外添加一些额外题目</p></blockquote><h1 id="704-二分查找">704. 二分查找</h1><p><a href="https://leetcode.cn/problems/binary-search/">https://leetcode.cn/problems/binary-search/</a></p><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果 <code>target</code> 存在返回下标，否则返回 <code>-1</code>。</p><p>你必须编写一个具有 <code>O(log n)</code> 时间复杂度的算法。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="line">输出: 4</span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 2</span><br><span class="line">输出: -1</span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>你可以假设 <code>nums</code> 中的所有元素是不重复的。</li><li><code>n</code> 将在 <code>[1, 10000]</code>之间。</li><li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间。</li></ol><h2 id="代码">代码</h2><ul><li>时间复杂度O(LogN)</li><li>空间复杂度O(1)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        right = L - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="27-移除元素">27. 移除元素</h1><p><a href="https://leetcode.cn/problems/remove-element/">https://leetcode.cn/problems/remove-element/</a></p><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素。元素的顺序可能发生改变。然后返回 <code>nums</code> 中与 <code>val</code> 不同的元素的数量。</p><p>假设 <code>nums</code> 中不等于 <code>val</code> 的元素数量为 <code>k</code>，要通过此题，您需要执行以下操作：</p><ul><li>更改 <code>nums</code> 数组，使 <code>nums</code> 的前 <code>k</code> 个元素包含不等于 <code>val</code> 的元素。<code>nums</code> 的其余元素和 <code>nums</code> 的大小并不重要。</li><li>返回 <code>k</code>。</li></ul><p><strong>用户评测：</strong></p><p>评测机将使用以下代码测试您的解决方案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int[] nums = [...]; // 输入数组</span><br><span class="line">int val = ...; // 要移除的值</span><br><span class="line">int[] expectedNums = [...]; // 长度正确的预期答案。</span><br><span class="line">                            // 它以不等于 val 的值排序。</span><br><span class="line"></span><br><span class="line">int k = removeElement(nums, val); // 调用你的实现</span><br><span class="line"></span><br><span class="line">assert k == expectedNums.length;</span><br><span class="line">sort(nums, 0, k); // 排序 nums 的前 k 个元素</span><br><span class="line">for (int i = 0; i &lt; actualLength; i++) &#123;</span><br><span class="line">    assert nums[i] == expectedNums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果所有的断言都通过，你的解决方案将会 <strong>通过</strong>。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,2,3], val = 3</span><br><span class="line">输出：2, nums = [2,2,_,_]</span><br><span class="line">解释：你的函数函数应该返回 k = 2, 并且 nums 中的前两个元素均为 2。</span><br><span class="line">你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">输出：5, nums = [0,1,4,0,3,_,_,_]</span><br><span class="line">解释：你的函数应该返回 k = 5，并且 nums 中的前五个元素为 0,0,1,3,4。</span><br><span class="line">注意这五个元素可以任意顺序返回。</span><br><span class="line">你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 50</code></li><li><code>0 &lt;= val &lt;= 100</code></li></ul><h2 id="代码">代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 使用双指针</span></span><br><span class="line">        <span class="comment"># slow指针指向可以存放数据的，fast遍历每个元素</span></span><br><span class="line">        slow = <span class="number">0</span></span><br><span class="line">        fast = <span class="number">0</span></span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> fast &lt; L:</span><br><span class="line">            <span class="keyword">if</span> nums[fast] != val:</span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">            fast += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure><h1 id="977-有序数组的平方">977. 有序数组的平方</h1><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">https://leetcode.cn/problems/squares-of-a-sorted-array/</a></p><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-4,-1,0,3,10]</span><br><span class="line">输出：[0,1,9,16,100]</span><br><span class="line">解释：平方后，数组变为 [16,1,0,9,100]</span><br><span class="line">排序后，数组变为 [0,1,9,16,100]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-7,-3,2,3,11]</span><br><span class="line">输出：[4,9,9,49,121]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 已按 <strong>非递减顺序</strong> 排序</li></ul><p><strong>进阶：</strong></p><ul><li>请你设计时间复杂度为 <code>O(n)</code> 的算法解决本问题</li></ul><h2 id="代码">代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(N)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedSquares</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 最大数只能从最左或最右中产生</span></span><br><span class="line">        <span class="comment"># 使用双指针，left从左向右，right从右向左，每次将nums[left] ^ 2 和nums[right] ^ 2中最大的放在末尾</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        right = L - <span class="number">1</span></span><br><span class="line">        res = [<span class="number">0</span>] * L</span><br><span class="line">        n = L - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            numLeftSq = nums[left] ** <span class="number">2</span></span><br><span class="line">            numRightSq = nums[right] ** <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> numLeftSq &lt; numRightSq:</span><br><span class="line">                res[n] = numRightSq</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res[n] = numLeftSq</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="922-按奇偶排序数组-ii">922. 按奇偶排序数组 II</h1><p><a href="https://leetcode.cn/problems/sort-array-by-parity-ii/">https://leetcode.cn/problems/sort-array-by-parity-ii/</a></p><p>给定一个非负整数数组 <code>nums</code>， <code>nums</code> 中一半整数是 <strong>奇数</strong> ，一半整数是 <strong>偶数</strong> 。</p><p>对数组进行排序，以便当 <code>nums[i]</code> 为奇数时，<code>i</code> 也是 <strong>奇数</strong> ；当 <code>nums[i]</code> 为偶数时， <code>i</code> 也是 <strong>偶数</strong> 。</p><p>你可以返回 <em>任何满足上述条件的数组作为答案</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,2,5,7]</span><br><span class="line">输出：[4,5,2,7]</span><br><span class="line">解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,3]</span><br><span class="line">输出：[2,3]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 2 * 104</code></li><li><code>nums.length</code> 是偶数</li><li><code>nums</code> 中一半是偶数</li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li></ul><p>**进阶：**可以不使用额外空间解决问题吗</p><h2 id="代码">代码</h2><ul><li>时间复杂度O(N)</li><li>这里时间复杂度并不是O(n^2)，因为偶数位和奇数位都只操作一次，不是n/2 * n/2的关系，而是n/2 + n/2的关系！</li><li>空间复杂度O(1)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortArrayByParityII</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 使用三指针</span></span><br><span class="line">        <span class="comment"># odd指针记录奇数可以放在的位置</span></span><br><span class="line">        <span class="comment"># i指针用来遍历每个数字</span></span><br><span class="line"></span><br><span class="line">        odd = <span class="number">1</span></span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, L, <span class="number">2</span>):</span><br><span class="line">            <span class="comment"># 偶数位遇到奇数</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 在奇数位找个偶数</span></span><br><span class="line">                <span class="keyword">while</span> nums[odd] % <span class="number">2</span> !=<span class="number">0</span>:</span><br><span class="line">                    odd += <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> nums[odd]!= nums[i]:</span><br><span class="line">                    <span class="comment"># 交换</span></span><br><span class="line">                    nums[odd] ^= nums[i]</span><br><span class="line">                    nums[i] ^= nums[odd]</span><br><span class="line">                    nums[odd] ^= nums[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="35-搜索插入位置">35. 搜索插入位置</h1><p><a href="https://leetcode.cn/problems/search-insert-position/">https://leetcode.cn/problems/search-insert-position/</a></p><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 为 <strong>无重复元素</strong> 的 <strong>升序</strong> 排列数组</li><li><code>-104 &lt;= target &lt;= 104</code></li></ul><h2 id="代码">代码</h2><ul><li>时间复杂度O(logN)</li><li>空间复杂度O(1)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findLeftBorder</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        right = L - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 一旦发现大于或者等于target的num[mid]，那么i就是我们要的结果</span></span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> right + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchInsert</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res = self.findLeftBorder(nums, target)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(res)</span><br></pre></td></tr></table></figure><h1 id="41-缺失的第一个正数">41. 缺失的第一个正数</h1><p><a href="https://leetcode.cn/problems/first-missing-positive/">https://leetcode.cn/problems/first-missing-positive/</a></p><p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p><p>请你实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,0]</span><br><span class="line">输出：3</span><br><span class="line">解释：范围 [1,2] 中的数字都在数组中。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,4,-1,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：1 在数组中，但 2 没有。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [7,8,9,11,12]</span><br><span class="line">输出：1</span><br><span class="line">解释：最小的正数 1 没有出现。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li></ul><h2 id="一般思路">一般思路</h2><p>可以从1开始依次枚举正整数，并且遍历数组；但这样的时间复杂度为O(N^2)，空间复杂度为O(1)；</p><p>当然，可以使用hashtable，将时间复杂度降到O(N)，但空间复杂度会为O(N)；因为hashtable的查找时间是O(1)。<code>我们为什么要使用哈希表？这是因为哈希表是一个可以支持快速查找的数据结构：给定一个元素，我们可以在 *O*(1) 的时间查找该元素是否在哈希表中</code></p><h2 id="进阶思路">进阶思路</h2><p>可以先将数组排序，然后对数据进行遍历，所有0以及负数可以不管，再按正数顺序查找数组中可以达到的不存在的最小正数;</p><p>但这个对数组排序仍然会占用更多空间</p><h2 id="进阶思路代码">进阶思路代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(N) # 对数组排序需要占用空间</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">firstMissingPositive</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 所有0以及负数都可以不管，重复值可以不管</span></span><br><span class="line">        <span class="comment"># 先排序一遍，再按顺序找不存在的数</span></span><br><span class="line">        nums.sort()</span><br><span class="line"></span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 设置个positive，假设从1开始</span></span><br><span class="line">        positive = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 如果遍历到positive则说明最小的正数不是当前值，可以找下一个</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] == positive:</span><br><span class="line">                positive += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 提前退出</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; positive:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> positive</span><br></pre></td></tr></table></figure><h2 id="动脑筋思路">动脑筋思路</h2><p>那是否有什么方法，允许对nums数组进行修改，并且保持O(N)的时间复杂度呢？</p><p>本题目如果是有序的数组，那就很好解决了，但问题就出在<code>现在是无序的</code>；</p><p>下面有个不错的思路：</p><p>题目要求一个长度为N的数组，所以没有出现的最小正整数的范围一定是[1, N + 1]（都是闭区间），我们对数组进行遍历，对于遍历到的数x，如果它在[1, N]范围内，则将数组中的第x - 1位置（因为下标从0开始）打上<code>标记</code>，如果在遍历结果后，所有位置都被打了标记，则说明最小正整数是<strong>N+1</strong>；否则，最小正整数就是<code>没有标记的下标+1</code></p><p>比如n = 6</p><table><thead><tr><th>3</th><th>4</th><th>-1</th><th>1</th><th>9</th><th>-5</th><th>1.将负数变为n+1</th></tr></thead><tbody><tr><td>3</td><td>4</td><td>7</td><td>1</td><td>9</td><td>7</td><td>2.将小于n=6的元素，它对应位置变成负数</td></tr><tr><td>-3</td><td>4</td><td>-7</td><td>-1</td><td>9</td><td>7</td><td>3.返回第一个大于0的下标+1</td></tr></tbody></table><p>注意，这里的第二步：将小于n=6的元素，它对应位置变成负数</p><p>比如第一个元素3，则将nums[3 - 1] = -abs(nums[3 - 1])，那就是将下标为2的原元素7变成1了-7</p><p>比如元素1，则将nums[1 - 1] = -abs(nums[1 - 1])，将下标为0的原元素3变成了-3</p><blockquote><p>也就是说，如果<strong>某个正数在数组里出现了</strong>，那把<strong>这个正数当作下标</strong>，将<strong>下标所在的数字打上标记</strong>（这里是将其值设置为负数）</p><p>比如下图中，缺少<code>正数2</code>，所以下标nums[2 - 1]的数字不会被打上标记！最终我们只要找哪个数字没有标记！它的下标就是我们要找的最小正数</p></blockquote><p>下面这个图看得更清楚</p><p><img src="https://cdn.lthero.cn/post_images/course/MLimage-20250903142618235.png" alt="image-20250903142618235"></p><p><img src="https://assets.leetcode-cn.com/solution-static/41/41_fig1.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecapmusr2day01-数组&quot;&gt;LeetCodeCapmusR2Day01-数组&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;第二轮刷题，期望是包含指定任务题目外添加一些额外题目&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;704-二分查</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay64额外题目</title>
    <link href="https://blog.lthero.cn/2025/08/31/LeetCodeCampsDay64/"/>
    <id>https://blog.lthero.cn/2025/08/31/LeetCodeCampsDay64/</id>
    <published>2025-08-31T07:27:33.000Z</published>
    <updated>2025-09-03T05:18:15.642Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1365-有多少小于当前数字的数字">1365. 有多少小于当前数字的数字</h1><p><a href="https://leetcode.cn/problems/how-many-numbers-are-smaller-than-the-current-number/">https://leetcode.cn/problems/how-many-numbers-are-smaller-than-the-current-number/</a></p><p>给你一个数组 <code>nums</code>，对于其中每个元素 <code>nums[i]</code>，请你统计数组中比它小的所有数字的数目。</p><p>换而言之，对于每个 <code>nums[i]</code> 你必须计算出有效的 <code>j</code> 的数量，其中 <code>j</code> 满足 <code>j != i</code> <strong>且</strong> <code>nums[j] &lt; nums[i]</code> 。</p><p>以数组形式返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [8,1,2,2,3]</span><br><span class="line">输出：[4,0,1,1,3]</span><br><span class="line">解释： </span><br><span class="line">对于 nums[0]=8 存在四个比它小的数字：（1，2，2 和 3）。 </span><br><span class="line">对于 nums[1]=1 不存在比它小的数字。</span><br><span class="line">对于 nums[2]=2 存在一个比它小的数字：（1）。 </span><br><span class="line">对于 nums[3]=2 存在一个比它小的数字：（1）。 </span><br><span class="line">对于 nums[4]=3 存在三个比它小的数字：（1，2 和 2）。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [6,5,4,8]</span><br><span class="line">输出：[2,1,0,3]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [7,7,7,7]</span><br><span class="line">输出：[0,0,0,0]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 500</code></li><li><code>0 &lt;= nums[i] &lt;= 100</code></li></ul><h2 id="代码">代码</h2><ul><li>时间复杂度O(Nlogn)</li><li>空间复杂度O(N)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">quickSort</span>(<span class="params">self, arr: <span class="built_in">list</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        Larr = <span class="built_in">len</span>(arr)</span><br><span class="line">        <span class="keyword">if</span> Larr &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> arr</span><br><span class="line">        pivot = arr[<span class="number">0</span>]</span><br><span class="line">        left = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr[<span class="number">1</span>:] <span class="keyword">if</span> x &lt;= pivot]</span><br><span class="line">        right = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr[<span class="number">1</span>:] <span class="keyword">if</span> x &gt; pivot]</span><br><span class="line">        <span class="keyword">return</span> self.quickSort(left) + [pivot] + self.quickSort(right)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">smallerNumbersThanCurrent</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 先做个排序，排序后的下标数i就是比nums[i]小的个数</span></span><br><span class="line">        <span class="comment"># 使用hash table</span></span><br><span class="line">        numsSorted = self.quickSort(nums)</span><br><span class="line">        Lnums = <span class="built_in">len</span>(numsSorted)</span><br><span class="line">        table = <span class="built_in">dict</span>()</span><br><span class="line">        table[numsSorted[<span class="number">0</span>]] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, Lnums):</span><br><span class="line">            <span class="comment"># 比如1，2，2，3；若遇到相同的两个值，不用进行更新；</span></span><br><span class="line">            <span class="comment"># 或者判断numsSorted[i]是否已经在table里，如果存在，不用进行更新；</span></span><br><span class="line">            <span class="keyword">if</span> numsSorted[i] &gt; numsSorted[i - <span class="number">1</span>]:</span><br><span class="line">                table[numsSorted[i]] = i</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 最后，按原数组的顺序展示结果</span></span><br><span class="line">        res = [<span class="number">0</span>] * Lnums</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, Lnums):</span><br><span class="line">            res[i] = table[nums[i]]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="941-有效的山脉数组">941. 有效的山脉数组</h1><p><a href="https://leetcode.cn/problems/valid-mountain-array/">https://leetcode.cn/problems/valid-mountain-array/</a></p><p>给定一个整数数组 <code>arr</code>，如果它是有效的山脉数组就返回 <code>true</code>，否则返回 <code>false</code>。</p><p>让我们回顾一下，如果 <code>arr</code> 满足下述条件，那么它是一个山脉数组：</p><ul><li><code>arr.length &gt;= 3</code></li><li>在 <code>0 &lt; i &lt; arr.length - 1</code> 条件下，存在 <code>i</code> 使得：<ul><li><code>arr[0] &lt; arr[1] &lt; ... arr[i-1] &lt; arr[i] </code></li><li><code>arr[i] &gt; arr[i+1] &gt; ... &gt; arr[arr.length - 1]</code></li></ul></li></ul><p><img src="https://assets.leetcode.com/uploads/2019/10/20/hint_valid_mountain_array.png" alt="img"></p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [2,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [3,5,5]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [0,3,2,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 104</code></li><li><code>0 &lt;= arr[i] &lt;= 104</code></li></ul><h2 id="思路一">思路一</h2><p>本题目要经过再次循环判断，先判断是否单调递增；再判断是否单调递减；</p><p>先找到假设中的TheMaxIndex递增序列里的最大值，再进行单调递减的判断，最终根据TheMaxIndex是否非头非尾以及index是否遍历完来判断结果</p><h2 id="代码一">代码一</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(1)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">validMountainArray</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        </span><br><span class="line">        TheTop = -<span class="number">1</span></span><br><span class="line">        L = <span class="built_in">len</span>(arr)</span><br><span class="line">        theMaxIndex = <span class="number">0</span></span><br><span class="line">        index = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> index &lt; L <span class="keyword">and</span> arr[theMaxIndex] &lt; arr[index]:</span><br><span class="line">            theMaxIndex = index</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        theMinIndex = theMaxIndex</span><br><span class="line">        <span class="comment"># 此时假设已经找到峰值，后面的数据都必须逐个减少，否则就False</span></span><br><span class="line">        <span class="keyword">while</span> index &lt; L <span class="keyword">and</span> arr[theMinIndex] &gt; arr[index]:</span><br><span class="line">            theMinIndex = index</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> index == L <span class="keyword">and</span> theMaxIndex != <span class="number">0</span> <span class="keyword">and</span> theMaxIndex != L -  <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="思路二">思路二</h2><p>使用二指针，left指针从左向右遍历，判断是否单调递增；right指针从右向左遍历，判断是否单调递减；</p><p>若最终两个指针位置相同，并且非头非尾（!=0且!=L-1），说明才符合要求</p><h2 id="代码二">代码二</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(1)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">validMountainArray</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 双指针，左指针从左向右遍历；右指针从右向左遍历，如果最终在峰值相遇</span></span><br><span class="line">        L = <span class="built_in">len</span>(arr)</span><br><span class="line">        <span class="keyword">if</span> L &lt; <span class="number">3</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = L - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left &lt; L - <span class="number">1</span> <span class="keyword">and</span> arr[left] &lt; arr[left + <span class="number">1</span>]:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> right &gt; <span class="number">0</span> <span class="keyword">and</span> arr[right] &lt; arr[right - <span class="number">1</span>]:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> left == right <span class="keyword">and</span> left !=<span class="number">0</span> <span class="keyword">and</span> right != L - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br></pre></td></tr></table></figure><h1 id="1207-独一无二的出现次数">1207. 独一无二的出现次数</h1><p><a href="https://leetcode.cn/problems/unique-number-of-occurrences/">https://leetcode.cn/problems/unique-number-of-occurrences/</a></p><p>给你一个整数数组 <code>arr</code>，如果每个数的出现次数都是独一无二的，就返回 <code>true</code>；否则返回 <code>false</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [1,2,2,1,1,3]</span><br><span class="line">输出：true</span><br><span class="line">解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [1,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [-3,0,1,-3,1,1,1,-3,10,0]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 1000</code></li><li><code>-1000 &lt;= arr[i] &lt;= 1000</code></li></ul><h2 id="思路">思路</h2><p>回归本题，<strong>本题强调了-1000 &lt;= arr[i] &lt;= 1000</strong>，那么就可以用数组来做哈希，arr[i]作为哈希表（数组）的下标，那么arr[i]可以是负数，怎么办？负数不能做数组下标。</p><p><strong>此时可以定义一个2001大小的数组，例如int count[2001];</strong>，统计的时候，将arr[i]统一加1000，这样就可以统计arr[i]的出现频率了。</p><p>题目中要求的是是否有相同的频率出现，那么需要再定义一个哈希表（数组）用来记录频率是否重复出现过，bool fre[1001]; 定义布尔类型的就可以了，<strong>因为题目中强调1 &lt;= arr.length &lt;= 1000，所以哈希表大小为1000就可以了</strong>。</p><p>如图所示：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML1207.%25E7%258B%25AC%25E4%25B8%2580%25E6%2597%25A0%25E4%25BA%258C%25E7%259A%2584%25E5%2587%25BA%25E7%258E%25B0%25E6%25AC%25A1%25E6%2595%25B0.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/1207.%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0.png" alt="img"></p><h2 id="代码">代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(N)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">uniqueOccurrences</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 使用hashtable</span></span><br><span class="line">        table = <span class="built_in">dict</span>()</span><br><span class="line">        L = <span class="built_in">len</span>(arr)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">            table[arr[i]] = table.get(arr[i], <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 方法一</span></span><br><span class="line">        <span class="comment"># table已经记录了每个数字出现次数，可以再建立个set表，把不重复的次数添加进去</span></span><br><span class="line">        <span class="comment"># res = set()</span></span><br><span class="line">        <span class="comment"># for i in table.values():</span></span><br><span class="line">        <span class="comment">#     res.add(i)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># if len(table) != len(res):</span></span><br><span class="line">        <span class="comment">#     return False</span></span><br><span class="line">        <span class="comment"># return True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line">        <span class="comment"># table已经记录了每个数字出现次数，对次数按顺序排序，如果出现相同的两个值则False</span></span><br><span class="line">        Ltable = <span class="built_in">len</span>(table)</span><br><span class="line">        valuesList = <span class="built_in">sorted</span>(table.values())</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, Ltable):</span><br><span class="line">            <span class="keyword">if</span> valuesList[i - <span class="number">1</span>] == valuesList[i]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h1 id="283-移动零">283. 移动零</h1><p><a href="https://leetcode.cn/problems/move-zeroes/">https://leetcode.cn/problems/move-zeroes/</a></p><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [0]</span><br><span class="line">输出: [0]</span><br></pre></td></tr></table></figure><p><strong>提示</strong>:</p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li></ul><p>**进阶：**你能尽量减少完成的操作次数吗？</p><h2 id="思路">思路</h2><p>使用双指针，slow指向可以放数据的下标，fast用来遍历，如果fast遇到非0则将nums[fast]赋值到nums[slow]；最后将nums[slow:]这个范围内的值赋值为0</p><p>如动画所示：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML283.%25E7%25A7%25BB%25E5%258A%25A8%25E9%259B%25B6.gif" alt="移动零"></p><p><img src="https://file1.kamacoder.com/i/algo/283.%E7%A7%BB%E5%8A%A8%E9%9B%B6.gif" alt="移动零"></p><h2 id="代码">代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">moveZeroes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        slow = <span class="number">0</span></span><br><span class="line">        fast = <span class="number">0</span></span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> fast &lt; L:</span><br><span class="line">            <span class="keyword">if</span> nums[fast] != <span class="number">0</span>:</span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">            fast += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(slow, L):</span><br><span class="line">            nums[i] = <span class="number">0</span></span><br></pre></td></tr></table></figure><h1 id="189-轮转数组">189. 轮转数组</h1><p><a href="https://leetcode.cn/problems/rotate-array/">https://leetcode.cn/problems/rotate-array/</a></p><p>给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3,4,5,6,7], k = 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右轮转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右轮转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右轮转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,-100,3,99], k = 2</span><br><span class="line">输出：[3,99,-1,-100]</span><br><span class="line">解释: </span><br><span class="line">向右轮转 1 步: [99,-1,-100,3]</span><br><span class="line">向右轮转 2 步: [3,99,-1,-100]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li><li><code>0 &lt;= k &lt;= 105</code></li></ul><p><strong>进阶：</strong></p><ul><li>尽可能想出更多的解决方案，至少有 <strong>三种</strong> 不同的方法可以解决这个问题。</li><li>你可以使用空间复杂度为 <code>O(1)</code> 的 <strong>原地</strong> 算法解决这个问题吗？</li></ul><h2 id="数据复制思路">数据复制思路</h2><p>我们遍历原数组，将原数组下标为 <em>i</em> 的元素放至新数组下标为 (<em>i</em>+<em>k</em>)mod<em>n</em> 的位置，最后将新数组拷贝至原数组即可。</p><h2 id="数据复制代码">数据复制代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(N)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        k %= L</span><br><span class="line">        new_nums = [<span class="number">0</span>] * L</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">            new_nums[ (i + k) % L ] = nums[i]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">            nums[i] = new_nums[i]</span><br></pre></td></tr></table></figure><h2 id="数组翻转思路">数组翻转思路</h2><p>该方法基于如下的事实：当我们将数组的元素向右移动 k 次后，尾部 k mod n 个元素会移动至数组头部，其余元素向后移动 k mod n 个位置。</p><p>该方法为数组的翻转：我们可以先将所有元素翻转，这样尾部的 k mod n 个元素就被移至数组头部，然后我们再翻转 [0,k mod n−1] 区间的元素和 [k mod n,n−1] 区间的元素即能得到最后的答案。</p><p>我们以 n=7，k=3 为例进行如下展示：</p><table><thead><tr><th>操作</th><th>结果</th></tr></thead><tbody><tr><td>原始数组</td><td>1 2 3 4 5 6 7</td></tr><tr><td>翻转所有元素</td><td>7 6 5 4 3 2 1</td></tr><tr><td>翻转 [0,k mod n−1] 区间的元素</td><td>5 6 7 4 3 2 1</td></tr><tr><td>翻转 [k mod n,n−1] 区间的元素</td><td>5 6 7 1 2 3 4</td></tr></tbody></table><p>下面为了省事，直接将k = k % n</p><h2 id="数组翻转代码">数组翻转代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(1)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">self, nums: <span class="built_in">list</span></span>):</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        right = L - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            nums[left], nums[right] = nums[right], nums[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 整体反转、前k反转、后n-k反转</span></span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        nums = self.swap(nums)</span><br><span class="line">        k = k % L</span><br><span class="line">        nums[:k] = self.swap(nums[:k])</span><br><span class="line">        nums[k:] = self.swap(nums[k:])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用python自带（但实际使用了O(N)空间</span></span><br><span class="line">        <span class="comment">#nums[:] = nums[-k:] + nums[:-k]</span></span><br></pre></td></tr></table></figure><h1 id="724-寻找数组的中心下标">724. 寻找数组的中心下标</h1><p><a href="https://leetcode.cn/problems/find-pivot-index/">https://leetcode.cn/problems/find-pivot-index/</a></p><p>给你一个整数数组 <code>nums</code> ，请计算数组的 <strong>中心下标</strong> 。</p><p>数组 <strong>中心下标</strong> 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。</p><p>如果中心下标位于数组最左端，那么左侧数之和视为 <code>0</code> ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。</p><p>如果数组有多个中心下标，应该返回 <strong>最靠近左边</strong> 的那一个。如果数组不存在中心下标，返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1, 7, 3, 6, 5, 6]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">中心下标是 3 。</span><br><span class="line">左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，</span><br><span class="line">右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1, 2, 3]</span><br><span class="line">输出：-1</span><br><span class="line">解释：</span><br><span class="line">数组中不存在满足此条件的中心下标。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2, 1, -1]</span><br><span class="line">输出：0</span><br><span class="line">解释：</span><br><span class="line">中心下标是 0 。</span><br><span class="line">左侧数之和 sum = 0 ，（下标 0 左侧不存在元素），</span><br><span class="line">右侧数之和 sum = nums[1] + nums[2] = 1 + -1 = 0 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li></ul><h2 id="思路一">思路一</h2><p>使用两个数组分别从左向右、从右向左计算累加值</p><p>随后，对两个数组判断是否存在一个同一下标i的相同值</p><p>中心下标位置的数字不参加运算</p><p>双指针，left从左向右；right从右向左遍历；同时求和</p><p>0, 1, 8,  11, <code>17</code>, 22, 28</p><p>22, 21, 14, <code>17</code>, 11, 6, 0</p><p>如果遇到下标位置一致且两个数组值一致，则返回这个下标</p><p>0, <code>2</code>, 3, 2</p><p><code>2</code>, 0, -1, 0</p><h2 id="代码一">代码一</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pivotIndex</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        sumFromLeft = [<span class="number">0</span>] * (L + <span class="number">1</span>)</span><br><span class="line">        sumFromRight = [<span class="number">0</span>] * (L + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">            sumFromLeft[i + <span class="number">1</span>] += nums[i] + sumFromLeft[i]</span><br><span class="line">            sumFromRight[L - <span class="number">1</span> - i] += nums[L - <span class="number">1</span> - i] + sumFromRight[L - i]</span><br><span class="line">        </span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = L</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> sumFromLeft[i] == sumFromRight[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> i - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="思路二">思路二</h2><p>先求出数组整体和，再从左向右遍历，实时地计算sumOfLeft以及sumOfRight的和，判断是否相等即可</p><h2 id="代码二">代码二</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(N)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pivotIndex</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        sumOfAll = <span class="built_in">sum</span>(nums)</span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        sumOfLeft = <span class="number">0</span></span><br><span class="line">        sumOfRight = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">            sumOfRight = sumOfAll - sumOfLeft</span><br><span class="line">            sumOfLeft += nums[i]</span><br><span class="line">            <span class="keyword">if</span> sumOfLeft == sumOfRight:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="34-在排序数组中查找元素的第一个和最后一个位置">34. 在排序数组中查找元素的第一个和最后一个位置</h1><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/</a></p><p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p><p>你必须设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出：[3,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [], target = 0</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 105</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>nums</code> 是一个非递减数组</li><li><code>-109 &lt;= target &lt;= 109</code></li></ul><h2 id="思路">思路</h2><p>本题基本指定使用二分查找，基础的二分查找中，仅能查到指定的target，但本题目要求查这个target的区间范围。</p><p>所以，本题目需要划分成查找target的左、右区间边界（即，例如5,7,7,8,8,10，需要找到第一个10作为右边界，以及第二个7作为左边界），所以需要对原二分查找进行修改</p><p>原二分查找的代码如下</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">L = <span class="built_in">len</span>(nums)</span><br><span class="line">left = <span class="number">0</span></span><br><span class="line">right = L - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> left &lt;= right:</span><br><span class="line">    mid = (left + right) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">        left = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">        right = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> mid</span><br></pre></td></tr></table></figure><p>如果要查左边界leftBorder，应该当nums[mid] &gt;= target时，将mid - 1赋值给leftBorder</p><p>比如，5,7,7,8,8,10，当left为3，right为5，mid为4，即nums[mid]为第二个8时，此时满足nums[mid]&gt;=target，则leftBorder就是mid - 1 = 3</p><h2 id="代码">代码</h2><ul><li>时间复杂度O(logN)</li><li>空间复杂度O(N)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchRange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 如果指定logn时间复杂度, 使用递归的方法或二分法</span></span><br><span class="line">        <span class="keyword">if</span> L == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 5,7,7,8,8,10</span></span><br><span class="line">        <span class="comment"># 这里leftBorder找的应该是第二个7的下标</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">findLeftBorder</span>(<span class="params">nums, target</span>):</span><br><span class="line">            L = <span class="built_in">len</span>(nums)</span><br><span class="line">            left = <span class="number">0</span></span><br><span class="line">            right = L - <span class="number">1</span></span><br><span class="line">            leftBorder = -<span class="number">2</span></span><br><span class="line">            <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">                mid = (left + right) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">                    leftBorder = right</span><br><span class="line">            <span class="keyword">return</span> leftBorder</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 5,7,7,8,8,10</span></span><br><span class="line">        <span class="comment"># 这里的rightBorder应该找第一个10的下标</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">findRightBorder</span>(<span class="params">nums, target</span>):</span><br><span class="line">            L = <span class="built_in">len</span>(nums)</span><br><span class="line">            left = <span class="number">0</span></span><br><span class="line">            right = L - <span class="number">1</span></span><br><span class="line">            rightBorder = -<span class="number">2</span></span><br><span class="line">            <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">                mid = (left + right) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt;= target:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                    rightBorder = left</span><br><span class="line">                <span class="keyword">else</span>: </span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> rightBorder</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        leftBorder = findLeftBorder(nums, target)</span><br><span class="line">        rightBorder = findRightBorder(nums, target)</span><br><span class="line">        <span class="comment"># print(leftBorder, rightBorder)</span></span><br><span class="line">        <span class="keyword">if</span> leftBorder == -<span class="number">2</span> <span class="keyword">or</span> rightBorder == -<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">elif</span> leftBorder &lt; rightBorder - <span class="number">1</span>:</span><br><span class="line">          <span class="comment"># </span></span><br><span class="line">            <span class="keyword">return</span> [leftBorder + <span class="number">1</span>, rightBorder - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1365-有多少小于当前数字的数字&quot;&gt;1365. 有多少小于当前数字的数字&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/how-many-numbers-are-smaller-than-the-current-nu</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>软件测试</title>
    <link href="https://blog.lthero.cn/2025/08/29/TestingEngineer/"/>
    <id>https://blog.lthero.cn/2025/08/29/TestingEngineer/</id>
    <published>2025-08-29T13:09:14.000Z</published>
    <updated>2025-09-02T02:07:03.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="day01">Day01</h1><h3 id="认识软件及测试">认识软件及测试</h3><ul><li>什么是软件：控制计算机硬件工作的工具</li><li>什么是软件测试：使用技术手段验证<strong>软件是否满足使用需求</strong></li><li>软件测试目的：<strong>减少软件bug，保障软件质量</strong></li></ul><h3 id="测试主流技能">测试主流技能</h3><ol><li>功能测试</li></ol><ul><li><p>按测试文档的每个用例数据，得到实际结果，与预期结果对比</p></li><li><p>功能测试主要验证程序的功能是否满足需求</p></li></ul><ol start="2"><li>自动化测试</li></ol><ul><li>使用工具或代码执行批量测试输入，最终再生成个报告</li><li>好处是效率更高</li></ul><ol start="3"><li>接口测试</li></ol><ul><li>使用工具或代码对<code>服务端提供的接口测试</code></li></ul><ol start="4"><li>性能测试</li></ol><ul><li>使用工具或代码，模拟多人使用软件，<code>查找服务器缺陷</code></li></ul><h3 id="常见的测试分类7种">常见的测试分类7种</h3><p>一共有7种，可以分成阶段和代码可见度划分两类</p><h4 id="按测试阶段划分">按测试阶段划分</h4><p>有四个阶段</p><ol><li>单元测试</li></ol><p>针对<code>程序源代码</code>进行测试（一般是开发自己做），条件是否判断正确等；</p><ul><li>测每一块砖</li></ul><ol start="2"><li>集成测试</li></ol><p>又叫<strong>接口测试</strong>，针对<code>模块之间访问地址进行测试</code></p><ul><li>测砖与砖之间</li></ul><ol start="3"><li>系统测试</li></ol><p>对整个系统进行测试，<strong>包括功能、非功能（兼容、文档）等测试</strong></p><ol start="4"><li>验收测试</li></ol><p>特殊项目，站在不同视角（内测，alpha测，beta测，灰度测试）</p><p><strong>内测、公测</strong>、使用不同人群来发扬项目缺陷（免费劳动力）</p><h4 id="按代码可见度划分">按代码可见度划分</h4><ol><li>黑盒测试</li></ol><p>源代码不可见，UI功能可见（是系统测试）</p><ol start="2"><li>灰盒测试</li></ol><p>部分源代码可见，UI功能不可见（是集成/接口测试）</p><ol start="3"><li>白盒测试</li></ol><p>全部代码可见，UI功能不可见（还是单元测试）</p><h3 id="模型-质量模型-评价指标">模型-质量模型(评价指标)</h3><p>从哪些角度进行评价</p><p>衡量一个优秀软件的维度</p><p>从<code>功能、性能、兼容、易用、安全</code>等8个指标</p><ol><li>功能</li></ol><p>需求：10个功能、功能详情</p><p>测试：功能数量为10个、功能正确实现（按需求说明书）、错误处理情况（引导性，报错内容）</p><ol start="2"><li>性能</li></ol><p>需求：预估每日在线人数20w</p><p>测试：服务器每秒处理请求数（20w在线服务器需求的处理数）、服务器硬件配置是否满足</p><ol start="3"><li>兼容性</li></ol><p>需求：浏览器、APP可以用</p><p>测试：chrome, edge, ie 几个内核服务器、操作系统(win7, 8, 10, 11, Mac, linux, android)、手机（分辨率、品牌、系统、网络、其它）</p><ol start="4"><li>易用性</li></ol><p>简洁（对比竞品）、友好、流畅、美观，对比竞品</p><ol start="5"><li>可靠性（鲁棒性）</li></ol><p>无响应（无响应）、卡顿（响应慢）、死机（系统崩溃）</p><ol start="6"><li>安全</li></ol><p>信息传输与信息存储，传输加密、存储加密</p><p>比如最近google的数据库泄露，因为密码明文存储</p><ol start="7"><li>可移植性</li></ol><p>网站数据迁移，比如原来预计40w用户，但现在需要扩张到200w，需要将服务器升迁，需要方便数据迁移</p><ol start="8"><li>可维护性</li></ol><p>代码的可维度性，核心代码要分离、有说明（网线打标、不纠缠）</p><h3 id="软件测试流程6步骤">软件测试流程6步骤</h3><blockquote><p>需求评审、计划编写、用例设计、用命执行、缺陷管理、测试报告</p></blockquote><ol><li>需求评审</li></ol><p>让测试和开发都保持<code>一致的需求理解</code>，要知道哪些核心功能（要有优先级）</p><ol start="2"><li>计划编写</li></ol><p>测什么、谁来测、怎么测</p><ol start="3"><li>用例设计</li></ol><p>验证项目是否符合<code>需求的操作文档</code></p><ol start="4"><li>用例执行</li></ol><p>项目模块开发完成开始执行用例文档实施测试</p><ol start="5"><li>缺陷管理</li></ol><p>对缺陷进行管理的过程，这个状态的结束时，bug一定被修复了</p><ol start="6"><li>测试报告</li></ol><p>实施测试结果文档</p><blockquote><p>需求-&gt;计划-&gt;用例设计-&gt;用例执行-&gt;bug管理-&gt;测试报告</p></blockquote><h3 id="测试用例">测试用例</h3><p>什么是用例、什么是测试用例、用例的作用、用例编写格式、用例练习</p><ol><li>什么是用例</li></ol><blockquote><p><strong>用</strong>户使用的案<strong>例</strong>（它是个简称）</p></blockquote><p>是否能开机：打开手机按下电源键3秒钏，看是否能开机</p><p>验证内在：打开手机设置查看内在是否为64G</p><p>验证屏幕：打开手机在白屏背景下检查屏幕是否有黑色点</p><p>检查运行速度：打开手机下载游戏，测试是否流畅</p><ol start="2"><li>什么是测试用例</li></ol><blockquote><p>为测试项目而设计<code>的执行文档</code></p></blockquote><ol start="3"><li>测试用例的作用</li></ol><ul><li>防止漏测（没有执行文档，一定会漏测）</li><li>实施测试的标准</li></ul><ol start="4"><li>用例设计编写格式</li></ol><p>用例编号、用例标题、项目/模块、优先级、前置条件、测试步骤、测试数据、预期结果 一共8个</p><ul><li>用例编号： 项目_模块_编号</li><li>用例标题：预期结果（测试点）</li><li>模块/项目：所属项目或模块</li><li>优先级：用例的重要程序或影响力P0~P4（P0最高），<code>用户频率用得最高的</code>才是核心功能</li><li>前置条件：有哪些前置操作</li><li>测试步骤：描述操作步骤</li><li>测试数据：操作步骤需要用的数据，没有可以为空</li><li>预期结果：期望达到的结果</li></ul><h4 id="练习">练习</h4><p>需求：QQ登录（4条）</p><p>1、账号为空</p><p>2、账号未注册</p><p>3、密码为空</p><p>4、密码错误</p><p>答案</p><table><thead><tr><th>用例编号</th><th>用例标题（预期结果+测试点）</th><th>模块/项目</th><th>优先级</th><th>前置条件</th><th>测试步骤</th><th>测试数据</th><th>预期结果</th></tr></thead><tbody><tr><td>QQ_登录_01</td><td>登录失败（账号为空）</td><td>登录</td><td>P1</td><td>打开登录页面、保持网络正确</td><td>1、输入账号；2、输入密码；3、点击登录</td><td>账号：空；密码：12345</td><td>登录失败，提示账号不可为空</td></tr><tr><td>QQ_登录_02</td><td>登录失败（账号未注册）</td><td>登录</td><td>P1</td><td>打开登录页面、保持网络正确、账号未注册</td><td>1、输入账号；2、输入密码；3、点击登录</td><td>账号：未注册的账号；密码：12345</td><td>登录失败，提示账号不存在</td></tr><tr><td>QQ_登录_03</td><td>登录失败（密码为空）</td><td>登录</td><td>P1</td><td>打开登录页面、保持网络正确、账号已注册</td><td>1、输入账号；2、输入密码；3、点击登录</td><td>账号：已注册的账号；密码：空</td><td>登录失败，提示密码不可为空</td></tr><tr><td>QQ_登录_04</td><td>登录失败（密码错误）</td><td>登录</td><td>P1</td><td>打开登录页面、保持网络正确、账号已注册</td><td>1、输入账号；2、输入密码；3、点击登录</td><td>账号：已注册的账号；密码：1234</td><td>登录失败，提示密码错误</td></tr></tbody></table><p>测试用例写什么？</p><ol><li>能对穷举场景设计测试点</li></ol><p>等价类划分法</p><ol start="2"><li><p>能对限定边界规则设计测试点</p></li><li><p>能对多条件依赖关系进行设计测试</p></li></ol><p>省、市、区的依赖关系</p><ol start="4"><li>能对项目业务进行设计测试点</li></ol><h1 id="day02">Day02</h1><h2 id="学习目标">学习目标</h2><blockquote><ol><li>能对穷举场景设计测试点</li><li>能对限定边界规则设计测试点</li><li>能对多条件依赖关系进行设计测试点</li><li>能对于项目业务进行设计测试点</li></ol></blockquote><p>等价类划分法、边界值分析法、判定表法、场景法可以依次解决上面四个目标</p><h3 id="等价类划分法-类型">等价类划分法(类型)</h3><blockquote><p>定义：在所有测试数据中，具有<code>某种共同特征</code>的数据集合进行划分（按年龄、性别）</p></blockquote><h4 id="分类">分类</h4><p>有效等价类：满足需求的数据集合</p><p>无效等价类：不满足需求的数据集合</p><blockquote><p>从有效取一个，无效里取至少一个（若有效等价类是范围6～8的数字，那无效类有大小6和大于8）</p></blockquote><h4 id="步骤">步骤</h4><ol><li>明确需求</li><li>确定有效和无效等价类</li><li>提取数据编写测试用例</li></ol><h4 id="案例一-长度校验">案例一（长度校验）</h4><ol><li>要求：6～10位自然数</li></ol><p>步骤</p><ol><li>明确需求：6～10位自然数</li><li>划分有效等价和无效等价：有效8位，无效（3位、12位）</li><li>数据编写测试用例：12312312（有效）、123（无效）、123123123123（无效）</li></ol><table><thead><tr><th>用例编号</th><th>用例标题（预期结果+测试点）</th><th>模块/项目</th><th>优先级</th><th>前置条件</th><th>测试步骤</th><th>测试数据</th><th>预期结果</th></tr></thead><tbody><tr><td>QQ_01</td><td>qq合法（8位自然数）</td><td>qq账号</td><td>P0</td><td>打开qq程序</td><td>1、输入账号；2、点击认证</td><td>账号：12312312</td><td>账号合法</td></tr><tr><td>QQ_02</td><td>qq不合法（3位自然数）</td><td>qq账号</td><td>P1</td><td>打开qq程序</td><td>1、输入账号；2、点击认证</td><td>账号：123</td><td>账号不合法</td></tr><tr><td>QQ_03</td><td>qq不合法（12位自然数）</td><td>qq账号</td><td>P1</td><td>打开qq程序</td><td>1、输入账号；2、点击认证</td><td>账号：123123123123</td><td>账号不合法</td></tr></tbody></table><h4 id="案例一-类型校验">案例一（类型校验）</h4><ol><li>要求：6～10位自然数</li></ol><p>步骤</p><ol><li>明确需求：6～10位自然数</li><li>划分有效等价和无效等价：有效8位自然数，无效8位非自然数、为空</li><li>数据编写测试用例：12312312（有效）、123123AB（无效）、空（无效）</li></ol><table><thead><tr><th>用例编号</th><th>用例标题（预期结果+测试点）</th><th>模块/项目</th><th>优先级</th><th>前置条件</th><th>测试步骤</th><th>测试数据</th><th>预期结果</th></tr></thead><tbody><tr><td>QQ_04</td><td>qq不合法（8位自然数）</td><td>qq账号</td><td>P1</td><td>打开qq程序</td><td>1、输入账号；2、点击认证</td><td>账号：123123AB</td><td>账号不合法</td></tr><tr><td>QQ_05</td><td>qq不合法（8位非自然数）</td><td>qq账号</td><td>P1</td><td>打开qq程序</td><td>1、输入账号；2、点击认证</td><td>账号：空</td><td>账号不合法</td></tr></tbody></table><h4 id="案例二">案例二</h4><p>要求：</p><p>区号：空或三位数字</p><p>前缀码：非“0”且非“1”开关的三位数字</p><p>后缀码：四位数字</p><p>步骤</p><ol><li><p>明确需求：<strong>长度、类型、规则</strong></p></li><li><p>划分有效无效：</p></li></ol><table><thead><tr><th>参数</th><th>说明</th><th>有效</th><th>有效数据</th><th>无效</th><th>无效数据</th></tr></thead><tbody><tr><td>区号</td><td>长度</td><td>空、3位数字</td><td>空；123</td><td>非3位数字</td><td>1234</td></tr><tr><td>前缀码</td><td>长度</td><td>3位</td><td>234</td><td>非3位</td><td>23</td></tr><tr><td>后缀码</td><td>长度</td><td>4位</td><td>1234</td><td>非4位</td><td>123</td></tr><tr><td>区号</td><td>类型</td><td>数字</td><td>/</td><td>非数字</td><td>12A</td></tr><tr><td>前缀码</td><td>类型</td><td>数字</td><td>/</td><td>非数字</td><td>23A</td></tr><tr><td>后缀码</td><td>类型</td><td>数字</td><td>/</td><td>非数字</td><td>123A</td></tr><tr><td>区号</td><td>规划</td><td>/</td><td>/</td><td>/</td><td>/</td></tr><tr><td>前缀码</td><td>规划</td><td>非0且非1</td><td>/</td><td>0开头、1开头</td><td>012、123</td></tr><tr><td>后缀码</td><td>规划</td><td>/</td><td>/</td><td>/</td><td>/</td></tr></tbody></table><p>需要10条用例（有效数据2条，无效数据8条）</p><ol start="3"><li>数据编写测试用例</li></ol><table><thead><tr><th>用例编号</th><th>用例标题（预期结果+测试点）</th><th>模块/项目</th><th>优先级</th><th>前置条件</th><th>测试步骤</th><th>测试数据</th><th>预期结果</th></tr></thead><tbody><tr><td>tel_01</td><td>合法（区号为空+其它正确）</td><td>qq账号</td><td>P0</td><td>打开验证程序</td><td>1、输入区号、前缀、后续；2、点击认证</td><td>账号：空；234；1234</td><td>电话合法</td></tr><tr><td>tel_02</td><td>合法（区号3位+其它正确）</td><td>qq账号</td><td>P0</td><td>打开验证程序</td><td>1、输入区号、前缀、后续；2、点击认证</td><td>账号：123；234；1234</td><td>电话合法</td></tr><tr><td>tel_03</td><td>不合法（区号4位+其它正确）</td><td>qq账号</td><td>P1</td><td>打开验证程序</td><td>1、输入区号、前缀、后续；2、点击认证</td><td>账号：1234；234；1234</td><td>电话不合法</td></tr><tr><td>tel_04</td><td>不合法（非0非1前缀2位数字+其它正确）</td><td>qq账号</td><td>P1</td><td>打开验证程序</td><td>1、输入区号、前缀、后续；2、点击认证</td><td>账号：123；23；1234</td><td>电话不合法</td></tr><tr><td>tel_05</td><td>不合法（后缀3位数字+其它正确）</td><td>qq账号</td><td>P1</td><td>打开验证程序</td><td>1、输入区号、前缀、后续；2、点击认证</td><td>账号：123；234；234</td><td>电话不合法</td></tr><tr><td>tel_06</td><td>不合法（区号3位非数字+其它正确）</td><td>qq账号</td><td>P1</td><td>打开验证程序</td><td>1、输入区号、前缀、后续；2、点击认证</td><td>账号：12A；234；1234</td><td>电话不合法</td></tr><tr><td>tel_07</td><td>不合法（前缀为非0且非1开头的非3位数字+其它正确）</td><td>qq账号</td><td>P1</td><td>打开验证程序</td><td>1、输入区号、前缀、后续；2、点击认证</td><td>账号：123；23A；1234</td><td>电话不合法</td></tr><tr><td>tel_08</td><td>不合法（后缀为非4位数字+其它正确）</td><td>qq账号</td><td>P1</td><td>打开验证程序</td><td>1、输入区号、前缀、后续；2、点击认证</td><td>账号：123；234；123A</td><td>电话不合法</td></tr><tr><td>tel_09</td><td>不合法（前缀为0开头3位数字+其它正确）</td><td>qq账号</td><td>P1</td><td>打开验证程序</td><td>1、输入区号、前缀、后续；2、点击认证</td><td>账号：123；012；1234</td><td>电话不合法</td></tr><tr><td>tel_010</td><td>不合法（前缀为1开头3位数字+其它正确）</td><td>qq账号</td><td>P1</td><td>打开验证程序</td><td>1、输入区号、前缀、后续；2、点击认证</td><td>账号：123；123；1234</td><td>电话不合法</td></tr></tbody></table><blockquote><p>重点：</p><ol><li>正向用例：一条尽可能覆盖多条</li><li>逆向用例：每一条数据，都是一条单独用例</li></ol></blockquote><p>这里写个总结，快速地划分等价类，依然用上面的号码判断问题</p><table><thead><tr><th>正向</th><th>逆向</th></tr></thead><tbody><tr><td>空+3位前缀（非0非1）开头+后缀</td><td>四位数字+3位前缀（非0非1）开头+后缀</td></tr><tr><td>三位数字+3位前缀（非0非1）开头+后缀</td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h4 id="适用场景">适用场景</h4><ul><li>需要有大量数据测试输入，但是没法穷举测试的地方<ul><li>输入框</li><li>下拉列表</li><li>单选复选框</li></ul></li><li>典型代表：页面的输入框类测试</li></ul><h3 id="边界值分析法-位数">边界值分析法(位数)</h3><h4 id="边界值说明">边界值说明</h4><blockquote><ul><li>选取正好等于、刚好大于、刚好小于边界的值作为测试数据<ul><li>上点：边界<strong>上的点</strong>（正好等于），<strong>两个点</strong></li><li>离点：距<strong>离</strong>上点最近的<strong>点</strong>（刚好大于，刚好小于），<strong>四个点</strong></li><li>内点：范围<strong>内的点</strong>（区间范围内的数据），内点一般取居中，与离点区分出来，<strong>一个点</strong></li></ul></li></ul><p>按位数的角度，用例最多7条</p></blockquote><h4 id="用例设计步骤">用例设计步骤</h4><ol><li>明确需求</li><li>确定<code>有效和无效等价类</code></li><li>确定<code>边界范围值</code></li><li>提取数据编写测试用例</li></ol><p>提示</p><ol><li>边界值能解决位数限制问题，但无法解决类型问题，所以需要结合等价类</li><li>有关范围限制，最多7条用例（暂时未优化）</li></ol><h4 id="练习一">练习一</h4><p>需求：通过边界值法验证标题长度的合法性</p><p>需求：标题长度大于0，小于等于30个字符</p><ol><li><p>明确需求：标题长度大于0，小于等于30个字符</p></li><li><p>有效、无效等价类（只考虑类型）</p></li></ol><p>有效：长度于[1～30]之间的字符</p><p>无效：长度于[1～30]之间的数字</p><ol start="3"><li>边界范围</li></ol><p>上点：0位和30位</p><p>离点：-1，1位，29位，31位     （因为-1是不可能的长度，可以删除）</p><p>内点：15位</p><p>如果全写一共9条，但-1这条不可能，而有效类和内点重复了，所以一共7条</p><ol start="4"><li>编写测试用例</li></ol><table><thead><tr><th>用例编号</th><th>用例标题（预期结果+测试点）</th><th>模块/项目</th><th>优先级</th><th>前置条件</th><th>测试步骤</th><th>测试数据</th><th>预期结果</th></tr></thead><tbody><tr><td>tel_01</td><td>不合法（标题为15位非字符串）</td><td>标题</td><td>P1</td><td>打开验证程序</td><td>1、输入标题；2、点击认证</td><td>账号：123451234512345</td><td>不合法</td></tr><tr><td>tel_02</td><td>不合法（标题为0位）</td><td>标题</td><td>P1</td><td>打开验证程序</td><td>1、输入标题；2、点击认证</td><td>账号：空</td><td>不合法</td></tr><tr><td>tel_03</td><td>合法（标题为30位字符串）</td><td>标题</td><td>P0</td><td>打开验证程序</td><td>1、输入标题；2、点击认证</td><td>账号：30个字符串</td><td>合法</td></tr><tr><td>tel_04</td><td>合法（标题为1位字符串）</td><td>标题</td><td>P0</td><td>打开验证程序</td><td>1、输入标题；2、点击认证</td><td>账号：A</td><td>合法</td></tr><tr><td>tel_05</td><td>合法（标题为29位字符串）</td><td>标题</td><td>P0</td><td>打开验证程序</td><td>1、输入标题；2、点击认证</td><td>账号：29个字符串</td><td>合法</td></tr><tr><td>tel_06</td><td>不合法（标题为31位字符串）</td><td>标题</td><td>P1</td><td>打开验证程序</td><td>1、输入标题；2、点击认证</td><td>账号：31个字符串</td><td>合法</td></tr><tr><td>tel_07</td><td>合法（标题为15位字符串）</td><td>标题</td><td>P0</td><td>打开验证程序</td><td>1、输入标题；2、点击认证</td><td>账号：15个字符串</td><td>合法</td></tr></tbody></table><h4 id="练习二">练习二</h4><p>需求：通过边界值法验证QQ号码合法性</p><p>要求：6～10位自然数</p><ol><li>明确需求：6～10位自然数</li><li>有效、无效类划分：<ol><li>有效类：6～10位自然数</li><li>无效类：6～10位包含非自然数</li></ol></li><li>边界范围<ol><li>上点：6位自然数、10位自然数</li><li>离点：5位自然数、7位自然数、9位自然数、11位自然数</li><li>内点：8位自然数</li></ol></li><li>编写测试用例</li></ol><table><thead><tr><th>用例编号</th><th>用例标题（预期结果+测试点）</th><th>模块/项目</th><th>优先级</th><th>前置条件</th><th>测试步骤</th><th>测试数据</th><th>预期结果</th></tr></thead><tbody><tr><td>qq_登录_01</td><td>不合法（QQ号为6位非自然数）</td><td>QQ号验证</td><td>P1</td><td>打开验证程序</td><td>1、输入qq号；2、点击认证</td><td>账号：12345A</td><td>不合法</td></tr><tr><td>qq_登录_02</td><td>合法（QQ号为6位自然数）</td><td>QQ号验证</td><td>P0</td><td>打开验证程序</td><td>1、输入qq号；2、点击认证</td><td>账号：123456</td><td>合法</td></tr><tr><td>qq_登录_03</td><td>合法（QQ号为10位自然数）</td><td>QQ号验证</td><td>P0</td><td>打开验证程序</td><td>1、输入qq号；2、点击认证</td><td>账号：1234567890</td><td>合法</td></tr><tr><td>qq_登录_04</td><td>不合法（QQ号为5位自然数）</td><td>QQ号验证</td><td>P1</td><td>打开验证程序</td><td>1、输入qq号；2、点击认证</td><td>账号：12345</td><td>不合法</td></tr><tr><td>qq_登录_05</td><td>合法（QQ号为7位自然数）</td><td>QQ号验证</td><td>P0</td><td>打开验证程序</td><td>1、输入qq号；2、点击认证</td><td>账号：1234567</td><td>合法</td></tr><tr><td>qq_登录_06</td><td>合法（QQ号为9位自然数）</td><td>QQ号验证</td><td>P0</td><td>打开验证程序</td><td>1、输入qq号；2、点击认证</td><td>账号：123456789</td><td>合法</td></tr><tr><td>qq_登录_07</td><td>不合法（QQ号为11位自然数）</td><td>QQ号验证</td><td>P1</td><td>打开验证程序</td><td>1、输入qq号；2、点击认证</td><td>账号：12345678901</td><td>不合法</td></tr><tr><td>qq_登录_08</td><td>合法（QQ号为8位自然数）</td><td>QQ号验证</td><td>P0</td><td>打开验证程序</td><td>1、输入qq号；2、点击认证</td><td>账号：12345678</td><td>合法</td></tr></tbody></table><blockquote><p>上面的用例可以再次优化，有些用例数据在同一个范围内，比如7、8、9中，7和9包含在内点里了，可以不用考虑</p><p>结论：7个可以优化为5个点</p><p><strong>上点：必选（不考虑区间开闭）</strong></p><p><strong>内点：必选（建议选择中间范围）</strong></p><p><strong>离点：开内闭外（考虑开闭区间，开区间选择内部离点，闭区间选择外部离点）</strong></p></blockquote><h4 id="使用场景">使用场景</h4><ul><li>在等价类的基础上针对有边界范围的测试数据输入的地方（重点关注边界）</li><li>常见词语描述：大小、尺寸、重量、最大、最小、至多、至少</li><li>有边界范围的输入框类测试</li></ul><h3 id="判定表法-条件">判定表法(条件)</h3><blockquote><p>针对依赖关系的需求</p></blockquote><h4 id="判定表定义及组成部分">判定表定义及组成部分</h4><ul><li>定义：一种以表格形式表达多条件逻辑判断的工具</li><li>组成：<ul><li>条件桩：列出问题中的所有条件，列出条件的次序不重要</li><li>动作桩：列出问题可能采取的操作，顺序不重要</li><li>条件项：列出问题对应的取值，所有可能情况下的真假值</li><li>动作项：列出条件项的、各种聚会情况下应该采取的动作结果</li></ul></li></ul><table><thead><tr><th>条件</th><th>是否欠费</th><th>是</th><th>是</th><th>否</th><th>否</th></tr></thead><tbody><tr><td></td><td>是否关机</td><td>是</td><td>是</td><td>是</td><td>是</td></tr><tr><td>操作</td><td>是否允许主被叫</td><td>否</td><td>否</td><td>否</td><td>是</td></tr></tbody></table><ul><li>规则：<ul><li>判断表中贯穿条件项和动作项的<code>一列就是一条规则</code></li><li>假设有n个条件，每个条件的聚会有两个(0,1), 全组合有2的n次方种规则</li></ul></li></ul><h4 id="步骤">步骤</h4><ol><li>明确需求</li><li>画出判定表<ol><li>列出条件桩和动作桩</li><li>填写条件项、对条件进行全组合</li><li>根据条件项的组合确定动作项</li><li>简化、合并相似规则（有相同的动作）</li></ol></li><li>根据规则编写测试用例</li></ol><h4 id="练习一">练习一</h4><p>规则：</p><ol><li>如果金额大于500元，又未过期，则发出批准单和提货单</li><li>如果金额大于500元，但过期了，则不发批准单与提货单;</li><li>如果金额小于等于500元，不论是否过期都发出批准单和提货单；</li><li>在过期的情况下不论金额大小还需要发出通知单</li></ol><p>判断表</p><ol><li>条件桩：是否大于500</li><li>条件桩：是否过期</li><li>动作桩：批准单</li><li>动作桩：提货单</li><li>动作桩：通知单</li></ol><table><thead><tr><th>是否大于500</th><th>是</th><th>是</th><th>否</th><th>否</th></tr></thead><tbody><tr><td>是否过期</td><td>是</td><td>否</td><td>是</td><td>否</td></tr><tr><td>批准单</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>提货单</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>通知单</td><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>编写测试用例</p><table><thead><tr><th>用例编号</th><th>用例标题（预期结果+测试点）</th><th>模块/项目</th><th>优先级</th><th>前置条件</th><th>测试步骤</th><th>测试数据</th><th>预期结果</th></tr></thead><tbody><tr><td>order_01</td><td>通知单（大于500，过期）</td><td>订单</td><td>P0</td><td>打开验证程序</td><td>1、输入金额；2、输入是否过期；3、点击验证</td><td>金额：600；过期</td><td>只发通知单</td></tr><tr><td>order_02</td><td>批准单、提货单（大于500，未过期）</td><td>订单</td><td>P0</td><td>打开验证程序</td><td>1、输入金额；2、输入是否过期；3、点击验证</td><td>金额：600；未过期</td><td>只发批准单、提货单</td></tr><tr><td>order_03</td><td>批准单、提货单、通知单（不大于500，过期）</td><td>订单</td><td>P0</td><td>打开验证程序</td><td>1、输入金额；2、输入是否过期；3、点击验证</td><td>金额：400；过期</td><td>只发批准单、提货单、通知单</td></tr><tr><td>order_04</td><td>批准单、提货单（不大于500，未过期）</td><td>订单</td><td>P0</td><td>打开验证程序</td><td>1、输入金额；2、输入是否过期；3、点击验证</td><td>金额：400；未过期</td><td>只发批准单、提货单</td></tr></tbody></table><h4 id="练习二">练习二</h4><p>需求：</p><ol><li>输入的第一列字符必须是A或B</li><li>输入的第二列字符必须是个数字</li><li>如果第一列字符不正确，则给出信息L</li><li>如果第二列字符不正确，则给出信息M</li><li>如果两列字符输入正确，则修改文件成功</li></ol><p>判定表</p><ol><li>条件：第一列是A或B</li><li>条件：第二列是个数字</li><li>动作：输出L</li><li>动作：输出M</li><li>动作：修改文件成功</li></ol><p>对应的判定表如下</p><table><thead><tr><th>第一列是A或B</th><th>是</th><th>是</th><th>否</th><th>否</th></tr></thead><tbody><tr><td>第二列是个数字</td><td>是</td><td>否</td><td>是</td><td>否</td></tr><tr><td>输出L</td><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr><td>输出M</td><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>修改文件成功</td><td>1</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><p>对应的测试用例如下</p><table><thead><tr><th>用例编号</th><th>用例标题（预期结果+测试点）</th><th>模块/项目</th><th>优先级</th><th>前置条件</th><th>测试步骤</th><th>测试数据</th><th>预期结果</th></tr></thead><tbody><tr><td>order_01</td><td>修改文件成功（第一列A第二列数字）</td><td>文件</td><td>P0</td><td>打开验证程序</td><td>1、输入字符串；2、点击验证</td><td>A2</td><td>修改文件成功</td></tr><tr><td>order_02</td><td>输出M（第一列A第二列非数字）</td><td>文件</td><td>P1</td><td>打开验证程序</td><td>1、输入字符串；2、点击验证</td><td>AA</td><td>输出M</td></tr><tr><td>order_03</td><td>输出L（第一列非A非B第二列数字</td><td>文件</td><td>P1</td><td>打开验证程序</td><td>1、输入字符串；2、点击验证</td><td>C2</td><td>输出L</td></tr><tr><td>order_04</td><td>输出L输出M（第一列非A非B第二列非数字）</td><td>文件</td><td>P1</td><td>打开验证程序</td><td>1、输入字符串；2、点击验证</td><td>CC</td><td>输出L输出M</td></tr></tbody></table><h4 id="使用场景">使用场景</h4><ul><li>有多个输入条件，多个输出结果，输入条件之间有组合关系，输入条件和输出结果之间有依赖关系</li><li>判定表一般适用于条件组合数量较少的情况（四个条件以下）</li><li>如果条件太多，比如5个及以上，说明业务设计得有问题，如果一个条件出错其它都会出错，应该要把它拆分开；或者使用<strong>正交法</strong></li></ul><h3 id="场景法">场景法</h3><blockquote><p>如果测试一个项目，先测试“业务”；</p><p>而对<strong>业务测试，使用场景法</strong></p></blockquote><ol><li>需要使用流程图法</li><li>先测试业务，再测试单功能、单模块、单页面</li></ol><h4 id="流程图">流程图</h4><p>业务用例是根据流程图来梳理，需要先了解流程图</p><p>作用：梳理业务用例</p><h4 id="适用场景">适用场景</h4><p>测试业务用例，可以使用场景法</p><h4 id="练习">练习</h4><p>![image-20250830194642361](/Users/lthero/Library/Application Support/typora-user-images/image-20250830194642361.png)</p><p>下面是对应的流程图</p><p>![image-20250830194859755](/Users/lthero/Library/Application Support/typora-user-images/image-20250830194859755.png)</p><p>应该先验证取钱金额再验证账户余额</p><table><thead><tr><th>用例编号</th><th>用例标题（预期结果+测试点）</th><th>模块/项目</th><th>优先级</th><th>前置条件</th><th>测试步骤</th><th>测试数据</th><th>预期结果</th></tr></thead><tbody><tr><td>ATM_01</td><td>取款失败（验证银行卡失败）</td><td>ATM</td><td>P1</td><td>打开验证程序</td><td>1、插入卡</td><td>网卡</td><td>取钱失败；退卡</td></tr><tr><td>ATM_02</td><td>取款失败（密码错误3次）</td><td>ATM</td><td>P1</td><td>打开验证程序</td><td>1、插入卡；2、密码错误</td><td>银行卡、非银行卡密码</td><td>吞卡</td></tr><tr><td>ATM_03</td><td>取款失败（取钱金额不正确）</td><td>ATM</td><td>P1</td><td>打开验证程序；</td><td>1、插入卡；2、密码正确；3、输入金额</td><td>银行卡、银行卡密码、金额</td><td>取钱失败；退卡</td></tr><tr><td>ATM_04</td><td>取款失败（账户余额不足）</td><td>ATM</td><td>P1</td><td>打开验证程序；卡余额为0</td><td>1、插入卡；2、密码正确；3、输入金额</td><td>银行卡、银行卡密码、金额1</td><td>取钱失败；退卡</td></tr><tr><td>ATM_05</td><td>取款失败（ATM余额不足）</td><td>ATM</td><td>P1</td><td>打开验证程序；卡余额充足；ATM余额为0</td><td>1、插入卡；2、密码正确；3、输入金额</td><td>银行卡、银行卡密码、金额100</td><td>提示故障</td></tr><tr><td>ATM_06</td><td>取款成功</td><td>ATM</td><td>P0</td><td>打开验证程序；卡余额充足；ATM余额为充足</td><td>1、插入卡；2、密码正确；3、输入金额</td><td>银行卡、银行卡密码、金额100</td><td>提取成功</td></tr></tbody></table><h3 id="错误推荐法">错误推荐法</h3><blockquote><p>定义：通过经验推测系统可能出现的问题</p><p>根据经验列举可能出现问题的清单，根据清单分析分析可能的原因</p></blockquote><h4 id="场景">场景</h4><ol><li>间紧任务量大时，根据之前项目类似经验找出易出错的模块重点测试</li><li>实践宽裕通过该方法列出之前出现问题较多的模块再次测试</li></ol><p>当所有用例都测试完了，bug都修复完了，如果此时离上线还有几个小时，此时使用错误推荐法，不要根据用例执行，使用经验来覆盖那些未测试到的功能和业务</p><p>先确定最核心的业务，把测试点列出来，先验证核心业务再测试功能测试单元测试等</p><h1 id="day03">Day03</h1><h2 id="学习目标">学习目标</h2><blockquote><ol><li>说出软件缺陷判定标准</li><li>说出项目中缺陷的管理流程</li><li>使用Excel对于缺陷进行管理</li><li>使用工具管理缺陷</li></ol></blockquote><h2 id="缺陷的定义">缺陷的定义</h2><p>软件在使用过程中存在的任何问题，都可以叫软件的缺陷，bug</p><h2 id="缺陷的判定标准">缺陷的判定标准</h2><p>软件未实现需求（规格）说明书中明确要求的功能-<strong>少功能</strong></p><p>软件实现的功能超出需求（规格）说明书指明的范围-<strong>多功能</strong></p><p>软件出现了需求（规格）说明书中<code>指明不应该出现 </code>的错误-<strong>显性功能错误</strong></p><p>软件未实现需求（规格）说明书中<code>虽未明确指明但应该实现 </code>的要求-<strong>隐性功能错误</strong></p><p>如果测试人员认为软件难以理解，不易使用，运行缓慢，用户体验不好，都为缺陷-<strong>不易使用</strong></p><h2 id="缺陷产生的原因">缺陷产生的原因</h2><blockquote><p>一个软件开发需要经过<strong>需求-&gt;设计-&gt;编码-&gt;运行-&gt;上线</strong>几个过程，而每个过程都可能出现<strong>错误或缺陷</strong></p></blockquote><ol><li>需求阶段：<strong>需求描述</strong>不易理解、有歧义、错误（项目</li><li>设计阶段：<strong>设计文档</strong>存在错误或缺陷（架构师</li><li>编码阶段：<strong>代码</strong>出现错误</li><li>运行阶段：<strong>软件</strong>、<strong>硬件</strong>系统本身故障导致</li></ol><h2 id="软件缺陷的生命周期">软件缺陷的生命周期</h2><p>![image-20250831105419860](/Users/lthero/Library/Application Support/typora-user-images/image-20250831105419860.png)</p><blockquote><p>在故障解决时，解决了A缺陷，可能会引发新的B/C缺陷，所以在故障解决里会引入其它缺陷</p></blockquote><p>发现bug后，按<code>故障分类-&gt;故障隔离-&gt;故障解决</code>对缺陷进行清除</p><h2 id="缺陷的核心内容">缺陷的核心内容</h2><blockquote><p>重点：</p><p>缺陷的描述：发现缺陷后，如何描述，让别人看懂（缺陷标题、条件、复现步骤）</p><p>缺陷的提交：指派人、优先级、类型等</p></blockquote><p>包含：<strong>缺陷的标题、缺陷的预置条件、缺陷的复现步骤、缺陷的预期结果、缺陷的实际结果、缺陷的必要附件</strong></p><h2 id="缺陷提交要素">缺陷提交要素</h2><p>![image-20250831110817935](/Users/lthero/Library/Application Support/typora-user-images/image-20250831110817935.png)</p><p>严重程度：表示问题严重程度，严重（主功能、核心业务受到影响）</p><p>优先级：主要是解决时间的区别；严重问题一天内解决，如果是一些建议性问题（严重程度低的）可以推迟下个版本解决</p><p>状态：New新缺陷；Open表示开发已经接管；Closed缺陷已经完成</p><h2 id="缺陷类型">缺陷类型</h2><p>![image-20250831111045539](/Users/lthero/Library/Application Support/typora-user-images/image-20250831111045539.png)</p><p>其中<code>功能错误、UI错误、兼容性问题</code> 是最重要的三个</p><h3 id="工程流程">工程流程</h3><p>设计用例-&gt;执行用例(执行测试)-&gt;缺陷（提交、验证、关闭）</p><p>缺陷定义：任何问题(Bug)</p><p>缺陷标准：多功能、少功能、显示功能错误、隐性功能错误、易用性</p><p>描述缺陷重点：缺陷标题、前置条件、复现步骤、预期结果、实际结果、附件备注</p><p>提交缺陷信息：指派人、缺陷编号、缺陷严重程序（严重、一般、建议）、优先级、缺陷类型</p><h2 id="练习">练习</h2><p>测试一个注册页面</p><p>![image-20250831132001319](/Users/lthero/Library/Application Support/typora-user-images/image-20250831132001319.png)</p><p>下面就是对这个测试页面进行的分析</p><p><img src="/Users/lthero/Documents/Master/%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/%E5%9B%BE/%E7%BB%83%E4%B9%A0-%E6%B5%8B%E8%AF%95%E6%B3%A8%E5%86%8C%E9%A1%B5%E9%9D%A2.png" alt="练习-测试注册页面"></p><h2 id="缺陷编写">缺陷编写</h2><h3 id="缺陷的跟踪流程">缺陷的跟踪流程</h3><p>![image-20250831140114482](/Users/lthero/Library/Application Support/typora-user-images/image-20250831140114482.png)</p><p>这里的<strong>黄色</strong>部分是<strong>测试</strong>；而<strong>绿色</strong>部分是<strong>开发</strong>人员</p><h3 id="提交缺陷注意事项">提交缺陷注意事项</h3><p>可重现：缺陷可以复现</p><p>规范性：符合公司或项目要求</p><p>唯一性：一个缺陷只上报一个问题</p><blockquote><p>问题：当你发现缺陷后，首先会怎么办？</p><p>回答：<strong>确定缺陷可以复现</strong>，以及确定是否为bug（是否有偶然性）</p></blockquote><h2 id="缺陷编写规范">缺陷编写规范</h2><p>准确：描述信息正确</p><p>具体：有细节且真实特定</p><p>简洁易懂：描述简单容量理解</p><p>次序清晰：描述缺陷过程有条件，有先后顺序</p><h1 id="day04">Day04</h1><h2 id="缺陷管理工具">缺陷管理工具</h2><p>下面是软件开发不同岗位的职责</p><p>![image-20250831141324215](/Users/lthero/Library/Application Support/typora-user-images/image-20250831141324215.png)</p><p>![image-20250831141513427](/Users/lthero/Library/Application Support/typora-user-images/image-20250831141513427.png)</p><ol><li>可以使用excel或项目管理工具（禅道，JIRA）</li></ol><h2 id="练习">练习</h2><p>![image-20250831201337869](/Users/lthero/Library/Application Support/typora-user-images/image-20250831201337869.png)</p><p>![image-20250831201350946](/Users/lthero/Library/Application Support/typora-user-images/image-20250831201350946.png)</p><p>分析需求、提取测试点、设计用例、用例评审、执行用例、缺陷管理、测试报告</p><p><img src="/Users/lthero/Documents/Master/%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/%E5%9B%BE/%E7%BB%83%E4%B9%A0-%E6%B5%8B%E8%AF%95%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2.png" alt="练习-测试登录页面"></p><h3 id="登录功能用例实现">登录功能用例实现</h3><table><thead><tr><th>用例编号</th><th>用例标题</th><th>项目/模块</th><th>优先级</th><th>前置条件</th><th>测试步骤</th><th>测试数据</th><th>预期结果</th></tr></thead><tbody><tr><td>qq_login_001</td><td>登录成功</td><td>登录</td><td>P0</td><td>1.打开登录页面；2.手机号已经注册</td><td>1.输入测试手机号；2.点击发送验证码；3.点击滑块按钮；4.拖动滑块；5.输入验证码；6.勾选协议；7.点击登录</td><td>1. 手机号：注册手机号；2.验证码：正确</td><td>登录成功，跳转到个人主页；手机号文本框失去焦点，变绿色</td></tr><tr><td>qq_login_002</td><td>登录失败（手机号为空）</td><td>登录</td><td>P1</td><td>1.打开登录页面；</td><td>1.输入测试手机号；2.点击发送验证码；3.拖动滑块；4.输入验证码；5.勾选协议；6.点击登录</td><td>1. 手机号：空；2.验证码：1234</td><td>登录失败：提示手机号不能为空；手机号文本框推动焦点，变红；滑块按钮不可点</td></tr><tr><td>qq_login_003</td><td>登录失败（手机号11位非自然数</td><td>登录</td><td>P1</td><td>1.打开登录页面；</td><td>1.输入测试手机号；2.点击发送验证码；3.拖动滑块；4.输入验证码；5.勾选协议；6.点击登录</td><td>1. 手机号：1350000111A；2.验证码：1234</td><td>登录失败：提示输入正确手机号；手机号文本框推动焦点，变红；滑块按钮不可点</td></tr><tr><td>qq_login_004</td><td>登录失败（手机号10位自然数</td><td>登录</td><td>P1</td><td>1.打开登录页面；</td><td>1.输入测试手机号；2.点击发送验证码；3.拖动滑块；4.输入验证码；5.勾选协议；6.点击登录</td><td>1. 手机号：135000111A；2.验证码：1234</td><td>登录失败：提示手机号未注册；手机号文本框推动焦点，变红；滑块按钮不可点</td></tr><tr><td>qq_login_005</td><td>登录失败（手机号12位自然数</td><td>登录</td><td>P1</td><td>1.打开登录页面；</td><td>1.输入测试手机号；2.点击发送验证码；3.拖动滑块；4.输入验证码；5.勾选协议；6.点击登录</td><td>1. 手机号：13500000111A；2.验证码：1234</td><td>登录失败：提示手机号未注册；手机号文本框推动焦点，变红；滑块按钮不可点</td></tr><tr><td>qq_login_006</td><td>登录失败（手机号未注册</td><td>登录</td><td>P1</td><td>1.打开登录页面；</td><td>1.输入测试手机号；2.点击发送验证码；3.点击滑块按钮；4.拖动滑块；5.输入验证码；6.勾选协议；7.点击登录</td><td>1. 手机号：1350000111；2.验证码：1234</td><td>登录失败：提示手机号未注册；手机号文本框推动焦点，变红；滑块按钮不可点</td></tr><tr><td>qq_login_007</td><td>登录失败（验证码为空</td><td>登录</td><td>P1</td><td>1.打开登录页面；</td><td>1.输入测试手机号；2.点击发送验证码；3.点击滑块按钮；4.拖动滑块；5.输入验证码；6.勾选协议；7.点击登录</td><td>1. 手机号：1350000111；2.验证码：</td><td>登录失败：提示验证码为空；手机号文本框推动焦点，变红；滑块按钮不可点</td></tr><tr><td>qq_login_008</td><td>登录失败（验证码为错误</td><td>登录</td><td>P1</td><td>1.打开登录页面；</td><td>1.输入测试手机号；2.点击发送验证码；3.点击滑块按钮；4.拖动滑块；5.输入验证码；6.勾选协议；7.点击登录</td><td>1. 手机号：1350000111；2.验证码：AAxx（错误）</td><td>登录失败：提示验证码错误；手机号文本框推动焦点，变绿；滑块按钮不可点</td></tr><tr><td>qq_login_009</td><td>登录失败（验证码为过期</td><td>登录</td><td>P1</td><td>1.打开登录页面；2.验证码超时</td><td>1.输入测试手机号；2.点击发送验证码；3.点击滑块按钮；4.拖动滑块；5.输入验证码；6.勾选协议；7.点击登录</td><td>1. 手机号：1350000111；2.验证码：AAxx（错误）</td><td>登录失败：提示验证码错误；手机号文本框推动焦点，变绿；滑块按钮不可点</td></tr><tr><td>qq_login_010</td><td>登录失败（未同意协议</td><td>登录</td><td>P1</td><td>1.打开登录页面；</td><td>1.输入测试手机号；2.点击发送验证码；3.点击滑块按钮；4.拖动滑块；5.输入验证码；6.不勾选协议；7.点击登录</td><td>1. 手机号：注册手机号；2.验证码：正确；3.不勾选协议</td><td>登录失败：提示请勾选协议；手机号文本框推动焦点，变绿；滑块按钮不可点</td></tr></tbody></table><h3 id="登录非功能用例实现">登录非功能用例实现</h3><table><thead><tr><th>用例编号</th><th>用例标题</th><th>项目/模块</th><th>优先级</th><th>前置条件</th><th>测试步骤</th><th>测试数据</th><th>预期结果</th></tr></thead><tbody><tr><td>qq_login_0011</td><td>显示和功能正常</td><td>登录</td><td>P2</td><td>1.安装Chrome;2使用Chrome打开登录页面</td><td>1.查看登录页面显示不正常；2.登录成功</td><td>1.显示与UI；1. 手机号：注册手机号；2.验证码：正确</td><td>1.显示正常；2.登录成功，跳转到个人主页；手机号文本框失去焦点，变绿色</td></tr><tr><td>qq_login_0012</td><td>显示和功能正常</td><td>登录</td><td>P2</td><td>1.安装FireFox;2使用FireFox打开登录页面</td><td>1.查看登录页面显示不正常；2.登录成功</td><td>1.显示与UI；1. 手机号：注册手机号；2.验证码：正确</td><td>1.显示正常；2.登录成功，跳转到个人主页；手机号文本框失去焦点，变绿色</td></tr></tbody></table><p>后面重复测试其它浏览器</p><table><thead><tr><th>用例编号</th><th>用例标题</th><th>项目/模块</th><th>优先级</th><th>前置条件</th><th>测试步骤</th><th>测试数据</th><th>预期结果</th></tr></thead><tbody><tr><td>qq_login_0016</td><td>显示与UI一致（布局）</td><td>登录</td><td>P3</td><td>1.打开登录页面；2.打开UI原型图</td><td>1.检查页面布局；</td><td>1.产品原型布局数据</td><td>1.页面与原型UI一致</td></tr><tr><td>qq_login_0017</td><td>显示与UI一致（图片与文字）</td><td>登录</td><td>P3</td><td>1.打开登录页面；2.打开UI原型图</td><td>1.检查页面图片与文字</td><td>1.产品原型布局数据</td><td>1.页面与真实数据一致，无错字</td></tr></tbody></table><p>滑块用例</p><table><thead><tr><th>用例编号</th><th>用例标题</th><th>项目/模块</th><th>优先级</th><th>前置条件</th><th>测试步骤</th><th>测试数据</th><th>预期结果</th></tr></thead><tbody><tr><td>qq_login_0018</td><td>发送验证码成功（滑动到指定位置）</td><td>滑块</td><td>P0</td><td>1.打开滑块界面</td><td>拖动滑块到指定空缺位置</td><td>手机号，正确手机号</td><td>发送验证码成功</td></tr><tr><td>qq_login_0019</td><td>发送验证码成功（1次未滑动到指定位置）</td><td>滑块</td><td>P1</td><td>1.打开滑块界面</td><td>拖动滑块1次未到指定空缺位置</td><td>手机号，正确手机号</td><td>验证码获取失败，滑块抖动效果，回到初始位置</td></tr><tr><td>qq_login_0020</td><td>发送验证码成功（3次未滑动到指定位置）</td><td>滑块</td><td>P1</td><td>1.打开滑块界面</td><td>拖动滑块3次未到指定空缺位置</td><td>手机号，正确手机号</td><td>验证码获取失败，滑块抖动效果，回到初始位置</td></tr><tr><td>qq_login_0021</td><td>发送验证码成功（5次未滑动到指定位置）</td><td>滑块</td><td>P1</td><td>1.打开滑块界面</td><td>拖动滑块5次未到指定空缺位置</td><td>手机号，正确手机号</td><td>验证码获取失败，滑块抖动效果，回到初始位置</td></tr><tr><td>qq_login_0022</td><td>发送验证码成功（错误达6次重试）</td><td>滑块</td><td>P1</td><td>1.打开滑块界面</td><td>拖动滑块6次未到指定空缺位置</td><td>手机号，正确手机号</td><td>验证码获取失败，滑块抖动效果，错误达6次重试</td></tr></tbody></table><ol><li>按用户的字段：不同用户是否显示正常1，2，3，</li><li>按功能的个数分页是否正常，每页固定多少个，超页是否显示，</li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;day01&quot;&gt;Day01&lt;/h1&gt;
&lt;h3 id=&quot;认识软件及测试&quot;&gt;认识软件及测试&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;什么是软件：控制计算机硬件工作的工具&lt;/li&gt;
&lt;li&gt;什么是软件测试：使用技术手段验证&lt;strong&gt;软件是否满足使用需求&lt;/strong&gt;&lt;/li</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay62图论part11</title>
    <link href="https://blog.lthero.cn/2025/08/26/LeetCodeCampsDay62/"/>
    <id>https://blog.lthero.cn/2025/08/26/LeetCodeCampsDay62/</id>
    <published>2025-08-26T12:58:50.000Z</published>
    <updated>2025-08-27T11:45:45.290Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday62图论part11">LeetCodeCampsDay62图论part11</h1><blockquote><p>Floyd算法与A*算法</p></blockquote><h1 id="97-小明逛公园">97.小明逛公园</h1><p>题目描述</p><p>小明喜欢去公园散步，公园内布置了许多的景点，相互之间通过小路连接，小明希望在观看景点的同时，能够节省体力，走最短的路径。</p><p>给定一个公园景点图，图中有 N 个景点（编号为 1 到 N），以及 M 条双向道路连接着这些景点。每条道路上行走的距离都是已知的。</p><p>小明有 Q 个观景计划，每个计划都有一个起点 start 和一个终点 end，表示他想从景点 start 前往景点 end。由于小明希望节省体力，他想知道每个观景计划中从起点到终点的最短路径长度。 请你帮助小明计算出每个观景计划的最短路径长度。</p><p>输入描述</p><p>第一行包含两个整数 N, M, 分别表示景点的数量和道路的数量。</p><p>接下来的 M 行，每行包含三个整数 u, v, w，表示景点 u 和景点 v 之间有一条长度为 w 的双向道路。</p><p>接下里的一行包含一个整数 Q，表示观景计划的数量。</p><p>接下来的 Q 行，每行包含两个整数 start, end，表示一个观景计划的起点和终点。</p><p>输出描述</p><p>对于每个观景计划，输出一行表示从起点到终点的最短路径长度。如果两个景点之间不存在路径，则输出 -1。</p><p>输入示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">7 3</span><br><span class="line">2 3 4</span><br><span class="line">3 6 6</span><br><span class="line">4 7 8</span><br><span class="line">2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure><p>输出示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">-1</span><br></pre></td></tr></table></figure><p>提示信息</p><p>从 2 到 3 的路径长度为 4，3 到 4 之间并没有道路。</p><p>1 &lt;= N, M, Q &lt;= 1000.</p><p>1 &lt;= w &lt;= 10000.</p><h2 id="floyd思路">Floyd思路</h2><p>在这之前我们讲解过，dijkstra朴素版、dijkstra堆优化、Bellman算法、Bellman队列优化（SPFA） 都是单源最短路，即只能有一个起点。</p><p>而本题是多源最短路，即 求多个起点到多个终点的多条最短路径。</p><p><strong>Floyd 算法对边的权值正负没有要求，都可以处理</strong>。</p><p>Floyd的核心思想是动态规划</p><p>例如我们再求节点1 到 节点9 的最短距离，用二维数组来表示即：grid[1][9]，如果最短距离是10 ，那就是 grid[1][9] = 10。</p><p>那 节点1 到 节点9 的最短距离 是不是可以由 节点1 到节点5的最短距离 + 节点5到节点9的最短距离组成呢？</p><p>即 grid[1][9] = grid[1][5] + grid[5][9]</p><p>节点1 到节点5的最短距离 是不是可以有 节点1 到 节点3的最短距离 + 节点3 到 节点5 的最短距离组成呢？</p><p>即 grid[1][5] = grid[1][3] + grid[3][5]</p><p>以此类推，节点1 到 节点3的最短距离 可以由更小的区间组成。</p><p>节点1 到 节点9 的最短距离 可以由 节点1 到节点5的最短距离 + 节点5到节点9的最短距离组成， 也可以有 节点1 到节点7的最短距离 + 节点7 到节点9的最短距离的距离组成。</p><p>选择其中最小的一个即可</p><p>之前在讲解动态规划的时候，给出过动规五部曲：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul><ol><li>dp数组下标与含义</li></ol><p>grid[i][j][k] = m，表示 <strong>节点i 到 节点j 以[1…k] 集合中的一个节点为中间节点的最短距离为m</strong>。</p><p>节点i 到 节点j 的最短距离为m，这句话可以理解，但 以[1…k]集合为中间节点就理解不了。</p><p>节点i 到 节点j 的最短路径中 一定是经过很多节点，那么这个集合用[1…k] 来表示。</p><p>反过来想，节点i 到 节点j 中间一定经过很多节点，那么你能用什么方式来表述中间这么多节点呢？</p><p>所以 这里的k不能单独指某个节点，k 一定要表示一个集合，即[1…k] ，表示节点1 到 节点k 一共k个节点的集合。</p><p>后续可以优化成二维数组，到时可能更方便理解</p><ol start="2"><li>递推公式</li></ol><p>我们分两种情况：</p><ol><li>节点i 到 节点j 的最短路径经过节点k</li><li>节点i 到 节点j 的最短路径不经过节点k</li></ol><ul><li>对于第一种情况，<code>grid[i][j][k] = grid[i][k][k - 1] + grid[k][j][k - 1]</code></li></ul><p>节点i 到 节点k 的最短距离 是不经过节点k，中间节点集合为[1…k-1]，所以 表示为<code>grid[i][k][k - 1]</code></p><p>节点k 到 节点j 的最短距离 也是不经过节点k，中间节点集合为[1…k-1]，所以表示为 <code>grid[k][j][k - 1]</code></p><ul><li>第二种情况，<code>grid[i][j][k] = grid[i][j][k - 1]</code></li></ul><p>如果节点i 到 节点j的最短距离 不经过节点k，那么 中间节点集合[1…k-1]，表示为 <code>grid[i][j][k - 1]</code></p><p>因为我们是求最短路，对于这两种情况自然是取最小值。</p><ul><li>即： <code>grid[i][j][k] = min(grid[i][k][k - 1] + grid[k][j][k - 1]， grid[i][j][k - 1])</code></li></ul><ol start="3"><li>dp初始化</li></ol><p>grid[i][j][k] = m，表示 节点i 到 节点j 以[1…k] 集合为中间节点的最短距离为m。</p><p>刚开始初始化k 是不确定的。</p><p>例如题目中只是输入边（节点2 -&gt; 节点6，权值为3），那么grid[2][6][k] = 3，k需要填什么呢？</p><p>把k 填成1，那如何上来就知道 节点2 经过节点1 到达节点6的最短距离是多少 呢。</p><p>所以 <strong>只能 把k 赋值为 0，本题 节点0 是无意义的，节点是从1 到 n。</strong></p><p>这样我们在下一轮计算的时候，就可以根据 grid[i][j][0] 来计算 grid[i][j][1]，此时的 grid[i][j][1] 就是 节点i 经过节点1 到达 节点j 的最小距离了</p><p>grid数组是一个三维数组，那么我们初始化的数据在 i 与 j 构成的平层，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240425104247.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240425104247.png" alt="img"></p><p>红色的 底部一层是我们初始化好的数据，注意：从三维角度去看初始化的数据很重要，下面我们在聊遍历顺序的时候还会再讲。</p><p>所以初始化代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">grid</span>(n + <span class="number">1</span>, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">10005</span>)));  <span class="comment">// C++定义了一个三位数组，10005是因为边的最大距离是10^4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">    cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;</span><br><span class="line">    grid[p1][p2][<span class="number">0</span>] = val;</span><br><span class="line">    grid[p2][p1][<span class="number">0</span>] = val; <span class="comment">// 注意这里是双向图</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>grid数组中其他元素数值应该初始化多少呢？</p><p>本题求的是最小值，所以输入数据没有涉及到的节点的情况都应该初始为一个最大数。</p><p>这样才不会影响，每次计算去最小值的时候 初始值对计算结果的影响。</p><p>所以grid数组的定义可以是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++写法，定义了一个三位数组，10005是因为边的最大距离是10^4</span></span><br><span class="line">vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">grid</span>(n + <span class="number">1</span>, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">10005</span>)));  </span><br></pre></td></tr></table></figure><ol start="4"><li>遍历顺序</li></ol><p>从递推公式：<code>grid[i][j][k] = min(grid[i][k][k - 1] + grid[k][j][k - 1]， grid[i][j][k - 1])</code> 可以看出，我们需要三个for循环，分别遍历i，j 和k</p><p>而 k 依赖于 k - 1， i 和j 的到 并不依赖与 i - 1 或者 j - 1 等等。</p><p>那么这三个for的嵌套顺序应该是什么样的呢？</p><p>我们来看初始化，我们是把 k =0 的 i 和j 对应的数值都初始化了，这样才能去计算 k = 1 的时候 i 和 j 对应的数值。</p><p>这就好比是一个三维坐标，i 和j 是平层，而k 是 垂直向上 的。</p><p>遍历的顺序是从底向上 一层一层去遍历。</p><p>所以遍历k 的for循环一定是在最外面，这样才能一层一层去遍历。如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240424120109.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240424120109.png" alt="img"></p><p>至于遍历 i 和 j 的话，for 循环的先后顺序无所谓。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            grid[i][j][k] = <span class="built_in">min</span>(grid[i][j][k<span class="number">-1</span>], grid[i][k][k<span class="number">-1</span>] + grid[k][j][k<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基于三维数组的floyd">基于三维数组的Floyd</h2><ul><li>时间复杂度： O(n^3)</li><li>空间复杂度：O(n^2)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">    graph = [[[<span class="number">10005</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)] </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        u, v, w = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        graph[u][v][<span class="number">0</span>] = w</span><br><span class="line">        graph[v][u][<span class="number">0</span>] = w</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                graph[i][j][k] = <span class="built_in">min</span>(graph[i][j][k - <span class="number">1</span>], graph[i][k][k - <span class="number">1</span>] + graph[k][j][k - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    q = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(q):</span><br><span class="line">        s, t = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        <span class="built_in">print</span>(graph[s][t][n] <span class="keyword">if</span> graph[s][t][n] != <span class="number">10005</span> <span class="keyword">else</span> -<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="空间优化">空间优化</h2><p>这里 我们可以做一下 空间上的优化，从滚动数组的角度来看，我们定义一个 grid[n + 1][ n + 1][2] 这么大的数组就可以，因为k 只是依赖于 k-1的状态，并不需要记录k-2，k-3，k-4 等等这些状态。</p><p>那么我们只需要记录 grid[i][j][1] 和 grid[i][j][0] 就好，之后就是 grid[i][j][1] 和 grid[i][j][0] 交替滚动。</p><p>再进一步想，如果本层计算（本层计算即k相同，从三维角度来讲） gird[i][j] 用到了 本层中刚计算好的 grid[i][k] 会有什么问题吗？</p><p>如果 本层刚计算好的 grid[i][k] 比上一层 （即k-1层）计算的 grid[i][k] 小，说明确实有 i 到 k 的更短路径，那么基于 更小的 grid[i][k] 去计算 gird[i][j] 没有问题。</p><p>如果 本层刚计算好的 grid[i][k] 比上一层 （即k-1层）计算的 grid[i][k] 大， 这不可能，因为这样也不会做更新 grid[i][k]的操作。</p><p>所以本层计算中，使用了本层计算过的 grid[i][k] 和 grid[k][j] 是没问题的。</p><p>那么就没必要区分，grid[i][k] 和 grid[k][j] 是 属于 k - 1 层的呢，还是 k 层的。</p><p>所以递归公式可以为：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grid[i][j] = <span class="built_in">min</span>(grid[i][j], grid[i][k] + grid[k][j]);</span><br></pre></td></tr></table></figure><h2 id="基于二维数组的floyd">基于二维数组的Floyd</h2><ul><li>时间复杂度： O(n^3)</li><li>空间复杂度：O(n^2)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">    graph = [[<span class="number">10005</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)] </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        u, v, w = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        graph[u][v] = w</span><br><span class="line">        graph[v][u] = w</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                graph[i][j] = <span class="built_in">min</span>(graph[i][j], graph[i][k] + graph[k][j])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    q = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(q):</span><br><span class="line">        s, t = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        <span class="built_in">print</span>(graph[s][t] <span class="keyword">if</span> graph[s][t] != <span class="number">10005</span> <span class="keyword">else</span> -<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="把k不放在最外层遍历是否可以？">把k不放在最外层遍历是否可以？</h2><p>难道 遍历k 放在最里层就不行吗？</p><p>k 放在最里层，代码是这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">            grid[i][j][k] = <span class="built_in">min</span>(grid[i][j][k<span class="number">-1</span>], grid[i][k][k<span class="number">-1</span>] + grid[k][j][k<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时就遍历了 j 与 k 形成一个平面，i 则是纵面，那遍历 就是这样的：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240424115827.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240424115827.png" alt="img"></p><p>而我们初始化的数据 是 k 为0， i 和 j 形成的平面做初始化，如果以 k 和 j 形成的平面去一层一层遍历，就造成了 递推公式 用不上上一轮计算的结果，从而导致结果不对（初始化的部分是 i 与j 形成的平面，在初始部分有讲过）。</p><p>我再给大家举一个测试用例</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">5 4</span><br><span class="line">1 2 10</span><br><span class="line">1 3 1</span><br><span class="line">3 4 1</span><br><span class="line">4 2 1</span><br><span class="line">1</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure><p>就是图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240424120942.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240424120942.png" alt="img"></p><p>求节点1 到 节点 2 的最短距离，运行结果是 10 ，但正确的结果很明显是3。</p><p>为什么呢？</p><p>因为 k 放在最里面，先就把 节点1 和 节点 2 的最短距离就确定了，后面再也不会计算节点 1 和 节点 2的距离，同时也不会基于 初始化或者之前计算过的结果来计算，即：不会考虑 节点1 到 节点3， 节点3 到节点 4，节点4到节点2 的距离。</p><p>造成这一原因，是 在三维立体坐标中， 我们初始化的是 i 和 i 在k 为0 所构成的平面，但遍历的时候 是以 j 和 k构成的平面以 i 为垂直方向去层次遍历。</p><p>而遍历k 的for循环如果放在中间呢，同样是 j 与k 行程一个平面，i 是纵面，遍历的也是这样：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240424115827-20250827174035639.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240424115827.png" alt="img"></p><p>同样不能完全用上初始化 和 上一层计算的结果。</p><p>根据这个情况再举一个例子：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5 2</span><br><span class="line">1 2 1</span><br><span class="line">2 3 10</span><br><span class="line">1</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure><p>图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240425112636.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240425112636.png" alt="img"></p><p>求 节点1 到节点3 的最短距离，如果k循环放中间，程序的运行结果是 -1，也就是不能到达节点3。</p><p>在计算 grid[i][j][k] 的时候，需要基于 grid[i][k][k-1] 和 grid[k][j][k-1]的数值。</p><p>也就是 计算 grid[1][3][2] （表示节点1 到 节点3，经过节点2） 的时候，需要基于 grid[1][2][1] 和 grid[2][3][1]的数值，而 我们初始化，只初始化了 k为0 的那一层。</p><p>造成这一原因 依然是 在三维立体坐标中， 我们初始化的是 i 和 j 在k 为0 所构成的平面，但遍历的时候 是以 j 和 k构成的平面以 i 为垂直方向去层次遍历。</p><p>很多录友对于 floyd算法的遍历顺序搞不懂，<strong>其实 是没有从三维的角度去思考</strong>，同时我把三维立体图给大家画出来，遍历顺序标出来，大家就很容易想明白，为什么 k 放在最外层 才能用上 初始化和上一轮计算的结果了。</p><h1 id="127-骑士的攻击">127.骑士的攻击</h1><p>题目描述</p><p>在象棋中，马和象的移动规则分别是“马走日”和“象走田”。现给定骑士的起始坐标和目标坐标，要求根据骑士的移动规则，计算从起点到达目标点所需的最短步数。</p><p>棋盘大小 1000 x 1000（棋盘的 x 和 y 坐标均在 [1, 1000] 区间内，包含边界）</p><p>输入描述</p><p>第一行包含一个整数 n，表示测试用例的数量，1 &lt;= n &lt;= 100。</p><p>接下来的 n 行，每行包含四个整数 a1, a2, b1, b2，分别表示骑士的起始位置 (a1, a2) 和目标位置 (b1, b2)。</p><p>输出描述</p><p>输出共 n 行，每行输出一个整数，表示骑士从起点到目标点的最短路径长度。</p><p>输入示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">5 2 5 4</span><br><span class="line">1 1 2 2</span><br><span class="line">1 1 8 8</span><br><span class="line">1 1 8 7</span><br><span class="line">2 1 3 3</span><br><span class="line">4 6 4 6</span><br></pre></td></tr></table></figure><p>输出示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>提示信息</p><p>骑士移动规则如图，红色是起始位置，黄色是骑士可以走的地方。</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20240626104833.png" alt="img"></p><h2 id="astrar思路">Astrar思路</h2><p>Astar 是一种 广搜的改良版。 有的是 Astar是 dijkstra 的改良版。</p><p>其实只是场景不同而已 我们在搜索最短路的时候， 如果是无权图（边的权值都是1） 那就用广搜，代码简洁，时间效率和 dijkstra 差不多 （具体要取决于图的稠密）</p><p>如果是有权图（边有不同的权值），优先考虑 dijkstra。</p><p>而 Astar 关键在于 启发式函数， 也就是 影响 广搜或者 dijkstra 从 容器（队列）里取元素的优先顺序。</p><p>以下，我用BFS版本的A * 来进行讲解。</p><p>在BFS中，我们想搜索，从起点到终点的最短路径，要一层一层去遍历。</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240611143712.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240611143712.png" alt="img"></p><p>如果 使用A * 的话，其搜索过程是这样的，如图，图中着色的都是我们要遍历的点。</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240611195223.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240611195223.png" alt="img"></p><p>（上面两图中 最短路长度都是8，只是走的方式不同而已）</p><p>大家可以发现 <strong>BFS 是没有目的性的 一圈一圈去搜索， 而 A * 是有方向性的去搜索</strong>。</p><p>看出 A * 可以节省很多没有必要的遍历步骤。</p><p>为了让大家可以明显看到区别，我将 BFS 和 A * 制作成可视化动图，大家可以自己看看动图，效果更好。</p><p>地址：<a href="https://kamacoder.com/tools/knight.html">https://kamacoder.com/tools/knight.html</a></p><p>那么 A * 为什么可以有方向性的去搜索，它的如何知道方向呢？</p><p><strong>其关键在于 启发式函数</strong>。</p><p>那么启发式函数落实到代码处，如果指引搜索的方向？</p><p>在本篇开篇中给出了BFS代码，指引 搜索的方向的关键代码在这里：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="type">int</span> n=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br></pre></td></tr></table></figure><p>从队列里取出什么元素，接下来就是从哪里开始搜索。</p><p><strong>所以 启发式函数 要影响的就是队列里元素的排序</strong>！</p><p>这是影响BFS搜索方向的关键。</p><p>对队列里节点进行排序，就需要给每一个节点权值，如何计算权值呢？</p><blockquote><p>每个节点的权值为F，给出公式为：F = G + H</p><p>G：起点达到目前遍历节点的距离</p><p>H：目前遍历的节点到达终点的距离</p><p>起点达到目前遍历节点的距离 + 目前遍历的节点到达终点的距离 就是起点到达终点的距离。</p></blockquote><p>本题的图是无权网格状，在计算两点距离通常有如下三种计算方式：</p><ol><li>曼哈顿距离，计算方式： d = abs(x1-x2)+abs(y1-y2)</li><li>欧氏距离（欧拉距离） ，计算方式：d = sqrt( (x1-x2)^2 + (y1-y2)^2 )</li><li>切比雪夫距离，计算方式：d = max(abs(x1 - x2), abs(y1 - y2))</li></ol><p>x1, x2 为起点坐标，y1, y2 为终点坐标 ，abs 为求绝对值，sqrt 为求开根号，</p><p>选择哪一种距离计算方式 也会导致 A * 算法的结果不同。</p><p>本题，采用欧拉距离才能最大程度体现 点与点之间的距离。</p><p>所以 使用欧拉距离计算 和 广搜搜出来的最短路的节点数是一样的。 （路径可能不同，但路径上的节点数是相同的）</p><p>我在制作动画演示的过程中，分别给出了曼哈顿、欧拉以及契比雪夫 三种计算方式下，A * 算法的寻路过程，大家可以自己看看看其区别。</p><p>动画地址：<a href="https://kamacoder.com/tools/knight.html">https://kamacoder.com/tools/knight.html</a></p><p>计算出来 F 之后，按照 F 的 大小，来选去出队列的节点。</p><p>可以使用 优先级队列 帮我们排好序，每次出队列，就是F最小的节点。</p><p>实现代码如下：（启发式函数 采用 欧拉距离计算方式）</p><h2 id="代码">代码</h2><p>A * 算法的时间复杂度 其实是不好去量化的，因为他取决于 启发式函数怎么写。</p><p>最坏情况下，A * 退化成广搜，算法的时间复杂度 是 O(n * 2)，n 为节点数量。</p><p>最佳情况，是从起点直接到终点，时间复杂度为 O(dlogd)，d 为起点到终点的深度。</p><p>因为在搜索的过程中也需要堆排序，所以是 O(dlogd)。</p><p>实际上 A * 的时间复杂度是介于 最优 和最坏 情况之间， 可以 非常粗略的认为 A * 算法的时间复杂度是 O(nlogn) ，n 为节点数量。</p><p>A * 算法的空间复杂度 O(b ^ d) ,d 为起点到终点的深度，b 是 图中节点间的连接数量，本题因为是无权网格图，所以 节点间连接数量为 4。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">moves = [(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">1</span>), (-<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, -<span class="number">1</span>,), (<span class="number">1</span>, -<span class="number">2</span>), (-<span class="number">2</span>, <span class="number">1</span>), (-<span class="number">1</span>, -<span class="number">2</span>), (-<span class="number">2</span>, -<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算两点之间的距离</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">distance</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> ((a[<span class="number">0</span>] - b[<span class="number">0</span>]) ** <span class="number">2</span> + (a[<span class="number">1</span>] - b[<span class="number">1</span>]) ** <span class="number">2</span>) ** <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">start, end</span>):</span><br><span class="line">    q = [(distance(start, end), start)]</span><br><span class="line"></span><br><span class="line">    step = &#123;start: <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        d, cur = heapq.heappop(q)</span><br><span class="line">        <span class="keyword">if</span> cur == end:</span><br><span class="line">            <span class="keyword">return</span> step[cur]</span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> moves:</span><br><span class="line">            nextx = cur[<span class="number">0</span>] + i</span><br><span class="line">            nexty = cur[<span class="number">1</span>] + j</span><br><span class="line">            <span class="keyword">if</span> <span class="number">1</span> &lt;= nextx &lt;= <span class="number">1000</span> <span class="keyword">and</span> <span class="number">1</span> &lt;= nexty &lt;= <span class="number">1000</span>:</span><br><span class="line">                <span class="comment"># </span></span><br><span class="line">                step_new = step[cur] + <span class="number">1</span></span><br><span class="line">                new = (nextx, nexty)</span><br><span class="line">                <span class="keyword">if</span> step_new &lt; step.get(new, <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)):</span><br><span class="line">                    step[new] = step_new</span><br><span class="line">                    <span class="comment"># 将走new这个节点添加到堆，并进行排序</span></span><br><span class="line">                    heapq.heappush(q, (distance(new, end) + step_new, new))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        a1, a2, b1, b2 = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        <span class="built_in">print</span>(bfs((a1, a2), (b1, b2)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday62图论part11&quot;&gt;LeetCodeCampsDay62图论part11&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Floyd算法与A*算法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;97-小明逛公园&quot;&gt;97.小明逛公</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay63总结</title>
    <link href="https://blog.lthero.cn/2025/08/26/LeetCodeCampsDay63/"/>
    <id>https://blog.lthero.cn/2025/08/26/LeetCodeCampsDay63/</id>
    <published>2025-08-26T12:52:00.000Z</published>
    <updated>2025-08-26T13:01:13.094Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday63总结">LeetCodeCampsDay63总结</h1><blockquote><p>训练营让我系统地、由浅入深地学了一遍算法知识并刷题目巩固知识，让我有了不小的进步！虽然以前也学过算法并做过笔记，但通常是不成体系、不系统化、不全面的，往往是看看别人代码，AC后就不管了，缺少了反思与总结的过程。此外，我从未有过如此常态化、持久化的算法学习，这两个月每天写打卡、写博客（我的博客数量从每月写几篇到每月30篇哈哈），让我也有养成了一定的生活规律，而且每一篇博客都见证了我的每一进步！更重要的是，与大家一起打卡，也让我有坚持下去的动力！“一个人可以走得很快，但一群人可以走得更远”！感谢同期的所有朋友，大家都是最棒的！祝各位前程似锦！！！</p></blockquote><h1 id="任务清单">任务清单</h1><p>● day 1 任务以及具体安排：<a href="https://docs.qq.com/doc/DUG9UR2ZUc3BjRUdY">第一章  数组part01 </a>（6.25）</p><p>● day 2 任务以及具体安排：<a href="https://docs.qq.com/doc/DUGRwWXNOVEpyaVpG">第一章  数组part02 </a> （6.26）</p><p>● day 3 任务以及具体安排：<a href="https://docs.qq.com/doc/DUGdqYWNYeGhlaVR6">第二章 链表part01</a>（6.27）</p><p>● day 4 任务以及具体安排：<a href="https://docs.qq.com/doc/DUFNjYUxYRHRVWklp">第二章 链表part02</a>（6.28）</p><p>● day5 周末休息（6.29）</p><p>● day 6 任务以及具体安排：<a href="https://docs.qq.com/doc/DUEtFSGdreWRuR2p4">第三章 哈希表part01</a>（6.30）</p><p>● day 7 任务以及具体安排：<a href="https://docs.qq.com/doc/DUElCb1NyTVpXa0Jj">第三章 哈希表part02 </a>（7.1）</p><p>● day 8 任务以及具体安排：<a href="https://docs.qq.com/doc/DUGdsY2JFaFhDRVZH">第四章 字符串part01</a>（7.2）</p><p>● day 9 任务以及具体安排：<a href="https://docs.qq.com/doc/DUHVXSnZNaXpVUHN4">第四章 字符串part02</a>（7.3）</p><p>● day 10 任务以及具体安排：<a href="https://docs.qq.com/doc/DUElqeHh3cndDbW1Q">第五章 栈与队列part01</a>（7.4）</p><p>● day 11 任务以及具体安排：<a href="https://docs.qq.com/doc/DUHh6UE5hUUZOZUd0">第五章 栈与队列part02</a>（7.5）</p><p>● day12 周末休息（7.6）</p><p>● day 13任务以及具体安排：<a href="https://docs.qq.com/doc/DUHRtdXZZSWFkeGdE">第六章 二叉树part01</a>（7.7）</p><p>● day 14 任务以及具体安排：<a href="https://docs.qq.com/doc/DUHN0ZVJuRmVYeWNv">第六章  二叉树 part02</a>（7.8）</p><p>● day 15 任务以及具体安排：<a href="https://docs.qq.com/doc/DUHBQRm1aSWR4T2NK">第六章  二叉树part03</a>（7.9）</p><p>● day 16 任务以及具体安排：<a href="https://docs.qq.com/doc/DUFFiVHl3YVlReVlr">第六章 二叉树 part04</a>（7.10）</p><p>● day 17任务以及具体安排：<a href="https://docs.qq.com/doc/DUGFRU2V6Z1F4alBH">第六章 二叉树part05</a>（7.11）</p><p>● day 18 任务以及具体安排：<a href="https://docs.qq.com/doc/DUHl2SGNvZmxqZm1X">第六章 二叉树part06</a>（7.12）</p><p>● day19 周末休息（7.13）</p><p>● day 20 任务以及具体安排：<a href="https://docs.qq.com/doc/DUHplVUp5YnN1bnBL">第六章 二叉树part07</a>（7.14）</p><p>● day 21 任务以及具体安排：<a href="https://docs.qq.com/doc/DUFBUQmxpQU1pa29C">第六章 二叉树part08</a>（7.15）</p><p>● day 22 任务以及具体安排：<a href="https://docs.qq.com/doc/DUEhsb0pUUm1WT2NP">第七章 回溯算法part01</a>（7.16）</p><p>● day 23 任务以及具体安排：<a href="https://docs.qq.com/doc/DUExTYXVzU1BiU2Zl">第七章 回溯算法part02</a>（7.17）</p><p>● day 24 任务以及具体安排：<a href="https://docs.qq.com/doc/DUElpbnNUR3hIbXlY">第七章 回溯算法part03</a>（7.18）</p><p>● day 25 任务以及具体安排：<a href="https://docs.qq.com/doc/DUG1yVHdlWEdNYlhZ">第七章 回溯算法part04</a>（7.19）</p><p>● day 26 周末休息（7.20）</p><p>● day 27 任务以及具体安排：<a href="https://docs.qq.com/doc/DUG1PQ1ZZY2xXY1ly">第八章 贪心算法 part01</a>（7.21）</p><p>● day 28 任务以及具体安排：<a href="https://docs.qq.com/doc/DUGFEdGFWeVhleFF1">第八章 贪心算法 part02</a>（7.22）</p><p>● day 29 任务以及具体安排：<a href="https://docs.qq.com/doc/DUEh5WFVlQkp1U0p4">第八章 贪心算法part03</a>（7.23）</p><p>● day 30 任务以及具体安排：<a href="https://docs.qq.com/doc/DUFRWc3BGRHFXZ1pO">第八章 贪心算法 part04</a>（7.24）</p><p>● day 31 任务以及具体安排：<a href="https://docs.qq.com/doc/DUFVRd3p5SHFMSExQ">第八章 贪心算法 part05</a>（7.25）</p><p>● day 32 任务以及具体安排：<a href="https://docs.qq.com/doc/DUGNUdVpoT0VJR01l">第九章 动态规划part01</a> （7.26）</p><p>● day 33 周末休息（7.27）</p><p>● day 34 任务以及具体安排：<a href="https://docs.qq.com/doc/DUE55cVJ5WkNoREhS">第九章 动态规划part02</a>（7.28）</p><p>● day 35 任务以及具体安排：<a href="https://docs.qq.com/doc/DUFhIUXRFYnVGUkFp">第九章 动态规划part03</a> (7.29)</p><p>● day 36 任务以及具体安排：<a href="https://docs.qq.com/doc/DUGdkaEl5dFN1QnBl">第九章 动态规划part04</a>（7.30）</p><p>● day 37 任务以及具体安排：<a href="https://docs.qq.com/doc/DUEVMRHZOemN5S2Vm">第九章 动态规划part05</a>（7.31）</p><p>● day 38 任务以及具体安排：<a href="https://docs.qq.com/doc/DUHBSRVRUc0Vsck1z">第九章 动态规划part06</a>（8.1）</p><p>● day 39 任务以及具体安排：<a href="https://docs.qq.com/doc/DUFVEbWRyZlpjaGty">第九章 动态规划part07</a>（8.2）</p><p>● day 40 周末休息（8.3）</p><p>● day 41 任务以及具体安排：<a href="https://docs.qq.com/doc/DUHhuT2RTTEtBeGhX">第九章 动态规划part08</a>（8.4）</p><p>● day 42任务以及具体安排：<a href="https://docs.qq.com/doc/DUGd5ZkNZS1NsYkFk">第九章 动态规划part09</a>（8.5）</p><p>● day 43 任务以及具体安排：<a href="https://docs.qq.com/doc/DUFhzV29ZSEtFVkto">第九章 动态规划part10</a>（8.6）</p><p>● day 44 任务以及具体安排：<a href="https://docs.qq.com/doc/DUEtsRGRXT2F2Y0FR">第九章 动态规划part11</a>（8.7）</p><p>● day 45 任务以及具体安排：<a href="https://docs.qq.com/doc/DUGt6dWVUUFhHUlpH">第九章 动态规划part12</a>（8.8）</p><p>● day 46 任务以及具体安排：<a href="https://docs.qq.com/doc/DUFJzanBWVXNVWW1N">第九章 动态规划part13</a>（8.9）</p><p>● day 47 周末休息（8.10）</p><p>● day 48 任务以及具体安排：<a href="https://docs.qq.com/doc/DUEJTT1BoS29NTGRD">第十章 单调栈part01</a>（8.11）</p><p>● day 49 任务以及具体安排：<a href="https://docs.qq.com/doc/DUHhnTHZUSGpHZ0Z2">第十章 单调栈part02</a>（8.12）</p><p>● day 50 图论一 ：<a href="https://docs.qq.com/doc/DUFBYZU9NV2ZjUWd5">第十一章：图论part01</a>（8.13）</p><p>● day 51 图论二：<a href="https://docs.qq.com/doc/DUFlHd2xtZ0dDc0Rl">第十一章：图论part02</a>（8.14）</p><p>● day 52 图论三 : <a href="https://docs.qq.com/doc/DUGxNbmFOVnd2SElD">第十一章：图论part03</a>（8.15）</p><p>● day 53 图论四 ： <a href="https://docs.qq.com/doc/DUGlaT3BkdWh0SGdL">第十一章：图论part04</a>（8.16）</p><p>● day 54 周末休息（8.17）</p><p>● day 55 图论五 ：<a href="https://docs.qq.com/doc/DUGxDT2FFbEt4S0xl?is_no_hook_redirect=1">第十一章：图论part05</a>（8.18）</p><p>● day 56 图论六 ：<a href="https://docs.qq.com/doc/DUEpTdnFobFVtTlBS?is_no_hook_redirect=1">第十一章：图论part06</a> （8.19）</p><p>● day 57 图论七：<a href="https://docs.qq.com/doc/DUHhST21JSWxVS29O?is_no_hook_redirect=1">第十一章：图论part07</a>（8.20）</p><p>● day 58 图论八：<a href="https://docs.qq.com/doc/DUFBrRUd3TWV2VlBz?is_no_hook_redirect=1">第十一章：图论part08</a>（8.21）</p><p>● day 59 图论九 ：<a href="https://docs.qq.com/doc/DUGhnd2RpeXdBSVRo?is_no_hook_redirect=1">第十一章：图论part09</a>（8.22）</p><p>● day 60 图论十：<a href="https://docs.qq.com/doc/DUEFDQUV3UElkaVhK?is_no_hook_redirect=1">第十一章：图论part10</a>（8.23）</p><p>● day 61 周末休息（8.24）</p><p>● day 62 图论十一：<a href="https://docs.qq.com/doc/DUEh0ZlVNZmFJRUZQ?is_no_hook_redirect=1">第十一章：图论part11</a>（8.25）</p><h1 id="打卡博客">打卡博客</h1><table><thead><tr><th></th></tr></thead><tbody><tr><td>第一周</td></tr><tr><td><a href="https://blog.lthero.com/2025/06/24/LeetCodeCampsDay1/">day1–双指针/快慢指针</a></td></tr><tr><td><a href="https://blog.lthero.com/2025/06/26/LeetCodeCampsDay2/">day2–二分搜索/双指针/滑动窗口/前缀和数组/螺旋矩阵</a></td></tr><tr><td><a href="https://blog.lthero.com/2025/06/26/LeetCodeCampsDay3/">day3–单链表/双向链表/递归反转链表/链表实现</a></td></tr><tr><td><a href="https://blog.lthero.com/2025/06/28/LeetCodeCampsDay4/">day4–快慢指针与链表/节点交换/环形链表</a></td></tr><tr><td>第二周</td></tr><tr><td><a href="https://blog.lthero.com/2025/06/30/LeetCodeCampsDay6/">day6–哈希表/快慢指针/循环问题=有环节点/双指针</a></td></tr><tr><td><a href="https://blog.lthero.com/2025/06/30/LeetCodeCampsDay7/">day7–双指针/生产者消费者/HashTable</a></td></tr><tr><td><a href="https://blog.lthero.com/2025/07/02/LeetCodeCampsDay8/">day8–双指针/字符串反转/python列表与字符串互换/python列表语法糖</a></td></tr><tr><td><a href="https://blog.lthero.com/2025/07/03/LeetCodeCampsDay9/">day9–kmp/字符串局部反转/字符串匹配/重复字符串查找</a></td></tr><tr><td><a href="https://blog.lthero.com/2025/07/04/LeetCodeCampsDay10/">day10–队列实现栈/栈实现队列</a></td></tr><tr><td><a href="https://blog.lthero.com/2025/07/06/LeetCodeCampsDay11/">day11–逆波兰表达示/滑动窗口/单调队列</a></td></tr><tr><td>第三周</td></tr><tr><td><a href="https://blog.lthero.com/2025/07/07/LeetCodeCampsDay13/">day13–二叉树递归/迭代/统一迭代/层序遍历</a></td></tr><tr><td><a href="https://blog.lthero.com/2025/07/08/LeetCodeCampsDay14/">day14–kmp应用/二叉树反转/前中后层序的实际应用/迭代递归实现/最大深度/最小深度/</a></td></tr><tr><td><a href="https://blog.lthero.com/2025/07/09/LeetCodeCampsDay15/">day15–树高度/深度求解/根节点到任意节点的路径/平衡二叉树判断/完全二叉树性质</a></td></tr><tr><td><a href="https://blog.lthero.com/2025/07/10/LeetCodeCampsDay16/">day16–根节点到任意节点的路径总和/层序/递归前序&amp;后序&amp;中序构建树/</a></td></tr><tr><td><a href="https://blog.lthero.com/2025/07/11/LeetCodeCampsDay17/">day-17二分搜索树判断/两个二叉树的操作/最大二叉树的创建</a></td></tr><tr><td><a href="https://blog.lthero.com/2025/07/13/LeetCodeCampsDay18/">day18–BST应用/二叉树的众数&amp;最小绝对值差/公共祖先/使用pre技巧</a></td></tr><tr><td>第四周</td></tr><tr><td><a href="https://blog.lthero.com/2025/07/14/LeetCodeCampsDay19/">day20–删除节点/添加节点/BST应用与扩展</a></td></tr><tr><td><a href="https://blog.lthero.com/2025/07/15/LeetCodeCampsDay21/">day21–BST构建/反中序遍历/修剪二叉树</a></td></tr><tr><td><a href="https://blog.lthero.com/2025/07/17/LeetCodeCampsDay22/">day22-从递归到回溯/路径记录/剪枝技巧</a></td></tr><tr><td><a href="https://blog.lthero.com/2025/07/18/LeetCodeCampsDay23/">day23–路径记录/单层操作去重复组合/回文串</a></td></tr><tr><td><a href="https://blog.lthero.com/2025/07/19/LeetCodeCampsDay24/">day24–去重复技巧/每次向path添加一个元素/多个元素区别</a></td></tr><tr><td><a href="https://blog.lthero.com/2025/07/19/LeetCodeCampsDay25/">day25–去重复技巧(不排序下)/全排列used数组/N皇后（回溯实现）/初见图问题/数独</a></td></tr><tr><td>第五周</td></tr><tr><td><a href="https://blog.lthero.com/2025/07/21/LeetCodeCampsDay27/">day27–贪心基础算法</a></td></tr><tr><td><a href="https://blog.lthero.com/2025/07/22/LeetCodeCampsDay28/">day28–贪心算法-买卖股票最佳时机/跳跃游戏1&amp;2</a></td></tr><tr><td><a href="https://blog.lthero.com/2025/07/24/LeetCodeCampsDay29/">day29–贪心算法/维度去除/左右遍历顺序</a></td></tr><tr><td><a href="https://blog.lthero.com/2025/07/24/LeetCodeCampsDay30/">day30–贪心算法/区间问题套路/python区间排序方法</a></td></tr><tr><td><a href="https://blog.lthero.com/2025/07/25/LeetCodeCampsDay31/">day31–贪心算法总结/二叉树中的贪心算法/区间问题/</a></td></tr><tr><td><a href="https://blog.lthero.com/2025/07/26/LeetCodeCampsDay32/">day32–动态规划入门与基础解题步骤</a></td></tr><tr><td>第六周</td></tr><tr><td><a href="https://blog.lthero.com/2025/07/28/LeetCodeCampsDay34/">day34–动态规划路径问题是一类、整数拆分与不同二叉树是一类</a></td></tr><tr><td><a href="https://blog.lthero.com/2025/07/29/LeetCodeCampsDay35/">day35–01背包问题初识/背包问题套路</a></td></tr><tr><td><a href="https://blog.lthero.com/2025/07/30/LeetCodeCampsDay36/">day36–将题目转成背包问题/装满背包的方法/最多物品数量/能否装满</a></td></tr><tr><td><a href="https://blog.lthero.com/2025/07/31/LeetCodeCampsDay37/">day37–完全背包问题/装满背包的方法数量/</a></td></tr><tr><td><a href="https://blog.lthero.com/2025/08/05/LeetCodeCampsDay38/">day38–完全背包问题/求排列数/求最小数</a></td></tr><tr><td><a href="https://blog.lthero.com/2025/08/05/LeetCodeCampsDay39/">day39–动态规划–打家劫舍问题/树形dp入门</a></td></tr><tr><td>第七周</td></tr><tr><td><a href="https://blog.lthero.com/2025/08/06/LeetCodeCampsDay41/">day41–动态规划–股票问题从入门到通关</a></td></tr><tr><td><a href="https://blog.lthero.com/2025/08/06/LeetCodeCampsDay42/">day42–动态规划–股票另类题目</a></td></tr><tr><td><a href="https://blog.lthero.com/2025/08/07/LeetCodeCampsDay43/">day43–动态规划–子序列长度问题/二维dp解决最长重复子数组</a></td></tr><tr><td><a href="https://blog.lthero.com/2025/08/07/LeetCodeCampsDay44/">day44–动态规划公共子序列/子序列和/二维dp</a></td></tr><tr><td><a href="https://blog.lthero.com/2025/08/08/LeetCodeCampsDay45/">day45–动态规划–字符串匹配(删除)问题/编辑距离/最长公共子序列变体</a></td></tr><tr><td><a href="https://blog.lthero.com/2025/08/11/LeetCodeCampsDay46/">day46–动态规划–回文串/回文序列</a></td></tr><tr><td>第八周</td></tr><tr><td><a href="https://blog.lthero.com/2025/08/11/LeetCodeCampsDay48/">day48–单调栈入门/下一个更大元素</a></td></tr><tr><td><a href="https://blog.lthero.com/2025/08/12/LeetCodeCampsDay49/">day49–单调栈接雨水/求最大矩形</a></td></tr><tr><td><a href="https://blog.lthero.com/2025/08/13/LeetCodeCampsDay50/">day50–图论基础</a></td></tr><tr><td><a href="https://blog.lthero.com/2025/08/14/LeetCodeCampsDay51/">day51–图论/岛屿面积/岛屿个数问题/深度和广度优先搜索/BFS/DFS</a></td></tr><tr><td><a href="https://blog.lthero.com/2025/08/22/LeetCodeCampsDay52/">day52–图论/水流问题/最大岛屿</a></td></tr><tr><td><a href="https://blog.lthero.com/2025/08/23/LeetCodeCampsDay53/">day53–字符串接龙/有向图的完全联通/岛屿周长</a></td></tr><tr><td>第九周</td></tr><tr><td><a href="https://blog.lthero.com/2025/08/23/LeetCodeCampsDay55/">day55–并查集初识</a></td></tr><tr><td><a href="https://blog.lthero.com/2025/08/23/LeetCodeCampsDay56/">day56–并查集/无向图&amp;有向图变成无向树&amp;有向树问题</a></td></tr><tr><td><a href="https://blog.lthero.com/2025/08/23/LeetCodeCampsDay57/">day57–最小生成树/Prim/Kruskal算法</a></td></tr><tr><td><a href="https://blog.lthero.com/2025/08/24/LeetCodeCampsDay58/">day58–dijkstra与拓扑排序初识</a></td></tr><tr><td><a href="https://blog.lthero.com/2025/08/26/LeetCodeCampsDay59/">day59–dijkstra优化与Bellman-ford算法</a></td></tr><tr><td><a href="https://blog.lthero.com/2025/08/26/LeetCodeCampsDay60/">day60–Bellman-ford算法优化</a></td></tr><tr><td>第十周</td></tr><tr><td><a href="https://blog.lthero.com/2025/08/26/LeetCodeCampsDay62/">day62–A*算法与Floyd最短路径算法</a></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday63总结&quot;&gt;LeetCodeCampsDay63总结&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;训练营让我系统地、由浅入深地学了一遍算法知识并刷题目巩固知识，让我有了不小的进步！虽然以前也学过算法并做过笔记，但通常是不成体系、不系统</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay60图论part10</title>
    <link href="https://blog.lthero.cn/2025/08/26/LeetCodeCampsDay60/"/>
    <id>https://blog.lthero.cn/2025/08/26/LeetCodeCampsDay60/</id>
    <published>2025-08-26T12:06:19.000Z</published>
    <updated>2025-08-27T07:44:51.854Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday60图论part10">LeetCodeCampsDay60图论part10</h1><h1 id="94-城市间货物运输-i">94.城市间货物运输 I</h1><p><a href="https://kamacoder.com/problempage.php?pid=1152">https://kamacoder.com/problempage.php?pid=1152</a></p><p>题目描述</p><p>某国为促进城市间经济交流，决定对货物运输提供补贴。共有 n 个编号为 1 到 n 的城市，通过道路网络连接，网络中的道路仅允许从某个城市单向通行到另一个城市，不能反向通行。</p><p>网络中的道路都有各自的运输成本和政府补贴，<strong>道路的权值计算方式为：运输成本 - 政府补贴</strong>。权值为正表示扣除了政府补贴后运输货物仍需支付的费用；权值为负则表示政府的补贴超过了支出的运输成本，实际表现为运输过程中还能赚取一定的收益。</p><p>请找出从城市 1 到城市 n 的所有可能路径中，综合政府补贴后的最低运输成本。如果最低运输成本是一个负数，它表示在遵循最优路径的情况下，运输过程中反而能够实现盈利。</p><p><strong>城市 1 到城市 n 之间可能会出现没有路径的情况，同时保证道路网络中不存在任何负权回路。</strong></p><p>输入描述</p><p>第一行包含两个正整数，第一个正整数 n 表示该国一共有 n 个城市，第二个整数 m 表示这些城市中共有 m 条道路。</p><p>接下来为 m 行，每行包括三个整数，s、t 和 v，表示 s 号城市运输货物到达 t 号城市，道路权值为 v （单向图）。</p><p>输出描述</p><p>如果能够从城市 1 到连通到城市 n， 请输出一个整数，表示运输成本。如果该整数是负数，则表示实现了盈利。如果从城市 1 没有路径可达城市 n，请输出 “unconnected”。</p><p>输入示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">6 7</span><br><span class="line">5 6 -2</span><br><span class="line">1 2 1</span><br><span class="line">5 3 1</span><br><span class="line">2 5 2</span><br><span class="line">2 4 -3</span><br><span class="line">4 6 4</span><br><span class="line">1 3 5</span><br></pre></td></tr></table></figure><p>输出示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>提示信息</p><p><img src="https://file1.kamacoder.com/i/web/20240329112127.png" alt="img"></p><p>示例中最佳路径是从 1 -&gt; 2 -&gt; 5 -&gt; 6，路上的权值分别为 1 2 -2，最终的最低运输成本为 1 + 2 + (-2) = 1。</p><p>示例 2：</p><p>4 2<br>1 2 -1<br>3 4 -1</p><p>在此示例中，无法找到一条路径从 1 通往 4，所以此时应该输出 “unconnected”。</p><p>数据范围：</p><p>1 &lt;= n &lt;= 1000；<br>1 &lt;= m &lt;= 10000;</p><p>-100 &lt;= v &lt;= 100;</p><h2 id="bellman-ford优化思路">Bellman-ford优化思路</h2><p>观察之前的代码，可以发现在遍历阶段可以优化，</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    graph = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        s, t, v = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        graph.append([s, t, v])</span><br><span class="line"></span><br><span class="line">    minDist = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * (n + <span class="number">1</span>)</span><br><span class="line">    minDist[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        updated = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> edge <span class="keyword">in</span> graph:</span><br><span class="line">            s, t, v = edge</span><br><span class="line">            <span class="keyword">if</span> minDist[s] != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">and</span> minDist[s] + v &lt; minDist[t]:</span><br><span class="line">                minDist[t] = minDist[s] + v</span><br><span class="line">                <span class="comment"># 添加个updated防止死循环，比如一直找不到满足条件的源点时</span></span><br><span class="line">                updated = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> updated:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(minDist[-<span class="number">1</span>] <span class="keyword">if</span> minDist[-<span class="number">1</span>] != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> <span class="string">&quot;unconnected&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>原代码的遍历条件是需要遍历(n-1)次，并且每次都要对整个graph遍历，虽然使用了minDist[s] != float(‘inf’)和minDist[s] + v &lt; minDist[t]这个条件来筛选更新对象，这样的思路虽然简单（可能也不简单？），<strong>但增加了很多无效遍历</strong></p><p>输入的边为以下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">5 6 -2</span><br><span class="line">1 2 1</span><br><span class="line">5 3 1</span><br><span class="line">2 5 2</span><br><span class="line">2 4 -3</span><br><span class="line">4 6 4</span><br><span class="line">1 3 5</span><br></pre></td></tr></table></figure><p>比如刚开始minDist[1]=0，</p><ol><li>edge信息为(s=5, t=6, v=-2)，此时minDist[s]为正无穷，不是要找的源点</li><li>edge信息为(s=1, t=2, v=1)，<code>此时minDist[s]为0，说明找到了源点</code> ，再进行“relax”，即对经过源点（1）能到达的终点（2）进行路径距离更新，如果<code>minDist[s] + v &lt; minDist[t]</code> ，说明经过源点s再到终点t是距离更近的</li><li>edge信息为(s=5, t=3, v=1)，此时minDist[s]为正无穷，不是要找的源点</li><li>…</li><li>edge信息为(s=1, t=3, v=5)，<code>此时minDist[s]为0，说明找到了源点</code> ，再更新终点（3）的距离</li></ol><p>这仅是一轮遍历，可以发现这么一次搜索，仅有找到了两次源点，而其它的都是无效的</p><p>此外，假如minDist[1]=0已经更新完成，此时i=2，即源点=2</p><ol><li>edge信息为(s=5, t=6, v=-2)，此时minDist[s]为正无穷，不是要找的源点</li><li>edge信息为(s=1, t=2, v=1)，此时minDist[s]不为正无穷，但**minDist[s] + v &lt; minDist[t]**已经不满足条件了，因为minDist[2]已经等于minDist[1] + 1，不是要找的源点</li><li>edge信息为(s=5, t=3, v=1)，此时minDist[s]为正无穷，不是要找的源点</li><li>edge信息为(s=2, t=5, v=2)，<code>此时minDist[s]为0，说明找到了源点</code>，再进行“relax”，即对经过源点（2）能到达的终点（5）进行路径距离更新</li><li>…</li></ol><p>这仅是一轮遍历，可以发现这么一次搜索，仅有找到了两次源点，而其它的都是无效的</p><blockquote><p>和dijkstra优化思路相似，可以使用一个<strong>邻接表+队列</strong>来控制哪些元素需要被遍历，从而减少无效遍历</p></blockquote><p>graph需要使用邻接表，其中s作为下标索引，而存储的是 &lt;t, v&gt; 这个结构体列表</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, t, v</span>):</span><br><span class="line">        self.t = t</span><br><span class="line">        self.v = v</span><br><span class="line"></span><br><span class="line">graph = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    s, t, v = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    graph[s].append(Edge(t, v))</span><br></pre></td></tr></table></figure><p>比如，输入的边会变成下面这样的邻接表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 [&lt;2, 1&gt;, &lt;3, 5&gt;]</span><br><span class="line">2 [&lt;5, 2&gt;, &lt;4, -3&gt;]</span><br><span class="line">4 [&lt;6, 4&gt;]</span><br><span class="line">5 [&lt;6, -2&gt;, &lt;3, 1&gt;]</span><br></pre></td></tr></table></figure><p>先将起点1添加到que中，若que不为空则一直弹出元素s，并对graph[s]遍历，注意graph[s]是个列表，里面是与它相连的终点</p><p>更新到每个终点的距离</p><p>这里还有个优化过程，如果某个终点已经达到过了，则不让它反复添加到队列里，设置个inQue即可</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inQue = [<span class="literal">False</span>] * (n + <span class="number">1</span>)</span><br><span class="line">inQue[<span class="number">1</span>] = <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>简单来说，如果不添加inQue之所以在某些情况下能通过，是因为那些测试用的图<strong>不包含负权回路</strong>。但是，这个代码存在一个致命缺陷：一旦图中存在负权回路，它就会陷入<strong>无限循环</strong>。</p><blockquote><p>所以，在后面95题目中，因为有负权回路，它必须要添加个inQue来判断</p></blockquote><p>详细解释</p><p>在一个没有负权回路的图中（无论边权是正还是负），一个节点的最短路径值 <code>minDist</code> 虽然可能会被更新多次，但更新的次数是有限的。</p><p>想象一下，从起点到节点 <code>X</code> 的最短路径值为 10。后来你又找到一条路径，值为 8，于是你更新 <code>minDist[X]</code> 并将 <code>X</code> 放入队列。再后来，你又找到一条更短的路径，值为 5，你再次更新并放入队列。</p><p>因为没有负权回路，节点的 <code>minDist</code> 值会一直降低，但它有一个最终的、最低的“底线”。一旦所有节点的 <code>minDist</code> 都达到了这个底线值，就不会再有新的更新了 (<code>if</code> 条件不再满足)，队列最终会变空，程序正常结束。</p><blockquote><p>所以，对于<strong>有向无环图 (DAG)</strong> 或者<strong>没有负权回路的图</strong>，你的代码可以算出正确答案，只是效率可能不高。</p></blockquote><h2 id="bellman-ford优化代码">Bellman-ford优化代码</h2><p>队列优化版Bellman_ford 的时间复杂度 并不稳定，效率高低依赖于图的结构。</p><p>例如 如果是一个双向图，且每一个节点和所有其他节点都相连的话，那么该算法的时间复杂度就接近于 Bellman_ford 的 O(N * E) N 为节点数量，E为边的数量。</p><p>在这种图中，每一个节点都会重复加入队列 n - 1次，因为 这种图中 每个节点 都有 n-1 条指向该节点的边，每条边指向该节点，就需要加入一次队列。（如果这里看不懂，可以在重温一下代码逻辑）</p><p>至于为什么 双向图且每一个节点和所有其他节点都相连的话，每个节点 都有 n-1 条指向该节点的边， 我再来举个例子，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240416104138.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240416104138.png" alt="img"></p><p>图中 每个节点都与其他所有节点相连，节点数n 为 4，每个节点都有3条指向该节点的边，即入度为3。</p><p>n为其他数值的时候，也是一样的。</p><p>当然这种图是比较极端的情况，也是最稠密的图。</p><p>所以如果图越稠密，则 SPFA的效率越接近与 Bellman_ford。</p><p>反之，图越稀疏，SPFA的效率就越高。</p><p>一般来说，SPFA 的时间复杂度为 O(K * N) K 为不定值，因为 节点需要计入几次队列取决于 图的稠密度。</p><p>如果图是一条线形图且单向的话，每个节点的入度为1，那么只需要加入一次队列，这样时间复杂度就是 O(N)。</p><p>所以 SPFA 在最坏的情况下是 O(N * E)，但 一般情况下 时间复杂度为 O(K * N)。</p><p>尽管如此，<strong>以上分析都是 理论上的时间复杂度分析</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, t, v</span>):</span><br><span class="line">        self.t = t</span><br><span class="line">        self.v = v</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    graph = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        s, t, v = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        graph[s].append(Edge(t, v))</span><br><span class="line"></span><br><span class="line">    minDist = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * (n + <span class="number">1</span>)</span><br><span class="line">    minDist[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">    que = deque()</span><br><span class="line">    que.append(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 这个inQue不添加似乎也可，但必须要保证没有负权回路，如果有负权回路，必须要添加inQue</span></span><br><span class="line">    <span class="comment"># 使用一个布尔数组 inQue 来在 O(1) 时间内完成判断</span></span><br><span class="line">    inQue = [<span class="literal">False</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    inQue[<span class="number">1</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> que:</span><br><span class="line">        s = que.popleft()</span><br><span class="line">        <span class="comment"># 从队列里取出的时候，要取消标记，我们只保证已经在队列里的元素不用重复加入</span></span><br><span class="line">        <span class="comment"># 把节点 s 标记为“当前不在队列中”，以便它将来如果被再次更新，还有机会重新加入队列</span></span><br><span class="line">        inQue[s] = <span class="literal">False</span> </span><br><span class="line">        <span class="keyword">for</span> edge <span class="keyword">in</span> graph[s]:</span><br><span class="line">            t, v = edge.t, edge.v</span><br><span class="line">            <span class="keyword">if</span> minDist[s] + v &lt; minDist[t]:</span><br><span class="line">                minDist[t] = minDist[s] + v</span><br><span class="line">                <span class="comment"># 已经在队列里的元素不用重复添加</span></span><br><span class="line">                <span class="keyword">if</span> inQue[t] == <span class="literal">False</span>:</span><br><span class="line">                    que.append(t)</span><br><span class="line">                    inQue[t] = <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(minDist[-<span class="number">1</span>] <span class="keyword">if</span> minDist[-<span class="number">1</span>] != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> <span class="string">&quot;unconnected&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="拓展">拓展</h2><p>这里可能有录友疑惑，<code>while (!que.empty())</code> 队里里 会不会造成死循环？ 例如 图中有环，这样一直有元素加入到队列里？</p><p>其实有环的情况，要看它是 正权回路 还是 负权回路。</p><p>题目描述中，已经说了，本题没有 负权回路 。</p><p>如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240412111849.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240412111849.png" alt="img"></p><p>正权回路 就是有环，但环的总权值为正数。</p><p>在有环且只有正权回路的情况下，即使元素重复加入队列，最后，也会因为 所有边都松弛后，节点数值（minDist数组）不在发生变化了 而终止。</p><p>（而且有重复元素加入队列是正常的，多条路径到达同一个节点，节点必要要选择一个最短的路径，而这个节点就会重复加入队列进行判断，选一个最短的）</p><p>在<a href="https://www.programmercarl.com/kamacoder/0094.%E5%9F%8E%E5%B8%82%E9%97%B4%E8%B4%A7%E7%89%A9%E8%BF%90%E8%BE%93I.html">0094.城市间货物运输I</a> 中我们讲过对所有边 最多松弛 n -1 次，就一定可以求出所有起点到所有节点的最小距离即 minDist数组。</p><p>即使再松弛n次以上， 所有起点到所有节点的最小距离（minDist数组） 不会再变了。 （这里如果不理解，建议认真看<a href="https://www.programmercarl.com/kamacoder/0094.%E5%9F%8E%E5%B8%82%E9%97%B4%E8%B4%A7%E7%89%A9%E8%BF%90%E8%BE%93I.html">0094.城市间货物运输I</a>讲解）</p><p>所以本题我们使用队列优化，有元素重复加入队列，也会因为最后 minDist数组 不会在发生变化而终止。</p><p>节点再加入队列，需要有松弛的行为， 而 每个节点已经都计算出来 起点到该节点的最短路径，那么就不会有 执行这个判断条件<code>if (minDist[to] &gt; minDist[from] + value)</code>，从而不会有新的节点加入到队列。</p><p>但如果本题有 负权回路，那情况就不一样了，我在下一题目讲解中，会重点讲解 负权回路 带来的变化。</p><h1 id="95-城市间货物运输-ii">95.城市间货物运输 II</h1><p>题目描述</p><p>某国为促进城市间经济交流，决定对货物运输提供补贴。共有 n 个编号为 1 到 n 的城市，通过道路网络连接，网络中的道路仅允许从某个城市单向通行到另一个城市，不能反向通行。</p><p>网络中的道路都有各自的运输成本和政府补贴，<strong>道路的权值计算方式为：运输成本 - 政府补贴</strong>。权值为正表示扣除了政府补贴后运输货物仍需支付的费用；权值为负则表示政府的补贴超过了支出的运输成本，实际表现为运输过程中还能赚取一定的收益。</p><p>然而，在评估从城市 1 到城市 n 的所有可能路径中综合政府补贴后的最低运输成本时，存在一种情况：**图中可能出现负权回路。**负权回路是指一系列道路的总权值为负，这样的回路使得通过反复经过回路中的道路，理论上可以无限地减少总成本或无限地增加总收益。为了避免货物运输商采用负权回路这种情况无限的赚取政府补贴，算法还需检测这种特殊情况。</p><p>请找出从城市 1 到城市 n 的所有可能路径中，综合政府补贴后的最低运输成本。同时能够检测并适当处理负权回路的存在。</p><p><strong>城市 1 到城市 n 之间可能会出现没有路径的情况</strong></p><p>输入描述</p><p>第一行包含两个正整数，第一个正整数 n 表示该国一共有 n 个城市，第二个整数 m 表示这些城市中共有 m 条道路。</p><p>接下来为 m 行，每行包括三个整数，s、t 和 v，表示 s 号城市运输货物到达 t 号城市，道路权值为 v。</p><p>输出描述</p><p>如果没有发现负权回路，则输出一个整数，表示从城市 <code>1</code> 到城市 <code>n</code> 的最低运输成本（包括政府补贴）。如果该整数是负数，则表示实现了盈利。如果发现了负权回路的存在，则输出 “circle”。如果从城市 1 无法到达城市 n，则输出 “unconnected”。</p><p>输入示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 4</span><br><span class="line">1 2 -1</span><br><span class="line">2 3 1</span><br><span class="line">3 1 -1 </span><br><span class="line">3 4 1</span><br></pre></td></tr></table></figure><p>输出示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">circle</span><br></pre></td></tr></table></figure><p>提示信息</p><p>路径中存在负权回路，从 1 -&gt; 2 -&gt; 3 -&gt; 1，总权值为 -1，理论上货物运输商可以在该回路无限循环赚取政府补贴，所以输出 “circle” 表示已经检测出了该种情况。</p><p>数据范围：</p><p>1 &lt;= n &lt;= 1000；<br>1 &lt;= m &lt;= 10000;</p><p>-100 &lt;= v &lt;= 100;</p><h2 id="基础思路">基础思路</h2><p>之前提到过，当遍历n-1次后，如果没有负权回路，不论再遍历多少次，minDist是不会生成更新的；</p><p>所以，我们可以遍历n次，如果第n次minDist需要发生更新，证明就存在负权回路</p><h2 id="基础代码">基础代码</h2><ul><li>时间复杂度O(NM)</li><li>空间复杂度O(M)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    <span class="comment"># graph不使用邻接表</span></span><br><span class="line">    graph = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        s, t, v = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        graph.append([s, t, v])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    minDist = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * (n + <span class="number">1</span>)</span><br><span class="line">    minDist[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历n次，第n次时需要判断是否发生了变化</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        updated = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> s, t, v <span class="keyword">in</span> graph:</span><br><span class="line">            judgeRes = minDist != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">and</span> minDist[s] + v &lt; minDist[t]</span><br><span class="line">            <span class="comment"># 第n次判断下就行</span></span><br><span class="line">            <span class="keyword">if</span> i == n:</span><br><span class="line">                <span class="keyword">if</span> judgeRes:</span><br><span class="line">                    <span class="comment"># 说明有负权回路(因为第n次又需要更新距离了)</span></span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;circle&quot;</span>)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> judgeRes:</span><br><span class="line">                    minDist[t] = minDist[s] + v</span><br><span class="line">                    updated = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 防止死循环</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> updated:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(minDist[-<span class="number">1</span>] <span class="keyword">if</span> minDist[-<span class="number">1</span>] != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> <span class="string">&quot;unconnected&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><hr><blockquote><p>那，如果使用优化代码（邻接表+队列）的方式，应该怎么写的呢？</p></blockquote><h2 id="优化思路">优化思路</h2><p>本题可不可 使用 队列优化版的bellman_ford（SPFA）呢？</p><p>上面的解法中，我们对所有边松弛了n-1次后，在松弛一次，如果出现minDist出现变化就判断有负权回路。</p><p>如果使用 SPFA 那么节点都是进队列的，那么节点进入队列几次后 足够判断该图是否有负权回路呢？</p><p>在 <a href="https://www.programmercarl.com/kamacoder/0094.%E5%9F%8E%E5%B8%82%E9%97%B4%E8%B4%A7%E7%89%A9%E8%BF%90%E8%BE%93I-SPFA">0094.城市间货物运输I-SPFA</a> 中，我们讲过 在极端情况下，即：所有节点都与其他节点相连，每个节点的入度为 n-1 （n为节点数量），所以每个节点最多加入 n-1 次队列。</p><p><s>那么如果节点加入队列的次数 超过了 n-1次 ，那么该图就一定有负权回路。</s></p><blockquote><p>对于某些复杂的 DAG，一个节点的松弛次数达到 <code>n</code> 是可能发生的，而这并不一定意味着存在负权环。一个更可靠、更被广泛接受的判断标准是<strong>当一个节点的松弛次数超过 <code>n</code> 时</strong>，才断定存在负权环。</p></blockquote><p>所以本题也是可以使用 SPFA 来做的。 代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123; <span class="comment">//邻接表</span></span><br><span class="line">    <span class="type">int</span> to;  <span class="comment">// 链接的节点</span></span><br><span class="line">    <span class="type">int</span> val; <span class="comment">// 边的权重</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> t, <span class="type">int</span> w): <span class="built_in">to</span>(t), <span class="built_in">val</span>(w) &#123;&#125;  <span class="comment">// 构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, p1, p2, val;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    vector&lt;list&lt;Edge&gt;&gt; <span class="built_in">grid</span>(n + <span class="number">1</span>); <span class="comment">// 邻接表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有边保存起来</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;</span><br><span class="line">        <span class="comment">// p1 指向 p2，权值为 val</span></span><br><span class="line">        grid[p1].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(p2, val));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> start = <span class="number">1</span>;  <span class="comment">// 起点</span></span><br><span class="line">    <span class="type">int</span> end = n;    <span class="comment">// 终点</span></span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minDist</span><span class="params">(n + <span class="number">1</span> , INT_MAX)</span></span>;</span><br><span class="line">    minDist[start] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(start); <span class="comment">// 队列里放入起点 </span></span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>; <span class="comment">// 记录节点加入队列几次</span></span><br><span class="line">    count[start]++;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> node = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Edge edge : grid[node]) &#123;</span><br><span class="line">            <span class="type">int</span> from = node;</span><br><span class="line">            <span class="type">int</span> to = edge.to;</span><br><span class="line">            <span class="type">int</span> value = edge.val;</span><br><span class="line">            <span class="keyword">if</span> (minDist[to] &gt; minDist[from] + value) &#123; <span class="comment">// 开始松弛</span></span><br><span class="line">                minDist[to] = minDist[from] + value;</span><br><span class="line">                que.<span class="built_in">push</span>(to);</span><br><span class="line">                count[to]++; </span><br><span class="line">                <span class="keyword">if</span> (count[to] == n) &#123;<span class="comment">// 如果加入队列次数超过 n-1次 就说明该图与负权回路</span></span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) que.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) cout &lt;&lt; <span class="string">&quot;circle&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (minDist[end] == INT_MAX) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;unconnected&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; minDist[end] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码看上去没问题，但提交之后会发现报错了，为什么呢？</p><p>例如这组数据：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">4 6</span><br><span class="line">1 4 3</span><br><span class="line">1 2 1</span><br><span class="line">1 3 1</span><br><span class="line">3 2 -2</span><br><span class="line">2 4 1</span><br><span class="line">3 4 0</span><br></pre></td></tr></table></figure><p>如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML2025-06-03_16-12-41.jpg" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/2025-06-03_16-12-41.jpg" alt="img"></p><p>上面代码在执行的过程中，节点4 已经出队列了，但 计算入度会反复计算 节点4的入度，导致 误判 该图有环。</p><p>我们需要记录哪些节点已经出队列了，哪些节点在队列里面，对于已经出队列的节点不用统计入度！</p><blockquote><p>所以，我们这里是一定需要添加inQue来判断哪些节点当前正在队列中</p><p>而在没有负权回路的情况，可以不使用inQue（如94题目）</p></blockquote><h3 id="致命缺陷：负权回路的-陷阱-☠">致命缺陷：负权回路的“陷阱” ☠️</h3><p>现在，我们来看看为什么 <code>in_queue</code> 和入队次数统计是必需的。</p><p><strong>考虑一个简单的负权回路：</strong></p><p>节点 A 到 B 的权是 3。</p><p>节点 B 回到 A 的权是 -5。</p><p>这个 <code>A -&gt; B -&gt; A</code> 的回路总权值为 <code>3 + (-5) = -2</code>。</p><p><strong>你的代码会发生什么：</strong></p><ol><li>程序从某个起点出发，最终更新了 <code>minDist[A]</code>。<code>A</code> 被加入队列 <code>que</code>。</li><li><code>A</code> 出队，用它更新了邻居 <code>B</code> 的距离 <code>minDist[B]</code>。<code>B</code> 被加入队列 <code>que</code>。</li><li><code>B</code> 出队，用它更新了邻居 <code>A</code> 的距离。因为回路是负权的，所以 <code>minDist[A]</code> 的新值一定比之前更小。于是，<code>A</code> <strong>又被加回了队列</strong>！</li><li><code>A</code> 再次出队，它又会去更新 <code>B</code>，使 <code>minDist[B]</code> 变得更小。<code>B</code> <strong>又被加回了队列</strong>！</li></ol><p>这个过程会无限重复下去。每绕一圈，<code>A</code> 和 <code>B</code> 的 <code>minDist</code> 值就会减 2，永无止境。你的 <code>while que:</code> 循环将永远不会结束，程序会超时（Time Limit Exceeded）。</p><h2 id="优化代码">优化代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, t, v</span>):</span><br><span class="line">        self.t = t</span><br><span class="line">        self.v = v</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># graph使用邻接表</span></span><br><span class="line">    <span class="comment"># 需要有个数据结构辅助</span></span><br><span class="line">    graph = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        s, t, v = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        graph[s].append(Edge(t, v))</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"> </span><br><span class="line">    que = deque()</span><br><span class="line">    que.append(<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    minDist = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * (n + <span class="number">1</span>)</span><br><span class="line">    minDist[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">    countInQ = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 记录节点是否在队列中，用于O(1)查询    </span></span><br><span class="line">    inQue = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    inQue[<span class="number">1</span>] = <span class="number">1</span> <span class="comment"># 这行可以不加，因为进入循环后也会被覆盖掉，但更容易理解</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> que:</span><br><span class="line">        s = que.popleft()</span><br><span class="line">        inQue[s] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> edge <span class="keyword">in</span> graph[s]:</span><br><span class="line">            t, v = edge.t, edge.v</span><br><span class="line">            <span class="keyword">if</span> minDist[s] + v &lt; minDist[t]:</span><br><span class="line">                minDist[t] = minDist[s] + v</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> inQue[t] == <span class="number">0</span>:</span><br><span class="line">                    countInQ[t] += <span class="number">1</span></span><br><span class="line">                    que.append(t)</span><br><span class="line">                    inQue[t] = <span class="number">1</span></span><br><span class="line"><span class="comment"># 对于某些复杂的 DAG，一个节点的松弛次数达到 n 是可能发生的，而这并不一定意味着存在负权环。一个更可靠、更被广泛接受的判断标准是当一个节点的松弛次数超过 n 时，才断定存在负权环。</span></span><br><span class="line">                    <span class="keyword">if</span> countInQ[t] &gt; n:</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&#x27;circle&#x27;</span>)</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">     </span><br><span class="line">    <span class="built_in">print</span>(minDist[-<span class="number">1</span>] <span class="keyword">if</span> minDist[-<span class="number">1</span>] != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> <span class="string">&quot;unconnected&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h1 id="96-城市间货物运输-iii">96.城市间货物运输 III</h1><p>题目描述</p><p>某国为促进城市间经济交流，决定对货物运输提供补贴。共有 n 个编号为 1 到 n 的城市，通过道路网络连接，网络中的道路仅允许从某个城市单向通行到另一个城市，不能反向通行。</p><p>网络中的道路都有各自的运输成本和政府补贴，**道路的权值计算方式为：运输成本 - 政府补贴。**权值为正表示扣除了政府补贴后运输货物仍需支付的费用；权值为负则表示政府的补贴超过了支出的运输成本，实际表现为运输过程中还能赚取一定的收益。</p><p>请计算在最多经过 k 个城市的条件下，从城市 src 到城市 dst 的最低运输成本。</p><p>输入描述</p><p>第一行包含两个正整数，第一个正整数 n 表示该国一共有 n 个城市，第二个整数 m 表示这些城市中共有 m 条道路。</p><p>接下来为 m 行，每行包括三个整数，s、t 和 v，表示 s 号城市运输货物到达 t 号城市，道路权值为 v。</p><p>最后一行包含三个正整数，src、dst、和 k，src 和 dst 为城市编号，从 src 到 dst 经过的城市数量限制。</p><p>输出描述</p><p>输出一个整数，表示从城市 src 到城市 dst 的最低运输成本，如果无法在给定经过城市数量限制下找到从 src 到 dst 的路径，则输出 “unreachable”，表示不存在符合条件的运输方案。</p><p>输入示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">6 7</span><br><span class="line">1 2 1</span><br><span class="line">2 4 -3</span><br><span class="line">2 5 2</span><br><span class="line">1 3 5</span><br><span class="line">3 5 1</span><br><span class="line">4 6 4</span><br><span class="line">5 6 -2</span><br><span class="line">2 6 1</span><br></pre></td></tr></table></figure><p>输出示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><p>提示信息</p><p>从 2 -&gt; 5 -&gt; 6 中转一站，运输成本为 0。</p><p>1 &lt;= n &lt;= 1000；</p><p>1 &lt;= m &lt;= 10000;</p><p>-100 &lt;= v &lt;= 100;</p><h2 id="思路">思路</h2><p>注意题目中描述是 <strong>最多经过 k 个城市的条件下，而不是一定经过k个城市，也可以经过的城市数量比k小，但要最短的路径</strong>。</p><p>在 <a href="https://www.programmercarl.com/kamacoder/0094.%E5%9F%8E%E5%B8%82%E9%97%B4%E8%B4%A7%E7%89%A9%E8%BF%90%E8%BE%93I.html">kama94.城市间货物运输I</a> 中我们讲了：<strong>对所有边松弛一次，相当于计算 起点到达 与起点一条边相连的节点 的最短距离</strong>。</p><p>节点数量为n，起点到终点，最多是 n-1 条边相连。 那么对所有边松弛 n-1 次 就一定能得到 起点到达 终点的最短距离。</p><p>（如果对以上讲解看不懂，建议详看 <a href="https://www.programmercarl.com/kamacoder/0094.%E5%9F%8E%E5%B8%82%E9%97%B4%E8%B4%A7%E7%89%A9%E8%BF%90%E8%BE%93I.html">kama94.城市间货物运输I</a> ）</p><p>本题是最多经过 k 个城市， 那么是 k + 1条边相连的节点。 这里可能有录友想不懂为什么是k + 1，来看这个图：</p><p><img src="https://file1.kamacoder.com/i/algo/20240402115614.png" alt="img"></p><p>图中，节点1 最多已经经过2个节点 到达节点4，那么中间是有多少条边呢，是 3 条边对吧。</p><p>所以本题就是求：起点最多经过k + 1 条边到达终点的最短距离。</p><p>对所有边松弛一次，相当于计算 起点到达 与起点一条边相连的节点 的最短距离，那么对所有边松弛 k + 1次，就是求 起点到达 与起点k + 1条边相连的节点的 最短距离。</p><p><strong>注意</strong>： 本题是 <a href="https://www.programmercarl.com/kamacoder/0094.%E5%9F%8E%E5%B8%82%E9%97%B4%E8%B4%A7%E7%89%A9%E8%BF%90%E8%BE%93I.html">kama94.城市间货物运输I</a> 的拓展题，如果对 bellman_ford 没有深入了解，强烈建议先看 <a href="https://www.programmercarl.com/kamacoder/0094.%E5%9F%8E%E5%B8%82%E9%97%B4%E8%B4%A7%E7%89%A9%E8%BF%90%E8%BE%93I.html">kama94.城市间货物运输I</a> 再做本题。</p><p>理解以上内容，其实本题代码就很容易了，bellman_ford 标准写法是松弛 n-1 次，本题就松弛 k + 1次就好。</p><p>以上代码 标准 bellman_ford 写法，松弛 k + 1次，看上去没什么问题。</p><p>但大家提交后，居然没通过！</p><p>这是为什么呢？</p><p>接下来我们拿这组数据来举例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4 4</span><br><span class="line">1 2 -1</span><br><span class="line">2 3 1</span><br><span class="line">3 1 -1</span><br><span class="line">3 4 1</span><br><span class="line">1 4 3</span><br></pre></td></tr></table></figure><p>（<strong>注意上面的示例是有负权回路的，只有带负权回路的图才能说明问题</strong>）</p><blockquote><p>负权回路是指一条道路的总权值为负，这样的回路使得通过反复经过回路中的道路，理论上可以无限地减少总成本或无限地增加总收益。</p></blockquote><p>正常来说，这组数据输出应该是 1，但以上代码输出的是 -2。</p><p>在讲解原因的时候，强烈建议大家，先把 minDist数组打印出来，看看minDist数组是不是按照自己的想法变化的，这样更容易理解我接下来的讲解内容。 （<strong>一定要动手，实践出真实，脑洞模拟不靠谱</strong>）</p><p>接下来，我按照上面的示例带大家 画图举例 对所有边松弛一次 的效果图。</p><p>起点为节点1， 起点到起点的距离为0，所以 minDist[1] 初始化为0 ，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240409111940.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240409111940.png" alt="img"></p><p>其他节点对应的minDist初始化为max，因为我们要求最小距离，那么还没有计算过的节点 默认是一个最大数，这样才能更新最小距离。</p><p>当我们开始对所有边开始第一次松弛：</p><p>边：节点1 -&gt; 节点2，权值为-1 ，minDist[2] &gt; minDist[1] + (-1)，更新 minDist[2] = minDist[1] + (-1) = 0 - 1 = -1 ，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240409111914.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240409111914.png" alt="img"></p><p>边：节点2 -&gt; 节点3，权值为1 ，minDist[3] &gt; minDist[2] + 1 ，更新 minDist[3] = minDist[2] + 1 = -1 + 1 = 0 ，如图：</p><p><img src="https://file1.kamacoder.com/i/algo/20240409111903.png" alt="img"></p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240409111903.png" alt="img"></p><p>边：节点3 -&gt; 节点1，权值为-1 ，minDist[1] &gt; minDist[3] + (-1)，更新 minDist[1] = 0 + (-1) = -1 ，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240409111849.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240409111849.png" alt="img"></p><p>边：节点3 -&gt; 节点4，权值为1 ，minDist[4] &gt; minDist[3] + 1，更新 minDist[4] = 0 + 1 = 1 ，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20241018192042.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20241018192042.png" alt="img"></p><p>以上是对所有边进行的第一次松弛，最后 minDist数组为 ：-1 -1 0 1 ，（从下标1算起）</p><p>后面几次松弛我就不挨个画图了，过程大同小异，我直接给出minDist数组的变化：</p><p>所有边进行的第二次松弛，minDist数组为 ： -2 -2 -1 0 所有边进行的第三次松弛，minDist数组为 ： -3 -3 -2 -1 所有边进行的第四次松弛，minDist数组为 ： -4 -4 -3 -2 （本示例中k为3，所以松弛4次）</p><p>最后计算的结果minDist[4] = -2，即 起点到 节点4，最多经过 3 个节点的最短距离是 -2，但 正确的结果应该是 1，即路径：节点1 -&gt; 节点2 -&gt; 节点3 -&gt; 节点4。</p><p>理论上来说，<strong>对所有边松弛一次，相当于计算 起点到达 与起点一条边相连的节点 的最短距离</strong>。</p><p>对所有边松弛两次，相当于计算 起点到达 与起点两条边相连的节点的最短距离。</p><p>对所有边松弛三次，以此类推。</p><p>但在对所有边松弛第一次的过程中，大家会发现，不仅仅 与起点一条边相连的节点更新了，所有节点都更新了。</p><p>而且对所有边的后面几次松弛，同样是更新了所有的节点，说明 至多经过k 个节点 这个限制 根本没有限制住，每个节点的数值都被更新了。</p><p>这是为什么？</p><p>在上面画图距离中，对所有边进行第一次松弛，在计算 边（节点2 -&gt; 节点3） 的时候，更新了 节点3。</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240409111903-20250827154449387.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240409111903.png" alt="img"></p><p>理论上来说节点3 应该在对所有边第二次松弛的时候才更新。 这因为当时是基于已经计算好的 节点2（minDist[2]）来做计算了。</p><p>minDist[2]在计算边：（节点1 -&gt; 节点2）的时候刚刚被赋值为 -1。</p><p>这样就造成了一个情况，即：计算minDist数组的时候，基于了本次松弛的 minDist数值，而不是上一次 松弛时候minDist的数值。<br>所以在每次计算 minDist 时候，要基于 对所有边上一次松弛的 minDist 数值才行，所以我们要记录上一次松弛的minDist。</p><h2 id="代码">代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">    edges = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        s, t, v = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        edges.append([s, t, v])</span><br><span class="line">    </span><br><span class="line">    src, dst, k = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">    minDist = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * (n + <span class="number">1</span>)</span><br><span class="line">    minDist[src] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    minDistLast = <span class="built_in">list</span>()</span><br><span class="line">    <span class="comment"># 因为最多经过！注意是经过k个城市，所以最多只能有k+1个边</span></span><br><span class="line">    <span class="comment"># 最多遍历k+1次</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 需要复制一份minDist</span></span><br><span class="line">        minDistLast = minDist[:]</span><br><span class="line">        updated = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> edge <span class="keyword">in</span> edges:</span><br><span class="line">            s, t, v = edge</span><br><span class="line">            <span class="comment"># 使用未更新的minDist进行比较</span></span><br><span class="line">            <span class="keyword">if</span> minDistLast[s] != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">and</span> minDistLast[s] + v &lt; minDist[t]:</span><br><span class="line">                minDist[t] = minDistLast[s] + v</span><br><span class="line">                updated = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 防止死循环</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> updated:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(minDist[dst] <span class="keyword">if</span> minDist[dst] != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> <span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday60图论part10&quot;&gt;LeetCodeCampsDay60图论part10&lt;/h1&gt;
&lt;h1 id=&quot;94-城市间货物运输-i&quot;&gt;94.城市间货物运输 I&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://kamacoder.co</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay59图论part09</title>
    <link href="https://blog.lthero.cn/2025/08/26/LeetCodeCampsDay59/"/>
    <id>https://blog.lthero.cn/2025/08/26/LeetCodeCampsDay59/</id>
    <published>2025-08-26T07:09:56.000Z</published>
    <updated>2025-08-26T12:37:25.435Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday59图论part09">LeetCodeCampsDay59图论part09</h1><h1 id="47-参加科学大会-第六期模拟笔试">47.参加科学大会（第六期模拟笔试）</h1><p>题目描述</p><p>小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。</p><p>小明的起点是第一个车站，终点是最后一个车站。然而，途中的各个车站之间的道路状况、交通拥堵程度以及可能的自然因素（如天气变化）等不同，这些因素都会影响每条路径的通行时间。</p><p>小明希望能选择一条花费时间最少的路线，以确保他能够尽快到达目的地。</p><p>输入描述</p><p>第一行包含两个正整数，第一个正整数 N 表示一共有 N 个公共汽车站，第二个正整数 M 表示有 M 条公路。</p><p>接下来为 M 行，每行包括三个整数，S、E 和 V，代表了从 S 车站可以单向直达 E 车站，并且需要花费 V 单位的时间。</p><p>输出描述</p><p>输出一个整数，代表小明从起点到终点所花费的最小时间。</p><p>输入示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">7 9</span><br><span class="line">1 2 1</span><br><span class="line">1 3 4</span><br><span class="line">2 3 2</span><br><span class="line">2 4 5</span><br><span class="line">3 4 2</span><br><span class="line">4 5 3</span><br><span class="line">2 6 4</span><br><span class="line">5 7 4</span><br><span class="line">6 7 9</span><br></pre></td></tr></table></figure><p>输出示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure><p>提示信息</p><p><strong>能够到达的情况：</strong></p><p>如下图所示，起始车站为 1 号车站，终点车站为 7 号车站，绿色路线为最短的路线，路线总长度为 12，则输出 12。</p><p><img src="https://kamacoder.com/upload/kamacoder.com/image/20240122/20240122163716_71030.png" alt="img"></p><p><strong>不能到达的情况：</strong></p><p>如下图所示，当从起始车站不能到达终点车站时，则输出 -1。</p><p><img src="https://kamacoder.com/upload/kamacoder.com/image/20240125/20240125154052_26956.png" alt="img"></p><p>数据范围：</p><p>1 &lt;= N &lt;= 500;<br>1 &lt;= M &lt;= 5000;</p><h2 id="邻接表">邻接表</h2><p>邻接表的，我来给大家画一个图：</p><p><img src="https://file1.kamacoder.com/i/algo/20240223103713.png" alt="img"></p><p>图中邻接表表示：</p><ul><li>节点1 指向 节点3 和 节点5</li><li>节点2 指向 节点4、节点3、节点5</li><li>节点3 指向 节点4</li><li>节点4 指向 节点1</li></ul><h2 id="dijkstra-堆优化版-思路">dijkstra（堆优化版）思路</h2><p>在第一个版本的实现思路中，我们提到了三部曲：</p><ol><li>第一步，选源点到哪个节点近且该节点未被访问过</li><li>第二步，该最近节点被标记访问过</li><li>第三步，更新非访问节点到源点的距离（即更新minDist数组）</li></ol><p>在LeetCodeCampsDay58里的47题目，我已经使用了一个优化的方法，</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">    graph = [[<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">    graphDict = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        s, t, v = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        graph[s][t] = v</span><br><span class="line">        graphDict[s].append(t)</span><br><span class="line"></span><br><span class="line">    visited = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    minDist = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * (n + <span class="number">1</span>)</span><br><span class="line">    minDist[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    parent = [-<span class="number">1</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>):</span><br><span class="line">        lowest = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        node = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> visited[j] == <span class="number">0</span> <span class="keyword">and</span> minDist[j] &lt; lowest:</span><br><span class="line">                lowest = minDist[j]</span><br><span class="line">                node = j</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> node == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        visited[node] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这里使用了邻接表进行遍历，而不是使用邻接矩阵</span></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> graphDict[node]:</span><br><span class="line">            <span class="keyword">if</span> visited[t] == <span class="number">0</span> <span class="keyword">and</span> minDist[t] &gt; graph[node][t]:</span><br><span class="line">                minDist[t] = <span class="built_in">min</span>(graph[node][t] + minDist[node], minDist[t])</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(minDist[-<span class="number">1</span>] <span class="keyword">if</span> minDist[-<span class="number">1</span>] != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> -<span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>但当时主体还是使用<strong>邻接矩阵</strong>进行遍历，仅在<code>更新非访问节点到源点的距离</code>时使用了<strong>邻接表</strong></p><p>其实可以全程只使用<strong>邻接表</strong>，从而进一步减少一些不必要的遍历</p><p>但新的问题来了，使用邻接矩阵遍历时，<strong>被遍历的对象是0～n这些节点</strong>；若使用邻接表，被遍历对象是什么呢？</p><p>这里的邻接表仅记录了所有节点到其它节点的信息，但它并不是一个被遍历对象，所以我们需要构造一个被遍历对象：使用一个数据结构，比如队列，我们不断地从队列里取出被遍历对象。初始化时，先将start起点加入到队列，</p><p>开始while循环，弹出一个元素（刚开始只能弹出start），将start标记为已经访问，再更新start的邻接表的其它终点到start的minDist距离，并将这些终点添加到队列中，最后，需要对队列再进行排序（按距离从小到大排序），保证队列首一定是距离最小的；随后再进行循环，直到队列里没有其它元素</p><p>所以这里使用了“<strong>邻接表+队列</strong>”来优化遍历</p><blockquote><p><strong>那，是否有哪种数据结构可以自动排序呢？</strong></p><p>堆！而且 直接把 边（带权值）加入到 <code>小顶堆</code>（利用堆来自动排序），那么每次我们从 <strong>堆顶</strong> 取出 边 自然就是 距离源点最近的节点所在的边。</p></blockquote><p>那，如何创建本题目需要的邻接表呢？我之前使用的邻接表，仅包含了起点和对应的终点们，如何将每个起点到终点的权值也添加进去？</p><p>可以创建一个数据结构，代码如下</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, t, v</span>):</span><br><span class="line">        self.t = t</span><br><span class="line">        self.v = v</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">    graph = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        s, t, v = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        graph[s].append(Edge(t, v))</span><br></pre></td></tr></table></figure><p>代码对应的示意图如下</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240223103904.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240223103904.png" alt="img"></p><ul><li>节点1 指向 节点3 权值为 1</li><li>节点1 指向 节点5 权值为 2</li><li>节点2 指向 节点4 权值为 7</li><li>节点2 指向 节点3 权值为 6</li><li>节点2 指向 节点5 权值为 3</li><li>节点3 指向 节点4 权值为 3</li><li>节点5 指向 节点1 权值为 10</li></ul><h2 id="堆优化代码">堆优化代码</h2><ul><li>时间复杂度：O(MlogM) M 为边的数量</li><li>空间复杂度O(N+M)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, t, v</span>):</span><br><span class="line">        self.t = t</span><br><span class="line">        self.v = v</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">    graph = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        s, t, v = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        graph[s].append(Edge(t, v))</span><br><span class="line"></span><br><span class="line">    visited = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    minDist = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * (n + <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建一个小顶堆</span></span><br><span class="line">    pq = <span class="built_in">list</span>()</span><br><span class="line">    <span class="comment"># 添加初始点，注意这里的初始点的距离为0</span></span><br><span class="line">    heapq.heappush(pq, (<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    <span class="comment"># 将start节点的距离设置为0</span></span><br><span class="line">    minDist[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> pq:</span><br><span class="line">      <span class="comment"># 弹出的节点就是离源点最近的</span></span><br><span class="line">        curDist, curNode = heapq.heappop(pq)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将当前节点标记为访问过</span></span><br><span class="line">        <span class="keyword">if</span> visited[curNode] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        visited[curNode] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 更新非访问节点到源点的距离（这部分代码和之前差不多）</span></span><br><span class="line">        <span class="keyword">for</span> edge <span class="keyword">in</span> graph[curNode]:</span><br><span class="line">            <span class="keyword">if</span> visited[edge.t] == <span class="number">0</span> <span class="keyword">and</span> curDist + edge.v &lt; minDist[edge.t]:</span><br><span class="line">                minDist[edge.t] = curDist + edge.v</span><br><span class="line">                <span class="comment"># 最重要，记录把相邻节点添加到堆中</span></span><br><span class="line">                heapq.heappush(pq, (minDist[edge.t], edge.t))</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">print</span>(minDist[-<span class="number">1</span>] <span class="keyword">if</span> minDist[-<span class="number">1</span>] != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> -<span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>堆优化的时间复杂度 只和边的数量有关 和节点数无关，在 优先级队列中 放的也是边。</p><p>以上代码中，<code>while (!pq.empty())</code> 里套了 <code>for (Edge edge : grid[cur.first])</code></p><p><code>for</code> 里 遍历的是 当前节点 cur 所连接边。</p><p>那 当前节点cur 所连接的边 也是不固定的， 这就让大家分不清，这时间复杂度究竟是多少？</p><p>其实 <code>for (Edge edge : grid[cur.first])</code> 里最终的数据走向 是 给队列里添加边。</p><p>那么跳出局部代码，整个队列 一定是 所有边添加了一次，同时也弹出了一次。</p><p>所以边添加一次时间复杂度是 O(M)， <code>while (!pq.empty())</code> 里每次都要弹出一个边来进行操作，在优先级队列（小顶堆）中 弹出一个元素的时间复杂度是 O(logM) ，这是堆排序的时间复杂度。</p><p>（当然小顶堆里 是 添加元素的时候 排序，还是 取数元素的时候排序，这个无所谓，时间复杂度都是O(M)，总之是一定要排序的，而小顶堆里也不会滞留元素，有多少元素添加 一定就有多少元素弹出）</p><p>所以 该算法整体时间复杂度为 O（MlogM)</p><p>网上的不少分析 会把 n （节点的数量）算进来，这个分析是有问题的，举一个极端例子，在n 为 10000，且是有一条边的 图里，以上代码，大家感觉执行了多少次？</p><p><code>while (!pq.empty())</code> 中的 pq 存的是边，其实只执行了一次。</p><p>所以该算法时间复杂度 和 节点没有关系。</p><p>至于空间复杂度，邻接表是 数组 + 链表 数组的空间 是 N ，有M条边 就申请对应多少个链表节点，所以是 复杂度是 N + M</p><h1 id="94-城市间货物运输-i">94.城市间货物运输 I</h1><p>题目描述</p><p>某国为促进城市间经济交流，决定对货物运输提供补贴。共有 n 个编号为 1 到 n 的城市，通过道路网络连接，网络中的道路仅允许从某个城市单向通行到另一个城市，不能反向通行。</p><p>网络中的道路都有各自的运输成本和政府补贴，<strong>道路的权值计算方式为：运输成本 - 政府补贴</strong>。权值为正表示扣除了政府补贴后运输货物仍需支付的费用；权值为负则表示政府的补贴超过了支出的运输成本，实际表现为运输过程中还能赚取一定的收益。</p><p>请找出从城市 1 到城市 n 的所有可能路径中，综合政府补贴后的最低运输成本。如果最低运输成本是一个负数，它表示在遵循最优路径的情况下，运输过程中反而能够实现盈利。</p><p><strong>城市 1 到城市 n 之间可能会出现没有路径的情况，同时保证道路网络中不存在任何负权回路。</strong></p><p>输入描述</p><p>第一行包含两个正整数，第一个正整数 n 表示该国一共有 n 个城市，第二个整数 m 表示这些城市中共有 m 条道路。</p><p>接下来为 m 行，每行包括三个整数，s、t 和 v，表示 s 号城市运输货物到达 t 号城市，道路权值为 v （单向图）。</p><p>输出描述</p><p>如果能够从城市 1 到连通到城市 n， 请输出一个整数，表示运输成本。如果该整数是负数，则表示实现了盈利。如果从城市 1 没有路径可达城市 n，请输出 “unconnected”。</p><p>输入示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">6 7</span><br><span class="line">5 6 -2</span><br><span class="line">1 2 1</span><br><span class="line">5 3 1</span><br><span class="line">2 5 2</span><br><span class="line">2 4 -3</span><br><span class="line">4 6 4</span><br><span class="line">1 3 5</span><br></pre></td></tr></table></figure><p>输出示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>提示信息</p><p><img src="https://file1.kamacoder.com/i/web/20240329112127.png" alt="img"></p><p>示例中最佳路径是从 1 -&gt; 2 -&gt; 5 -&gt; 6，路上的权值分别为 1 2 -2，最终的最低运输成本为 1 + 2 + (-2) = 1。</p><p>示例 2：</p><p>4 2<br>1 2 -1<br>3 4 -1</p><p>在此示例中，无法找到一条路径从 1 通往 4，所以此时应该输出 “unconnected”。</p><p>数据范围：</p><p>1 &lt;= n &lt;= 1000；<br>1 &lt;= m &lt;= 10000;</p><p>-100 &lt;= v &lt;= 100;</p><h2 id="bellman-ford算法思路">Bellman-ford算法思路</h2><p>本题依然是单源最短路问题，求 从 节点1 到节点n 的最小费用。 <strong>但本题不同之处在于 边的权值是有负数了</strong>。</p><p>从 节点1 到节点n 的最小费用也可以是负数，费用如果是负数 则表示 运输的过程中 政府补贴大于运输成本。</p><p>在求单源最短路的方法中，使用dijkstra 的话，则要求图中边的权值都为正数。</p><p>我们在 <a href="https://www.programmercarl.com/kamacoder/0047.%E5%8F%82%E4%BC%9Adijkstra%E6%9C%B4%E7%B4%A0.html">dijkstra朴素版</a> 中专门有讲解：为什么有边为负数 使用dijkstra就不行了。</p><p><strong>本题是经典的带负权值的单源最短路问题，此时就轮到Bellman_ford登场了</strong>，接下来我们来详细介绍Bellman_ford 算法 如何解决这类问题。</p><blockquote><p>该算法是由 R.Bellman 和L.Ford 在20世纪50年代末期发明的算法，故称为Bellman_ford算法。</p></blockquote><p><strong>Bellman_ford算法的核心思想是 对所有边进行松弛n-1次操作（n为节点数量），从而求得目标最短路</strong>。</p><h3 id="什么叫做松弛">什么叫做松弛</h3><p>看到这里，估计大家都比较晕了，为什么是 n-1 次，那“松弛”这两个字究竟是个啥意思？</p><p>我们先来说什么是 “松弛”。</p><p>《算法四》里面把这个操作叫做 “放松”， 英文版里叫做 “relax the edge”</p><p>所以大家翻译过来，就是 “放松” 或者 “松弛” 。</p><p>但《算法四》没有具体去讲这个 “放松” 究竟是个啥？ 网上很多题解也没有讲题解里的 “松弛这条边，松弛所有边”等等 里面的 “松弛” 究竟是什么意思？</p><p>这里我给大家举一个例子，每条边有起点、终点和边的权值。例如一条边，节点A 到 节点B 权值为value，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240327102620.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240327102620.png" alt="img"></p><p>minDist[B] 表示 到达B节点 最小权值，minDist[B] 有哪些状态可以推出来？</p><p>状态一： minDist[A] + value 可以推出 minDist[B] 状态二： minDist[B]本身就有权值 （可能是其他边链接的节点B 例如节点C，以至于 minDist[B]记录了其他边到minDist[B]的权值）</p><p>minDist[B] 应为如何取舍。</p><p>本题我们要求最小权值，那么 这两个状态我们就取最小的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (minDist[B] &gt; minDist[A] + value) minDist[B] = minDist[A] + value</span><br></pre></td></tr></table></figure><p>也就是说，如果 通过 A 到 B 这条边可以获得更短的到达B节点的路径，即如果 <code>minDist[B] &gt; minDist[A] + value</code>，那么我们就更新 <code>minDist[B] = minDist[A] + value</code> ，<strong>这个过程就叫做 “松弛</strong>” 。</p><p>以上讲了这么多，其实都是围绕以下这句代码展开：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (minDist[B] &gt; minDist[A] + value) minDist[B] = minDist[A] + value</span><br></pre></td></tr></table></figure><p><strong>这句代码就是 Bellman_ford算法的核心操作</strong>。</p><p>以上代码也可以这么写：<code>minDist[B] = min(minDist[A] + value, minDist[B])</code></p><p>如果大家看过代码随想录的动态规划章节，会发现 无论是背包问题还是子序列问题，这段代码（递推公式）出现频率非常高的。</p><p>其实 Bellman_ford算法 也是采用了动态规划的思想，即：将一个问题分解成多个决策阶段，通过状态之间的递归关系最后计算出全局最优解。</p><p>（如果理解不了动态规划的思想也无所谓，理解我上面讲的松弛操作就好）</p><p><strong>那么为什么是 n - 1次 松弛呢</strong>？</p><p>这里要给大家模拟一遍 Bellman_ford 的算法才行，接下来我们来看看对所有边松弛 n - 1 次的操作是什么样的。</p><p>我们依然使用<strong>minDist数组来表达 起点到各个节点的最短距离</strong>，例如minDist[3] = 5 表示起点到达节点3 的最小距离为5</p><h3 id="模拟过程">模拟过程</h3><p>初始化过程。</p><p>起点为节点1， 起点到起点的距离为0，所以 minDist[1] 初始化为0</p><p>如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240328104119.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240328104119.png" alt="img"></p><p>其他节点对应的minDist初始化为max，因为我们要求最小距离，那么还没有计算过的节点 默认是一个最大数，这样才能更新最小距离。</p><p>对所有边 进行第一次松弛： （什么是松弛，在上面我已经详细讲过）</p><p>以示例给出的所有边为例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">5 6 -2</span><br><span class="line">1 2 1</span><br><span class="line">5 3 1</span><br><span class="line">2 5 2</span><br><span class="line">2 4 -3</span><br><span class="line">4 6 4</span><br><span class="line">1 3 5</span><br></pre></td></tr></table></figure><p>接下来我们来松弛一遍所有的边。</p><p>边：节点5 -&gt; 节点6，权值为-2 ，minDist[5] 还是默认数值max，所以不能基于 节点5 去更新节点6，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240329113537.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240329113537.png" alt="img"></p><p>（在复习一下，minDist[5] 表示起点到节点5的最短距离）</p><p>边：节点1 -&gt; 节点2，权值为1 ，minDist[2] &gt; minDist[1] + 1 ，更新 minDist[2] = minDist[1] + 1 = 0 + 1 = 1 ，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240329113703.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240329113703.png" alt="img"></p><p>边：节点5 -&gt; 节点3，权值为1 ，minDist[5] 还是默认数值max，所以不能基于节点5去更新节点3 如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240329113827.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240329113827.png" alt="img"></p><p>边：节点2 -&gt; 节点5，权值为2 ，minDist[5] &gt; minDist[2] + 2 （经过上面的计算minDist[2]已经不是默认值，而是 1），更新 minDist[5] = minDist[2] + 2 = 1 + 2 = 3 ，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240329113927.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240329113927.png" alt="img"></p><p>边：节点2 -&gt; 节点4，权值为-3 ，minDist[4] &gt; minDist[2] + (-3)，更新 minDist[4] = minDist[2] + (-3) = 1 + (-3) = -2 ，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240329114036.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240329114036.png" alt="img"></p><p>边：节点4 -&gt; 节点6，权值为4 ，minDist[6] &gt; minDist[4] + 4，更新 minDist[6] = minDist[4] + 4 = -2 + 4 = 2</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240329114120.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240329114120.png" alt="img"></p><p>边：节点1 -&gt; 节点3，权值为5 ，minDist[3] &gt; minDist[1] + 5，更新 minDist[3] = minDist[1] + 5 = 0 + 5 = 5 ，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240329114324.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240329114324.png" alt="img"></p><hr><p>以上是对所有边进行一次松弛之后的结果。</p><p>那么需要对所有边松弛几次才能得到 起点（节点1） 到终点（节点6）的最短距离呢？</p><p><strong>对所有边松弛一次，相当于计算 起点到达 与起点一条边相连的节点 的最短距离</strong>。</p><p>上面的距离中，我们得到里 起点达到 与起点一条边相邻的节点2 和 节点3 的最短距离，分别是 minDist[2] 和 minDist[3]</p><p>这里有录友疑惑了 minDist[3] = 5，分明不是 起点到达 节点3 的最短距离，节点1 -&gt; 节点2 -&gt; 节点5 -&gt; 节点3 这条路线 距离才是4。</p><p>注意我上面讲的是 <strong>对所有边松弛一次，相当于计算 起点到达 与起点一条边相连的节点 的最短距离</strong>，这里 说的是 一条边相连的节点。</p><p>与起点（节点1）一条边相邻的节点，到达节点2 最短距离是 1，到达节点3 最短距离是5。</p><p>而 节点1 -&gt; 节点2 -&gt; 节点5 -&gt; 节点3 这条路线 是 与起点 三条边相连的路线了。</p><p>所以对所有边松弛一次 能得到 与起点 一条边相连的节点最短距离。</p><p>那对所有边松弛两次 可以得到与起点 两条边相连的节点的最短距离。</p><p>那对所有边松弛三次 可以得到与起点 三条边相连的节点的最短距离，这个时候，我们就能得到到达节点3真正的最短距离，也就是 节点1 -&gt; 节点2 -&gt; 节点5 -&gt; 节点3 这条路线。</p><p>那么再回归刚刚的问题，<strong>需要对所有边松弛几次才能得到 起点（节点1） 到终点（节点6）的最短距离呢</strong>？</p><p>节点数量为n，那么起点到终点，最多是 n-1 条边相连。</p><p>那么无论图是什么样的，边是什么样的顺序，我们对所有边松弛 n-1 次 就一定能得到 起点到达 终点的最短距离。</p><p>其实也同时计算出了，起点 到达 所有节点的最短距离，因为所有节点与起点连接的边数最多也就是 n-1 条边。</p><p>截止到这里，Bellman_ford 的核心算法思路，大家就了解的差不多了。</p><p>共有两个关键点。</p><ul><li>“松弛”究竟是个啥？</li><li>为什么要对所有边松弛 n - 1 次 （n为节点个数） ？</li></ul><p>那么Bellman_ford的解题解题过程其实就是对所有边松弛 n-1 次，然后得出得到终点的最短路径</p><h2 id="代码">代码</h2><ul><li>时间复杂度： O(N * E) , N为节点数量，E为图中边的数量</li><li>空间复杂度： O(N) ，即 minDist 数组所开辟的空间</li></ul><p>关于空间复杂度，可能有录友疑惑，代码中数组grid不也开辟空间了吗？ 为什么只算minDist数组的空间呢？</p><p>grid数组是用来存图的，这是题目描述中必须要使用的空间，而不是我们算法所使用的空间。</p><p>我们在讲空间复杂度的时候，一般都是说，我们这个算法所用的空间复杂度。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    graph = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        s, t, v = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        graph.append([s, t, v])</span><br><span class="line"></span><br><span class="line">    minDist = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * (n + <span class="number">1</span>)</span><br><span class="line">    minDist[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        updated = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> edge <span class="keyword">in</span> graph:</span><br><span class="line">            s, t, v = edge</span><br><span class="line">            <span class="keyword">if</span> minDist[s] != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">and</span> minDist[s] + v &lt; minDist[t]:</span><br><span class="line">                minDist[t] = minDist[s] + v</span><br><span class="line">                updated = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> updated:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(minDist[-<span class="number">1</span>] <span class="keyword">if</span> minDist[-<span class="number">1</span>] != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> <span class="string">&quot;unconnected&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="拓展">拓展</h3><p>有录友可能会想，那我 松弛 n 次，松弛 n + 1次，松弛 2 * n 次会怎么样？</p><p>其实没啥影响，结果不会变的，因为 题目中说了 “同时保证道路网络中不存在任何负权回路” 也就是图中没有 负权回路（在有向图中出现有向环 且环的总权值为负数）。</p><p>那么我们只要松弛 n - 1次 就一定能得到结果，没必要在松弛更多次了。</p><p>这里有疑惑的录友，可以加上打印 minDist数组 的日志，尝试一下，看看松弛 n 次会怎么样。</p><p>你会发现 松弛 大于 n - 1次，minDist数组 就不会变化了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday59图论part09&quot;&gt;LeetCodeCampsDay59图论part09&lt;/h1&gt;
&lt;h1 id=&quot;47-参加科学大会-第六期模拟笔试&quot;&gt;47.参加科学大会（第六期模拟笔试）&lt;/h1&gt;
&lt;p&gt;题目描述&lt;/p&gt;
&lt;p&gt;小明是一位科</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay58图论part08</title>
    <link href="https://blog.lthero.cn/2025/08/24/LeetCodeCampsDay58/"/>
    <id>https://blog.lthero.cn/2025/08/24/LeetCodeCampsDay58/</id>
    <published>2025-08-24T15:49:33.000Z</published>
    <updated>2025-08-26T06:05:52.356Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday58图论part08">LeetCodeCampsDay58图论part08</h1><blockquote><p>拓扑排序与dijkstra初识</p></blockquote><h1 id="117-软件构建">117.软件构建</h1><p>题目描述</p><p>某个大型软件项目的构建系统拥有 N 个文件，文件编号从 0 到 N - 1，在这些文件中，某些文件依赖于其他文件的内容，这意味着如果文件 A 依赖于文件 B，则必须在处理文件 A 之前处理文件 B （0 &lt;= A, B &lt;= N - 1）。请编写一个算法，用于确定文件处理的顺序。</p><p>输入描述</p><p>第一行输入两个正整数 N, M。表示 N 个文件之间拥有 M 条依赖关系。</p><p>后续 M 行，每行两个正整数 S 和 T，表示 T 文件依赖于 S 文件。</p><p>输出描述</p><p>输出共一行，如果能处理成功，则输出文件顺序，用空格隔开。</p><p>如果不能成功处理（相互依赖），则输出 -1。</p><p>输入示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5 4</span><br><span class="line">0 1</span><br><span class="line">0 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br></pre></td></tr></table></figure><p>输出示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4</span><br></pre></td></tr></table></figure><p>提示信息</p><p>文件依赖关系如下：</p><p><img src="https://kamacoder.com/upload/kamacoder.com/image/20240430/20240430150745_18459.png" alt="img"></p><p>所以，文件处理的顺序除了示例中的顺序，还存在</p><p>0 2 4 1 3</p><p>0 2 1 3 4</p><p>等等合法的顺序。</p><p>数据范围：</p><p>0 &lt;= N &lt;= 10 ^ 5</p><p>1 &lt;= M &lt;= 10 ^ 9</p><p>每行末尾无空格</p><h2 id="拓扑排序思路">拓扑排序思路</h2><p>拓扑排序指的是一种 解决问题的大体思路， 而具体算法，可能是广搜也可能是深搜。</p><p>大家可能发现 各式各样的解法，纠结哪个是拓扑排序？</p><p><code>其实只要能在把 有向无环图 进行线性排序 的算法 都可以叫做 拓扑排序</code>。</p><p>实现拓扑排序的算法有两种：卡恩算法（BFS）和DFS</p><blockquote><p>卡恩1962年提出这种解决拓扑排序的思路</p></blockquote><p>一般来说我们只需要掌握 BFS （广度优先搜索）就可以了，清晰易懂，如果还想多了解一些，可以再去学一下 DFS 的思路，但 DFS 不是本篇重点。</p><p>接下来我们来讲解BFS的实现思路。</p><p>以题目中示例为例如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240510110836.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240510110836.png" alt="img"></p><p>做拓扑排序的话，如果肉眼去找开头的节点，一定能找到 节点0 吧，都知道要从节点0 开始。</p><p>但为什么我们能找到 节点0呢，因为我们肉眼看着 这个图就是从 节点0出发的。</p><p>作为出发节点，它有什么特征？</p><p>你看节点0 的入度 为0 出度为2， 也就是 没有边指向它，而它有两条边是指出去的。</p><blockquote><p>节点的入度表示 有多少条边指向它，节点的出度表示有多少条边 从该节点出发。</p></blockquote><p>所以当我们做拓扑排序的时候，应该优先找 入度为 0 的节点，只有入度为0，它才是出发节点。 <strong>理解以上内容很重要</strong>！</p><p>接下来我给出 拓扑排序的过程，其实就两步：</p><ol><li>找到入度为0 的节点，加入结果集</li><li>将该节点从图中移除</li></ol><p>循环以上两步，直到 所有节点都在图中被移除了。</p><p>结果集的顺序，就是我们想要的拓扑排序顺序 （结果集里顺序可能不唯一）</p><h2 id="模拟过程">模拟过程</h2><p>用本题的示例来模拟这一过程：</p><p>1、找到入度为0 的节点，加入结果集</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240510113110.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240510113110.png" alt="img"></p><p>2、将该节点从图中移除</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240510113142.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240510113142.png" alt="img"></p><hr><p>1、找到入度为0 的节点，加入结果集</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240510113345.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240510113345.png" alt="img"></p><p>这里大家会发现，节点1 和 节点2 入度都为0， 选哪个呢？</p><p>选哪个都行，所以这也是为什么拓扑排序的结果是不唯一的。</p><p>2、将该节点从图中移除</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240510113640.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240510113640.png" alt="img"></p><hr><p>1、找到入度为0 的节点，加入结果集</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240510113853.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240510113853.png" alt="img"></p><p>节点2 和 节点3 入度都为0，选哪个都行，这里选节点2</p><p>2、将该节点从图中移除</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240510114004.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240510114004.png" alt="img"></p><hr><p>后面的过程一样的，节点3 和 节点4，入度都为0，选哪个都行。</p><p>最后结果集为： 0 1 2 3 4 。当然结果不唯一的。</p><h2 id="判断有环">判断有环</h2><p>如果有 有向环怎么办呢？例如这个图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240510115115.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240510115115.png" alt="img"></p><p>这个图，我们只能将入度为0 的节点0 接入结果集。</p><p>之后，节点1、2、3、4 形成了环，找不到入度为0 的节点了，所以此时结果集里只有一个元素。</p><p>那么如果我们发现结果集元素个数 不等于 图中节点个数，我们就可以认定图中一定有 有向环！</p><p>这也是拓扑排序判断有向环的方法。</p><p>通过以上过程的模拟大家会发现这个拓扑排序好像不难，还有点简单</p><h2 id="小技巧">小技巧</h2><ol><li>构建一个字典里是列表的结构</li></ol><p>如graph = {1:[], 2:[]}</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">graph = defaultdict(<span class="built_in">list</span>) </span><br></pre></td></tr></table></figure><ol start="2"><li>将set/list里的元素输出成str</li></ol><p>比如a = [1, 2, 3, 4]</p><p>如果直接print(a)会得到<code>[1, 2, 3, 4]</code></p><p>如果要输出<code>1, 2, 3, 4</code>，可以使用下面的代码</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot; &quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, a)))</span><br></pre></td></tr></table></figure><ol start="3"><li>对列表进行带条件的初始化</li></ol><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DgreeZero = deque([i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n) <span class="keyword">if</span> inDegree[i] == <span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>从而可以替换下面几行代码</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">  DegreeZero = deque()</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">      <span class="keyword">if</span> inDegree[i] == <span class="number">0</span>:</span><br><span class="line">          DegreeZero.append(i)</span><br></pre></td></tr></table></figure><h2 id="拓扑排序代码">拓扑排序代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">    inDegree = [<span class="number">0</span>] * (n)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># from collections import defaultdict</span></span><br><span class="line">    <span class="comment"># graph = defaultdict(list) # 可以构建一个字典里是列表的结构</span></span><br><span class="line">    graph = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># edges = list()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        s, t = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        inDegree[t] += <span class="number">1</span>     </span><br><span class="line">        graph[s].append(t)  </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将入度为0的节点添加到队列里，后面准备使用广度优先搜索对这些节点遍历 </span></span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">    DegreeZero = deque()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> inDegree[i] == <span class="number">0</span>:</span><br><span class="line">            DegreeZero.append(i)</span><br><span class="line">            </span><br><span class="line">    <span class="comment"># 上面四行代码可以简化为</span></span><br><span class="line">    <span class="comment"># DgreeZero = deque([i for i in range(n) if inDegree[i] == 0])</span></span><br><span class="line"></span><br><span class="line">    res = <span class="built_in">list</span>()</span><br><span class="line">    <span class="comment"># 从入度为0的节点开始</span></span><br><span class="line">    <span class="keyword">while</span> DegreeZero:</span><br><span class="line">        node = DegreeZero.popleft()</span><br><span class="line">        res.append(<span class="built_in">str</span>(node))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将入度为0节点的终点节点入度减一</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> graph[node]:</span><br><span class="line">            inDegree[i] -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 如果入度为0了，也加入到队列中</span></span><br><span class="line">            <span class="keyword">if</span> inDegree[i] == <span class="number">0</span>:</span><br><span class="line">                DegreeZero.append(i)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断是否有环，如果res的长度不等于图中节点个数n则有环</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(res) != n:</span><br><span class="line">        <span class="built_in">print</span>(-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>.join(res))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 技巧二，使用map将字典里的数字变成字符串</span></span><br><span class="line">    <span class="comment"># print(&quot; &quot;.join(map(str, res)))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h1 id="47-参加科学大会-第六期模拟笔试">47.参加科学大会（第六期模拟笔试）</h1><p>题目描述</p><p>小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。</p><p>小明的起点是第一个车站，终点是最后一个车站。然而，途中的各个车站之间的道路状况、交通拥堵程度以及可能的自然因素（如天气变化）等不同，这些因素都会影响每条路径的通行时间。</p><p>小明希望能选择一条花费时间最少的路线，以确保他能够尽快到达目的地。</p><p>输入描述</p><p>第一行包含两个正整数，第一个正整数 N 表示一共有 N 个公共汽车站，第二个正整数 M 表示有 M 条公路。</p><p>接下来为 M 行，每行包括三个整数，S、E 和 V，代表了从 S 车站可以单向直达 E 车站，并且需要花费 V 单位的时间。</p><p>输出描述</p><p>输出一个整数，代表小明从起点到终点所花费的最小时间。</p><p>输入示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">7 9</span><br><span class="line">1 2 1</span><br><span class="line">1 3 4</span><br><span class="line">2 3 2</span><br><span class="line">2 4 5</span><br><span class="line">3 4 2</span><br><span class="line">4 5 3</span><br><span class="line">2 6 4</span><br><span class="line">5 7 4</span><br><span class="line">6 7 9</span><br></pre></td></tr></table></figure><p>输出示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure><p>提示信息</p><p><strong>能够到达的情况：</strong></p><p>如下图所示，起始车站为 1 号车站，终点车站为 7 号车站，绿色路线为最短的路线，路线总长度为 12，则输出 12。</p><p><img src="https://kamacoder.com/upload/kamacoder.com/image/20240122/20240122163716_71030.png" alt="img"></p><p>**<br>**</p><p><strong>不能到达的情况：</strong></p><p>如下图所示，当从起始车站不能到达终点车站时，则输出 -1。</p><p><img src="https://kamacoder.com/upload/kamacoder.com/image/20240125/20240125154052_26956.png" alt="img"></p><p>数据范围：</p><p>1 &lt;= N &lt;= 500;<br>1 &lt;= M &lt;= 5000;</p><h2 id="dijkstra思路">dijkstra思路</h2><h3 id="模拟过程">模拟过程</h3><hr><p>0、初始化</p><p>minDist数组数值初始化为int最大值。</p><p>这里在强点一下 <strong>minDist数组的含义：记录所有节点到源点的最短路径</strong>，那么初始化的时候就应该初始为最大值，这样才能在后续出现最短路径的时候及时更新。</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240130115306.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240130115306.png" alt="img"></p><p>（图中，max 表示默认值，节点0 不做处理，统一从下标1 开始计算，这样下标和节点数值统一， 方便大家理解，避免搞混）</p><p>源点（节点1） 到自己的距离为0，所以 minDist[1] = 0</p><p>此时所有节点都没有被访问过，所以 visited数组都为0</p><hr><p>以下为dijkstra 三部曲</p><p>1、选源点到哪个节点近且该节点未被访问过</p><p>源点距离源点最近，距离为0，且未被访问。</p><p>2、该最近节点被标记访问过</p><p>标记源点访问过</p><p>3、更新非访问节点到源点的距离（即更新minDist数组） ，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240130115421.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240130115421.png" alt="img"></p><p>更新 minDist数组，即：源点（节点1） 到 节点2 和 节点3的距离。</p><ul><li>源点到节点2的最短距离为1，小于原minDist[2]的数值max，更新minDist[2] = 1</li><li>源点到节点3的最短距离为4，小于原minDist[3]的数值max，更新minDist[3] = 4</li></ul><p>可能有录友问：为啥和 minDist[2] 比较？</p><p>再强调一下 minDist[2] 的含义，它表示源点到节点2的最短距离，那么目前我们得到了 源点到节点2的最短距离为1，小于默认值max，所以更新。 minDist[3]的更新同理</p><hr><p>1、选源点到哪个节点近且该节点未被访问过</p><p>未访问过的节点中，源点到节点2距离最近，选节点2</p><p>2、该最近节点被标记访问过</p><p>节点2被标记访问过</p><p>3、更新非访问节点到源点的距离（即更新minDist数组） ，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240130121240.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240130121240.png" alt="img"></p><p>更新 minDist数组，即：源点（节点1） 到 节点6 、 节点3 和 节点4的距离。</p><p><strong>为什么更新这些节点呢？ 怎么不更新其他节点呢</strong>？</p><p>因为 源点（节点1）通过 已经计算过的节点（节点2） 可以链接到的节点 有 节点3，节点4和节点6.</p><p>更新 minDist数组：</p><ul><li>源点到节点6的最短距离为5，小于原minDist[6]的数值max，更新minDist[6] = 5</li><li>源点到节点3的最短距离为3，小于原minDist[3]的数值4，更新minDist[3] = 3</li><li>源点到节点4的最短距离为6，小于原minDist[4]的数值max，更新minDist[4] = 6</li></ul><hr><p>1、选源点到哪个节点近且该节点未被访问过</p><p>未访问过的节点中，源点距离哪些节点最近，怎么算的？</p><p>其实就是看 minDist数组里的数值，minDist 记录了 源点到所有节点的最近距离，结合visited数组筛选出未访问的节点就好。</p><p>从 上面的图，或者 从minDist数组中，我们都能看出 未访问过的节点中，源点（节点1）到节点3距离最近。</p><p>2、该最近节点被标记访问过</p><p>节点3被标记访问过</p><p>3、更新非访问节点到源点的距离（即更新minDist数组） ，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240130120434.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240130120434.png" alt="img"></p><p>由于节点3的加入，那么源点可以有新的路径链接到节点4 所以更新minDist数组：</p><p>更新 minDist数组：</p><ul><li>源点到节点4的最短距离为5，小于原minDist[4]的数值6，更新minDist[4] = 5</li></ul><hr><p>1、选源点到哪个节点近且该节点未被访问过</p><p>距离源点最近且没有被访问过的节点，有节点4 和 节点6，距离源点距离都是 5 （minDist[4] = 5，minDist[6] = 5） ，选哪个节点都可以。</p><p>2、该最近节点被标记访问过</p><p>节点4被标记访问过</p><p>3、更新非访问节点到源点的距离（即更新minDist数组） ，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240201105335.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240201105335.png" alt="img"></p><p>由于节点4的加入，那么源点可以链接到节点5 所以更新minDist数组：</p><ul><li>源点到节点5的最短距离为8，小于原minDist[5]的数值max，更新minDist[5] = 8</li></ul><hr><p>1、选源点到哪个节点近且该节点未被访问过</p><p>距离源点最近且没有被访问过的节点，是节点6，距离源点距离是 5 （minDist[6] = 5）</p><p>2、该最近节点被标记访问过</p><p>节点6 被标记访问过</p><p>3、更新非访问节点到源点的距离（即更新minDist数组） ，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240201110250.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240201110250.png" alt="img"></p><p>由于节点6的加入，那么源点可以链接到节点7 所以 更新minDist数组：</p><ul><li>源点到节点7的最短距离为14，小于原minDist[7]的数值max，更新minDist[7] = 14</li></ul><hr><p>1、选源点到哪个节点近且该节点未被访问过</p><p>距离源点最近且没有被访问过的节点，是节点5，距离源点距离是 8 （minDist[5] = 8）</p><p>2、该最近节点被标记访问过</p><p>节点5 被标记访问过</p><p>3、更新非访问节点到源点的距离（即更新minDist数组） ，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240201110651.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240201110651.png" alt="img"></p><p>由于节点5的加入，那么源点有新的路径可以链接到节点7 所以 更新minDist数组：</p><ul><li>源点到节点7的最短距离为12，小于原minDist[7]的数值14，更新minDist[7] = 12</li></ul><hr><p>1、选源点到哪个节点近且该节点未被访问过</p><p>距离源点最近且没有被访问过的节点，是节点7（终点），距离源点距离是 12 （minDist[7] = 12）</p><p>2、该最近节点被标记访问过</p><p>节点7 被标记访问过</p><p>3、更新非访问节点到源点的距离（即更新minDist数组） ，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240201110920.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240201110920.png" alt="img"></p><p>节点7加入，但节点7到节点7的距离为0，所以 不用更新minDist数组</p><hr><p>最后我们要求起点（节点1） 到终点 （节点7）的距离。</p><p>再来回顾一下minDist数组的含义：记录 每一个节点距离源点的最小距离。</p><p>那么起到（节点1）到终点（节点7）的最短距离就是 minDist[7] ，按上面举例讲解来说，minDist[7] = 12，节点1 到节点7的最短路径为 12。</p><p>路径如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240201111352.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240201111352.png" alt="img"></p><p>在上面的讲解中，每一步 我都是按照 dijkstra 三部曲来讲解的，理解了这三部曲，代码也就好懂的</p><h2 id="dijkstra代码">dijkstra代码</h2><ul><li>时间复杂度O(N2)</li><li>空间复杂度O(N2)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">    graph = [[<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">    graphDict = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        s, t, v = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        graph[s][t] = v</span><br><span class="line">        graphDict[s].append(t)</span><br><span class="line"></span><br><span class="line">    visited = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    minDist = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * (n + <span class="number">1</span>)</span><br><span class="line">    minDist[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    parent = [-<span class="number">1</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>):</span><br><span class="line">        lowest = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        node = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> visited[j] == <span class="number">0</span> <span class="keyword">and</span> minDist[j] &lt; lowest:</span><br><span class="line">                lowest = minDist[j]</span><br><span class="line">                node = j</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> node == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        visited[node] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># for t in range(n + 1):  # 在prim算法里，因为prim是全局贪心算法，所以需要对所有节点遍历</span></span><br><span class="line">        <span class="comment"># 而本算法里，只能对node的相邻节点进行遍历</span></span><br><span class="line">        <span class="comment"># 我是使用了graphDict只存储与node相邻的节点</span></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> graphDict[node]:</span><br><span class="line">            <span class="keyword">if</span> visited[t] == <span class="number">0</span> <span class="keyword">and</span> minDist[t] &gt; graph[node][t]:</span><br><span class="line">                <span class="comment"># 在prim算法里，这里会直接等于graph[node][t]</span></span><br><span class="line">                <span class="comment"># prim是求 非访问节点到最小生成树的最小距离，而 dijkstra是求 非访问节点到源点的最小距离。</span></span><br><span class="line">                <span class="comment"># 而本算法，需要判断是否值得更新（graph[node][t] + minDist[node]相当于绕路到node再到t）</span></span><br><span class="line">                minDist[t] = <span class="built_in">min</span>(graph[node][t] + minDist[node], minDist[t])</span><br><span class="line">                <span class="comment"># parent用来记录边，注意，不能写成parent[node] = t，因为一个node可能会指向多个t，后面的数据会将前面覆盖</span></span><br><span class="line">                parent[t] = node</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 或者对n+1遍历，但在条件里添加一个graph[node][t] != float(&#x27;inf)，达到同样只对node相邻的节点遍历的效果</span></span><br><span class="line">        <span class="comment"># for t in range(n + 1):</span></span><br><span class="line">        <span class="comment">#     if visited[t] == 0 and minDist[t] &gt; graph[node][t] and graph[node][t] != float(&#x27;inf&#x27;):</span></span><br><span class="line">        <span class="comment">#         minDist[t] = min(graph[node][t] + minDist[node], minDist[t])</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(parent)</span><br><span class="line">    <span class="built_in">print</span>(minDist[-<span class="number">1</span>] <span class="keyword">if</span> minDist[-<span class="number">1</span>] != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> -<span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="dijkstra记录边">dijkstra记录边</h2><p>初始化一个数组用来记录当前节点的先驱节点</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent = [-<span class="number">1</span>] * (n + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>在发生数值更新时记录边，注意一定要是parent[t] = node，而不是parent[node] = t，因为一个node可能会对应多个t，后面的数据可能会将前面的覆盖掉</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> graphDict[node]:</span><br><span class="line">    <span class="keyword">if</span> visited[t] == <span class="number">0</span> <span class="keyword">and</span> minDist[t] &gt; graph[node][t]:</span><br><span class="line">        minDist[t] = <span class="built_in">min</span>(graph[node][t] + minDist[node], minDist[t])</span><br><span class="line">        parent[t] = node</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday58图论part08&quot;&gt;LeetCodeCampsDay58图论part08&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;拓扑排序与dijkstra初识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;117-软件构建&quot;&gt;117.</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay57图论part07</title>
    <link href="https://blog.lthero.cn/2025/08/23/LeetCodeCampsDay57/"/>
    <id>https://blog.lthero.cn/2025/08/23/LeetCodeCampsDay57/</id>
    <published>2025-08-23T15:32:14.000Z</published>
    <updated>2025-08-25T08:35:37.230Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday57图论part07">LeetCodeCampsDay57图论part07</h1><blockquote><p>最小生成树算法</p><p>分别使用Prim算法和Kruscal算法</p><p><strong>prim 算法是维护节点的集合，而 Kruskal 是维护边的集合</strong>。</p></blockquote><h1 id="53-寻宝-第七期模拟笔试">53.寻宝（第七期模拟笔试）</h1><p>题目描述</p><p>在世界的某个区域，有一些分散的神秘岛屿，每个岛屿上都有一种珍稀的资源或者宝藏。国王打算在这些岛屿上建公路，方便运输。</p><p>不同岛屿之间，路途距离不同，国王希望你可以规划建公路的方案，如何可以以最短的总公路距离将 所有岛屿联通起来（注意：这是一个无向图）。</p><p>给定一张地图，其中包括了所有的岛屿，以及它们之间的距离。以最小化公路建设长度，确保可以链接到所有岛屿。</p><p>输入描述</p><p>第一行包含两个整数V 和 E，V代表顶点数，E代表边数 。顶点编号是从1到V。例如：V=2，一个有两个顶点，分别是1和2。</p><p>接下来共有 E 行，每行三个整数 v1，v2 和 val，v1 和 v2 为边的起点和终点，val代表边的权值。</p><p>输出描述</p><p>输出联通所有岛屿的最小路径总距离</p><p>输入示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">7 11</span><br><span class="line">1 2 1</span><br><span class="line">1 3 1</span><br><span class="line">1 5 2</span><br><span class="line">2 6 1</span><br><span class="line">2 4 2</span><br><span class="line">2 3 2</span><br><span class="line">3 4 1</span><br><span class="line">4 5 1</span><br><span class="line">5 6 2</span><br><span class="line">5 7 1</span><br><span class="line">6 7 1</span><br></pre></td></tr></table></figure><p>输出示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><p>提示信息</p><p>数据范围：<br>2 &lt;= V &lt;= 10000;<br>1 &lt;= E &lt;= 100000;<br>0 &lt;= val &lt;= 10000;</p><p>如下图，可见将所有的顶点都访问一遍，总距离最低是6.</p><p><img src="https://kamacoder.com/upload/kamacoder.com/image/20230919/20230919201506_90440.png" alt="img"></p><h2 id="prim算法精讲">prim算法精讲</h2><p>本题是最小生成树的模板题，那么我们来讲一讲最小生成树。</p><p>最小生成树可以使用prim算法也可以使用kruskal算法计算出来。</p><p>本篇我们先讲解prim算法。</p><p>最小生成树是所有节点的最小连通子图，即：以最小的成本（边的权值）将图中所有节点链接到一起。</p><p>图中有n个节点，那么一定可以用n-1条边将所有节点连接到一起。</p><p>那么如何选择这n-1条边就是最小生成树算法的任务所在。</p><p>例如本题示例中的无向有权图为：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20231206164306.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20231206164306.png" alt="img"></p><p>那么在这个图中，如何选取n-1条边使得图中所有节点连接到一起，并且边的权值和最小呢？</p><p>（图中为n为7，即7个节点，那么只需要n-1即6条边就可以讲所有顶点连接到一起）</p><p>prim算法是从节点的角度采用贪心的策略每次寻找距离最小生成树最近的节点并加入到最小生成树中。</p><p>prim算法核心就是三步，我称为<strong>prim三部曲</strong>，大家一定要熟悉这三步，代码相对会好些很多：</p><ol><li>第一步，选距离生成树最近节点</li><li>第二步，最近节点加入生成树</li><li>第三步，更新非生成树节点到生成树的距离（即更新minDist数组）</li></ol><p>现在录友们会对这三步很陌生，不知道这是干啥的，没关系，下面将会画图举例来带大家把这<strong>prim三部曲</strong>理解到位。</p><p>在prim算法中，有一个数组特别重要，这里我起名为：minDist。</p><p>刚刚我有讲过“每次寻找距离最小生成树最近的节点并加入到最小生成树中”，那么如何寻找距离最小生成树最近的节点呢？</p><p>这就用到了minDist数组，它用来作什么呢？</p><p><strong>minDist数组用来记录每一个节点距离最小生成树的最近距离</strong>。理解这一点非常重要，这也是prim算法最核心要点所在，很多录友看不懂prim算法的代码，都是因为没有理解透这个数组的含义。</p><p>接下来，我们来通过一步一步画图，来带大家巩固<strong>prim三部曲</strong>以及minDist数组的作用。</p><p>（<strong>示例中节点编号是从1开始，所以为了让大家看的不晕，minDist数组下标我也从1开始计数，下标0就不使用了，这样下标和节点标号就可以对应上了，避免大家搞混</strong>）</p><h3 id="1-初始状态">1 初始状态</h3><p>minDist数组里的数值初始化为最大数，因为本题节点距离不会超过10000，所以初始化最大数为10001就可以。</p><p>相信这里录友就要问了，为什么这么做？</p><p>现在还没有最小生成树，默认每个节点距离最小生成树是最大的，这样后面我们在比较的时候，发现更近的距离，才能更新到minDist数组上。</p><p>如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20231215105603.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20231215105603.png" alt="img"></p><p>开始构造最小生成树</p><h3 id="2">2</h3><p>1、prim三部曲，第一步：选距离生成树最近节点</p><p>选择距离最小生成树最近的节点，加入到最小生成树，刚开始还没有最小生成树，所以随便选一个节点加入就好（因为每一个节点一定会在最小生成树里，所以随便选一个就好），那我们选择节点1（符合遍历数组的习惯，第一个遍历的也是节点1）</p><p>2、prim三部曲，第二步：最近节点加入生成树</p><p>此时节点1已经算最小生成树的节点。</p><p>3、prim三部曲，第三步：更新非生成树节点到生成树的距离（即更新minDist数组）</p><p>接下来，我们要更新所有节点距离最小生成树的距离，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20231222102048.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20231222102048.png" alt="img"></p><p>注意下标0，我们就不管它了，下标1与节点1对应，这样可以避免大家把节点搞混。</p><p>此时所有非生成树的节点距离最小生成树（节点1）的距离都已经跟新了。</p><ul><li>节点2与节点1的距离为1，比原先的距离值10001小，所以更新minDist[2]。</li><li>节点3和节点1的距离为1，比原先的距离值10001小，所以更新minDist[3]。</li><li>节点5和节点1的距离为2，比原先的距离值10001小，所以更新minDist[5]。</li></ul><p><strong>注意图中我标记了minDist数组里更新的权值</strong>，是哪两个节点之间的权值，例如minDist[2]=1，这个1是节点1与节点2之间的连线，清楚这一点对最后我们记录最小生成树的权值总和很重要。</p><p>（我在后面依然会不断重复prim三部曲，可能基础好的录友会感觉有点啰嗦，但也是让大家感觉这三部曲求解的过程）</p><h3 id="3">3</h3><p>1、prim三部曲，第一步：选距离生成树最近节点</p><p>选取一个距离最小生成树（节点1）最近的非生成树里的节点，节点2，3，5距离最小生成树（节点1）最近，选节点2（其实选节点3或者节点2都可以，距离一样的）加入最小生成树。</p><p>2、prim三部曲，第二步：最近节点加入生成树</p><p>此时节点1和节点2，已经算最小生成树的节点。</p><p>3、prim三部曲，第三步：更新非生成树节点到生成树的距离（即更新minDist数组）</p><p>接下来，我们要更新节点距离最小生成树的距离，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20231222102431.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20231222102431.png" alt="img"></p><p>此时所有非生成树的节点距离最小生成树（节点1、节点2）的距离都已经跟新了。</p><ul><li>节点3和节点2的距离为2，和原先的距离值1小，所以不用更新。</li><li>节点4和节点2的距离为2，比原先的距离值10001小，所以更新minDist[4]。</li><li>节点5和节点2的距离为10001（不连接），所以不用更新。</li><li>节点6和节点2的距离为1，比原先的距离值10001小，所以更新minDist[6]。</li></ul><h3 id="4">4</h3><p>1、prim三部曲，第一步：选距离生成树最近节点</p><p>选择一个距离最小生成树（节点1、节点2）最近的非生成树里的节点，节点3，6距离最小生成树（节点1、节点2）最近，选节点3（选节点6也可以，距离一样）加入最小生成树。</p><p>2、prim三部曲，第二步：最近节点加入生成树</p><p>此时节点1、节点2、节点3算是最小生成树的节点。</p><p>3、prim三部曲，第三步：更新非生成树节点到生成树的距离（即更新minDist数组）</p><p>接下来更新节点距离最小生成树的距离，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20231222102457.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20231222102457.png" alt="img"></p><p>所有非生成树的节点距离最小生成树（节点1、节点2、节点3）的距离都已经跟新了。</p><ul><li>节点4和节点3的距离为1，和原先的距离值2小，所以更新minDist[4]为1。</li></ul><p>上面为什么我们只比较节点4和节点3的距离呢？</p><p>因为节点3加入最小生成树后，非生成树节点只有节点4和节点3是链接的，所以需要重新更新一下节点4距离最小生成树的距离，其他节点距离最小生成树的距离都不变。</p><h3 id="5">5</h3><p>1、prim三部曲，第一步：选距离生成树最近节点</p><p>继续选择一个距离最小生成树（节点1、节点2、节点3）最近的非生成树里的节点，为了巩固大家对minDist数组的理解，这里我再啰嗦一遍：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20231217213516.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20231217213516.png" alt="img"></p><p><strong>minDist数组是记录了所有非生成树节点距离生成树的最小距离</strong>，所以从数组里我们能看出来，非生成树节点4和节点6距离生成树最近。</p><p>任选一个加入生成树，我们选节点4（选节点6也行）。</p><p><strong>注意</strong>，我们根据minDist数组，选取距离生成树最近的节点加入生成树，那么<strong>minDist数组里记录的其实也是最小生成树的边的权值</strong>（我在图中把权值对应的是哪两个节点也标记出来了）。</p><p>如果大家不理解，可以跟着我们下面的讲解，看minDist数组的变化，minDist数组里记录的权值对应的哪条边。</p><p>理解这一点很重要，因为最后我们要求最小生成树里所有边的权值和。</p><p>2、prim三部曲，第二步：最近节点加入生成树</p><p>此时节点1、节点2、节点3、节点4算是最小生成树的节点。</p><p>3、prim三部曲，第三步：更新非生成树节点到生成树的距离（即更新minDist数组）</p><p>接下来更新节点距离最小生成树的距离，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20231222102618.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20231222102618.png" alt="img"></p><p>minDist数组已经更新了所有非生成树的节点距离最小生成树（节点1、节点2、节点3、节点4）的距离。</p><ul><li>节点5和节点4的距离为1，和原先的距离值2小，所以更新minDist[5]为1。</li></ul><h3 id="6">6</h3><p>1、prim三部曲，第一步：选距离生成树最近节点</p><p>继续选距离最小生成树（节点1、节点2、节点3、节点4）最近的非生成树里的节点，只有节点5和节点6。</p><p>选节点5（选节点6也可以）加入生成树。</p><p>2、prim三部曲，第二步：最近节点加入生成树</p><p>节点1、节点2、节点3、节点4、节点5算是最小生成树的节点。</p><p>3、prim三部曲，第三步：更新非生成树节点到生成树的距离（即更新minDist数组）</p><p>接下来更新节点距离最小生成树的距离，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20231222102646.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20231222102646.png" alt="img"></p><p>minDist数组已经更新了所有非生成树的节点距离最小生成树（节点1、节点2、节点3、节点4、节点5）的距离。</p><ul><li>节点6和节点5距离为2，比原先的距离值1大，所以不更新</li><li>节点7和节点5距离为1，比原先的距离值10001小，更新minDist[7]</li></ul><h3 id="7">7</h3><p>1、prim三部曲，第一步：选距离生成树最近节点</p><p>继续选距离最小生成树（节点1、节点2、节点3、节点4、节点5）最近的非生成树里的节点，只有节点6和节点7。</p><p>2、prim三部曲，第二步：最近节点加入生成树</p><p>选节点6（选节点7也行，距离一样的）加入生成树。</p><p>3、prim三部曲，第三步：更新非生成树节点到生成树的距离（即更新minDist数组）</p><p>节点1、节点2、节点3、节点4、节点5、节点6算是最小生成树的节点，接下来更新节点距离最小生成树的距离，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20231222102732.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20231222102732.png" alt="img"></p><p>这里就不在重复描述了，大家类推，最后，节点7加入生成树，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20231222102820.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20231222102820.png" alt="img"></p><h3 id="最后">最后</h3><p>最后我们就生成了一个最小生成树，绿色的边将所有节点链接到一起，并且保证权值是最小的，因为我们在更新minDist数组的时候，都是选距离最小生成树最近的点加入到树中。</p><p>讲解上面的模拟过程的时候，我已经强调多次minDist数组是记录了所有非生成树节点距离生成树的最小距离。</p><p>最后，minDist数组也就是记录的是最小生成树所有边的权值。</p><p>我在图中，特别把每条边的权值对应的是哪两个节点标记出来（例如minDist[7]=1，对应的是节点5和节点7之间的边，而不是节点6和节点7），为了就是让大家清楚，minDist里的每一个值对应的是哪条边。</p><p>那么我们要求最小生成树里边的权值总和就是把最后的minDist数组累加一起。</p><p>以下代码，我对prim三部曲，做了重点注释，大家根据这三步，就可以透彻理解prim。</p><h2 id="prim代码">Prim代码</h2><ul><li>时间复杂度O(N^2)</li><li>空间复杂度O(N^2)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    v, e = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    graph = [[<span class="number">10001</span>] * (v + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(v + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(e):</span><br><span class="line">        s, t, w = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        graph[s][t] = w</span><br><span class="line">        graph[t][s] = w</span><br><span class="line">    </span><br><span class="line">    visited = [<span class="number">0</span>] * (v + <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># visited[1] = 1</span></span><br><span class="line">    minDist = [<span class="number">10001</span>] * (v + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 选择距离生成树最近节点</span></span><br><span class="line">    <span class="comment"># 最近节点加入生成树</span></span><br><span class="line">    <span class="comment"># 更新非生成树节点到生成树的距离</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># i表示起点</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, v + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># lowestDist记录全局里距离生成树最近的距离，每次都要初始化为10002最大值</span></span><br><span class="line">        lowestDist = <span class="number">10002</span></span><br><span class="line">        <span class="comment"># 用来存放离生成树最近的节点</span></span><br><span class="line">        node = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 选择距离生成树最近的节点（j表示终点）</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, v + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> visited[j] == <span class="number">0</span> <span class="keyword">and</span> minDist[j] &lt; lowestDist:</span><br><span class="line">                lowestDist = minDist[j]</span><br><span class="line">                <span class="comment"># 表示node是距离生成树最近的节点</span></span><br><span class="line">                node = j</span><br><span class="line">                <span class="comment"># print(node, minDist[node])</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 最近节点node加入生成树</span></span><br><span class="line">        visited[node] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 更新非生成树节点到生成树的距离</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, v + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> visited[j] == <span class="number">0</span> <span class="keyword">and</span> graph[node][j] &lt; minDist[j]:</span><br><span class="line">                minDist[j] = graph[node][j]</span><br><span class="line">                <span class="comment"># print(graph[node][j])</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># print(visited)</span></span><br><span class="line">    <span class="comment"># print(minDist)</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, v + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> visited[i] == <span class="number">1</span>:</span><br><span class="line">            res += minDist[i]</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="prim记录边">Prim记录边</h2><p>上面讲解的是记录了最小生成树所有边的权值，如果让打印出来最小生成树的每条边呢？或者说要把这个最小生成树画出来呢？</p><p>此时我们就需要把最小生成树里每一条边记录下来。</p><p>此时有两个问题：</p><ul><li>1、用什么结构来记录</li><li>2、如何记录</li></ul><p>如果记录边，其实就是记录两个节点就可以，两个节点连成一条边。</p><p>如何记录两个节点呢？</p><p>我们使用一维数组就可以记录。parent[节点编号] = 节点编号，这样就把一条边记录下来了。（当然如果节点编号非常大，可以考虑使用map）</p><p>使用一维数组记录是有向边，不过我们这里不需要记录方向，所以只关注两条边是连接的就行。</p><p>parent数组初始化代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">parent</span><span class="params">(v + <span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>接下来就是第二个问题，如何记录？</p><p>我们再来回顾一下prim三部曲，</p><ol><li>第一步，选距离生成树最近节点</li><li>第二步，最近节点加入生成树</li><li>第三步，更新非生成树节点到生成树的距离（即更新minDist数组）</li></ol><p>大家先思考一下，我们是在第几步，可以记录最小生成树的边呢？</p><p>在本面上半篇我们讲解过：“我们根据minDist数组，选组距离生成树最近的节点加入生成树，那么<strong>minDist数组里记录的其实也是最小生成树的边的权值</strong>。”</p><p>既然minDist数组记录了最小生成树的边，是不是就是在更新minDist数组的时候，去更新parent数组来记录一下对应的边呢。</p><p>所以在prim三部曲中的第三步，更新parent数组，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= v; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isInTree[j] &amp;&amp; grid[cur][j] &lt; minDist[j]) &#123;</span><br><span class="line">        minDist[j] = grid[cur][j];</span><br><span class="line">        parent[j] = cur; <span class="comment">// 记录最小生成树的边 （注意数组指向的顺序很重要）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中注释中，我强调了数组指向的顺序很重要。因为不少录友在这里会写成这样： <code>parent[cur] = j</code> 。</p><p>这里估计大家会疑惑了，parent[节点编号A] = 节点编号B，就表示A和B相连，我们这里就不用在意方向，代码中为什么只能 <code>parent[j] = cur</code> 而不能 <code>parent[cur] = j</code> 这么写呢？</p><p>如果写成 <code>parent[cur] = j</code>，在for循环中，有多个j满足要求，那么 parent[cur] 就会被反复覆盖，因为cur是一个固定值。</p><p>举个例子，cur=1，在for循环中，可能就j=2，j=3，j=4都符合条件，那么本来应该记录节点1与节点2、节点3、节点4相连的。</p><p>如果 <code>parent[cur] = j</code> 这么写，最后更新的逻辑是 parent[1] = 2, parent[1] = 3， parent[1] = 4，最后只能记录节点1与节点4相连，其他相连情况都被覆盖了。</p><p>如果这么写 <code>parent[j] = cur</code>，那就是 parent[2] = 1, parent[3] = 1， parent[4] = 1 ，这样才能完整表示出节点1与其他节点都是链接的，才没有被覆盖。</p><p>主要问题也是我们使用了一维数组来记录。</p><p>如果是二维数组，来记录两个点链接，例如 parent[节点编号A][节点编号B] = 1 ，parent[节点编号B][节点编号A] = 1，来表示节点A与节点B相连，那就没有上面说的这个注意事项了，当然这么做的话，就是多开辟的内存空间。</p><h2 id="kruskal思路">Kruskal思路</h2><p>在上一篇 我们讲解了 prim算法求解 最小生成树，本篇我们来讲解另一个算法：Kruskal，同样可以求最小生成树。</p><p><strong>prim 算法是维护节点的集合，而 Kruskal 是维护边的集合</strong>。</p><p>上来就这么说，大家应该看不太懂，这里是先让大家有这么个印象，带着这个印象在看下文，理解的会更到位一些。</p><p>kruscal的思路：</p><ul><li>边的权值排序，因为要优先选最小的边加入到生成树里</li><li>遍历排序后的边<ul><li>如果边首尾的两个节点在同一个集合，说明如果连上这条边图中会出现环</li><li>如果边首尾的两个节点不在同一个集合，加入到最小生成树，并把两个节点加入同一个集合</li></ul></li></ul><p>下面我们画图举例说明kruscal的工作过程。</p><p>依然以示例中，如下这个图来举例。</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240111113514.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240111113514.png" alt="img"></p><p>将图中的边按照权值有小到大排序，这样从贪心的角度来说，优先选 权值小的边加入到 最小生成树中。</p><p>排序后的边顺序为[(1,2) (4,5) (1,3) (2,6) (3,4) (6,7) (5,7) (1,5) (3,2) (2,4) (5,6)]</p><blockquote><p>(1,2) 表示节点1 与 节点2 之间的边。权值相同的边，先后顺序无所谓。</p></blockquote><p><strong>开始从头遍历排序后的边</strong>。</p><hr><p>选边(1,2)，节点1 和 节点2 不在同一个集合，所以生成树可以添加边(1,2)，并将 节点1，节点2 放在同一个集合。</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240111114204.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240111114204.png" alt="img"></p><hr><p>选边(4,5)，节点4 和 节点 5 不在同一个集合，生成树可以添加边(4,5) ，并将节点4，节点5 放到同一个集合。</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240111120458.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240111120458.png" alt="img"></p><p><strong>大家判断两个节点是否在同一个集合，就看图中两个节点是否有绿色的粗线连着就行</strong></p><hr><p>（这里在强调一下，以下选边是按照上面排序好的边的数组来选择的）</p><p>选边(1,3)，节点1 和 节点3 不在同一个集合，生成树添加边(1,3)，并将节点1，节点3 放到同一个集合。</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240112105834.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240112105834.png" alt="img"></p><hr><p>选边(2,6)，节点2 和 节点6 不在同一个集合，生成树添加边(2,6)，并将节点2，节点6 放到同一个集合。</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240112110214.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240112110214.png" alt="img"></p><hr><p>选边(3,4)，节点3 和 节点4 不在同一个集合，生成树添加边(3,4)，并将节点3，节点4 放到同一个集合。</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240112110450.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240112110450.png" alt="img"></p><hr><p>选边(6,7)，节点6 和 节点7 不在同一个集合，生成树添加边(6,7)，并将 节点6，节点7 放到同一个集合。</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240112110637.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240112110637.png" alt="img"></p><hr><p>选边(5,7)，节点5 和 节点7 在同一个集合，不做计算。</p><p>选边(1,5)，两个节点在同一个集合，不做计算。</p><p>后面遍历 边(3,2)，(2,4)，(5,6) 同理，都因两个节点已经在同一集合，不做计算。</p><hr><p>此时 我们就已经生成了一个最小生成树，即：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240112110637-20250824234540717.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240112110637.png" alt="img"></p><p>在上面的讲解中，看图的话 大家知道如何判断 两个节点 是否在同一个集合（是否有绿色的线连在一起），以及如何把两个节点加入集合（就在图中把两个节点连上）</p><p><strong>但在代码中，如果将两个节点加入同一个集合，又如何判断两个节点是否在同一个集合呢</strong>？</p><p>这里就涉及到我们之前讲解的<a href="https://www.programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">并查集</a>。</p><p>我们在并查集开篇的时候就讲了，并查集主要就两个功能：</p><ul><li>将两个元素添加到一个集合中</li><li>判断两个元素在不在同一个集合</li></ul><p>大家发现这正好符合 Kruskal算法的需求，这也是为什么 <strong>我要先讲并查集，再讲 Kruskal</strong>。</p><h2 id="kruskal代码">Kruskal代码</h2><ul><li>时间复杂度：nlogn （快排） + logn （并查集） ，所以最后依然是 nlogn 。n为边的数量。</li><li>空间复杂度O(n)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, l, r, val</span>):</span><br><span class="line">        self.l = l</span><br><span class="line">        self.r = r</span><br><span class="line">        self.val = val</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n</span>):</span><br><span class="line">        self.parent = <span class="built_in">list</span>(<span class="built_in">range</span>(n + <span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 递归搜索时间复杂度logn</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, u</span>):</span><br><span class="line">        <span class="keyword">if</span> self.parent[u] != u:</span><br><span class="line">            self.parent[u] = self.find(self.parent[u]) <span class="comment"># 路径压缩</span></span><br><span class="line">        <span class="keyword">return</span> self.parent[u]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">join</span>(<span class="params">self, u, v</span>):</span><br><span class="line">        rootU = self.find(u)</span><br><span class="line">        rootV = self.find(v)</span><br><span class="line">        <span class="keyword">if</span> rootU != rootV:</span><br><span class="line">            self.parent[v] = rootU</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSame</span>(<span class="params">self, u, v</span>):</span><br><span class="line">        <span class="keyword">return</span> self.find(u) == self.find(v)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    v, e = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 需要有“点-边”对应关系，使用字典</span></span><br><span class="line">    edges = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(e):</span><br><span class="line">        s, t, w = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        edges.append(Edge(s, t, w))</span><br><span class="line"></span><br><span class="line">    edges.sort(key = <span class="keyword">lambda</span> edge: edge.val)</span><br><span class="line">    </span><br><span class="line">    union = UnionFind(v)</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="comment"># edge结构为(&#x27;1 2&#x27;, 1) </span></span><br><span class="line">    <span class="keyword">for</span> edge <span class="keyword">in</span> edges:</span><br><span class="line">      <span class="comment"># 注意这里得到的是rootx和rooty</span></span><br><span class="line">        rootx = union.find(edge.l)</span><br><span class="line">        rooty = union.find(edge.r)</span><br><span class="line">        <span class="comment"># 如果不是同一个根，说明至少有一个节点不在并查集中（即不在生成树中，可以把这个边加入）</span></span><br><span class="line">        <span class="keyword">if</span> rootx != rooty:</span><br><span class="line">            res += edge.val</span><br><span class="line">            <span class="comment"># 这里要加入的也是rootx和rooty而不是x和y</span></span><br><span class="line">            union.join(rootx, rooty)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>不使用结构体代码</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n</span>):</span><br><span class="line">        self.parent = <span class="built_in">list</span>(<span class="built_in">range</span>(n + <span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, u</span>):</span><br><span class="line">        <span class="keyword">if</span> self.parent[u] != u:</span><br><span class="line">            self.parent[u] = self.find(self.parent[u]) <span class="comment"># 路径压缩</span></span><br><span class="line">        <span class="keyword">return</span> self.parent[u]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">join</span>(<span class="params">self, u, v</span>):</span><br><span class="line">        rootU = self.find(u)</span><br><span class="line">        rootV = self.find(v)</span><br><span class="line">        <span class="keyword">if</span> rootU != rootV:</span><br><span class="line">            self.parent[v] = rootU</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSame</span>(<span class="params">self, u, v</span>):</span><br><span class="line">        <span class="keyword">return</span> self.find(u) == self.find(v)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    v, e = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 需要有“点-边”对应关系，使用字典</span></span><br><span class="line">    edges = <span class="built_in">dict</span>()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(e):</span><br><span class="line">        s, t, w = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"> </span><br><span class="line">        edges[<span class="built_in">str</span>(s)+<span class="string">&#x27; &#x27;</span>+<span class="built_in">str</span>(t)] = w</span><br><span class="line"> </span><br><span class="line">    edges = <span class="built_in">sorted</span>(edges.items(), key = <span class="keyword">lambda</span> x : x[<span class="number">1</span>])</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">print</span>(edges)</span><br><span class="line"> </span><br><span class="line">    union = UnionFind(v)</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="comment"># edge结构为(&#x27;1 2&#x27;, 1) </span></span><br><span class="line">    <span class="keyword">for</span> edge <span class="keyword">in</span> edges:</span><br><span class="line">        s, t = <span class="built_in">map</span>(<span class="built_in">int</span>, edge[<span class="number">0</span>].split())</span><br><span class="line">        rootS = union.find(s)</span><br><span class="line">        rootT = union.find(t)</span><br><span class="line">        <span class="keyword">if</span> rootS != rootT:</span><br><span class="line">            res += edge[<span class="number">1</span>]</span><br><span class="line">            union.join(rootS, rootT)</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="kruskal记录边">Kruskal记录边</h2><p>如果题目要求将最小生成树的边输出的话，应该怎么办呢？</p><p>Kruskal 算法 输出边的话，相对prim 要容易很多，因为 Kruskal 本来就是直接操作边，边的结构自然清晰，不用像 prim一样 需要再将节点连成线输出边 （因为prim是对节点操作，而 Kruskal是对边操作，这是本质区别）</p><p>本题中，边的结构为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r, val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么我们只需要找到 在哪里把生成树的边保存下来就可以了。</p><p>当判断两个节点不在同一个集合的时候，这两个节点的边就加入到最小生成树， 所以添加边的操作在这里：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Edge&gt; result; <span class="comment">// 存储最小生成树的边</span></span><br><span class="line"><span class="comment">// 如果祖先不同，则不在同一个集合</span></span><br><span class="line"><span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">    result.<span class="built_in">push_back</span>(edge); <span class="comment">// 记录最小生成树的边</span></span><br><span class="line">    result_val += edge.val; <span class="comment">// 这条边可以作为生成树的边</span></span><br><span class="line">    <span class="built_in">join</span>(x, y); <span class="comment">// 两个节点加入到同一个集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小技巧">小技巧</h2><p>sort以及sorted使用</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">edges.sort(key = <span class="keyword">lambda</span> edge: edge.val)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sorted使用</span></span><br><span class="line"><span class="built_in">sorted</span>(edges, key = <span class="keyword">lambda</span> edge: edga.val)</span><br></pre></td></tr></table></figure><p>表示对edge.val作为排序依据(key)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday57图论part07&quot;&gt;LeetCodeCampsDay57图论part07&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;最小生成树算法&lt;/p&gt;
&lt;p&gt;分别使用Prim算法和Kruscal算法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;prim </summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay56图论part06</title>
    <link href="https://blog.lthero.cn/2025/08/23/LeetCodeCampsDay56/"/>
    <id>https://blog.lthero.cn/2025/08/23/LeetCodeCampsDay56/</id>
    <published>2025-08-23T12:19:56.000Z</published>
    <updated>2025-08-23T15:07:33.860Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday56图论part06">LeetCodeCampsDay56图论part06</h1><blockquote><p>无向图&amp;有向图变成无向树&amp;有向树问题</p></blockquote><h1 id="108-冗余的边">108.冗余的边</h1><p>题目描述</p><p>有一个图，它是一棵树，他是拥有 n 个节点（节点编号1到n）和 n - 1 条边的连通无环无向图，例如如图：</p><p><img src="https://file.kamacoder.com/pics/20250325153433.png" alt="img"></p><p>现在在这棵树上的基础上，添加一条边（依然是n个节点，但有n条边），使这个图变成了有环图，如图：</p><p><img src="https://file.kamacoder.com/pics/20250325153510.png" alt="img"></p><p>先请你找出冗余边，删除后，使该图可以重新变成一棵树。</p><p>输入描述</p><p>第一行包含一个整数 N，表示图的节点个数和边的个数。</p><p>后续 N 行，每行包含两个整数 s 和 t，表示图中 s 和 t 之间有一条边。</p><p>输出描述</p><p>输出一条可以删除的边。如果有多个答案，请删除标准输入中最后出现的那条边。</p><p>输入示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure><p>输出示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 3</span><br></pre></td></tr></table></figure><p>提示信息</p><p><img src="https://kamacoder.com/upload/kamacoder.com/image/20240417/20240417110831_73733.png" alt="img"></p><p>图中的 1 2，2 3，1 3 等三条边在删除后都能使原图变为一棵合法的树。但是 1 3 由于是标准输出里最后出现的那条边，所以输出结果为 1 3</p><p>数据范围：</p><p>1 &lt;= N &lt;= 1000.</p><h2 id="并查集思路">并查集思路</h2><p>如何判断哪条边是多余的？</p><p>对输入的边进行遍历，如果这边的两个节点已经在并查集里了，则说明这边就是多余的，可以把这边添加到备选列表；否则，再添加到并查集中</p><h2 id="并查集代码">并查集代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, size</span>):</span><br><span class="line">        self.parent = <span class="built_in">list</span>(<span class="built_in">range</span>(size + <span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 返回u节点的根节点</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, u</span>):</span><br><span class="line">        <span class="keyword">if</span> self.parent[u] != u:</span><br><span class="line">            <span class="comment"># 路径压缩</span></span><br><span class="line">            self.parent[u] = self.find(self.parent[u])</span><br><span class="line">        <span class="keyword">return</span> self.parent[u]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">join</span>(<span class="params">self, u, v</span>):</span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        root_u = self.find(u)</span><br><span class="line">        root_v = self.find(v)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root_u != root_v:</span><br><span class="line">            self.parent[root_v] = root_u</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSame</span>(<span class="params">self, u, v</span>):</span><br><span class="line">        <span class="keyword">return</span> self.find(u) == self.find(v)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    union = UnionFind(n)</span><br><span class="line">    </span><br><span class="line">    res = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        s, t = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        <span class="comment"># 如果节点已经存在并查集中，那就把它添加到候选列表</span></span><br><span class="line">        <span class="keyword">if</span> union.isSame(s, t):</span><br><span class="line">            <span class="comment"># res.append([s, t])</span></span><br><span class="line">            <span class="built_in">print</span>(s, t)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            union.join(s, t)</span><br><span class="line">    <span class="comment"># print(f&quot;&#123;res[-1][0]&#125; &#123;res[-1][1]&#125;&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="扩展">扩展</h2><p>题目要求 “请删除标准输入中最后出现的那条边” ，不少录友疑惑，这代码分明是遇到在同一个根的两个节点立刻就返回了，怎么就求出 最后出现的那条边 了呢。</p><p>有这种疑惑的录友是 认为发现一条冗余边后，后面还可能会有一条冗余边。</p><p>其实并不会。</p><p>题目是在 树的基础上 添加一条边，所以冗余边仅仅是一条。</p><p>到这一条可能靠前出现，可能靠后出现。</p><p>例如，题目输入示例：</p><p>输入示例</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure><p>图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240527110320.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240527110320.png" alt="img"></p><p>输出示例</p><p>1 3</p><p>当我们从前向后遍历，优先让前面的边连上，最后判断冗余边就是 1 3。</p><p>如果我们从后向前便利，优先让后面的边连上，最后判断的冗余边就是 1 2。</p><p>题目要求“请删除标准输入中最后出现的那条边”，所以 1 3 这条边才是我们要求的</p><h2 id="思路">思路</h2><p>如何判断哪条边是多余的？</p><p>对输入的边进行遍历，如果这边的两个节点已经在并查集里了，则说明这边就是多余的</p><p>可以把这边备选</p><h2 id="代码">代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, size</span>):</span><br><span class="line">        self.parent = <span class="built_in">list</span>(<span class="built_in">range</span>(size + <span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 返回u节点的根节点</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, u</span>):</span><br><span class="line">        <span class="keyword">if</span> self.parent[u] != u:</span><br><span class="line">            <span class="comment"># 路径压缩</span></span><br><span class="line">            self.parent[u] = self.find(self.parent[u])</span><br><span class="line">        <span class="keyword">return</span> self.parent[u]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">join</span>(<span class="params">self, u, v</span>):</span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        root_u = self.find(u)</span><br><span class="line">        root_v = self.find(v)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root_u != root_v:</span><br><span class="line">            self.parent[root_v] = root_u</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSame</span>(<span class="params">self, u, v</span>):</span><br><span class="line">        <span class="keyword">return</span> self.find(u) == self.find(v)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    union = UnionFind(n)</span><br><span class="line">    </span><br><span class="line">    res = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        s, t = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        <span class="comment"># 如果节点已经存在并查集中，那就把它添加到候选列表</span></span><br><span class="line">        <span class="keyword">if</span> union.isSame(s, t):</span><br><span class="line">            <span class="comment"># res.append([s, t])</span></span><br><span class="line">            <span class="built_in">print</span>(s, t)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            union.join(s, t)</span><br><span class="line">    <span class="comment"># print(f&quot;&#123;res[-1][0]&#125; &#123;res[-1][1]&#125;&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h1 id="109-冗余的边ii">109.冗余的边II</h1><p>题目描述</p><p>有一种有向树,该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。有向树拥有 n 个节点和 n - 1 条边。如图：</p><p><img src="https://file.kamacoder.com/pics/20250326162639.png" alt="img"></p><p>现在有一个有向图，有向图是在有向树中的两个没有直接链接的节点中间添加一条有向边。如图：</p><p><img src="https://file.kamacoder.com/pics/20250326162836.png" alt="img"></p><p>输入一个有向图，该图由一个有着 n 个节点(节点编号 从 1 到 n)，n 条边，请返回一条可以删除的边，使得删除该条边之后该有向图可以被当作一颗有向树。</p><p>输入描述</p><p>第一行输入一个整数 N，表示有向图中节点和边的个数。</p><p>后续 N 行，每行输入两个整数 s 和 t，代表这是 s 节点连接并指向 t 节点的单向边</p><p>输出描述</p><p>输出一条可以删除的边，若有多条边可以删除，请输出标准输入中最后出现的一条边。</p><p>输入示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><p>输出示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 3</span><br></pre></td></tr></table></figure><p>提示信息</p><p><img src="https://kamacoder.com/upload/kamacoder.com/image/20240418/20240418110555_68889.png" alt="img"></p><p>在删除 2 3 后有向图可以变为一棵合法的有向树，所以输出 2 3</p><p><strong>数据范围：</strong></p><p>1 &lt;= N &lt;= 1000.</p><h2 id="思路">思路</h2><p>本题与 <a href="https://www.programmercarl.com/kamacoder/0108.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5.html">108.冗余连接</a> 类似，但本题是一个有向图，有向图相对要复杂一些。</p><p>本题的本质是 ：有一个有向图，是由一颗有向树 + 一条有向边组成的 （所以此时这个图就不能称之为有向树），现在让我们找到那条边 把这条边删了，让这个图恢复为有向树。</p><p>还有“<strong>若有多条边可以删除，请输出标准输入中最后出现的一条边</strong>”，这说明在两条边都可以删除的情况下，要删顺序靠后的边！</p><p>我们来想一下 有向树的性质，如果是有向树的话，只有根节点入度为0，其他节点入度都为1（因为该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点）。</p><p>所以情况一：如果我们找到入度为2的点，那么删一条指向该节点的边就行了。</p><p>如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240527115807.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240527115807.png" alt="img"></p><p>找到了节点3 的入度为2，删 1 -&gt; 3 或者 2 -&gt; 3 。选择删顺序靠后便可。</p><p>但 入度为2 还有一种情况，情况二，只能删特定的一条边，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240527151456.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240527151456.png" alt="img"></p><p>节点3 的入度为 2，但在删除边的时候，只能删 这条边（节点1 -&gt; 节点3），如果删这条边（节点4 -&gt; 节点3），那么删后本图也不是有向树了（因为找不到根节点）。</p><p>综上，如果发现入度为2的节点，我们需要判断 删除哪一条边，删除后本图能成为有向树。如果是删哪个都可以，优先删顺序靠后的边。</p><p>情况三： 如果没有入度为2的点，说明 图中有环了（注意是有向环）。</p><p>如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240527120531.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240527120531.png" alt="img"></p><p>对于情况三，删掉构成环的边就可以了</p><h2 id="代码">代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, size</span>):</span><br><span class="line">        self.parent = <span class="built_in">list</span>(<span class="built_in">range</span>(size + <span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 返回u节点的根节点</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, u</span>):</span><br><span class="line">        <span class="keyword">if</span> self.parent[u] != u:</span><br><span class="line">            <span class="comment"># 路径压缩</span></span><br><span class="line">            self.parent[u] = self.find(self.parent[u])</span><br><span class="line">        <span class="keyword">return</span> self.parent[u]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">join</span>(<span class="params">self, u, v</span>):</span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        root_u = self.find(u)</span><br><span class="line">        root_v = self.find(v)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root_u != root_v:</span><br><span class="line">            self.parent[root_v] = root_u</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSame</span>(<span class="params">self, u, v</span>):</span><br><span class="line">        <span class="keyword">return</span> self.find(u) == self.find(v)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断删除edge后，graph是否仍然为树，使用并查集</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isLegal</span>(<span class="params">graph, edge:<span class="built_in">list</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    s, t = edge</span><br><span class="line">    union = UnionFind(<span class="built_in">len</span>(graph))</span><br><span class="line">    <span class="keyword">for</span> u, v <span class="keyword">in</span> graph:</span><br><span class="line">        <span class="keyword">if</span> u == s <span class="keyword">and</span> v == t:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> union.isSame(u, v):</span><br><span class="line">            <span class="comment"># 找到了冗余的边</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            union.join(u, v)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line"><span class="comment"># 入度为二，直接删除一条（选择更靠后的）</span></span><br><span class="line"><span class="comment"># 入度为二，但只能删除特定的一条边（删除此边后，节点仍然在并查集中）</span></span><br><span class="line"><span class="comment"># 没有入度为2的点，存在：有向环</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 记录每个节点的入度数</span></span><br><span class="line">    indegree = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    graph = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">      <span class="comment"># s, t分别表示start和target</span></span><br><span class="line">        s, t = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        graph.append([s, t])</span><br><span class="line">        indegree[t] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 找到入度为2的节点的边</span></span><br><span class="line">    res = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> s, t <span class="keyword">in</span> graph:</span><br><span class="line">        <span class="keyword">if</span> indegree[t] == <span class="number">2</span>:</span><br><span class="line">            res.append([s, t])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 若找到了入度为2的节点</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(res) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 如果把res[-1]这条边删除后，graph仍然是有向树，则可以删除</span></span><br><span class="line">        <span class="keyword">if</span> isLegal(graph, res[-<span class="number">1</span>]):</span><br><span class="line">            u, v = res[-<span class="number">1</span>]</span><br><span class="line">            <span class="built_in">print</span>(u, v)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 说明这条边不能删除，则需要删除另一条边（题目保证一定会删除一条）</span></span><br><span class="line">            u, v = res[-<span class="number">2</span>]</span><br><span class="line">            <span class="built_in">print</span>(u, v)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 再处理入度不为2的情况，此时删除环内的一条边即可</span></span><br><span class="line">        <span class="comment"># 找出冗余的边，就回到了冗余的边1的问题</span></span><br><span class="line">        <span class="comment"># 此时才使用并查集处理</span></span><br><span class="line">        union = UnionFind(n)</span><br><span class="line">        <span class="keyword">for</span> u, v <span class="keyword">in</span> graph:</span><br><span class="line">            <span class="keyword">if</span> union.isSame(u, v):</span><br><span class="line">                <span class="comment"># 找到了冗余的边</span></span><br><span class="line">                <span class="built_in">print</span>(u, v)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                union.join(u, v)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday56图论part06&quot;&gt;LeetCodeCampsDay56图论part06&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;无向图&amp;amp;有向图变成无向树&amp;amp;有向树问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;108</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay55图论part05(并查集)</title>
    <link href="https://blog.lthero.cn/2025/08/23/LeetCodeCampsDay55/"/>
    <id>https://blog.lthero.cn/2025/08/23/LeetCodeCampsDay55/</id>
    <published>2025-08-23T07:19:28.000Z</published>
    <updated>2025-08-23T12:19:36.865Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday55图论part05-并查集">LeetCodeCampsDay55图论part05(并查集)</h1><blockquote><p>包含并查集基础与一个基础题目</p></blockquote><h1 id="并查集理论基础">并查集理论基础</h1><h2 id="背景">背景</h2><p>首先要知道并查集可以解决什么问题呢？</p><p>并查集常用来解决连通性问题。</p><p>大白话就是当我们需要判断两个元素是否在同一个集合里的时候，我们就要想到用并查集。</p><p>并查集主要有两个功能：</p><ul><li>将两个元素添加到一个集合中。</li><li>判断两个元素在不在同一个集合</li></ul><p>接下来围绕并查集的这两个功能来展开讲解。</p><h2 id="原理讲解">原理讲解</h2><p>从代码层面，我们如何将两个元素添加到同一个集合中呢。</p><p>此时有录友会想到：可以把他放到同一个数组里或者set 或者 map 中，这样就表述两个元素在同一个集合。</p><p>那么问题来了，对这些元素分门别类，可不止一个集合，可能是很多集合，成百上千，那么要定义这么多个数组吗？</p><p>有录友想，那可以定义一个二维数组。</p><p>但如果我们要判断两个元素是否在同一个集合里的时候 我们又能怎么办？ 只能把而二维数组都遍历一遍。</p><p>而且每当想添加一个元素到某集合的时候，依然需要把把二维数组都遍历一遍，才知道要放在哪个集合里。</p><p>这仅仅是一个粗略的思路，如果沿着这个思路去实现代码，非常复杂，因为管理集合还需要很多逻辑。</p><p>那么我们来换一个思路来看看。</p><p>我们将三个元素A，B，C （分别是数字）放在同一个集合，其实就是将三个元素连通在一起，如何连通呢。</p><p>只需要用一个一维数组来表示，即：father[A] = B，father[B] = C 这样就表述 A 与 B 与 C连通了（有向连通图）。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将v，u 这条边加入并查集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">    v = <span class="built_in">find</span>(v); <span class="comment">// 寻找v的根</span></span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span>; <span class="comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span></span><br><span class="line">    father[v] = u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能有录友想，这样我可以知道 A 连通 B，因为 A 是索引下标，根据 father[A]的数值就知道 A 连通 B。那怎么知道 B 连通 A呢？</p><p>我们的目的是判断这三个元素是否在同一个集合里，知道 A 连通 B 就已经足够了。</p><p>这里要讲到寻根思路，只要 A ，B，C 在同一个根下就是同一个集合。</p><p>给出A元素，就可以通过 father[A] = B，father[B] = C，找到根为 C。</p><p>给出B元素，就可以通过 father[B] = C，找到根也为为 C，说明 A 和 B 是在同一个集合里。 大家会想第一段代码里find函数是如何实现的呢？其实就是通过数组下标找到数组元素，一层一层寻根过程，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并查集里寻根的过程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == father[u]) <span class="keyword">return</span> u; <span class="comment">// 如果根就是自己，直接返回</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">find</span>(father[u]); <span class="comment">// 如果根不是自己，就根据数组下标一层一层向下找</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何表示 C 也在同一个元素里呢？ 我们需要 father[C] = C，即C的根也为C，这样就方便表示 A，B，C 都在同一个集合里了。</p><p>所以father数组初始化的时候要 father[i] = i，默认自己指向自己。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并查集初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们如何判断两个元素是否在同一个集合里，如果通过 find函数 找到 两个元素属于同一个根的话，那么这两个元素就是同一个集合，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u);</span><br><span class="line">    v = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">return</span> u == v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路径压缩">路径压缩</h2><p>在实现 find 函数的过程中，我们知道，通过递归的方式，不断获取father数组下标对应的数值，最终找到这个集合的根。</p><p>搜索过程像是一个多叉树中从叶子到根节点的过程，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20230602102619.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20230602102619.png" alt="img"></p><p>如果这棵多叉树高度很深的话，每次find函数 去寻找根的过程就要递归很多次。</p><p>我们的目的只需要知道这些节点在同一个根下就可以，所以对这棵多叉树的构造只需要这样就可以了，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20230602103040.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20230602103040.png" alt="img"></p><p>除了根节点其他所有节点都挂载根节点下，这样我们在寻根的时候就很快，只需要一步，</p><p>如果我们想达到这样的效果，就需要 <strong>路径压缩</strong>，将非根节点的所有节点直接指向根节点。 那么在代码层面如何实现呢？</p><p>我们只需要在递归的过程中，让 father[u] 接住 递归函数 find(father[u]) 的返回结果。</p><p>因为 find 函数向上寻找根节点，father[u] 表述 u 的父节点，那么让 father[u] 直接获取 find函数 返回的根节点，这样就让节点 u 的父节点 变成根节点。</p><p>代码如下，注意看注释，路径压缩就一行代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并查集里寻根的过程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == father[u]) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> father[u] = <span class="built_in">find</span>(father[u]); <span class="comment">// 路径压缩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码在C++中，可以用三元表达式来精简一下，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u == father[u] ? u : father[u] = <span class="built_in">find</span>(father[u]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相信不少录友在学习并查集的时候，对上面这三行代码实现的 find函数 很熟悉，但理解上却不够深入，仅仅知道这行代码很好用，不知道这里藏着路径压缩的过程。</p><p>所以对于算法初学者来说，直接看精简代码学习是不太友好的，往往忽略了很多细节。</p><h2 id="代码模板">代码模板</h2><p>那么此时并查集的模板就出来了， 整体模板C++代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">1005</span>; <span class="comment">// n根据题目中节点数量而定，一般比节点数量大一点就好</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; father = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n, <span class="number">0</span>); <span class="comment">// C++里的一种数组结构</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 并查集里寻根的过程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u == father[u] ? u : father[u] = <span class="built_in">find</span>(father[u]); <span class="comment">// 路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u);</span><br><span class="line">    v = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">return</span> u == v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将v-&gt;u 这条边加入并查集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">    v = <span class="built_in">find</span>(v); <span class="comment">// 寻找v的根</span></span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ; <span class="comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span></span><br><span class="line">    father[v] = u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过模板，我们可以知道，并查集主要有三个功能。</p><ol><li>寻找根节点，函数：find(int u)，也就是判断这个节点的祖先节点是哪个</li><li>将两个节点接入到同一个集合，函数：join(int u, int v)，将两个节点连在同一个根节点上</li><li>判断两个节点是否在同一个集合，函数：isSame(int u, int v)，就是判断两个节点是不是同一个根节点</li></ol><h2 id="常见误区">常见误区</h2><p>这里估计有录友会想，模板中的 join 函数里的这段代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">u = <span class="built_in">find</span>(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">v = <span class="built_in">find</span>(v); <span class="comment">// 寻找v的根</span></span><br><span class="line"><span class="keyword">if</span> (u == v) <span class="keyword">return</span> ; <span class="comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span></span><br></pre></td></tr></table></figure><p>与 isSame 函数的实现是不是重复了？ 如果抽象一下呢，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u);</span><br><span class="line">    v = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">return</span> u == v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将v-&gt;u 这条边加入并查集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isSame</span>(u, v)) <span class="keyword">return</span> ; <span class="comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span></span><br><span class="line">    father[v] = u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写可以吗？ 好像看出去没问题，而且代码更精简了。</p><p><strong>其实这么写是有问题的</strong>，在join函数中 我们需要寻找 u 和 v 的根，然后再进行连线在一起，而不是直接 用 u 和 v 连线在一起。</p><p>举一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">join</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">join</span>(<span class="number">3</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>此时构成的图是这样的：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20230525111307.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20230525111307.png" alt="img"></p><p>此时问 1，3是否在同一个集合，我们调用 <code>join(1, 2); join(3, 2);</code> 很明显本意要表示 1，3是在同一个集合。</p><p>但我们来看一下代码逻辑，当我们调用 <code>isSame(1, 3)</code>的时候，find(1) 返回的是1，find(3)返回的是3。 <code>return 1 == 3</code> 返回的是false，代码告诉我们 1 和 3 不在同一个集合，这明显不符合我们的预期，所以问题出在哪里？</p><p>问题出在我们精简的代码上，即 join 函数 一定要先 通过find函数寻根再进行关联。</p><p>如果find函数是这么实现，再来看一下逻辑过程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">    v = <span class="built_in">find</span>(v); <span class="comment">// 寻找v的根</span></span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ; <span class="comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span></span><br><span class="line">    father[v] = u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别将 这两对元素加入集合。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">join</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">join</span>(<span class="number">3</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>当执行<code>join(3, 2)</code>的时候，会先通过find函数寻找 3的根为3，2的根为1 （第一个<code>join(1, 2)</code>，将2的根设置为1），所以最后是将1 指向 3。</p><p>构成的图是这样的：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20230525112101.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20230525112101.png" alt="img"></p><p>因为在join函数里，我们有find函数进行寻根的过程，这样就保证元素 1，2，3在这个有向图里是强连通的。</p><p>此时我们在调用 <code>isSame(1, 3)</code>的时候，find(1) 返回的是3，find(3) 返回的也是3，<code>return 3 == 3</code> 返回的是true，即告诉我们 元素 1 和 元素3 是 在同一个集合里的。</p><h2 id="模拟过程">模拟过程</h2><p>（<strong>凸显途径合并的过程，每一个join都要画图</strong>）</p><p>不少录友在接触并查集模板之后，用起来很娴熟，因为模板确实相对固定，但是对并查集内部数据组织方式以及如何判断是否是同一个集合的原理很模糊。</p><p>通过以上讲解之后，我再带大家一步一步去画一下，并查集内部数据连接方式。</p><p>1、<code>join(1, 8);</code></p><p><img src="https://cdn.lthero.cn/post_images/course/ML20231122112727.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20231122112727.png" alt="img"></p><p>2、<code>join(3, 8);</code></p><p><img src="https://cdn.lthero.cn/post_images/course/ML20231122113857.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20231122113857.png" alt="img"></p><p>有录友可能想，<code>join(3, 8)</code> 在图中为什么 将 元素1 连向元素 3 而不是将 元素 8 连向 元素 3 呢？</p><p>这一点 我在 「常见误区」标题下已经详细讲解了，因为在<code>join(int u, int v)</code>函数里 要分别对 u 和 v 寻根之后再进行关联。</p><p>3、<code>join(1, 7);</code></p><p><img src="https://cdn.lthero.cn/post_images/course/ML20231122114108.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20231122114108.png" alt="img"></p><p>4、<code>join(8, 5);</code></p><p><img src="https://cdn.lthero.cn/post_images/course/ML20231122114847.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20231122114847.png" alt="img"></p><p>这里8的根是3，那么 5 应该指向 8 的根 3，这里的原因，我们在上面「常见误区」已经讲过了。 但 为什么 图中 8 又直接指向了 3 了呢？</p><p><strong>因为路经压缩了</strong></p><p>即如下代码在寻找根的过程中，会有路径压缩，减少 下次查询的路径长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并查集里寻根的过程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u == father[u] ? u : father[u] = <span class="built_in">find</span>(father[u]); <span class="comment">// 路径压缩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、<code>join(2, 9);</code></p><p><img src="https://cdn.lthero.cn/post_images/course/ML20231122115000.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20231122115000.png" alt="img"></p><p>6、<code>join(6, 9);</code></p><p><img src="https://cdn.lthero.cn/post_images/course/ML20231122115404.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20231122115404.png" alt="img"></p><p>这里为什么是 2 指向了 6，因为 9的根为 2，所以用2指向6。</p><p>大家看懂这个有向图后，相信应该知道如下函数的返回值了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">isSame</span>(<span class="number">8</span>, <span class="number">7</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">isSame</span>(<span class="number">7</span>, <span class="number">2</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>返回值分别如下，表示，8 和 7 是同一个集合，而 7 和 2 不是同一个集合。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure><h2 id="拓展">拓展</h2><p>在「路径压缩」讲解中，我们知道如何靠压缩路径来缩短查询根节点的时间。</p><p>其实还有另一种方法：按秩（rank）合并。</p><p>rank表示树的高度，即树中结点层次的最大值。</p><p>例如两个集合（多叉树）需要合并，如图所示：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20230602172250.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20230602172250.png" alt="img"></p><p>树1 rank 为2，树2 rank 为 3。那么合并两个集合，是 树1 合入 树2，还是 树2 合入 树1呢？</p><p>我们来看两个不同方式合入的效果。</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20230602172933.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20230602172933.png" alt="img"></p><p>这里可以看出，树2 合入 树1 会导致整棵树的高度变的更高，而 树1 合入 树2 整棵树的高度 和 树2 保持一致。</p><p>所以在 join函数中如何合并两棵树呢？</p><p>一定是 rank 小的树合入 到 rank大 的树，这样可以保证最后合成的树rank 最小，降低在树上查询的路径长度。</p><p>按秩合并的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">1005</span>; <span class="comment">// n根据题目中节点数量而定，一般比节点数量大一点就好</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; father = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n, <span class="number">0</span>); <span class="comment">// C++里的一种数组结构</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; rank = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n, <span class="number">1</span>); <span class="comment">// 初始每棵树的高度都为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">        rank[i] = <span class="number">1</span>; <span class="comment">// 也可以不写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 并查集里寻根的过程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u == father[u] ? u : <span class="built_in">find</span>(father[u]);<span class="comment">// 注意这里不做路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u);</span><br><span class="line">    v = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">return</span> u == v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将v-&gt;u 这条边加入并查集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">    v = <span class="built_in">find</span>(v); <span class="comment">// 寻找v的根</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rank[u] &lt;= rank[v]) father[u] = v; <span class="comment">// rank小的树合入到rank大的树</span></span><br><span class="line">    <span class="keyword">else</span> father[v] = u;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rank[u] == rank[v] &amp;&amp; u != v) rank[v]++; <span class="comment">// 如果两棵树高度相同，则v的高度+1，因为上面 if (rank[u] &lt;= rank[v]) father[u] = v; 注意是 &lt;=</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以注意到在上面的模板代码中，我是没有做路径压缩的，因为一旦做路径压缩，rank记录的高度就不准了，根据rank来判断如何合并就没有意义。</p><p>也可以在 路径压缩的时候，再去实时修生rank的数值，但这样在代码实现上麻烦了不少，关键是收益很小。</p><p>其实我们在优化并查集查询效率的时候，只用路径压缩的思路就够了，不仅代码实现精简，而且效率足够高。</p><p>按秩合并的思路并没有将树形结构尽可能的扁平化，所以在整理效率上是没有路径压缩高的。</p><p>说到这里可能有录友会想，那在路径压缩的代码中，只有查询的过程 即 find 函数的执行过程中会有路径压缩，如果一直没有使用find函数，是不是相当于这棵树就没有路径压缩，导致查询效率依然很低呢？</p><p>大家可以再去回顾使用路径压缩的 并查集模板，在isSame函数 和 join函数中，我们都调用了 find 函数来进行寻根操作。</p><p>也就是说，无论使用并查集模板里哪一个函数（除了init函数），都会有路径压缩的过程，第二次访问相同节点的时候，这个节点就是直连根节点的，即 第一次访问的时候它的路径就被压缩了。</p><p><strong>所以这里推荐大家直接使用路径压缩的并查集模板就好</strong>，但按秩合并的优化思路我依然给大家讲清楚，有助于更深一步理解并查集的优化过程。</p><h2 id="复杂度分析">复杂度分析</h2><p>这里对路径压缩版并查集来做分析。</p><p>空间复杂度： O(n) ，申请一个father数组。</p><p>关于时间复杂度，如果想精确表达出来需要繁琐的数学证明，就不在本篇讲解范围内了，大家感兴趣可以自己去深入研究。</p><p>这里做一个简单的分析思路。</p><p>路径压缩后的并查集时间复杂度在O(logn)与O(1)之间，且随着查询或者合并操作的增加，时间复杂度会越来越趋于O(1)。</p><p>了解到这个程度对于求职面试来说就够了。</p><p>在第一次查询的时候，相当于是n叉树上从叶子节点到根节点的查询过程，时间复杂度是logn，但路径压缩后，后面的查询操作都是O(1)，而 join 函数 和 isSame函数 里涉及的查询操作也是一样的过程。</p><h2 id="总结">总结</h2><p>本篇我们讲解了并查集的背景、原理、两种优化方式（路径压缩，按秩合并），代码模板，常见误区，以及模拟过程。</p><p>要知道并查集解决什么问题，在什么场景下我们要想到使用并查集。</p><p>接下来进一步优化并查集的执行效率，重点介绍了路径压缩的方式，另一种方法：按秩合并，我们在 「拓展」中讲解。</p><p>通过一步一步的原理讲解，最后给出并查集的模板，所有的并查集题目都在这个模板的基础上进行操作或者适当修改。</p><p>但只给出模板还是不够的，针对大家学习并查集的常见误区，详细讲解了模板代码的细节。</p><p>为了让录友们进一步了解并查集的运行过程，我们再通过具体用例模拟一遍代码过程并画出对应的内部数据连接图（有向图）。</p><p>这里也建议大家去模拟一遍才能对并查集理解的更到位。</p><p>如果对模板代码还是有点陌生，不用担心，接下来我会讲解对应LeetCode上的并查集题目，通过一系列题目练习，大家就会感受到这套模板有多么的好用！</p><h1 id="并查集套路代码-python">并查集套路代码(python)</h1><p>并查集主要有三个功能：</p><ol><li>寻找根节点，函数：find(int u)，也就是判断这个节点的祖先节点是哪个</li><li>将两个节点接入到同一个集合，函数：join(int u, int v)，将两个节点连在同一个根节点上</li><li>判断两个节点是否在同一个集合，函数：isSame(int u, int v)，就是判断两个节点是不是同一个根节点</li></ol><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 并查集搜索</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, size</span>):</span><br><span class="line">        <span class="comment"># 初始化，每个节点（从0到size)的根为自己</span></span><br><span class="line">        self.parent = <span class="built_in">list</span>(<span class="built_in">range</span>(size + <span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, u</span>):</span><br><span class="line">        <span class="keyword">if</span> self.parent[u] != u:</span><br><span class="line">            self.parent[u] = self.find(self.parent[u]) <span class="comment"># 路径压缩</span></span><br><span class="line">            <span class="comment"># return self.find(self.parent[u]) # 不路径压缩</span></span><br><span class="line">        <span class="keyword">return</span> self.parent[u]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">join</span>(<span class="params">self, u, v</span>):</span><br><span class="line">        root_u = self.find(u)</span><br><span class="line">        root_v = self.find(v)</span><br><span class="line">        <span class="comment"># 如果他们的根不同，则将v的根指向u的根</span></span><br><span class="line">        <span class="keyword">if</span> root_u != root_v:</span><br><span class="line">            self.parent[root_v] = root_u</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSame</span>(<span class="params">self, u, v</span>):</span><br><span class="line">        root_u = self.find(u)</span><br><span class="line">        root_v = self.find(v)</span><br><span class="line">        <span class="keyword">return</span> root_u == root_v</span><br></pre></td></tr></table></figure><h1 id="107-寻找存在的路径">107.寻找存在的路径</h1><p>题目描述</p><p>给定一个包含 n 个节点的无向图中，节点编号从 1 到 n （含 1 和 n ）。</p><p>你的任务是判断是否有一条从节点 source 出发到节点 destination 的路径存在。</p><p>输入描述</p><p>第一行包含两个正整数 N 和 M，N 代表节点的个数，M 代表边的个数。</p><p>后续 M 行，每行两个正整数 s 和 t，代表从节点 s 与节点 t 之间有一条边。</p><p>最后一行包含两个正整数，代表起始节点 source 和目标节点 destination。</p><p>输出描述</p><p>输出一个整数，代表是否存在从节点 source 到节点 destination 的路径。如果存在，输出 1；否则，输出 0。</p><p>输入示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 4</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br><span class="line">3 4</span><br><span class="line">1 4</span><br></pre></td></tr></table></figure><p>输出示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>提示信息</p><p><img src="https://kamacoder.com/upload/kamacoder.com/image/20240416/20240416112946_20453.png" alt="img"></p><p>数据范围：</p><p>1 &lt;= M, N &lt;= 100。</p><h2 id="并查集思路">并查集思路</h2><p>本题可以理解为</p><p>若source和destination拥有相同的root，则说明他们之间存在路径</p><p>使用 join(int u, int v)将每条边加入到并查集。</p><p>最后 isSame(int u, int v) 判断是否是同一个根 就可以了。</p><h2 id="并查集代码">并查集代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 并查集搜索</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, size</span>):</span><br><span class="line">        <span class="comment"># 初始化，每个节点（从0到size)的根为自己</span></span><br><span class="line">        self.parent = <span class="built_in">list</span>(<span class="built_in">range</span>(size + <span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, u</span>):</span><br><span class="line">        <span class="keyword">if</span> self.parent[u] != u:</span><br><span class="line">            self.parent[u] = self.find(self.parent[u]) <span class="comment"># 路径压缩</span></span><br><span class="line">            <span class="comment"># return self.find(self.parent[u]) # 不路径压缩</span></span><br><span class="line">        <span class="keyword">return</span> self.parent[u]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">join</span>(<span class="params">self, u, v</span>):</span><br><span class="line">        root_u = self.find(u)</span><br><span class="line">        root_v = self.find(v)</span><br><span class="line">        <span class="comment"># 如果他们的根不同，则将v的根指向u的根</span></span><br><span class="line">        <span class="keyword">if</span> root_u != root_v:</span><br><span class="line">            self.parent[root_v] = root_u</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSame</span>(<span class="params">self, u, v</span>):</span><br><span class="line">        root_u = self.find(u)</span><br><span class="line">        root_v = self.find(v)</span><br><span class="line">        <span class="keyword">return</span> root_u == root_v</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用节点个数初始化UnionFind</span></span><br><span class="line">    union = UnionFind(n)</span><br><span class="line"></span><br><span class="line">    graph = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        u, v = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        union.join(u, v)</span><br><span class="line">    </span><br><span class="line">    source, destination = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    res = union.isSame(source, destination)</span><br><span class="line">    <span class="keyword">if</span> res:</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday55图论part05-并查集&quot;&gt;LeetCodeCampsDay55图论part05(并查集)&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;包含并查集基础与一个基础题目&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;并查集理论基</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay53图论part04</title>
    <link href="https://blog.lthero.cn/2025/08/23/LeetCodeCampsDay53/"/>
    <id>https://blog.lthero.cn/2025/08/23/LeetCodeCampsDay53/</id>
    <published>2025-08-23T05:42:12.000Z</published>
    <updated>2025-08-23T07:18:25.382Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday53图论part04">LeetCodeCampsDay53图论part04</h1><blockquote><p>继续使用深度/广度优先解决图的问题</p><p>其中105是有向图问题</p></blockquote><h1 id="110-字符串接龙">110.字符串接龙</h1><p><a href="https://kamacoder.com/problempage.php?pid=1183">https://kamacoder.com/problempage.php?pid=1183</a></p><p>题目描述</p><p>字典 strList 中从字符串 beginStr 和 endStr 的转换序列是一个按下述规格形成的序列：</p><ol><li>序列中第一个字符串是 beginStr。</li><li>序列中最后一个字符串是 endStr。</li><li>每次转换只能改变一个字符。</li><li>转换过程中的中间字符串必须是字典 strList 中的字符串，且strList里的每个字符串只用使用一次。</li></ol><p>给你两个字符串 beginStr 和 endStr 和一个字典 strList，找到从 beginStr 到 endStr 的最短转换序列中的字符串数目。如果不存在这样的转换序列，返回 0。</p><p>输入描述</p><p>第一行包含一个整数 N，表示字典 strList 中的字符串数量。 第二行包含两个字符串，用空格隔开，分别代表 beginStr 和 endStr。 后续 N 行，每行一个字符串，代表 strList 中的字符串。</p><p>输出描述</p><p>输出一个整数，代表从 beginStr 转换到 endStr 需要的最短转换序列中的字符串数量。如果不存在这样的转换序列，则输出 0。</p><p>输入示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">abc def</span><br><span class="line">efc</span><br><span class="line">dbc</span><br><span class="line">ebc</span><br><span class="line">dec</span><br><span class="line">dfc</span><br><span class="line">yhn</span><br></pre></td></tr></table></figure><p>输出示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>提示信息</p><p>从 startStr 到 endStr，在 strList 中最短的路径为 abc -&gt; dbc -&gt; dec -&gt; def，所以输出结果为 4，如图：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20240529121038.png" alt="img"></p><p>数据范围：</p><p>2 &lt;= N &lt;= 500</p><h2 id="广度优先搜索思路">广度优先搜索思路</h2><p>以示例1为例，从这个图中可以看出 abc 到 def的路线 不止一条，但最短的一条路径上是4个节点。</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20250317105155.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20250317105155.png" alt="img"></p><p>本题难点在于如何将输入变成一个无向图</p><p>第二难点在于求最短路径长度</p><p><strong>解决思路</strong></p><p>从beginStr开始（加入到广度优先遍历队列中）</p><p>从队列中先弹出curS，并对strList字符串遍历，如果curS与strList相差一个字母，则将strList添加到队列，并且记录从beginStr到达strList的步数，随后进行下一轮遍历；</p><p>本题需要有个辅助函数，用来判断两个字符串是否仅相差一个字母</p><h2 id="广度优先搜索代码">广度优先搜索代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判断s1与s2的不同字母是否仅有一个</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">judge</span>(<span class="params">s1, s2</span>):</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    Ls1 = <span class="built_in">len</span>(s1)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Ls1):</span><br><span class="line">        <span class="keyword">if</span> s1[i] != s2[i]:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count == <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    beginStr, endStr = <span class="built_in">input</span>().split()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> beginStr == endStr:</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># </span></span><br><span class="line">    strList = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        strList.append(<span class="built_in">input</span>())</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 使用广度优先搜索</span></span><br><span class="line">    visited = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="comment"># que加入的是当前节点，以及从beginStr到当前节点的步数</span></span><br><span class="line">    que = [[beginStr, <span class="number">1</span>]]</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="keyword">while</span> que:</span><br><span class="line">        curs, step = que.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 如果当前字符串和endStr仅差一个字符，则可以结束了</span></span><br><span class="line">        <span class="keyword">if</span> judge(curs, endStr):</span><br><span class="line">            <span class="built_in">print</span>(step + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 对strList进行遍历，如果未访问过，并且strList[i]和curs仅差距一个字符，则可以遍历这个strList[i]</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> visited[i] == <span class="number">0</span> <span class="keyword">and</span> judge(strList[i], curs):</span><br><span class="line">                visited[i] = <span class="number">1</span></span><br><span class="line">                que.append([strList[i], step + <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h1 id="105-有向图的完全联通">105.有向图的完全联通</h1><p>题目描述</p><p>给定一个有向图，包含 N 个节点，节点编号分别为 1，2，…，N。现从 1 号节点开始，如果可以从 1 号节点的边可以到达任何节点，则输出 1，否则输出 -1。</p><p>输入描述</p><p>第一行包含两个正整数，表示节点数量 N 和边的数量 K。 后续 K 行，每行两个正整数 s 和 t，表示从 s 节点有一条边单向连接到 t 节点。</p><p>输出描述</p><p>如果可以从 1 号节点的边可以到达任何节点，则输出 1，否则输出 -1。</p><p>输入示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 4</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br></pre></td></tr></table></figure><p>输出示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>提示信息</p><p><img src="https://kamacoder.com/upload/kamacoder.com/image/20240415/20240415192546_54466.png" alt="img"></p><p>从 1 号节点可以到达任意节点，输出 1。</p><p><strong>数据范围：</strong></p><p>1 &lt;= N &lt;= 100；<br>1 &lt;= K &lt;= 2000。</p><h2 id="深度优先遍历的思路">深度优先遍历的思路</h2><blockquote><p>本题可以先创建个邻接表，并对每个节点进行访问，最终判断是否存在未访问过的节点</p></blockquote><p>使用深度优先遍历时（其实广度优先遍历也是一样的），需要</p><ol><li>输入输出</li></ol><p>输入应该为（graph, visited, 以及当前节点）</p><p>def dfs(graph, visited, p):</p><ol start="2"><li>终止条件</li></ol><p>dfs有两种写法，这里有一个很重要的逻辑，就是在递归中，<strong>我们是处理当前访问的节点，还是处理下一个要访问的节点</strong>。</p><p>本题中什么叫做处理，就是 visited数组来记录访问过的节点，该节点默认 数组里元素都是false，把元素标记为true就是处理 本节点了。</p><ul><li>如果我们是处理当前访问的节点，当前访问的节点如果是 true ，说明是访问过的节点，那就终止本层递归，如果不是true，我们就把它赋值为true，因为这是我们处理本层递归的节点。</li></ul><p>对应代码为</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">graph, visited, p</span>):</span><br><span class="line">  <span class="comment"># 先判断是否访问过</span></span><br><span class="line"><span class="keyword">if</span> visited[p] == <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 再设置为访问过</span></span><br><span class="line">visited[p] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 后面是单层逻辑</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> graph[p]:</span><br><span class="line">        <span class="keyword">if</span> visited[i] == <span class="number">0</span>:</span><br><span class="line">            dfs(graph, visited, i)</span><br></pre></td></tr></table></figure><ul><li>如果我们是处理下一层访问的节点，而不是当前层。那么就要在 深搜三部曲中第三步：处理目前搜索节点出发的路径的时候对 节点进行处理。这样的话，就不需要终止条件，<code>而是在 搜索下一个节点的时候，直接判断 下一个节点是否是我们要搜的节点。</code></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">graph, visited, p</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> graph[p]:</span><br><span class="line">      <span class="comment"># 判断下一个节点是否被访问过，如果未访问过才去访问</span></span><br><span class="line">        <span class="keyword">if</span> visited[i] == <span class="number">0</span>:</span><br><span class="line">          <span class="comment"># 设置它被访问过</span></span><br><span class="line">            visited[i] = <span class="number">1</span></span><br><span class="line">            dfs(graph, visited, i)</span><br></pre></td></tr></table></figure><ol start="3"><li>单层逻辑</li></ol><p>本题的单层逻辑就是将节点设置为被访问过，不需要进行回溯（因为不用走回头路）</p><p><strong>那什么时候需要回溯操作呢？</strong></p><p>当我们需要搜索一条可行路径的时候，就需要回溯操作了，因为没有回溯，就没法“调头”， 如果不理解的话，去看我写的 <a href="https://www.programmercarl.com/kamacoder/0098.%E6%89%80%E6%9C%89%E5%8F%AF%E8%BE%BE%E8%B7%AF%E5%BE%84.html">0098.所有可达路径</a> 的题解。</p><h2 id="深度优先遍历代码">深度优先遍历代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用深度优先遍历，如果所有节点都能被访问(visited)则输出1，否则输出-1</span></span><br><span class="line"><span class="comment"># graph使用邻接表</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">graph, visited, p</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> graph[p]:</span><br><span class="line">        <span class="keyword">if</span> visited[i] == <span class="number">0</span>:</span><br><span class="line">            visited[i] = <span class="number">1</span></span><br><span class="line">            dfs(graph, visited, i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, k = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置为n+1是因为把0也算进去了，省得对下标进行换算</span></span><br><span class="line">    graph = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># visited记录的是每个节点是否有被访问过</span></span><br><span class="line">    visited = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    visited[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        start, end = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        graph[start].append(end)</span><br><span class="line">    </span><br><span class="line">    dfs(graph, visited, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> visited[i] == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="广度优先搜索">广度优先搜索</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果使用广度优先搜索，</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">graph, path, p</span>):</span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">    que = deque()</span><br><span class="line">    que.append(p)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> que:</span><br><span class="line">        cur = que.popleft()</span><br><span class="line">        path.add(cur)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> graph[cur]:</span><br><span class="line">            que.append(i)</span><br><span class="line">        <span class="comment"># 如果没有下面这步，会死循环</span></span><br><span class="line">        graph[cur] = []</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bfs2</span>(<span class="params">graph, visited, p</span>):</span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">    que = deque()</span><br><span class="line">    que.append(p)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> que:</span><br><span class="line">        cur = que.popleft()</span><br><span class="line">        visited[cur] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> graph[cur]:</span><br><span class="line">            <span class="keyword">if</span> visited[i] == <span class="number">0</span>:</span><br><span class="line">              <span class="comment"># 或者在这儿写visited[i] = 1也可以</span></span><br><span class="line">                que.append(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, k = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置为n+1是因为把0也算进去了，省得对下标进行换算</span></span><br><span class="line">    graph = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        start, end = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        graph[start].append(end)</span><br><span class="line">  </span><br><span class="line">   <span class="comment"># visited记录的是每个节点是否有被访问过</span></span><br><span class="line">    visited = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    visited[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    bfs2(graph, visited, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> visited[i] == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># bfs另一种写法</span></span><br><span class="line">  <span class="comment"># path用来记录被访问过的节点</span></span><br><span class="line">    <span class="comment">#path = set()</span></span><br><span class="line">    <span class="comment">#bfs(graph, path, 1)</span></span><br><span class="line">    <span class="comment">#if path == &#123;i for i in range(1, n + 1)&#125;:</span></span><br><span class="line">    <span class="comment">#    print(1)</span></span><br><span class="line">    <span class="comment">#    return</span></span><br><span class="line">    <span class="comment">#print(-1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h1 id="106-岛屿的周长">106.岛屿的周长</h1><p>题目描述</p><p>给定一个由 1（陆地）和 0（水）组成的矩阵，岛屿是被水包围，并且通过水平方向或垂直方向上相邻的陆地连接而成的。</p><p>你可以假设矩阵外均被水包围。在矩阵中恰好拥有一个岛屿，假设组成岛屿的陆地边长都为 1，请计算岛屿的周长。岛屿内部没有水域。</p><p>输入描述</p><p>第一行包含两个整数 N, M，表示矩阵的行数和列数。之后 N 行，每行包含 M 个数字，数字为 1 或者 0，表示岛屿的单元格。</p><p>输出描述</p><p>输出一个整数，表示岛屿的周长。</p><p>输入示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 5</span><br><span class="line">0 0 0 0 0 </span><br><span class="line">0 1 0 1 0</span><br><span class="line">0 1 1 1 0</span><br><span class="line">0 1 1 1 0</span><br><span class="line">0 0 0 0 0</span><br></pre></td></tr></table></figure><p>输出示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">14</span><br></pre></td></tr></table></figure><p>提示信息</p><p><img src="https://kamacoder.com/upload/kamacoder.com/image/20240416/20240416100952_15971.png" alt="img"></p><p>岛屿的周长为 14。</p><p>数据范围：</p><p>1 &lt;= M, N &lt;= 50。</p><h2 id="广度优先搜索思路">广度优先搜索思路</h2><p>题目明确了岛被水包围，但要考虑岛周围是边界的问题</p><p>计算每块陆地的相邻块，相邻块有几个是水，则有周长就加几</p><p>遍历每一个空格，遇到岛屿则计算其上下左右的空格情况。</p><p>如果该陆地上下左右的空格是有水域，则说明是一条边，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240524115933.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240524115933.png" alt="img"></p><p>陆地的右边空格是水域，则说明找到一条边。</p><p>如果该陆地上下左右的空格出界了，则说明是一条边，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240524120105.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240524120105.png" alt="img"></p><p>该陆地的下边空格出界了，则说明找到一条边。</p><h2 id="广度优先搜索代码">广度优先搜索代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">direction = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>]]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">graph, visited, x, y</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">    que = deque()</span><br><span class="line">    que.append([x, y])</span><br><span class="line">    visited[x][y] = <span class="number">1</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> que:</span><br><span class="line">        curx, cury = que.popleft()</span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> direction:</span><br><span class="line">            nextx = curx + i</span><br><span class="line">            nexty = cury + j</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= nextx &lt; <span class="built_in">len</span>(graph) <span class="keyword">and</span> <span class="number">0</span> &lt;= nexty &lt; <span class="built_in">len</span>(graph[<span class="number">0</span>]):</span><br><span class="line">                <span class="keyword">if</span> graph[nextx][nexty] == <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># print(nextx, nexty)</span></span><br><span class="line">                    res += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> visited[nextx][nexty] == <span class="number">0</span> <span class="keyword">and</span> graph[nextx][nexty] == <span class="number">1</span>:</span><br><span class="line">                    visited[nextx][nexty] = <span class="number">1</span></span><br><span class="line">                    que.append([nextx, nexty])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果出界了，直接就当前海水</span></span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">    graph = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        graph.append(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line">    </span><br><span class="line">    visited = [[<span class="number">0</span>] * m <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">if</span> visited[i][j] == <span class="number">0</span> <span class="keyword">and</span> graph[i][j] == <span class="number">1</span>:</span><br><span class="line">                res = bfs(graph, visited, i, j)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday53图论part04&quot;&gt;LeetCodeCampsDay53图论part04&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;继续使用深度/广度优先解决图的问题&lt;/p&gt;
&lt;p&gt;其中105是有向图问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay52图论part03</title>
    <link href="https://blog.lthero.cn/2025/08/22/LeetCodeCampsDay52/"/>
    <id>https://blog.lthero.cn/2025/08/22/LeetCodeCampsDay52/</id>
    <published>2025-08-22T02:36:08.000Z</published>
    <updated>2025-08-23T07:18:32.402Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday52图论part03">LeetCodeCampsDay52图论part03</h1><h1 id="101-孤岛的总面积">101.孤岛的总面积</h1><h6 id="题目描述">题目描述</h6><p>给定一个由 1（陆地）和 0（水）组成的矩阵，岛屿指的是由水平或垂直方向上相邻的陆地单元格组成的区域，且完全被水域单元格包围。孤岛是那些位于矩阵内部、所有单元格都不接触边缘的岛屿。</p><p>现在你需要计算所有孤岛的总面积，岛屿面积的计算方式为组成岛屿的陆地的总数。</p><h6 id="输入描述">输入描述</h6><p>第一行包含两个整数 N, M，表示矩阵的行数和列数。之后 N 行，每行包含 M 个数字，数字为 1 或者 0。</p><h6 id="输出描述">输出描述</h6><p>输出一个整数，表示所有孤岛的总面积，如果不存在孤岛，则输出 0。</p><h6 id="输入示例">输入示例</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 1 0 0 0</span><br><span class="line">1 1 0 0 0</span><br><span class="line">0 0 1 0 0</span><br><span class="line">0 0 0 1 1</span><br></pre></td></tr></table></figure><h6 id="输出示例">输出示例</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h6 id="提示信息">提示信息</h6><p><img src="https://kamacoder.com/upload/kamacoder.com/image/20240412/20240412113711_58587.png" alt="img"></p><p>在矩阵中心部分的岛屿，因为没有任何一个单元格接触到矩阵边缘，所以该岛屿属于孤岛，总面积为 1。</p><p>数据范围：</p><p>1 &lt;= M, N &lt;= 50。</p><h2 id="思路0">思路0</h2><p>题目要求没有任何一个单元格接触到矩阵边缘，那：从四个边缘出发，将与之相邻的格子都变成海洋（设置为0），随后再统计保留下来为陆地的格子即可</p><p>如图，在遍历地图周围四个边，靠地图四边的陆地，都为绿色，</p><p><img src="https://file1.kamacoder.com/i/algo/20220830104632.png" alt="img"></p><p>在遇到地图周边陆地的时候，将1都变为0，此时地图为这样：</p><p><img src="https://file1.kamacoder.com/i/algo/20220830104651.png" alt="img"></p><p>然后我们再去遍历这个地图，遇到有陆地的地方，去采用深搜或者广搜，边统计所有陆地。</p><h2 id="代码0">代码0</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">direction = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>]]</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将x,y相邻的位置都变成海洋（0)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">graph, x, y</span>):</span><br><span class="line">    que = deque()</span><br><span class="line">    que.append([x, y])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> que:</span><br><span class="line">        curX, curY = que.popleft()</span><br><span class="line">        graph[curX][curY] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> direction:</span><br><span class="line">            nextX = curX + i</span><br><span class="line">            nextY = curY + j</span><br><span class="line">            <span class="keyword">if</span> nextX &lt; <span class="number">0</span> <span class="keyword">or</span> nextY &lt; <span class="number">0</span> <span class="keyword">or</span> nextX &gt;= <span class="built_in">len</span>(graph) <span class="keyword">or</span> nextY &gt;= <span class="built_in">len</span>(graph[<span class="number">0</span>]):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> graph[nextX][nextY] == <span class="number">1</span>:</span><br><span class="line">                que.append([nextX, nextY])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    graph = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        graph.append(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line">    </span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 从上、下开始将相邻格子变成海洋</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">if</span> graph[<span class="number">0</span>][i] == <span class="number">1</span>:</span><br><span class="line">            bfs(graph, <span class="number">0</span>, i)</span><br><span class="line">        <span class="keyword">if</span> graph[n - <span class="number">1</span>][i] == <span class="number">1</span>:</span><br><span class="line">            bfs(graph, n - <span class="number">1</span>, i)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 从左、右开始将相邻格子变成海洋</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> graph[i][<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">            bfs(graph, i, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> graph[i][m - <span class="number">1</span>] == <span class="number">1</span>:</span><br><span class="line">            bfs(graph, i, m - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> graph[i][j] == <span class="number">1</span>:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="广度优先搜索思路一">广度优先搜索思路一</h2><p>我的思路是，对每个格子遍历，如果这个格子搜索到的相邻格子是边缘位置，则将它标记，并最终将整个区域返回-1；否则就返回实际的面积值；实际取所有返回值的最大值</p><h2 id="广度优先搜索思路二">广度优先搜索思路二</h2><ul><li>时间复杂度O(M * N)</li><li>空间复杂度O(M * N)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果某个岛在边缘上则直接返回-1</span></span><br><span class="line"><span class="comment"># 否则才计算这个岛的面积</span></span><br><span class="line"></span><br><span class="line">direction = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">graph, visited, x, y</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="comment"># </span></span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">    que = deque()</span><br><span class="line">    que.append([x, y])</span><br><span class="line"></span><br><span class="line">    area = <span class="number">1</span></span><br><span class="line">    flag = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> que:</span><br><span class="line">        curX, curY = que.popleft()</span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> direction:</span><br><span class="line">            nextX = curX + i</span><br><span class="line">            nextY = curY + j</span><br><span class="line">            <span class="keyword">if</span> nextX &lt; <span class="number">0</span> <span class="keyword">or</span> nextY &lt; <span class="number">0</span> <span class="keyword">or</span> nextX &gt;= <span class="built_in">len</span>(graph) <span class="keyword">or</span> nextY &gt;= <span class="built_in">len</span>(graph[<span class="number">0</span>]):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> graph[nextX][nextY] == <span class="number">1</span> <span class="keyword">and</span> visited[nextX][nextY] == <span class="number">2</span>:</span><br><span class="line">                flag = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> graph[nextX][nextY] == <span class="number">1</span> <span class="keyword">and</span> visited[nextX][nextY] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> nextX == <span class="number">0</span> <span class="keyword">or</span> nextY == <span class="number">0</span> <span class="keyword">or</span> nextX == <span class="built_in">len</span>(graph) - <span class="number">1</span> <span class="keyword">or</span> nextY == <span class="built_in">len</span>(graph[<span class="number">0</span>]) - <span class="number">1</span>:</span><br><span class="line">                    visited[nextX][nextY] = <span class="number">2</span></span><br><span class="line">                    flag = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    visited[nextX][nextY] = <span class="number">1</span></span><br><span class="line">                    area += <span class="number">1</span></span><br><span class="line">                que.append([nextX, nextY])</span><br><span class="line">    <span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> area</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    graph = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        graph.append(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line">    </span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    visited = [[<span class="number">0</span>] * m <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> visited[i][j] == <span class="number">0</span> <span class="keyword">and</span> graph[i][j] == <span class="number">1</span>:</span><br><span class="line">                visited[i][j] = <span class="number">1</span></span><br><span class="line">                res += <span class="built_in">max</span>(bfs(graph, visited, i, j), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h1 id="102-沉没孤岛">102.沉没孤岛</h1><h6 id="题目描述">题目描述</h6><p>给定一个由 1（陆地）和 0（水）组成的矩阵，岛屿指的是由水平或垂直方向上相邻的陆地单元格组成的区域，且完全被水域单元格包围。孤岛是那些位于矩阵内部、所有单元格都不接触边缘的岛屿。</p><p>现在你需要将所有孤岛“沉没”，即将孤岛中的所有陆地单元格（1）转变为水域单元格（0）。</p><h6 id="输入描述">输入描述</h6><p>第一行包含两个整数 N, M，表示矩阵的行数和列数。</p><p>之后 N 行，每行包含 M 个数字，数字为 1 或者 0，表示岛屿的单元格。</p><h6 id="输出描述">输出描述</h6><p>输出将孤岛“沉没”之后的岛屿矩阵。 注意：每个元素后面都有一个空格</p><h6 id="输入示例">输入示例</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 1 0 0 0</span><br><span class="line">1 1 0 0 0</span><br><span class="line">0 0 1 0 0</span><br><span class="line">0 0 0 1 1</span><br></pre></td></tr></table></figure><h6 id="输出示例">输出示例</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 1 0 0 0</span><br><span class="line">1 1 0 0 0</span><br><span class="line">0 0 0 0 0</span><br><span class="line">0 0 0 1 1</span><br></pre></td></tr></table></figure><h6 id="提示信息">提示信息</h6><p><img src="https://kamacoder.com/upload/kamacoder.com/image/20240412/20240412144356_69900.png" alt="img"></p><p>将孤岛沉没。</p><p><img src="https://kamacoder.com/upload/kamacoder.com/image/20240412/20240412144445_89755.png" alt="img"></p><p>数据范围：</p><p>1 &lt;= M, N &lt;= 50。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从上、下、左、右开始将与边缘格子相邻的格子保持为陆地</span></span><br><span class="line"><span class="comment"># 将孤岛变成海洋</span></span><br><span class="line"></span><br><span class="line">direction = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">graph, x, y</span>):</span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">    que = deque()</span><br><span class="line">    que.append([x, y])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> que:</span><br><span class="line">        curx, cury = que.popleft()</span><br><span class="line">        <span class="comment"># 设置为2表示可以被保留</span></span><br><span class="line">        graph[curx][cury] = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> direction:</span><br><span class="line">            nextx = curx + i</span><br><span class="line">            nexty = cury + j</span><br><span class="line">            <span class="keyword">if</span> nextx &lt; <span class="number">0</span> <span class="keyword">or</span> nexty &lt; <span class="number">0</span> <span class="keyword">or</span> nextx &gt;= <span class="built_in">len</span>(graph) <span class="keyword">or</span> nexty &gt;= <span class="built_in">len</span>(graph[<span class="number">0</span>]):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> graph[nextx][nexty] == <span class="number">1</span>:</span><br><span class="line">                que.append([nextx, nexty])</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    graph = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        graph.append(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 从上、下两行开始</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">if</span> graph[<span class="number">0</span>][i] == <span class="number">1</span>:</span><br><span class="line">            bfs(graph, <span class="number">0</span>, i)</span><br><span class="line">        <span class="keyword">if</span> graph[n - <span class="number">1</span>][i] == <span class="number">1</span>:</span><br><span class="line">            bfs(graph, n - <span class="number">1</span>, i)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 从左、右两列开始</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> graph[i][<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">            bfs(graph, i, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> graph[i][m - <span class="number">1</span>] == <span class="number">1</span>:</span><br><span class="line">            bfs(graph, i, m - <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">if</span> graph[i][j] == <span class="number">1</span>:</span><br><span class="line">                graph[i][j] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> graph[i][j] == -<span class="number">1</span>:</span><br><span class="line">                graph[i][j] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> graph:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> line:</span><br><span class="line">            <span class="built_in">print</span>(i, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="103-水流问题">103 水流问题</h1><p><a href="https://kamacoder.com/problempage.php?pid=1175">https://kamacoder.com/problempage.php?pid=1175</a></p><p>题目描述</p><p>现有一个 N × M 的矩阵，每个单元格包含一个数值，这个数值代表该位置的相对高度。矩阵的左边界和上边界被认为是第一组边界，而矩阵的右边界和下边界被视为第二组边界。</p><p>矩阵模拟了一个地形，当雨水落在上面时，水会根据地形的倾斜向低处流动，但只能从较高或等高的地点流向较低或等高并且相邻（上下左右方向）的地点。我们的目标是确定那些单元格，从这些单元格出发的水可以达到第一组边界和第二组边界。</p><p>输入描述</p><p>第一行包含两个整数 N 和 M，分别表示矩阵的行数和列数。</p><p>后续 N 行，每行包含 M 个整数，表示矩阵中的每个单元格的高度。</p><p>输出描述</p><p>输出共有多行，每行输出两个整数，用一个空格隔开，表示可达第一组边界和第二组边界的单元格的坐标，输出顺序任意。</p><p>输入示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 5</span><br><span class="line">1 3 1 2 4</span><br><span class="line">1 2 1 3 2</span><br><span class="line">2 4 7 2 1</span><br><span class="line">4 5 6 1 1</span><br><span class="line">1 4 1 2 1</span><br></pre></td></tr></table></figure><p>输出示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0 4</span><br><span class="line">1 3</span><br><span class="line">2 2</span><br><span class="line">3 0</span><br><span class="line">3 1</span><br><span class="line">3 2</span><br><span class="line">4 0</span><br><span class="line">4 1</span><br></pre></td></tr></table></figure><p>提示信息</p><p><img src="https://kamacoder.com/upload/kamacoder.com/image/20240418/20240418103946_19439.png" alt="img"></p><p>图中的蓝色方块上的雨水既能流向第一组边界，也能流向第二组边界。所以最终答案为所有蓝色方块的坐标。</p><p>数据范围：</p><p>1 &lt;= M, N &lt;= 100。</p><h2 id="搜索思路">搜索思路</h2><p>一个比较直白的想法，其实就是 遍历每个点，然后看这个点 能不能同时到达第一组边界和第二组边界。</p><p>至于遍历方式，可以用dfs，也可以用bfs，以下用dfs来举例。</p><p>这种思路很直白，但很明显，以上代码超时了。 来看看时间复杂度。</p><p>遍历每一个节点，是 m * n，遍历每一个节点的时候，都要做深搜，深搜的时间复杂度是： m * n</p><p>那么整体时间复杂度 就是 O(m^2 * n^2) ，这是一个四次方的时间复杂度。</p><p>那么我们可以 <code>反过来想，从第一组边界上的节点 逆流而上，将遍历过的节点都标记上</code>。</p><p>同样从第二组边界的边上节点 逆流而上，将遍历过的节点也标记上。</p><p>然后<strong>两方都标记过的节点就是既可以流向第一组边界也可以流向第二组边界的节点</strong>。</p><p>从第一组边界边上节点出发，如图： （图中并没有把所有遍历的方向都画出来，只画关键部分）</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20250304174747.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20250304174747.png" alt="img"></p><p>从第二组边界上节点出发，如图： （图中并没有把所有遍历的方向都画出来，只画关键部分）</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20250304174801.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20250304174801.png" alt="img"></p><p>最后，我们得到两个方向交界的这些节点，就是我们最后要求的节点。</p><h2 id="深度优先搜索代码">深度优先搜索代码</h2><p>那么本题整体的时间复杂度其实是： 2 * n * m + n * m ，所以最终时间复杂度为 O(n * m) 。</p><p>空间复杂度为：O(n * m) 这个就不难理解了。开了几个 n * m 的数组</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">firstborder = <span class="built_in">set</span>()</span><br><span class="line">secondborder = <span class="built_in">set</span>()</span><br><span class="line">direction = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">graph, visited, border, x, y</span>):</span><br><span class="line">    <span class="keyword">if</span> visited[x][y] == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    visited[x][y] = <span class="number">1</span></span><br><span class="line">    border.add((x, y))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> direction:</span><br><span class="line">        nextx = x + i</span><br><span class="line">        nexty = y + j</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt;= nextx &lt; <span class="built_in">len</span>(graph) <span class="keyword">and</span> <span class="number">0</span> &lt;= nexty &lt; <span class="built_in">len</span>(graph[<span class="number">0</span>]) <span class="keyword">and</span> <span class="built_in">int</span>(graph[x][y]) &lt;= <span class="built_in">int</span>(graph[nextx][nexty]):</span><br><span class="line">            dfs(graph, visited, border, nextx, nexty)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">global</span> firstborder, secondborder</span><br><span class="line"></span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">    graph = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        graph.append(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line">    </span><br><span class="line">    visited = [[<span class="number">0</span>] * m <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># 从第一边界（第一列）和从第一边界（第一行）出发</span></span><br><span class="line">        dfs(graph, visited, firstborder, i, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        dfs(graph, visited, firstborder, <span class="number">0</span>, i)</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    visited = [[<span class="number">0</span>] * m <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># 第二边界（最后一列）和第二边界（最后一行）出发</span></span><br><span class="line">        dfs(graph, visited, secondborder, i, m - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        dfs(graph, visited, secondborder, n - <span class="number">1</span>, i)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    res = firstborder &amp; secondborder</span><br><span class="line">    <span class="comment"># 最后统计同时出现在firstborder和secondborder里的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x, y <span class="keyword">in</span> res:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;x&#125;</span> <span class="subst">&#123;y&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="广度优先思路">广度优先思路</h2><p>只有写法和深度优先不太一样，注意将visited的判断放在while循环内</p><h2 id="广度优先代码">广度优先代码</h2><p>那么本题整体的时间复杂度其实是： 2 * n * m + n * m ，所以最终时间复杂度为 O(n * m) 。</p><p>空间复杂度为：O(n * m) 这个就不难理解了。开了几个 n * m 的数组</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">graph, visited, border, x, y</span>):</span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">    que = deque()</span><br><span class="line">    que.append([x, y])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> que:</span><br><span class="line">        curx, cury = que.popleft()</span><br><span class="line">        <span class="keyword">if</span> visited[curx][cury] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        visited[curx][cury] = <span class="number">1</span></span><br><span class="line">        border.add((curx, cury))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> direction:</span><br><span class="line">            nextx = curx + i</span><br><span class="line">            nexty = cury + j</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= nextx &lt; <span class="built_in">len</span>(graph) <span class="keyword">and</span> <span class="number">0</span> &lt;= nexty &lt; <span class="built_in">len</span>(graph[<span class="number">0</span>]) <span class="keyword">and</span> <span class="built_in">int</span>(graph[curx][cury]) &lt;= <span class="built_in">int</span>(graph[nextx][nexty]):</span><br><span class="line">                que.append([nextx, nexty])</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">global</span> firstborder, secondborder</span><br><span class="line"></span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">    graph = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        graph.append(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line">    </span><br><span class="line">    visited = [[<span class="number">0</span>] * m <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># 从第一边界（第一列）和从第一边界（第一行）出发</span></span><br><span class="line">        bfs(graph, visited, firstborder, i, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        bfs(graph, visited, firstborder, <span class="number">0</span>, i)</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    visited = [[<span class="number">0</span>] * m <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># 第二边界（最后一列）和第二边界（最后一行）出发</span></span><br><span class="line">        bfs(graph, visited, secondborder, i, m - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        bfs(graph, visited, secondborder, n - <span class="number">1</span>, i)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    res = firstborder &amp; secondborder</span><br><span class="line">    <span class="comment"># 最后统计同时出现在firstborder和secondborder里的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x, y <span class="keyword">in</span> res:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;x&#125;</span> <span class="subst">&#123;y&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h1 id="104-建造最大岛屿">104.建造最大岛屿</h1><p><a href="https://kamacoder.com/problempage.php?pid=1176">https://kamacoder.com/problempage.php?pid=1176</a></p><p>题目描述</p><p>给定一个由 1（陆地）和 0（水）组成的矩阵，你最多可以将矩阵中的一格水变为一块陆地，在执行了此操作之后，矩阵中最大的岛屿面积是多少。</p><p>岛屿面积的计算方式为组成岛屿的陆地的总数。岛屿是被水包围，并且通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设矩阵外均被水包围。</p><p>输入描述</p><p>第一行包含两个整数 N, M，表示矩阵的行数和列数。之后 N 行，每行包含 M 个数字，数字为 1 或者 0，表示岛屿的单元格。</p><p>输出描述</p><p>输出一个整数，表示最大的岛屿面积。</p><p>输入示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 1 0 0 0</span><br><span class="line">1 1 0 0 0</span><br><span class="line">0 0 1 0 0</span><br><span class="line">0 0 0 1 1</span><br></pre></td></tr></table></figure><p>输出示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><p>提示信息</p><p><img src="https://kamacoder.com/upload/kamacoder.com/image/20240415/20240415145559_94626.png" alt="img"></p><p>对于上面的案例，有两个位置可将 0 变成 1，使得岛屿的面积最大，即 6。</p><p><img src="https://kamacoder.com/upload/kamacoder.com/image/20240415/20240415145650_61097.png" alt="img"></p><p>数据范围：</p><p>1 &lt;= M, N &lt;= 50。</p><h2 id="搜索代码">搜索代码</h2><p>其实每次深搜遍历计算最大岛屿面积，我们都做了很多重复的工作。</p><p>只要用一次深搜把每个岛屿的面积记录下来就好。</p><p>第一步：一次遍历地图，得出各个岛屿的面积，并做编号记录。可以使用map记录，key为岛屿编号，value为岛屿面积</p><p>第二步：再遍历地图，遍历0的方格（因为要将0变成1），并统计该1（由0变成的1）周边岛屿面积，将其相邻面积相加在一起，遍历所有 0 之后，就可以得出 选一个0变成1 之后的最大面积。</p><p>拿如下地图的岛屿情况来举例： （1为陆地）</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20220829104834.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20220829104834.png" alt="img"></p><p>第一步，则遍历地图，并将岛屿的编号和面积都统计好，过程如图所示：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20220829105644.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20220829105644.png" alt="img"></p><p>这个过程时间复杂度 n * n 。可能有录友想：分明是两个for循环下面套这一个dfs，时间复杂度怎么回事 n * n呢？</p><p>其实大家可以仔细看一下代码，<strong>n * n这个方格地图中，每个节点我们就遍历一次，并不会重复遍历</strong>。</p><p>第二步过程如图所示：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20220829105249.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20220829105249.png" alt="img"></p><p>也就是遍历每一个0的方格，并统计其相邻岛屿面积，最后取一个最大值。</p><p>这个过程的时间复杂度也为 n * n。</p><p>所以整个解法的时间复杂度，为 n * n + n * n 也就是 n^2。</p><p>当然这里还有一个优化的点，就是 可以不用 visited数组，因为有mark来标记，所以遍历过的grid[i][j]是不等于1的。</p><h2 id="广度优先代码">广度优先代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 技巧解题</span></span><br><span class="line"><span class="comment"># 先把所有岛屿面积求出来，并且给这个岛屿进行编号（需要修改graph里这个岛屿块数值），并记录这个编号岛屿的面积（放在字典里）</span></span><br><span class="line"><span class="comment"># 再遍历所有海洋（假设把当前海洋变成陆地），并且计算当前这块海洋相邻的岛屿总面积，就能找到一个最合适变成陆地的海洋块</span></span><br><span class="line"></span><br><span class="line">direction = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># bfs的目的是计算每个岛屿的面积，以及将岛屿“涂色”，同一个岛屿将拥有相同的编号</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">graph, visited, x, y, number</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">    area = <span class="number">1</span></span><br><span class="line">    que = deque()</span><br><span class="line">    que.append([x, y])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> que:</span><br><span class="line">        curx, cury = que.popleft()</span><br><span class="line">        <span class="comment"># 进行岛屿编号</span></span><br><span class="line">        graph[curx][cury] = number</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> direction:</span><br><span class="line">            nextx = curx + i</span><br><span class="line">            nexty = cury + j</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span>&lt;= nextx &lt; <span class="built_in">len</span>(graph) <span class="keyword">and</span> <span class="number">0</span>&lt;= nexty &lt; <span class="built_in">len</span>(graph[<span class="number">0</span>]) <span class="keyword">and</span> visited[nextx][nexty] == <span class="number">0</span> <span class="keyword">and</span> graph[nextx][nexty] == <span class="number">1</span>:</span><br><span class="line">              <span class="comment"># 注意计算面积的位置</span></span><br><span class="line">                visited[nextx][nexty] = <span class="number">1</span></span><br><span class="line">                area += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                que.append([nextx, nexty])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> area</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">    graph = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        graph.append(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line">    </span><br><span class="line">    number = <span class="number">1</span></span><br><span class="line">    <span class="comment"># res为最大岛屿面积</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    table = <span class="built_in">dict</span>()</span><br><span class="line">    visited = [[<span class="number">0</span>] * (m) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="comment"># 第一次遍历，将岛屿编号并且记录最大面积</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">if</span> graph[i][j] != <span class="number">0</span> <span class="keyword">and</span> visited[i][j] == <span class="number">0</span>:</span><br><span class="line">                number += <span class="number">1</span></span><br><span class="line">                temp  = bfs(graph, visited, i, j, number)</span><br><span class="line">                res = <span class="built_in">max</span>(res, temp)</span><br><span class="line">                table[number] = temp</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 第二次遍历，只针对海洋进行操作</span></span><br><span class="line">    <span class="comment"># 对海洋块的周围岛屿进行计算，注意某一个海洋块，有可能被同一个编号的岛屿包围，所以不要重复添加某个岛屿</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="comment"># 如果为海洋</span></span><br><span class="line">            <span class="keyword">if</span> graph[x][y] == <span class="number">0</span>:</span><br><span class="line">                temp = <span class="number">1</span></span><br><span class="line">                <span class="comment"># 记录是否已经添加过某个岛屿</span></span><br><span class="line">                added = <span class="built_in">set</span>()</span><br><span class="line">                <span class="keyword">for</span> i, j <span class="keyword">in</span> direction:</span><br><span class="line">                    nextx = x + i</span><br><span class="line">                    nexty = y + j</span><br><span class="line">                    <span class="keyword">if</span> <span class="number">0</span>&lt;= nextx &lt; <span class="built_in">len</span>(graph) <span class="keyword">and</span> <span class="number">0</span>&lt;= nexty &lt; <span class="built_in">len</span>(graph[<span class="number">0</span>]) <span class="keyword">and</span> graph[nextx][nexty] != <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">if</span> graph[nextx][nexty] <span class="keyword">not</span> <span class="keyword">in</span> added:</span><br><span class="line">                            temp += table[graph[nextx][nexty]]</span><br><span class="line">                            added.add(graph[nextx][nexty])</span><br><span class="line">                <span class="comment"># 求岛屿最大面积</span></span><br><span class="line">                res = <span class="built_in">max</span>(temp, res)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday52图论part03&quot;&gt;LeetCodeCampsDay52图论part03&lt;/h1&gt;
&lt;h1 id=&quot;101-孤岛的总面积&quot;&gt;101.孤岛的总面积&lt;/h1&gt;
&lt;h6 id=&quot;题目描述&quot;&gt;题目描述&lt;/h6&gt;
&lt;p&gt;给定一个由 1（陆</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>服务器上使用Hysteria2配合Proxychain代理</title>
    <link href="https://blog.lthero.cn/2025/08/21/Hysteria2Proxychain/"/>
    <id>https://blog.lthero.cn/2025/08/21/Hysteria2Proxychain/</id>
    <published>2025-08-21T13:37:50.000Z</published>
    <updated>2025-08-21T14:04:48.386Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hysteria2客户端使用教程">Hysteria2客户端使用教程</h1><blockquote><p>本文是在linux服务器上（作为客户端！）使用hysteria2代理，不是在服务器上搭建hysteria2！！！！</p></blockquote><h2 id="客户端安装">客户端安装</h2><p>官方教程：<a href="https://v2.hysteria.network/zh/docs/getting-started/Installation/">https://v2.hysteria.network/zh/docs/getting-started/Installation/</a></p><blockquote><p>但！由于需要用本方法的机器无法直接用代理，所以安装hysteria2最好先将hy2可执行文件下载到电脑上，再上传到服务器上，再使用本地安装</p></blockquote><ol><li>下载可执行文件</li></ol><table><thead><tr><th style="text-align:left">文件</th><th style="text-align:left">架构</th><th style="text-align:left">注意</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://download.hysteria.network/app/latest/hysteria-linux-amd64">hysteria-linux-amd64</a></td><td style="text-align:left">x86-64</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://download.hysteria.network/app/latest/hysteria-linux-amd64-avx">hysteria-linux-amd64-avx</a></td><td style="text-align:left">x86-64</td><td style="text-align:left">需要 AVX 指令集</td></tr><tr><td style="text-align:left"><a href="https://download.hysteria.network/app/latest/hysteria-linux-386">hysteria-linux-386</a></td><td style="text-align:left">x86</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://download.hysteria.network/app/latest/hysteria-linux-arm">hysteria-linux-arm</a></td><td style="text-align:left">ARMv7</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://download.hysteria.network/app/latest/hysteria-linux-armv5">hysteria-linux-armv5</a></td><td style="text-align:left">ARMv5</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://download.hysteria.network/app/latest/hysteria-linux-arm64">hysteria-linux-arm64</a></td><td style="text-align:left">ARM64</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://download.hysteria.network/app/latest/hysteria-linux-s390x">hysteria-linux-s390x</a></td><td style="text-align:left">s390x</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://download.hysteria.network/app/latest/hysteria-linux-mipsle">hysteria-linux-mipsle</a></td><td style="text-align:left">MIPS</td><td style="text-align:left">小端序</td></tr><tr><td style="text-align:left"><a href="https://download.hysteria.network/app/latest/hysteria-linux-mipsle-sf">hysteria-linux-mipsle-sf</a></td><td style="text-align:left">MIPS</td><td style="text-align:left">小端序，无硬件浮点支持</td></tr><tr><td style="text-align:left"><a href="https://download.hysteria.network/app/latest/hysteria-linux-riscv64">hysteria-linux-riscv64</a></td><td style="text-align:left">RISC-V 64</td><td style="text-align:left"></td></tr></tbody></table><ol start="2"><li>使用本地文件安装的命令，/path/to/hysteria-linux-amd64是可执行文件路径</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash &lt;(curl -fsSL https://get.hy2.sh/) --<span class="built_in">local</span> /path/to/hysteria-linux-amd64</span><br></pre></td></tr></table></figure><ol start="3"><li>如果连<code>curl -fsSL https://get.hy2.sh/</code>都会卡住，那就先把脚本上传到服务器，再本地执行这脚本，<code>假如脚本名字为hy2.sh</code></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash hy2.sh --<span class="built_in">local</span> /path/to/hysteria-linux-amd64</span><br></pre></td></tr></table></figure><h2 id="客户端本文教程">客户端本文教程</h2><p>官方教程：<a href="https://v2.hysteria.network/zh/docs/getting-started/Client/">https://v2.hysteria.network/zh/docs/getting-started/Client/</a></p><h3 id="前提条件">前提条件</h3><ul><li>一个能连接的 Hysteria 服务器</li></ul><h3 id="创建配置文件">创建配置文件</h3><p>假设你已经将可执行文件下载到了一个目录中，名字是 <code>hysteria-linux-amd64-avx</code>。在同目录下创建一个 <code>config.yaml</code> 文件。</p><blockquote><p><strong>注意</strong>： 部分配置项值可能和 YAML 语法冲突。 例如， 类似于 <code>[2001:db8::1]:443</code> 的 IPv6 地址+端口会导致配置文件解析失败。 只需将值放在 <code>&quot;&quot;</code> 中写成 <code>&quot;[2001:db8::1]:443&quot;</code> 即可解决这类问题。</p></blockquote><p><strong>请务必根据你的服务器设置和需求替换这些值。</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span> <span class="string">xx.xxx.xx.xx:1122</span> <span class="comment"># 服务器ip和端口</span></span><br><span class="line"><span class="attr">auth:</span> <span class="string">xxxxx</span>  <span class="comment"># 输入密码</span></span><br><span class="line"></span><br><span class="line"><span class="attr">bandwidth:</span></span><br><span class="line">  <span class="attr">up:</span> <span class="number">200</span> <span class="string">mbps</span>  </span><br><span class="line">  <span class="attr">down:</span> <span class="number">200</span> <span class="string">mbps</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">tls:</span></span><br><span class="line">  <span class="attr">sni:</span> <span class="string">bing.com</span>  <span class="comment"># 输入伪装域名</span></span><br><span class="line">  <span class="attr">insecure:</span> <span class="literal">true</span>  <span class="comment"># 根据服务端进行配置，自签证书则为true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">socks5:</span></span><br><span class="line">  <span class="attr">listen:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:1080</span></span><br><span class="line"><span class="attr">http:</span></span><br><span class="line">  <span class="attr">listen:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8080</span></span><br></pre></td></tr></table></figure><h2 id="运行客户端">运行客户端</h2><p>通过以下命令启动客户端：</p><p><strong>默认文件名（config.yaml）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./hysteria-linux-amd64-avx</span><br></pre></td></tr></table></figure><p>或者！或者！或者！或者！或者！或者！</p><p><strong>自定义文件名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./hysteria-linux-amd64-avx -c whatever.yaml</span><br></pre></td></tr></table></figure><blockquote><p><strong>提示：</strong> 你也可以使用 <code>./hysteria-linux-amd64-avx client</code>，但由于客户端是默认模式，所以这部分可以省略。</p></blockquote><p>如果你看到日志显示 “connected to server” 且没有错误，恭喜 🎉！你已成功部署了一个 Hysteria 客户端。</p><blockquote><p>后续可以使用systemctl添加个服务，来管理hysteria自动启动</p></blockquote><h1 id="proxychains搭建使用教程">proxychains搭建使用教程</h1><p>拥有v2ray后，再搭配proxychains，从而让各种linux上软件可以访问外网</p><h2 id="一-debian安装">一、Debian安装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install proxychains4 -y</span><br></pre></td></tr></table></figure><h2 id="二-centos安装">二、Centos安装</h2><h3 id="1-有epel源">1、有epel源</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y proxychains-ng</span><br></pre></td></tr></table></figure><h2 id="自行编译">自行编译</h2><h4 id="1-下载源码">(1)下载源码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://ghproxy.com/https://github.com/rofl0r/proxychains-ng.git</span><br></pre></td></tr></table></figure><h4 id="2-编译和安装">(2)编译和安装</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apt install gcc</span><br><span class="line">cd proxychains-ng</span><br><span class="line">./configure --prefix=/usr --sysconfdir=/etc</span><br><span class="line">make </span><br><span class="line">make install</span><br><span class="line">make install-config</span><br><span class="line">cd .. &amp;&amp; rm -rf proxychains-ng</span><br></pre></td></tr></table></figure><h4 id="3-查看proxychains是否安装">(3)查看proxychains是否安装</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">which proxychains4</span><br></pre></td></tr></table></figure><h2 id="三-修改配置文件">三、修改配置文件</h2><p>已经准备好了一个可用的socks代理，<code>上面的hysteria2就行，它的socks端口是1080</code></p><p>安装后默认配置文件在<code>/etc/proxychains4.conf</code></p><p>proxychains-ng支持多种代理模式：</p><ul><li>dynamic_chain ：按照代理列表顺序自动选取可用代理</li><li>strict_chain ：按照代理列表顺序使用代理，所有代理必须可用</li><li>round_robin_chain ：轮询模式，自动跳过不可用代理</li><li>random_chain ：随机模式</li></ul><p>我们只需要编辑proxychains的配置文件，将scosks代理的ip，端口，用户名，密码填进去即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/proxychains4.conf </span><br><span class="line"><span class="comment">#直接划到最后并添加下面的内容</span></span><br><span class="line"><span class="comment">#使用hysteria2默认的本地代理，本地ip和端口要和上面的对应上</span></span><br><span class="line">socks5 127.0.0.1 1080</span><br></pre></td></tr></table></figure><h2 id="四-使用">四、使用</h2><p>只需要使用代理的命令前加上proxychains就可以了，比如</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 curl cip.cc</span><br></pre></td></tr></table></figure><p>我们可以看到IP已经变成socks代理的IP</p><p>当然，也可以直接输入</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 bash</span><br></pre></td></tr></table></figure><p>这样就能新建一个具有代理功能的新终端，不需要在每条命令前都加proxychains了</p><p><code>甚至可以添加个alias,把proxychains4别称为proxy</code></p><p>操作如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br><span class="line"><span class="comment"># 添加下面这行，其中proxy是别称</span></span><br><span class="line"><span class="built_in">alias</span> proxy=<span class="string">&#x27;proxychains4&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;hysteria2客户端使用教程&quot;&gt;Hysteria2客户端使用教程&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;本文是在linux服务器上（作为客户端！）使用hysteria2代理，不是在服务器上搭建hysteria2！！！！&lt;/p&gt;
&lt;/blockquote&gt;
</summary>
      
    
    
    
    <category term="折腾" scheme="https://blog.lthero.cn/categories/%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="折腾" scheme="https://blog.lthero.cn/tags/%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay51图论part02</title>
    <link href="https://blog.lthero.cn/2025/08/14/LeetCodeCampsDay51/"/>
    <id>https://blog.lthero.cn/2025/08/14/LeetCodeCampsDay51/</id>
    <published>2025-08-14T04:44:48.000Z</published>
    <updated>2025-08-14T06:10:38.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday51图论part02">LeetCodeCampsDay51图论part02</h1><blockquote><p>包含深度优先搜索和广度优先搜索的基础代码</p></blockquote><h1 id="99-岛屿数量">99. 岛屿数量</h1><p><a href="https://kamacoder.com/problempage.php?pid=1171">https://kamacoder.com/problempage.php?pid=1171</a></p><p>题目描述</p><p>给定一个由 1（陆地）和 0（水）组成的矩阵，你需要计算岛屿的数量。岛屿由水平方向或垂直方向上相邻的陆地连接而成，并且四周都是水域。你可以假设矩阵外均被水包围。</p><p>输入描述</p><p>第一行包含两个整数 N, M，表示矩阵的行数和列数。</p><p>后续 N 行，每行包含 M 个数字，数字为 1 或者 0。</p><p>输出描述</p><p>输出一个整数，表示岛屿的数量。如果不存在岛屿，则输出 0。</p><p>输入示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 1 0 0 0</span><br><span class="line">1 1 0 0 0</span><br><span class="line">0 0 1 0 0</span><br><span class="line">0 0 0 1 1</span><br></pre></td></tr></table></figure><p>输出示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p>提示信息</p><p><img src="https://kamacoder.com/upload/kamacoder.com/image/20240411/20240411153209_67737.png" alt="img"></p><p>根据测试案例中所展示，岛屿数量共有 3 个，所以输出 3。</p><p><strong>数据范围：</strong></p><p>1 &lt;= N, M &lt;= 50</p><h2 id="图论思路">图论思路</h2><p>注意题目中每座岛屿只能由<strong>水平方向和/或竖直方向上</strong>相邻的陆地连接形成。</p><p>也就是说斜角度链接是不算了， 例如示例二，是三个岛屿，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20220726094200.png" alt="图一"></p><p><img src="https://file1.kamacoder.com/i/algo/20220726094200.png" alt="图一"></p><p>这道题题目是 DFS，BFS，并查集，基础题目。</p><p>本题思路，是用遇到一个没有遍历过的节点陆地，计数器就加一，然后把该节点陆地所能遍历到的陆地都标记上。</p><p>在遇到标记过的陆地节点和海洋节点的时候直接跳过。 这样计数器就是最终岛屿的数量。</p><p>那么如何把节点陆地所能遍历到的陆地都标记上呢，就可以使用 DFS，BFS或者并查集</p><h2 id="深度优先dfs代码">深度优先DFS代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">direction = [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>],[-<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,-<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">graph, visited, x, y</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">  <span class="comment"># 注意，仅探索x,y的上、下、左、右相邻的区域</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        nextX = x + direction[i][<span class="number">0</span>]</span><br><span class="line">        nextY = y + direction[i][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> nextX&lt;<span class="number">0</span> <span class="keyword">or</span> nextX&gt;=<span class="built_in">len</span>(graph) <span class="keyword">or</span> nextY&lt;<span class="number">0</span> <span class="keyword">or</span> nextY &gt;= <span class="built_in">len</span>(graph[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> visited[nextX][nextY] == <span class="number">0</span> <span class="keyword">and</span> graph[nextX][nextY] == <span class="number">1</span>:</span><br><span class="line">            visited[nextX][nextY] = <span class="number">1</span></span><br><span class="line">            dfs(graph, visited, nextX, nextY)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">    table = []</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        table.append(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    visited = [[<span class="number">0</span>] * (m) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">if</span> visited[i][j] == <span class="number">0</span> <span class="keyword">and</span> table[i][j] == <span class="number">1</span>:</span><br><span class="line">                visited[i][j] == <span class="number">1</span></span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 把i,j附近相邻的区域（上、下、左、右相邻位置）全部标记为1（已经探索过）</span></span><br><span class="line">                dfs(table, visited, i, j)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>上面的dfs代码没有直接写终止条件，也可以直接写终止条件</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">direction = [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>],[-<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,-<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">graph, visited, x, y</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">  <span class="comment"># 表示 如果当前节点已经被访问或者本身不可达，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> visited[x][y] == <span class="number">1</span> <span class="keyword">or</span> graph[x][y] == <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 记录为访问过</span></span><br><span class="line">    visited[x][y] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment"># 注意，仅探索x,y的上、下、左、右相邻的区域</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        nextX = x + direction[i][<span class="number">0</span>]</span><br><span class="line">        nextY = y + direction[i][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> nextX&lt;<span class="number">0</span> <span class="keyword">or</span> nextX&gt;=<span class="built_in">len</span>(graph) <span class="keyword">or</span> nextY&lt;<span class="number">0</span> <span class="keyword">or</span> nextY &gt;= <span class="built_in">len</span>(graph[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        dfs(graph, visited, nextX, nextY)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">    table = []</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        table.append(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    visited = [[<span class="number">0</span>] * (m) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">if</span> visited[i][j] == <span class="number">0</span> <span class="keyword">and</span> table[i][j] == <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># visited[i][j] == 1， 注意这种先判断终止条件的写法不需要在前面将当前位置设置已经去过</span></span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 把i,j附近相邻的区域（上、下、左、右相邻位置）全部标记为1（已经探索过）</span></span><br><span class="line">                dfs(table, visited, i, j)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>在二叉树里，深度优先搜索和前、中、后序遍历可以对应上</p><p>而广度优先遍历则可以和层序遍历对应上</p><h2 id="广搜的过程">广搜的过程</h2><p>上面我们提过，BFS是一圈一圈的搜索过程，但具体是怎么一圈一圈来搜呢。</p><p>我们用一个方格地图，假如每次搜索的方向为 上下左右（不包含斜上方），那么给出一个start起始位置，那么BFS就是从四个方向走出第一步。</p><p><img src="https://file1.kamacoder.com/i/algo/20220825104505.png" alt="图一"></p><p>如果加上一个end终止位置，那么使用BFS的搜索过程如图所示：</p><p><img src="https://file1.kamacoder.com/i/algo/20220825102653.png" alt="图二"></p><p>我们从图中可以看出，从start起点开始，是一圈一圈，向外搜索，方格编号1为第一步遍历的节点，方格编号2为第二步遍历的节点，第四步的时候我们找到终止点end。</p><p>正是因为BFS一圈一圈的遍历方式，所以一旦遇到终止点，那么一定是一条最短路径。</p><p>而且地图还可以有障碍，如图所示：</p><p><img src="https://file1.kamacoder.com/i/algo/20220825103900.png" alt="图三"></p><p>在第五步，第六步 我只把关键的节点染色了，其他方向周边没有去染色，大家只要关注关键地方染色的逻辑就可以。</p><p>从图中可以看出，如果添加了障碍，我们是第六步才能走到end终点。</p><p>只要BFS只要搜到终点一定是一条最短路径，大家可以参考上面的图，自己再去模拟一下</p><h2 id="代码框架">代码框架</h2><p>大家应该好奇，这一圈一圈的搜索过程是怎么做到的，是放在什么容器里，才能这样去遍历。</p><p>很多网上的资料都是直接说用队列来实现。</p><p>其实，我们仅仅需要一个容器，能保存我们要遍历过的元素就可以，<strong>那么用队列，还是用栈，甚至用数组，都是可以的</strong>。</p><p><strong>用队列的话，就是保证每一圈都是一个方向去转，例如统一顺时针或者逆时针</strong>。</p><p>因为队列是先进先出，加入元素和弹出元素的顺序是没有改变的。</p><p><strong>如果用栈的话，就是第一圈顺时针遍历，第二圈逆时针遍历，第三圈有顺时针遍历</strong>。</p><p>因为栈是先进后出，加入元素和弹出元素的顺序改变了。</p><p>那么广搜需要注意 转圈搜索的顺序吗？ 不需要！</p><p>所以用队列，还是用栈都是可以的，但大家都习惯用队列了，<strong>所以下面的讲解用我也用队列来讲，只不过要给大家说清楚，并不是非要用队列，用栈也可以</strong>。</p><h2 id="广度优先bfs代码">广度优先BFS代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">direction = [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>],[-<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,-<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 广搜索用队列会方便一些，但使用栈也可以</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">graph, visited, x, y</span>):</span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">    que = deque()</span><br><span class="line">    que.append([x, y])</span><br><span class="line">    visited[x][y] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> que:</span><br><span class="line">        curX, curY = que.popleft()</span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> direction:</span><br><span class="line">            nextX = curX + i</span><br><span class="line">            nextY = curY + j</span><br><span class="line">            <span class="keyword">if</span> nextX&lt;<span class="number">0</span> <span class="keyword">or</span> nextX&gt;=<span class="built_in">len</span>(graph) <span class="keyword">or</span> nextY&lt;<span class="number">0</span> <span class="keyword">or</span> nextY &gt;= <span class="built_in">len</span>(graph[<span class="number">0</span>]):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> visited[nextX][nextY] == <span class="number">0</span> <span class="keyword">and</span> graph[nextX][nextY] == <span class="number">1</span>:</span><br><span class="line">                visited[nextX][nextY] = <span class="number">1</span></span><br><span class="line">                que.append([nextX, nextY])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">    table = []</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        table.append(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    visited = [[<span class="number">0</span>] * (m) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">if</span> visited[i][j] == <span class="number">0</span> <span class="keyword">and</span> table[i][j] == <span class="number">1</span>:</span><br><span class="line">                visited[i][j] == <span class="number">1</span></span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">                bfs(table, visited, i, j)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h1 id="100-岛屿的最大面积">100. 岛屿的最大面积</h1><p>题目描述</p><p>给定一个由 1（陆地）和 0（水）组成的矩阵，计算岛屿的最大面积。岛屿面积的计算方式为组成岛屿的陆地的总数。岛屿由水平方向或垂直方向上相邻的陆地连接而成，并且四周都是水域。你可以假设矩阵外均被水包围。</p><p>输入描述</p><p>第一行包含两个整数 N, M，表示矩阵的行数和列数。后续 N 行，每行包含 M 个数字，数字为 1 或者 0，表示岛屿的单元格。</p><p>输出描述</p><p>输出一个整数，表示岛屿的最大面积。如果不存在岛屿，则输出 0。</p><p>输入示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 1 0 0 0</span><br><span class="line">1 1 0 0 0</span><br><span class="line">0 0 1 0 0</span><br><span class="line">0 0 0 1 1</span><br></pre></td></tr></table></figure><p>输出示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>提示信息</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240412103942_51284.png" alt="img"></p><p><img src="https://kamacoder.com/upload/kamacoder.com/image/20240412/20240412103942_51284.png" alt="img"></p><p>样例输入中，岛屿的最大面积为 4。</p><p>数据范围：</p><p>1 &lt;= M, N &lt;= 50。</p><h2 id="深度优先思路">深度优先思路</h2><p>和上面题目很像，但这次是求每个小岛的面积，也那在对每个小岛开始遍历时，需要在dfs函数里统计相邻块的面积</p><p>就是搜索每个岛屿上“1”的数量，然后取一个最大的。</p><h2 id="深度优先dfs代码">深度优先DFS代码</h2><ul><li>时间复杂度O(m + n)</li><li>空间复杂度O(m + n)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">direction = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">graph, visited, x: <span class="built_in">int</span>, y: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    area = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> direction:</span><br><span class="line">        nextX = x + i</span><br><span class="line">        nextY = y + j</span><br><span class="line">        <span class="comment"># 如果下一个节点不可达，直接跳过</span></span><br><span class="line">        <span class="keyword">if</span> nextX &lt; <span class="number">0</span> <span class="keyword">or</span> nextY &lt; <span class="number">0</span> <span class="keyword">or</span> nextX &gt;= <span class="built_in">len</span>(graph) <span class="keyword">or</span> nextY &gt;= <span class="built_in">len</span>(graph[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> graph[nextX][nextY] == <span class="number">1</span> <span class="keyword">and</span> visited[nextX][nextY]== <span class="number">0</span>:</span><br><span class="line">            visited[nextX][nextY] = <span class="number">1</span></span><br><span class="line">            area += dfs(graph, visited, nextX, nextY)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> area</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    graph = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        graph.append(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line">    </span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    visited = [[<span class="number">0</span>] * m <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">if</span> graph[i][j] == <span class="number">1</span> <span class="keyword">and</span> visited[i][j] == <span class="number">0</span>:</span><br><span class="line">                visited[i][j] = <span class="number">1</span></span><br><span class="line">                <span class="comment"># 搜索每个岛屿上“1”的数量，然后取一个最大的。</span></span><br><span class="line">                res = <span class="built_in">max</span>(dfs(graph, visited, i, j), res)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="深度优先代码2">深度优先代码2</h2><ul><li>时间复杂度O(m + n)</li><li>空间复杂度O(m + n)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">direction = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs2</span>(<span class="params">graph, visited, x: <span class="built_in">int</span>, y: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">  <span class="comment"># 注意要写终止条件，并且返回0</span></span><br><span class="line">    <span class="keyword">if</span> graph[x][y] == <span class="number">0</span> <span class="keyword">or</span> visited[x][y] == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 单层逻辑</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 当前位置记录为已经去过</span></span><br><span class="line">    visited[x][y] = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 初始化面积为1</span></span><br><span class="line">    area = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> direction:</span><br><span class="line">        nextX = x + i</span><br><span class="line">        nextY = y + j</span><br><span class="line">        <span class="comment"># 如果越界则跳过</span></span><br><span class="line">        <span class="keyword">if</span> nextX &lt; <span class="number">0</span> <span class="keyword">or</span> nextY &lt; <span class="number">0</span> <span class="keyword">or</span> nextX &gt;= <span class="built_in">len</span>(graph) <span class="keyword">or</span> nextY &gt;= <span class="built_in">len</span>(graph[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># 将面积增加</span></span><br><span class="line">        area += dfs2(graph, visited, nextX, nextY)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> area</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    graph = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        graph.append(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line">    </span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    visited = [[<span class="number">0</span>] * m <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">if</span> graph[i][j] == <span class="number">1</span> <span class="keyword">and</span> visited[i][j] == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># visited[i][j] = 1 </span></span><br><span class="line">                <span class="comment"># 搜索每个岛屿上“1”的数量，然后取一个最大的。</span></span><br><span class="line">                res = <span class="built_in">max</span>(dfs2(graph, visited, i, j), res)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="广度优先代码">广度优先代码</h2><ul><li>时间复杂度O(m + n)</li><li>空间复杂度O(m + n)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">graph, visited, x: <span class="built_in">int</span>, y: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">    que = deque()</span><br><span class="line">    que.append([x, y])</span><br><span class="line"></span><br><span class="line">    area = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> que:</span><br><span class="line">        curX, curY = que.popleft()</span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> direction:</span><br><span class="line">            nextX = curX + i</span><br><span class="line">            nextY = curY + j</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> nextX &lt; <span class="number">0</span> <span class="keyword">or</span> nextY &lt; <span class="number">0</span> <span class="keyword">or</span> nextX &gt;= <span class="built_in">len</span>(graph) <span class="keyword">or</span> nextY &gt;= <span class="built_in">len</span>(graph[<span class="number">0</span>]):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> graph[nextX][nextY] == <span class="number">1</span> <span class="keyword">and</span> visited[nextX][nextY] == <span class="number">0</span>:</span><br><span class="line">                area += <span class="number">1</span></span><br><span class="line">                visited[nextX][nextY] = <span class="number">1</span></span><br><span class="line">                que.append([nextX,nextY])</span><br><span class="line">    <span class="keyword">return</span> area</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    graph = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        graph.append(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line">    </span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    visited = [[<span class="number">0</span>] * m <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">if</span> graph[i][j] == <span class="number">1</span> <span class="keyword">and</span> visited[i][j] == <span class="number">0</span>:</span><br><span class="line">                visited[i][j] = <span class="number">1</span></span><br><span class="line">                <span class="comment"># 搜索每个岛屿上“1”的数量，然后取一个最大的。</span></span><br><span class="line">                res = <span class="built_in">max</span>(bfs(graph, visited, i, j), res)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday51图论part02&quot;&gt;LeetCodeCampsDay51图论part02&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;包含深度优先搜索和广度优先搜索的基础代码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;99-岛屿数量&quot;&gt;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay50图论part01</title>
    <link href="https://blog.lthero.cn/2025/08/13/LeetCodeCampsDay50/"/>
    <id>https://blog.lthero.cn/2025/08/13/LeetCodeCampsDay50/</id>
    <published>2025-08-13T15:40:25.000Z</published>
    <updated>2025-08-23T06:28:08.817Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday50图论part01">LeetCodeCampsDay50图论part01</h1><blockquote><p>图论基础</p></blockquote><h1 id="图的基本概念">图的基本概念</h1><p>二维坐标中，两点可以连成线，多个点连成的线就构成了图。</p><p>当然图也可以就一个节点，甚至没有节点（空图）</p><h3 id="图的种类">图的种类</h3><p>整体上一般分为 有向图 和 无向图。</p><p>有向图是指 图中边是有方向的：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240510195737.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240510195737.png" alt="img"></p><p>无向图是指 图中边没有方向：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240510195451.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240510195451.png" alt="img"></p><p>加权有向图，就是图中边是有权值的，例如：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240510195821.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240510195821.png" alt="img"></p><p>加权无向图也是同理。</p><h3 id="度">度</h3><p>无向图中有几条边连接该节点，该节点就有几度。</p><p>例如，该无向图中，节点4的度为5，节点6的度为3。</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240511115029.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240511115029.png" alt="img"></p><p>在有向图中，每个节点有出度和入度。</p><p>出度：从该节点出发的边的个数。</p><p>入度：指向该节点边的个数。</p><p>例如，该有向图中，节点3的入度为2，出度为1，节点1的入度为0，出度为2。</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240511115235.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240511115235.png" alt="img"></p><h2 id="连通性">连通性</h2><p>在图中表示节点的连通情况，我们称之为连通性。</p><h3 id="连通图">连通图</h3><p>在无向图中，任何两个节点都是可以到达的，我们称之为连通图 ，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240511102351.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240511102351.png" alt="img"></p><p>如果有节点不能到达其他节点，则为非连通图，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240511102449.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240511102449.png" alt="img"></p><p>节点1 不能到达节点4。</p><h3 id="强连通图">强连通图</h3><p>在有向图中，任何两个节点是可以相互到达的，我们称之为 强连通图。</p><p>这里有录友可能想，这和无向图中的连通图有什么区别，不是一样的吗？</p><p>我们来看这个有向图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240511104531.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240511104531.png" alt="img"></p><p>这个图是强连通图吗？</p><p>初步一看，好像这节点都连着呢，但这不是强连通图，节点1 可以到节点5，但节点5 不能到 节点1 。</p><p>强连通图是在有向图中<strong>任何两个节点是可以相互到达</strong></p><p>下面这个有向图才是强连通图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20240511113101.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20240511113101.png" alt="img"></p><h3 id="连通分量">连通分量</h3><p>在无向图中的极大连通子图称之为该图的一个连通分量。</p><p>只看概念大家可能不理解，我来画个图：</p><p><img src="https://file1.kamacoder.com/i/algo/20240511111559.png" alt="img"></p><p>该无向图中 节点1、节点2、节点5 构成的子图就是 该无向图中的一个连通分量，该子图所有节点都是相互可达到的。</p><p>同理，节点3、节点4、节点6 构成的子图 也是该无向图中的一个连通分量。</p><p>那么无向图中 节点3 、节点4 构成的子图 是该无向图的联通分量吗？</p><p>不是！</p><p>因为必须是极大联通子图才能是连通分量，所以 必须是节点3、节点4、节点6 构成的子图才是连通分量。</p><p>在图论中，连通分量是一个很重要的概念，例如岛屿问题（后面章节会有专门讲解）其实就是求连通分量。</p><h3 id="强连通分量"><a href="https://www.programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F">#</a>强连通分量</h3><p>在有向图中极大强连通子图称之为该图的强连通分量。</p><p>如图：</p><p><img src="https://file1.kamacoder.com/i/algo/20240511112951.png" alt="img"></p><p>节点1、节点2、节点3、节点4、节点5 构成的子图是强连通分量，因为这是强连通图，也是极大图。</p><p>节点6、节点7、节点8 构成的子图 不是强连通分量，因为这不是强连通图，节点8 不能达到节点6。</p><p>节点1、节点2、节点5 构成的子图 也不是 强连通分量，因为这不是极大图。</p><h2 id="图的构造"><a href="https://www.programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%9B%BE%E7%9A%84%E6%9E%84%E9%80%A0">#</a>图的构造</h2><p>我们如何用代码来表示一个图呢？</p><p>一般使用邻接表、邻接矩阵 或者用类来表示。</p><p>主要是 朴素存储、邻接表和邻接矩阵。</p><p>关于朴素存储，这是我自创的名字，因为这种存储方式，就是将所有边存下来。</p><p>例如图：</p><p><img src="https://file1.kamacoder.com/i/algo/20240511112951.png" alt="img"></p><p>图中有8条边，我们就定义 8 * 2的数组，即有n条边就申请n * 2，这么大的数组：</p><p><img src="https://file1.kamacoder.com/i/algo/20250110114348.png" alt="img"></p><p>数组第一行：6 7，就表示节点6 指向 节点7，以此类推。</p><p>当然可以不用数组，用map，或者用 类 到可以表示出 这种边的关系。</p><p>这种表示方式的好处就是直观，把节点与节点之间关系很容易展现出来。</p><p>但如果我们想知道 节点1 和 节点6 是否相连，我们就需要把存储空间都枚举一遍才行。</p><p>这是明显的缺点，同时，我们在深搜和广搜的时候，都不会使用这种存储方式。</p><p>因为 搜索中，需要知道 节点与其他节点的链接情况，而这种朴素存储，都需要全部枚举才知道链接情况。</p><p>在图论章节的后面文章讲解中，我会举例说明的。大家先有个印象。</p><h3 id="邻接矩阵"><a href="https://www.programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5">#</a>邻接矩阵</h3><p>邻接矩阵 使用 二维数组来表示图结构。 邻接矩阵是从节点的角度来表示图，有多少节点就申请多大的二维数组。</p><p>例如： grid[2][5] = 6，表示 节点 2 连接 节点5 为有向图，节点2 指向 节点5，边的权值为6。</p><p>如果想表示无向图，即：grid[2][5] = 6，grid[5][2] = 6，表示节点2 与 节点5 相互连通，权值为6。</p><p>如图：</p><p><img src="https://file1.kamacoder.com/i/algo/20240222110025.png" alt="img"></p><p>在一个 n （节点数）为8 的图中，就需要申请 8 * 8 这么大的空间。</p><p>图中有一条双向边，即：grid[2][5] = 6，grid[5][2] = 6</p><p>这种表达方式（邻接矩阵） 在 边少，节点多的情况下，会导致申请过大的二维数组，造成空间浪费。</p><p>而且在寻找节点连接情况的时候，需要遍历整个矩阵，即 n * n 的时间复杂度，同样造成时间浪费。</p><p>邻接矩阵的优点：</p><ul><li>表达方式简单，易于理解</li><li>检查任意两个顶点间是否存在边的操作非常快</li><li>适合稠密图，在边数接近顶点数平方的图中，邻接矩阵是一种空间效率较高的表示方法。</li></ul><p>缺点：</p><ul><li>遇到稀疏图，会导致申请过大的二维数组造成空间浪费 且遍历 边 的时候需要遍历整个n * n矩阵，造成时间浪费</li></ul><h3 id="邻接表"><a href="https://www.programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E9%82%BB%E6%8E%A5%E8%A1%A8">#</a>邻接表</h3><p>邻接表 使用 数组 + 链表的方式来表示。 邻接表是从边的数量来表示图，有多少边 才会申请对应大小的链表。</p><p>邻接表的构造如图：</p><p><img src="https://file1.kamacoder.com/i/algo/20240223103713.png" alt="img"></p><p>这里表达的图是：</p><ul><li>节点1 指向 节点3 和 节点5</li><li>节点2 指向 节点4、节点3、节点5</li><li>节点3 指向 节点4</li><li>节点4指向节点1</li></ul><p>有多少边 邻接表才会申请多少个对应的链表节点。</p><p>从图中可以直观看出 使用 数组 + 链表 来表达 边的连接情况 。</p><p>邻接表的优点：</p><ul><li>对于稀疏图的存储，只需要存储边，空间利用率高</li><li>遍历节点连接情况相对容易</li></ul><p>缺点：</p><ul><li>检查任意两个节点间是否存在边，效率相对低，需要 O(V)时间，V表示某节点连接其他节点的数量。</li><li>实现相对复杂，不易理解</li></ul><p><strong>以上大家可能理解比较模糊，没关系</strong>，因为大家还没做过图论的题目，对于图的表达没有概念。</p><p>这里我先不给出具体的实现代码，大家先有个初步印象，在后面算法题实战中，我还会讲到具体代码实现，等带大家做算法题，写了代码之后，自然就理解了。</p><h2 id="图的遍历方式"><a href="https://www.programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F">#</a>图的遍历方式</h2><p>图的遍历方式基本是两大类：</p><ul><li>深度优先搜索（dfs）</li><li>广度优先搜索（bfs）</li></ul><p>在讲解二叉树章节的时候，其实就已经讲过这两种遍历方式。</p><p>二叉树的递归遍历，是dfs 在二叉树上的遍历方式。</p><p>二叉树的层序遍历，是bfs 在二叉树上的遍历方式。</p><p>dfs 和 bfs 一种搜索算法，可以在不同的数据结构上进行搜索，在二叉树章节里是在二叉树这样的数据结构上搜索。</p><p>而在图论章节，则是在图（邻接表或邻接矩阵）上进行搜索</p><h1 id="797-所有可能的路径">797. 所有可能的路径</h1><p><a href="https://leetcode.cn/problems/all-paths-from-source-to-target/">https://leetcode.cn/problems/all-paths-from-source-to-target/</a></p><p>给你一个有 <code>n</code> 个节点的 <strong>有向无环图（DAG）</strong>，请你找出从节点 <code>0</code> 到节点 <code>n-1</code> 的所有路径并输出（<strong>不要求按特定顺序</strong>）</p><p><code>graph[i]</code> 是一个从节点 <code>i</code> 可以访问的所有节点的列表（即从节点 <code>i</code> 到节点 <code>graph[i][j]</code>存在一条有向边）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/28/all_1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：graph = [[1,2],[3],[3],[]]</span><br><span class="line">输出：[[0,1,3],[0,2,3]]</span><br><span class="line">解释：有两条路径 0 -&gt; 1 -&gt; 3 和 0 -&gt; 2 -&gt; 3</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/28/all_2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：graph = [[4,3,1],[3,2,4],[3],[4],[]]</span><br><span class="line">输出：[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == graph.length</code></li><li><code>2 &lt;= n &lt;= 15</code></li><li><code>0 &lt;= graph[i][j] &lt; n</code></li><li><code>graph[i][j] != i</code>（即不存在自环）</li><li><code>graph[i]</code> 中的所有元素 <strong>互不相同</strong></li><li>保证输入为 <strong>有向无环图（DAG）</strong></li></ul><h2 id="邻接矩阵的图代码">邻接矩阵的图代码</h2><p>因为leetcode给的输入是邻接表，为了使用邻接矩阵作为输入，需要使用ACM模式（即自己处理输入数据）</p><ul><li>时间复杂度O(N)</li><li>空间复杂度O(N)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">graph, x: <span class="built_in">int</span>, n: <span class="built_in">int</span>, path: <span class="built_in">list</span>, result: <span class="built_in">list</span></span>):</span><br><span class="line">    <span class="comment"># 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> x == n:</span><br><span class="line">        <span class="comment"># 这里需要使用path的copy版，或者使用path.copy()</span></span><br><span class="line">        result.append(path.copy())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 表示x起点，i终点</span></span><br><span class="line">            <span class="keyword">if</span> graph[x][i] == <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 遍历下一个</span></span><br><span class="line">                path.append(i)</span><br><span class="line">                dfs(graph, i, n, path, result)</span><br><span class="line">                <span class="comment"># 回溯</span></span><br><span class="line">                path.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">    graph = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="comment"># 读取起点、终点</span></span><br><span class="line">        s, t = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        <span class="comment"># 设置起点、终点</span></span><br><span class="line">        graph[s][t] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    result = <span class="built_in">list</span>()</span><br><span class="line">    dfs(graph, <span class="number">1</span>, n, [<span class="number">1</span>], result)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> result:</span><br><span class="line">        <span class="built_in">print</span>(-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> path <span class="keyword">in</span> result:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, path)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="邻接表图代码">邻接表图代码</h2><ul><li>时间复杂度O(N)</li><li>空间复杂度O(N)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.res = <span class="built_in">list</span>()</span><br><span class="line">        self.path = [<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self, graph, x: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="comment"># 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> x == n:</span><br><span class="line">            self.res.append(self.path.copy())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> graph[x]:</span><br><span class="line">                self.path.append(i)</span><br><span class="line">                self.dfs(graph, i, n)</span><br><span class="line">                self.path.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">allPathsSourceTarget</span>(<span class="params">self, graph: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        n = <span class="built_in">len</span>(graph)</span><br><span class="line">        self.dfs(graph, <span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday50图论part01&quot;&gt;LeetCodeCampsDay50图论part01&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;图论基础&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;图的基本概念&quot;&gt;图的基本概念&lt;/h1&gt;
&lt;p&gt;二维</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay49单调栈part02</title>
    <link href="https://blog.lthero.cn/2025/08/12/LeetCodeCampsDay49/"/>
    <id>https://blog.lthero.cn/2025/08/12/LeetCodeCampsDay49/</id>
    <published>2025-08-12T06:49:03.000Z</published>
    <updated>2025-08-12T08:22:37.246Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday49单调栈part02">LeetCodeCampsDay49单调栈part02</h1><blockquote></blockquote><h1 id="42-接雨水">42. 接雨水</h1><p><a href="https://leetcode.cn/problems/trapping-rain-water/">https://leetcode.cn/problems/trapping-rain-water/</a></p><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出：6</span><br><span class="line">解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [4,2,0,3,2,5]</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><code>1 &lt;= n &lt;= 2 * 104</code></li><li><code>0 &lt;= height[i] &lt;= 105</code></li></ul><h2 id="单调栈思路">单调栈思路</h2><p>和使用双指针按列求解不同，使用单调栈需要按行求解</p><ol><li>首先单调栈是按照行方向来计算雨水，如图：</li></ol><p><img src="https://cdn.lthero.cn/post_images/course/ML20210223092629946.png" alt="42.接雨水2"></p><p><img src="https://file1.kamacoder.com/i/algo/20210223092629946.png" alt="42.接雨水2"></p><p>知道这一点，后面的就可以理解了。</p><ol><li>使用单调栈内元素的顺序</li></ol><p>从大到小还是从小到大呢？</p><p>从栈头（元素从栈头弹出）到栈底的顺序应该是从小到大的顺序。</p><p>因为一旦发现添加的柱子高度大于栈头元素了，此时就出现凹槽了，栈头元素就是凹槽底部的柱子，栈头第二个元素就是凹槽左边的柱子，而添加的元素就是凹槽右边的柱子。</p><p>如图：</p><p><img src="https://file1.kamacoder.com/i/algo/2021022309321229.png" alt="42.接雨水4"></p><p>关于单调栈的顺序给大家一个总结： <a href="https://programmercarl.com/0739.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.html">739. 每日温度</a>中求一个元素右边第一个更大元素，单调栈就是递增的，<a href="https://programmercarl.com/0084.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.html">84.柱状图中最大的矩形</a>求一个元素右边第一个更小元素，单调栈就是递减的。</p><ol><li>遇到相同高度的柱子怎么办。</li></ol><p>遇到相同的元素，更新栈内下标，就是将栈里元素（旧下标）弹出，将新元素（新下标）加入栈中。</p><p>例如 5 5 1 3 这种情况。如果添加第二个5的时候就应该将第一个5的下标弹出，把第二个5添加到栈中。</p><p><strong>因为我们要求宽度的时候 如果遇到相同高度的柱子，需要使用最右边的柱子来计算宽度</strong>。</p><p>如图所示：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20210223094619398.png" alt="42.接雨水5"></p><p><img src="https://file1.kamacoder.com/i/algo/20210223094619398.png" alt="42.接雨水5"></p><ol><li>栈里要保存什么数值</li></ol><p>使用单调栈，也是通过 长 * 宽 来计算雨水面积的。</p><p>长就是通过柱子的高度来计算，宽是通过柱子之间的下标来计算，</p><p>那么栈里有没有必要存一个pair&lt;int, int&gt;类型的元素，保存柱子的高度和下标呢。</p><p>其实不用，栈里就存放下标就行，想要知道对应的高度，通过height[stack.top()] 就知道弹出的下标对应的高度了。</p><p>所以栈的定义如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="built_in">int</span>&gt; st; <span class="comment"># 存着下标，计算的时候用下标对应的柱子高度</span></span><br></pre></td></tr></table></figure><p>明确了如上几点，我们再来看处理逻辑。</p><h4 id="单调栈处理逻辑">单调栈处理逻辑</h4><p>以下操作过程其实和 <a href="https://programmercarl.com/0739.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.html">739. 每日温度</a>也是一样的，建议先做 <a href="https://programmercarl.com/0739.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.html">739. 每日温度</a>。</p><p>以下逻辑主要就是三种情况</p><ul><li>情况一：当前遍历的元素（柱子）高度小于栈顶元素的高度 height[i] &lt; height[st.top()]</li><li>情况二：当前遍历的元素（柱子）高度等于栈顶元素的高度 height[i] == height[st.top()]</li><li>情况三：当前遍历的元素（柱子）高度大于栈顶元素的高度 height[i] &gt; height[st.top()]</li></ul><p>先将下标0的柱子加入到栈中，<code>st.push(0);</code>。 栈中存放我们遍历过的元素，所以先将下标0加进来。</p><p>然后开始从下标1开始遍历所有的柱子，<code>for (int i = 1; i &lt; height.size(); i++)</code>。</p><p>如果当前遍历的元素（柱子）高度小于栈顶元素的高度，就把这个元素加入栈中，因为栈里本来就要保持从小到大的顺序（从栈头到栈底）。</p><p>代码如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (height[i] &lt; height[st.top()])  st.push(i);</span><br></pre></td></tr></table></figure><p>如果当前遍历的元素（柱子）高度等于栈顶元素的高度，要跟更新栈顶元素，因为遇到相相同高度的柱子，需要使用最右边的柱子来计算宽度。</p><p>代码如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (height[i] == height[st.top()]) &#123; // 例如 5 5 1 7 这种情况</span><br><span class="line">  st.pop();</span><br><span class="line">  st.push(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前遍历的元素（柱子）高度大于栈顶元素的高度，此时就出现凹槽了，如图所示：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML2021022309321229-20230310123027977.png" alt="42.接雨水4"></p><p><img src="https://file1.kamacoder.com/i/algo/2021022309321229-20230310123027977.png" alt="42.接雨水4"></p><p>取栈顶元素，将栈顶元素弹出，这个就是凹槽的底部，也就是中间位置，下标记为mid，对应的高度为height[mid]（就是图中的高度1）。</p><p>此时的栈顶元素st.top()，就是凹槽的左边位置，下标为st.top()，对应的高度为height[st.top()]（就是图中的高度2）。</p><p>当前遍历的元素i，就是凹槽右边的位置，下标为i，对应的高度为height[i]（就是图中的高度3）。</p><p>此时大家应该可以发现其实就是<strong>栈顶和栈顶的下一个元素以及要入栈的元素，三个元素来接水！</strong></p><p>那么雨水高度是 min(凹槽左边高度, 凹槽右边高度) - 凹槽底部高度，代码为：<code>int h = min(height[st.top()], height[i]) - height[mid];</code></p><p>雨水的宽度是 凹槽右边的下标 - 凹槽左边的下标 - 1（因为只求中间宽度），代码为：<code>int w = i - st.top() - 1 ;</code></p><p>当前凹槽雨水的体积就是：<code>h * w</code>。</p><h2 id="单调栈代码">单调栈代码</h2><ul><li>时间复杂度O(N^2）</li><li>空间复杂度O(N)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        stack = <span class="built_in">list</span>()</span><br><span class="line">        stack.append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        L = <span class="built_in">len</span>(height)</span><br><span class="line">        sumOfRain = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L):</span><br><span class="line">            <span class="keyword">if</span> height[i] &lt; height[stack[-<span class="number">1</span>]]:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> height[i] == height[stack[-<span class="number">1</span>]]:</span><br><span class="line">                    stack.pop()</span><br><span class="line">                    stack.append(i)</span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> height[i] &gt; height[stack[-<span class="number">1</span>]]:</span><br><span class="line">                    j = stack.pop()</span><br><span class="line">                    <span class="keyword">if</span> stack:</span><br><span class="line">                        h = <span class="built_in">min</span>(height[stack[-<span class="number">1</span>]], height[i]) - height[j]</span><br><span class="line">                        w = i - stack[-<span class="number">1</span>] - <span class="number">1</span></span><br><span class="line">                        sumOfRain += h * w</span><br><span class="line">                stack.append(i)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sumOfRain</span><br></pre></td></tr></table></figure><h1 id="84-柱状图中最大的矩形">84. 柱状图中最大的矩形</h1><p><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">https://leetcode.cn/problems/largest-rectangle-in-histogram/</a></p><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：heights = [2,1,5,6,2,3]</span><br><span class="line">输出：10</span><br><span class="line">解释：最大的矩形为图中红色区域，面积为 10</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： heights = [2,4]</span><br><span class="line">输出： 4</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= heights.length &lt;=105</code></li><li><code>0 &lt;= heights[i] &lt;= 104</code></li></ul><h2 id="单调栈思路">单调栈思路</h2><h3 id="题目分析">题目分析</h3><p>本题是要找每个柱子左右两边第一个小于该柱子的柱子，所以从栈头（元素从栈头弹出）到栈底的顺序应该是从大到小的顺序！</p><p>我来举一个例子，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20230221165730.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20230221165730.png" alt="img"></p><p>只有栈里从大到小的顺序，才能保证栈顶元素找到左右两边第一个小于栈顶元素的柱子。</p><p>所以本题单调栈的顺序正好与接雨水反过来。</p><p>此时大家应该可以发现其实就是<strong>栈顶和栈顶的下一个元素以及要入栈的三个元素组成了我们要求最大面积的高度和宽度</strong></p><p>首先来说末尾为什么要加元素0？</p><p>如果数组本身就是升序的，例如[2,4,6,8]，那么入栈之后 都是单调递减，一直都没有走 情况三 计算结果的哪一步，所以最后输出的就是0了。 如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20230221163936.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20230221163936.png" alt="img"></p><p>那么结尾加一个0，就会让栈里的所有元素，走到情况三的逻辑。</p><p>开头为什么要加元素0？</p><p>如果数组本身是降序的，例如 [8,6,4,2]，在 8 入栈后，6 开始与8 进行比较，此时我们得到 mid（8），right（6），但是得不到 left。</p><p>（mid、left，right 都是对应版本一里的逻辑）</p><p>因为 将 8 弹出之后，栈里没有元素了，那么为了避免空栈取值，直接跳过了计算结果的逻辑。</p><p>之后又将6 加入栈（此时8已经弹出了），然后 就是 4 与 栈口元素 6 进行比较，周而复始，那么计算的最后结果result就是0。 如图所示：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20230221164533.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20230221164533.png" alt="img"></p><p>所以我们需要在 height数组前后各加一个元素0。</p><h2 id="单调栈代码">单调栈代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestRectangleArea</span>(<span class="params">self, heights: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        stack = <span class="built_in">list</span>()</span><br><span class="line">        stack.append(<span class="number">0</span>)</span><br><span class="line">        heights.insert(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        heights.append(<span class="number">0</span>)</span><br><span class="line">        L = <span class="built_in">len</span>(heights)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L):</span><br><span class="line">            <span class="keyword">if</span> heights[i] &gt; heights[stack[-<span class="number">1</span>]]:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">elif</span> heights[i] == heights[stack[-<span class="number">1</span>]]:</span><br><span class="line">                stack.pop()</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">while</span> stack  <span class="keyword">and</span> heights[i] &lt; heights[stack[-<span class="number">1</span>]]:</span><br><span class="line">                    mid = stack.pop()</span><br><span class="line">                    <span class="keyword">if</span> stack:</span><br><span class="line">                        left = stack[-<span class="number">1</span>]</span><br><span class="line">                        h = heights[mid]</span><br><span class="line">                        </span><br><span class="line">                        w = i - left - <span class="number">1</span></span><br><span class="line">                        res = <span class="built_in">max</span>(res, h * w)</span><br><span class="line">                stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday49单调栈part02&quot;&gt;LeetCodeCampsDay49单调栈part02&lt;/h1&gt;
&lt;blockquote&gt;&lt;/blockquote&gt;
&lt;h1 id=&quot;42-接雨水&quot;&gt;42. 接雨水&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;htt</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay48单调栈part01</title>
    <link href="https://blog.lthero.cn/2025/08/11/LeetCodeCampsDay48/"/>
    <id>https://blog.lthero.cn/2025/08/11/LeetCodeCampsDay48/</id>
    <published>2025-08-11T09:21:13.000Z</published>
    <updated>2025-08-11T14:36:59.904Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday48单调栈part01">LeetCodeCampsDay48单调栈part01</h1><blockquote><p>初识单调栈</p></blockquote><h1 id="单调栈">单调栈</h1><blockquote><p>什么时候用单调栈呢？</p></blockquote><p><strong>通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了</strong>。时间复杂度为O(n)。</p><p>如果暴力求解，比如两层for循环，时间复杂度是O(n^2)</p><blockquote><p>那么单调栈的原理是什么呢？为什么时间复杂度是O(n)就可以找到每一个元素的右边第一个比它大的元素位置呢？</p></blockquote><p><strong>单调栈的本质是空间换时间</strong>，因为在遍历的过程中需要用一个栈来记录右边第一个比当前元素高的元素，优点是整个数组只需要遍历一次。</p><p><strong>更直白来说，就是用一个栈来记录我们遍历过的元素</strong>，因为我们遍历数组的时候，我们不知道之前都遍历了哪些元素，以至于遍历一个元素找不到是不是之前遍历过一个更小的，所以我们需要用一个容器（这里用单调栈）来记录我们遍历过的元素。</p><p>在使用单调栈的时候首先要明确如下几点：</p><ol><li>单调栈里存放的元素是什么？</li></ol><p>单调栈里<code>只需要存放元素的下标i就可以了</code>，如果需要使用对应的元素，直接<code>T[i]</code>就可以获取。</p><ol><li>单调栈里元素是递增呢？ 还是递减呢？</li></ol><p><strong>注意以下讲解中，顺序的描述为 从栈头到栈底的顺序</strong>，因为单纯的说从左到右或者从前到后，不说栈头朝哪个方向的话，大家一定比较懵。</p><p>使用单调栈主要有三个判断条件。</p><ul><li>当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况</li><li>当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况</li><li>当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况</li></ul><p><strong>把这三种情况分析清楚了，也就理解透彻了</strong>。</p><p>接下来我们用temperatures = [73, 74, 75, 71, 71, 72, 76, 73]为例来逐步分析，输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p><hr><p>首先先将第一个遍历元素加入单调栈</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20210219124434172.jpg" alt="739.每日温度1"></p><p><img src="https://file1.kamacoder.com/i/algo/20210219124434172.jpg" alt="739.每日温度1"></p><hr><p>加入T[1] = 74，因为T[1] &gt; T[0]（当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况）。</p><p>我们要保持一个递增单调栈（从栈头到栈底），所以将T[0]弹出，T[1]加入，此时result数组可以记录了，result[0] = 1，即T[0]右面第一个比T[0]大的元素是T[1]。</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20210219124504299.jpg" alt="739.每日温度2"></p><p><img src="https://file1.kamacoder.com/i/algo/20210219124504299.jpg" alt="739.每日温度2"></p><hr><p>加入T[2]，同理，T[1]弹出</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20210219124527361.jpg" alt="739.每日温度3"></p><p><img src="https://file1.kamacoder.com/i/algo/20210219124527361.jpg" alt="739.每日温度3"></p><hr><p>加入T[3]，T[3] &lt; T[2] （当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况），加T[3]加入单调栈。</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20210219124610761.jpg" alt="739.每日温度4"></p><p><img src="https://file1.kamacoder.com/i/algo/20210219124610761.jpg" alt="739.每日温度4"></p><hr><p>加入T[4]，T[4] == T[3] （当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况），此时依然要加入栈，不用计算距离，因为我们要求的是右面第一个大于本元素的位置，而不是大于等于！</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20210219124633444.jpg" alt="739.每日温度5"></p><p><img src="https://file1.kamacoder.com/i/algo/20210219124633444.jpg" alt="739.每日温度5"></p><hr><p>加入T[5]，T[5] &gt; T[4] （当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况），将T[4]弹出，同时计算距离，更新result</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20210219124700567.jpg" alt="739.每日温度6"></p><p><img src="https://file1.kamacoder.com/i/algo/20210219124700567.jpg" alt="739.每日温度6"></p><hr><p>T[4]弹出之后， T[5] &gt; T[3] （当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况），将T[3]继续弹出，同时计算距离，更新result</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20210219124726613.jpg" alt="739.每日温度7"></p><p><img src="https://file1.kamacoder.com/i/algo/20210219124726613.jpg" alt="739.每日温度7"></p><hr><p>直到发现T[5]小于T[st.top()]，终止弹出，将T[5]加入单调栈</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20210219124807715.jpg" alt="739.每日温度8"></p><p><img src="https://file1.kamacoder.com/i/algo/20210219124807715.jpg" alt="739.每日温度8"></p><hr><p>加入T[6]，同理，需要将栈里的T[5]，T[2]弹出</p><p><img src="https://cdn.lthero.cn/post_images/course/ML2021021912483374.jpg" alt="739.每日温度9"></p><p><img src="https://file1.kamacoder.com/i/algo/2021021912483374.jpg" alt="739.每日温度9"></p><hr><p>同理，继续弹出</p><p><img src="https://cdn.lthero.cn/post_images/course/ML2021021912490098.jpg" alt="739.每日温度10"></p><p><img src="https://file1.kamacoder.com/i/algo/2021021912490098.jpg" alt="739.每日温度10"></p><hr><p>此时栈里只剩下了T[6]</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20210219124930156.jpg" alt="739.每日温度11"></p><p><img src="https://file1.kamacoder.com/i/algo/20210219124930156.jpg" alt="739.每日温度11"></p><hr><p>加入T[7]， T[7] &lt; T[6] 直接入栈，这就是最后的情况，result数组也更新完了。</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20210219124957216.jpg" alt="739.每日温度12"></p><p><img src="https://file1.kamacoder.com/i/algo/20210219124957216.jpg" alt="739.每日温度12"></p><p>此时有同学可能就疑惑了，那result[6] , result[7]怎么没更新啊，元素也一直在栈里。</p><p>其实定义result数组的时候，就应该直接初始化为0，如果result没有更新，说明这个元素右面没有更大的了，也就是为0。</p><p>以上在图解的时候，已经把，这三种情况都做了详细的分析。</p><ul><li>情况一：当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况</li><li>情况二：当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况</li><li>情况三：当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况</li></ul><p>通过以上过程，大家可以自己再模拟一遍，就会发现：只有单调栈递增（从栈口到栈底顺序），就是求右边第一个比自己大的，单调栈递减的话，就是求右边第一个比自己小的。</p><h1 id="739-每日温度">739. 每日温度</h1><p><a href="https://leetcode.cn/problems/daily-temperatures/">https://leetcode.cn/problems/daily-temperatures/</a></p><p>给定一个整数数组 <code>temperatures</code> ，表示每天的温度，返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是指对于第 <code>i</code> 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: temperatures = [73,74,75,71,69,72,76,73]</span><br><span class="line">输出: [1,1,4,2,1,1,0,0]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: temperatures = [30,40,50,60]</span><br><span class="line">输出: [1,1,1,0]</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: temperatures = [30,60,90]</span><br><span class="line">输出: [1,1,0]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= temperatures.length &lt;= 105</code></li><li><code>30 &lt;= temperatures[i] &lt;= 100</code></li></ul><h2 id="单调栈思路">单调栈思路</h2><p>使用单调栈，栈底元素是最大的</p><p>先将第一个元素入栈，栈内记录这个元素的下标</p><p>从第二个元素开始遍历，如果num[i]小于栈Top元素则直接入栈</p><p>如果num[i]大于栈Top元素则将栈Top弹出，并且res[j]=i-j（假设j为栈Top元素的值)，表示第j天右边第一个更大的元素是（i-j)天后</p><h2 id="单调栈代码">单调栈代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dailyTemperatures</span>(<span class="params">self, temperatures: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]: </span><br><span class="line">        stack = <span class="built_in">list</span>()</span><br><span class="line">        stack.append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        L = <span class="built_in">len</span>(temperatures)</span><br><span class="line">        res = [<span class="number">0</span>] * L</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L):</span><br><span class="line">            <span class="comment"># 如果temper[i]更小，直接添加进入</span></span><br><span class="line">            <span class="keyword">if</span> temperatures[i] &lt;= temperatures[stack[-<span class="number">1</span>]]:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果temper[i]更大，先将栈中小于temper[i]的都弹出来</span></span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> temperatures[i] &gt; temperatures[stack[-<span class="number">1</span>]]:</span><br><span class="line">                    j = stack.pop()</span><br><span class="line">                    res[j] = i - j</span><br><span class="line">                stack.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="496-下一个更大元素-i">496. 下一个更大元素 I</h1><p><a href="https://leetcode.cn/problems/next-greater-element-i/">https://leetcode.cn/problems/next-greater-element-i/</a></p><p><code>nums1</code> 中数字 <code>x</code> 的 <strong>下一个更大元素</strong> 是指 <code>x</code> 在 <code>nums2</code> 中对应位置 <strong>右侧</strong> 的 <strong>第一个</strong> 比 <code>x</code> 大的元素。</p><p>给你两个 <strong>没有重复元素</strong> 的数组 <code>nums1</code> 和 <code>nums2</code> ，下标从 <strong>0</strong> 开始计数，其中<code>nums1</code> 是 <code>nums2</code> 的子集。</p><p>对于每个 <code>0 &lt;= i &lt; nums1.length</code> ，找出满足 <code>nums1[i] == nums2[j]</code> 的下标 <code>j</code> ，并且在 <code>nums2</code> 确定 <code>nums2[j]</code> 的 <strong>下一个更大元素</strong> 。如果不存在下一个更大元素，那么本次查询的答案是 <code>-1</code> 。</p><p>返回一个长度为 <code>nums1.length</code> 的数组 <code>ans</code> 作为答案，满足 <code>ans[i]</code> 是如上所述的 <strong>下一个更大元素</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [4,1,2], nums2 = [1,3,4,2].</span><br><span class="line">输出：[-1,3,-1]</span><br><span class="line">解释：nums1 中每个值的下一个更大元素如下所述：</span><br><span class="line">- 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。</span><br><span class="line">- 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。</span><br><span class="line">- 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [2,4], nums2 = [1,2,3,4].</span><br><span class="line">输出：[3,-1]</span><br><span class="line">解释：nums1 中每个值的下一个更大元素如下所述：</span><br><span class="line">- 2 ，用加粗斜体标识，nums2 = [1,2,3,4]。下一个更大元素是 3 。</span><br><span class="line">- 4 ，用加粗斜体标识，nums2 = [1,2,3,4]。不存在下一个更大元素，所以答案是 -1 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000</code></li><li><code>0 &lt;= nums1[i], nums2[i] &lt;= 104</code></li><li><code>nums1</code>和<code>nums2</code>中所有整数 <strong>互不相同</strong></li><li><code>nums1</code> 中的所有整数同样出现在 <code>nums2</code> 中</li></ul><p>**进阶：**你可以设计一个时间复杂度为 <code>O(nums1.length + nums2.length)</code> 的解决方案吗？</p><h2 id="单调栈思路">单调栈思路</h2><p>线索1、nums2里所有数字不同</p><p>线索2、nums1是nums2子集</p><p>问题可以变成：先求nums2里的每个元素的下一更大元素（使用单调栈）</p><p>再想办法把nums1和nums2映射，可以考虑桶排序（因为本题目的数字范围不大），如果数字范围大，则需要使用map进行映射</p><h2 id="单调栈代码-普通">单调栈代码（普通）</h2><ul><li>时间复杂度O(N * M)</li><li>空间复杂度O(M)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextGreaterElement</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        stack = <span class="built_in">list</span>()</span><br><span class="line">        stack.append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        L2 = <span class="built_in">len</span>(nums2)</span><br><span class="line">        biggerNums2 = [-<span class="number">1</span>] * <span class="number">10000</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L2):</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> nums2[i] &lt;= nums2[stack[-<span class="number">1</span>]]:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> nums2[stack[-<span class="number">1</span>]] &lt; nums2[i]:</span><br><span class="line">                    j = stack.pop()</span><br><span class="line">                    biggerNums2[nums2[j]] = nums2[i]</span><br><span class="line">                stack.append(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">            res.append(biggerNums2[i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>或者使用python自带的index函数，直接调用nums1.index(nums2[stack[-1]])</p><h2 id="单调栈代码-优化">单调栈代码（优化）</h2><ul><li>时间复杂度O(N * M)</li><li>空间复杂度O(M)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextGreaterElement</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        stack = <span class="built_in">list</span>()</span><br><span class="line">        stack.append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        L2 = <span class="built_in">len</span>(nums2)</span><br><span class="line">        <span class="comment"># 默认值都为-1</span></span><br><span class="line">        res = [-<span class="number">1</span>] * <span class="built_in">len</span>(nums1)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L2):</span><br><span class="line">            <span class="comment"># 如果新数字小于栈顶值，就无脑添加进来</span></span><br><span class="line">            <span class="keyword">if</span> nums2[i] &lt;= nums2[stack[-<span class="number">1</span>]]:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> nums2[stack[-<span class="number">1</span>]] &lt; nums2[i]:</span><br><span class="line">                    <span class="keyword">if</span> nums2[stack[-<span class="number">1</span>]] <span class="keyword">in</span> nums1:</span><br><span class="line">                        <span class="comment"># 找到nums2[i]在nums1对应下标</span></span><br><span class="line">                        index = nums1.index(nums2[stack[-<span class="number">1</span>]])</span><br><span class="line">                        <span class="comment"># 添加到答案组里</span></span><br><span class="line">                        res[index] = nums2[i]</span><br><span class="line">                    <span class="comment"># 注意这个pop操作，不论nums2[stack[-1]]是否在nums1都要执行</span></span><br><span class="line">                    stack.pop()</span><br><span class="line">                stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="503-下一个更大元素-ii">503. 下一个更大元素 II</h1><p><a href="https://leetcode.cn/problems/next-greater-element-ii/">https://leetcode.cn/problems/next-greater-element-ii/</a></p><p>给定一个循环数组 <code>nums</code> （ <code>nums[nums.length - 1]</code> 的下一个元素是 <code>nums[0]</code> ），返回 <em><code>nums</code> 中每个元素的 <strong>下一个更大元素</strong></em> 。</p><p>数字 <code>x</code> 的 <strong>下一个更大的元素</strong> 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 <code>-1</code> 。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,1]</span><br><span class="line">输出: [2,-1,2]</span><br><span class="line">解释: 第一个 1 的下一个更大的数是 2；</span><br><span class="line">数字 2 找不到下一个更大的数； </span><br><span class="line">第二个 1 的下一个最大的数需要循环搜索，结果也是 2。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3,4,3]</span><br><span class="line">输出: [2,3,4,-1,4]</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li></ul><h2 id="单调栈思路">单调栈思路</h2><p>找下一个更大的元素，可以使用单调栈</p><p>单调递减栈，栈底是整个栈最大值</p><p>stack初始化添加下标0</p><p>从下标1开始遍历（进行循环遍历一次，从1到(1+len(nums))），若nums[i]大于stack[-1]（指栈顶值）则将栈顶值弹出，并且res[j] = nums[i]（j表示栈顶值元素在nums里的下标值）</p><p>如果nums[i]小于stack[-1]，则直接将nums[i]添加进去</p><h2 id="单调栈代码">单调栈代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextGreaterElements</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        stack = <span class="built_in">list</span>()</span><br><span class="line">        stack.append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        L = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = [-<span class="number">1</span>] * L</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span> * L):</span><br><span class="line">            <span class="keyword">if</span> nums[i % L] &lt;= nums[stack[-<span class="number">1</span>]]:</span><br><span class="line">                stack.append(i % L)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> nums[i % L] &gt; nums[stack[-<span class="number">1</span>]]:</span><br><span class="line">                    j = stack.pop()</span><br><span class="line">                    res[j] = nums[i % L]</span><br><span class="line">                stack.append(i % L)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday48单调栈part01&quot;&gt;LeetCodeCampsDay48单调栈part01&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;初识单调栈&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;单调栈&quot;&gt;单调栈&lt;/h1&gt;
&lt;blockqu</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCodeCampsDay46动态规划part13</title>
    <link href="https://blog.lthero.cn/2025/08/11/LeetCodeCampsDay46/"/>
    <id>https://blog.lthero.cn/2025/08/11/LeetCodeCampsDay46/</id>
    <published>2025-08-11T02:12:26.000Z</published>
    <updated>2025-08-11T07:48:41.402Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcodecampsday46动态规划part13">LeetCodeCampsDay46动态规划part13</h1><blockquote><p>使用dp解决回文串和回文序列问题</p></blockquote><h1 id="647-回文子串">647. 回文子串</h1><p><a href="https://leetcode.cn/problems/palindromic-substrings/">https://leetcode.cn/problems/palindromic-substrings/</a></p><p>给你一个字符串 <code>s</code> ，请你统计并返回这个字符串中 <strong>回文子串</strong> 的数目。</p><p><strong>回文字符串</strong> 是正着读和倒过来读一样的字符串。</p><p><strong>子字符串</strong> 是字符串中的由连续字符组成的一个序列。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aaa&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 由小写英文字母组成</li></ul><h2 id="普通思路">普通思路</h2><p>本题和前面写过的26. 单词拆分有点像</p><p>需要将s拆分成长度为1、2、…L的子串，做法：使用双指针，i作为子串结尾位置；j作为子串起点位置，从而对所有子串进行判断是否为回文串；</p><p>比如s= ‘abc’，将得到a, ab, b, abc, bc, c 再对每个子串判断是否为回文串（调用个函数即可）</p><p><strong>但这种写法会超时，因为有太多的重复内容被反复计算</strong></p><p>所以需要有dp的方法来判断回文串</p><h2 id="普通代码-超时">普通代码（超时）</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countSubstrings</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">isLegal</span>(<span class="params">s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            left = <span class="number">0</span></span><br><span class="line">            right = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                <span class="keyword">if</span> s[left] != s[right]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        L = <span class="built_in">len</span>(s)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                <span class="comment"># print(s[j: i])</span></span><br><span class="line">                <span class="keyword">if</span> isLegal(s[j: i]):</span><br><span class="line">                    res += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="动态规划思路">动态规划思路</h2><p>一个更好的思路，把问题拆成子问题</p><p>比如为了判断abcba是否为子串，可以先判断bcb是否为子串-&gt;判断c是否为子串</p><p>所以问题可以变成</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20230102170752.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20230102170752.png" alt="img"></p><p>同时使用两个指针遍历，和普通思路一样，也需要将s拆分成长度为1、2、…L的子串s[j: i]（左闭右闭）</p><ul><li>如果长度为1，即s[j]==s[i]且j==i，那一定是回文，令dp[j][i]=1</li><li>如果长度为2，即s[j]==s[i]且j+1==i，也是回文，令dp[j][i]=1</li><li>如果长度大于2，比如abcba，即s[j]==s[i]=a，且j+1&lt;i，此时需要判断s[j+1:i-1]（左闭右闭）这一段(bcb)是否为回文串，如果bcb已经是回文串（即令dp[j + 1][i - 1]=1），那s[j:i]（左闭右闭），也是回文，令dp[j][i]=1；否则就不是回文</li></ul><p>反之</p><ul><li>如果s[j]!=s[i]，那一定不是回文串</li></ul><h2 id="动态规划代码">动态规划代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countSubstrings</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 下面使用动态规划解决</span></span><br><span class="line">        L = <span class="built_in">len</span>(s)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        dp = [[<span class="literal">False</span>] * (L + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(L + <span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># 全部初始化为False即可</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i + <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># print(s[j - 1], s[i - 1])</span></span><br><span class="line">                <span class="keyword">if</span> s[j - <span class="number">1</span>] == s[i - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">if</span> j == i:</span><br><span class="line">                        <span class="comment"># 同一个字符且位置相同</span></span><br><span class="line">                        res += <span class="number">1</span></span><br><span class="line">                        dp[j][i] = <span class="literal">True</span>    </span><br><span class="line">                    <span class="keyword">elif</span> j + <span class="number">1</span> == i:</span><br><span class="line">                        <span class="comment"># 相邻两个字符</span></span><br><span class="line">                        res += <span class="number">1</span></span><br><span class="line">                        dp[j][i] = <span class="literal">True</span>    </span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="comment"># j与i之间有其它字符，此时要判断s[j+1: i-1]（左闭右闭）是否为回文，如果它也是回文，才能说明s[j: i]（左闭右闭）是回文</span></span><br><span class="line">                        <span class="keyword">if</span> dp[j + <span class="number">1</span>][i - <span class="number">1</span>]:</span><br><span class="line">                            dp[j][i] = <span class="literal">True</span> </span><br><span class="line">                            res += <span class="number">1</span>                   </span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>注意这里的遍历顺序，最好是i从后向前遍历，因为在状态转换时需要使用dp[i + 1][j - 1]</p><p>所以i的范围从[L-1, 0]而j的范围从[i, L-1]，而dp的含义还是s[j-1,i+1]这段字符串是否为回文</p><h2 id="代码改进">代码改进</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面使用动态规划解决</span></span><br><span class="line">L = <span class="built_in">len</span>(s)</span><br><span class="line">res = <span class="number">0</span></span><br><span class="line">dp = [[<span class="literal">False</span>] * (L) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(L)]</span><br><span class="line"><span class="comment"># 全部初始化为False即可</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, L):</span><br><span class="line">        <span class="comment"># print(s[j - 1], s[i - 1])</span></span><br><span class="line">        <span class="keyword">if</span> s[j] == s[i]:</span><br><span class="line">            <span class="keyword">if</span> j == i:</span><br><span class="line">                <span class="comment"># 同一个字符且位置相同</span></span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">                dp[i][j] = <span class="literal">True</span>    </span><br><span class="line">            <span class="keyword">elif</span> j - <span class="number">1</span> == i:</span><br><span class="line">                <span class="comment"># 相邻两个字符</span></span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">                dp[i][j] = <span class="literal">True</span>    </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># j与i之间有其它字符，此时要判断s[j+1: i-1]（左闭右闭）是否为回文，如果它也是回文，才能说明s[j: i]（左闭右闭）是回文</span></span><br><span class="line">                <span class="keyword">if</span> dp[i + <span class="number">1</span>][j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = <span class="literal">True</span> </span><br><span class="line">                    res += <span class="number">1</span>                   </span><br><span class="line"><span class="comment"># print(dp)</span></span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="516-最长回文子序列">516. 最长回文子序列</h1><p><a href="https://leetcode.cn/problems/longest-palindromic-subsequence/">https://leetcode.cn/problems/longest-palindromic-subsequence/</a></p><p>给你一个字符串 <code>s</code> ，找出其中最长的回文子序列，并返回该序列的长度。</p><p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;bbbab&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：一个可能的最长回文子序列为 &quot;bbbb&quot; 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;cbbd&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：一个可能的最长回文子序列为 &quot;bb&quot; 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由小写英文字母组成</li></ul><h2 id="动态规划思路">动态规划思路</h2><p>注意这题是回文子序列（不要求连续）</p><p>仍然可以使用dp数组做，和647. 回文子串思路相似</p><ol><li>dp下标与含义</li></ol><p>dp[i][j]表示s[i:j]（左闭右闭）的最长的回文子序列长度</p><ol start="2"><li>递推公式</li></ol><p>在判断回文子串的题目中，关键逻辑就是看s[i]与s[j]是否相同。</p><p>如果s[i]与s[j]相同，那么<strong>dp[i][j] = dp[i + 1][j - 1] + 2</strong></p><p>如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20210127151350563.jpg" alt="516.最长回文子序列"></p><p><img src="https://file1.kamacoder.com/i/algo/20210127151350563.jpg" alt="516.最长回文子序列"></p><p>如果不相同，说明s[i]和s[j]的同时加入 并不能增加[i,j]区间回文子序列的长度，<strong>那么分别加入s[i]、s[j]看看哪一个可以组成最长的回文子序列。</strong></p><p>加入s[j]的回文子序列长度为dp[i + 1][j]。</p><p>加入s[i]的回文子序列长度为dp[i][j - 1]。</p><p>那么dp[i][j]一定是取最大的，即：dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20210127151420476.jpg" alt="516.最长回文子序列1"></p><p><img src="https://file1.kamacoder.com/i/algo/20210127151420476.jpg" alt="516.最长回文子序列1"></p><ol start="3"><li>初始化</li></ol><p>首先要考虑当i 和j 相同的情况，从递推公式：dp[i][j] = dp[i + 1][j - 1] + 2; 可以看出 递推公式是计算不到 i 和j相同时候的情况。</p><p>所以需要手动的将i==j的情况全部初始化为1，其它值初始化为0</p><blockquote><p>当然，也可以不手动初始化，但需要在s[i]==s[j]时，手动添加判断条件，如果i==j则赋值为1；而且j - 1==i时需要手动赋值为2</p></blockquote><ol start="4"><li>遍历顺序</li></ol><p>从递归公式中，可以看出，dp[i][j] 依赖于 dp[i + 1][j - 1] ，dp[i + 1][j] 和 dp[i][j - 1]，如图：</p><p><img src="https://cdn.lthero.cn/post_images/course/ML20230102172155.png" alt="img"></p><p><img src="https://file1.kamacoder.com/i/algo/20230102172155.png" alt="img"></p><p><strong>所以遍历i的时候一定要从下到上遍历，这样才能保证下一行的数据是经过计算的</strong>。</p><h2 id="动态规划代码">动态规划代码</h2><ul><li>时间复杂度O(N^2)</li><li>空间复杂度O(N^2)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindromeSubseq</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># dp下标与含义</span></span><br><span class="line">        <span class="comment"># dp[i][j]表示s[j:i]（左闭右闭）的最长回文子序列</span></span><br><span class="line"></span><br><span class="line">        L = <span class="built_in">len</span>(s)</span><br><span class="line">        dp = [[<span class="number">0</span>] * L <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(L)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, L):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                    <span class="keyword">if</span> i == j:</span><br><span class="line">                        dp[i][j] = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> j - <span class="number">1</span> == i:</span><br><span class="line">                        dp[i][j] = <span class="number">2</span></span><br><span class="line">                    <span class="keyword">elif</span> dp[i + <span class="number">1</span>][j - <span class="number">1</span>] != <span class="number">0</span>:</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j - <span class="number">1</span>], dp[i + <span class="number">1</span>][j])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="动态规划代码二">动态规划代码二</h2><p>手动初始化</p><ul><li>时间复杂度O(N^2)</li><li>空间复杂度O(N^2)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindromeSubseq</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># dp下标与含义</span></span><br><span class="line">        <span class="comment"># dp[i][j]表示s[j:i]（左闭右闭）的最长回文子序列</span></span><br><span class="line"></span><br><span class="line">        L = <span class="built_in">len</span>(s)</span><br><span class="line">        dp = [[<span class="number">0</span>] * L <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(L)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对角线全为1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">            dp[i][i] = <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, L):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j - <span class="number">1</span>], dp[i + <span class="number">1</span>][j])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcodecampsday46动态规划part13&quot;&gt;LeetCodeCampsDay46动态规划part13&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;使用dp解决回文串和回文序列问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;647-回文子串&quot;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://blog.lthero.cn/tags/leetcode/"/>
    
  </entry>
  
</feed>
