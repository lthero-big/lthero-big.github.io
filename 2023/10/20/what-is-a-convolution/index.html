<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>what_is_a_convolution | lthero</title><meta name="keywords" content="技术&amp;生活"><meta name="author" content="lthero"><meta name="copyright" content="lthero"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="卷积先提出了个投色子问题  下面是第一种可视化的方案  下面是第二种可视化的方案 将第二行的色子反转，对应位置与第一行的色子进行匹配，匹配结果：两行点数相加为7，并且一共有6种可能，$P(7)&#x3D;6 \div 36$  而将第二行的色子左移，直到让第二行最后一个色子与第一行第一个色子匹配，匹配结果：两行点数相加为2，并且有1种可能  继续将第二行色子不断右移，则可以分别匹配到不同的相加后点">
<meta property="og:type" content="article">
<meta property="og:title" content="what_is_a_convolution">
<meta property="og:url" content="https://blog.lthero.cn/2023/10/20/what-is-a-convolution/index.html">
<meta property="og:site_name" content="lthero">
<meta property="og:description" content="卷积先提出了个投色子问题  下面是第一种可视化的方案  下面是第二种可视化的方案 将第二行的色子反转，对应位置与第一行的色子进行匹配，匹配结果：两行点数相加为7，并且一共有6种可能，$P(7)&#x3D;6 \div 36$  而将第二行的色子左移，直到让第二行最后一个色子与第一行第一个色子匹配，匹配结果：两行点数相加为2，并且有1种可能  继续将第二行色子不断右移，则可以分别匹配到不同的相加后点">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.lthero.cn/webPic/background/wallhaven-285e6x.png">
<meta property="article:published_time" content="2023-10-20T05:43:45.000Z">
<meta property="article:modified_time" content="2023-10-21T16:25:26.567Z">
<meta property="article:author" content="lthero">
<meta property="article:tag" content="技术&amp;生活">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.lthero.cn/webPic/background/wallhaven-285e6x.png"><link rel="shortcut icon" href="https://cdn.lthero.cn/webPic/logo/lthero_logo.png"><link rel="canonical" href="https://blog.lthero.cn/2023/10/20/what-is-a-convolution/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="iNo3p5pDMQW3QRCjgVQ_A-4vbPCQipgCC1evSSmk8p8"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/5.13.0/css/all.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://ltherocn2.oss-cn-beijing.aliyuncs.com/cdn/css/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":90,"position":"top","messagePrev":"这篇文章距离他上一次更新已经过去了……我算算啊……好像是","messageNext":"天吧，不知道是否还有效啊!"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'what_is_a_convolution',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-22 00:25:26'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/mycss/lthero-css.css"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="lthero" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/webPic/logo/lthero_avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">136</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">66</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">54</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.lthero.cn/webPic/background/wallhaven-285e6x.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">lthero</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">what_is_a_convolution</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-20T05:43:45.000Z" title="发表于 2023-10-20 13:43:45">2023-10-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-21T16:25:26.567Z" title="更新于 2023-10-22 00:25:26">2023-10-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>26分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="what_is_a_convolution"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h2><p>先提出了个投色子问题</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/post_images/course/ML/Snipaste_2023-10-20_13-46-26.png" alt="Snipaste_2023-10-20_13-46-26"></p>
<p>下面是第一种可视化的方案</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/post_images/course/ML/Snipaste_2023-10-20_13-47-20.png" alt="Snipaste_2023-10-20_13-47-20"></p>
<p>下面是第二种可视化的方案</p>
<p>将第二行的色子反转，对应位置与第一行的色子进行匹配，匹配结果：<strong>两行点数相加为7，并且一共有6种可能</strong>，$P(7)&#x3D;6 \div 36$</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/post_images/course/ML/Snipaste_2023-10-20_14-04-54.png" alt="Snipaste_2023-10-20_14-04-54"></p>
<p>而将第二行的色子左移，直到<strong>让第二行最后一个色子与第一行第一个色子匹配</strong>，匹配结果：<strong>两行点数相加为2，并且有1种可能</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/post_images/course/ML/Snipaste_2023-10-20_14-08-00.png" alt="Snipaste_2023-10-20_14-08-00"></p>
<p>继续将第二行色子不断右移，则可以分别匹配到<strong>不同的相加后点数</strong>，以及对应的概率</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/post_images/course/ML/Snipaste_2023-10-20_14-06-06.png" alt="Snipaste_2023-10-20_14-06-06"></p>
<p>然而，上面的概率是建立在每个色子都有相同的概率（1&#x2F;6)基础上得到的，如果每个色子的概率不同呢？比如<strong>红色3</strong>的概率是0.24，而<strong>红色4</strong>的概率是0.1 ，如下图所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/post_images/course/ML/Snipaste_2023-10-20_14-10-21.png" alt="每一组色子的概率不平等"></p>
<p>那么，此时<strong>两组点数相加为3</strong>的概率就会发生变化，比如 $P(3)&#x3D;0.16 \times 0.22 + 0.21 \times 0.11$</p>
<p>当然，计算的方式还是和之前相同的，只用把<strong>相加为3</strong>的<strong>两组色子的概率</strong>进行<strong>相乘</strong>，随后将<strong>相加数为3</strong>的很多<strong>概率相乘的结果</strong>再<strong>相加</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/post_images/course/ML/Snipaste_2023-10-20_14-12-08.png" alt="Snipaste_2023-10-20_14-12-08"></p>
<p>将上面的概率抽像出来，第一组变成$a_1, a_2……$第二组变成$b_1,b_2……$</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/post_images/course/ML/Snipaste_2023-10-20_14-19-08.png" alt="Snipaste_2023-10-20_14-19-08"></p>
<p>下面的同样如此</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/post_images/course/ML/Snipaste_2023-10-20_14-21-41.png" alt="Snipaste_2023-10-20_14-21-41"></p>
<p>下面将引入“卷积”概念</p>
<p>$\begin{gathered}(a*b)<em>n&#x3D;\sum</em>{i,j}a_i\cdot b_j\i+j&#x3D;n\end{gathered}$</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/post_images/course/ML/Snipaste_2023-10-20_14-39-59.png" alt="Snipaste_2023-10-20_14-39-59"></p>
<hr>
<p>下面是个举例，$(1,2,3)* (4,5,6)$，先将$(4,5,6)$反转，再逐个和$(1,2,3)$匹配相乘</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/post_images/course/ML/Snipaste_2023-10-20_15-35-37.png" alt="Snipaste_2023-10-20_15-35-37"></p>
<p>如果使用python进行运算</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">np.convolve((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>))</span><br><span class="line"><span class="comment">#将得到</span></span><br><span class="line">array([<span class="number">4</span>,<span class="number">13</span>,<span class="number">28</span>,<span class="number">27</span>,<span class="number">18</span>])</span><br></pre></td></tr></table></figure>



<hr>
<p>如果第一组很长，第二组很短，也可以进行计算</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/post_images/course/ML/Snipaste_2023-10-20_15-39-15.png" alt="Snipaste_2023-10-20_15-39-15"></p>
<hr>
<p>如果使用二维矩阵作为第二组，将图片作为第一组，那么可以得到<strong>“模糊”</strong>效果的结果图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/post_images/course/ML/Snipaste_2023-10-20_15-40-06.png" alt="Snipaste_2023-10-20_15-40-06"></p>
<p>如果放大来看，会发现第二组的矩阵，每个值都$1 &#x2F; 9$，它代表将<strong>附近9个像素值进行加权运算</strong>，最终得到<strong>一个像素值</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/post_images/course/ML/Snipaste_2023-10-20_15-42-03.png" alt="Snipaste_2023-10-20_15-42-03"></p>
<p>当然，如果原像素值是<strong>RGB（三通道）</strong>，那么需要将三个通道中<strong>对应通道的值</strong>进行计算。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/post_images/course/ML/Snipaste_2023-10-20_15-43-43.png" alt="Snipaste_2023-10-20_15-43-43"></p>
<p>而将上述的行为，我们称作：卷积</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/post_images/course/ML/Snipaste_2023-10-20_15-45-31.png" alt="将图片进行卷积"></p>
<hr>
<p><strong>高斯模糊图</strong></p>
<p>如果“第二组”的矩阵分成$5 \times 5$的形式，而且，矩阵最中心的值是最大的，其它地方的值是离中心越远就越小，这样的数据分布特征是符合“高斯分布”</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/post_images/course/ML/Snipaste_2023-10-20_15-45-53.png" alt="Snipaste_2023-10-20_15-45-53"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/post_images/course/ML/Snipaste_2023-10-20_15-47-07.png" alt="高斯分布矩阵"></p>
<p>如果我们使用高斯分布矩阵对这$5 \times 5$格子内像素进行卷积操作，<strong>矩阵最中心的像素会有更大的权重，而越边缘的像素会有更小的权重</strong>，对原图进行这样的“高斯矩阵”卷积，将得到<strong>高斯模糊图</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/post_images/course/ML/Snipaste_2023-10-20_15-47-32.png" alt="Snipaste_2023-10-20_15-47-32"></p>
<hr>
<p>下面的矩阵更特殊，其<strong>左侧边缘为正权，右边缘为负权</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/post_images/course/ML/Snipaste_2023-10-20_15-49-51.png" alt="矩阵-左侧边缘为正权，右边缘为负权"></p>
<p>如果对一张灰度图片进行操作（只有一个通道），比如下面的情况，最左边一列全黑（对应像素值为0），最右边一列全白（对应像素值为1），那么，对这片区域进行“卷积”操作后，会得到一个<strong>负值</strong>，我们将<strong>“卷积”操作后的结果的“负值”</strong>定义为红色，<strong>结果的“正值”</strong>定义为蓝色。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/post_images/course/ML/Snipaste_2023-10-20_15-51-19.png" alt="对这片区域进行卷积操作"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/post_images/course/ML/Snipaste_2023-10-20_15-54-26.png" alt="最终得到红色的色块"></p>
<p>如果一片区域里面都是相同的颜色，那么这个区域进行“卷积”操作的结果就是“零”，<strong>非正非负定义成黑色</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/post_images/course/ML/Snipaste_2023-10-20_15-55-04.png" alt="区域里面全是相同颜色"></p>
<p>对整个图片进行了“卷积”操作后的结果如下图所示，可以看到，只有在边缘的地方才有颜色，而且<strong>左边缘是红色，右边缘是蓝色</strong></p>
<p>那么，这种矩阵就可以用来找到图片的<strong>“左右”边缘</strong>（对图片是先从上到下逐个行，再对每行从左到右扫描）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/post_images/course/ML/Snipaste_2023-10-20_15-56-34.png" alt="“左右”边缘图"></p>
<hr>
<p>如果将上面的矩阵进行调整，最<strong>上层是正权，最下层是负权</strong>，那么对图片卷积操作后，将得到<strong>“上下”边缘的图</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/post_images/course/ML/Snipaste_2023-10-20_15-59-45.png" alt="矩阵-上层是正权，最下层是负权"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/post_images/course/ML/Snipaste_2023-10-20_16-00-55.png" alt="“上下”边缘的图"></p>
<p>其实，这个矩阵有个正式的名字：<strong>Kernel</strong>，核</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/post_images/course/ML/Snipaste_2023-10-20_16-02-21.png" alt="将原图与Kernel进行卷积操作"></p>
<hr>
<h2 id="卷积求解"><a href="#卷积求解" class="headerlink" title="卷积求解"></a>卷积求解</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/post_images/course/ML/Snipaste_2023-10-21_10-47-11.png" alt="Snipaste_2023-10-21_10-47-11"></p>
<h2 id="fftconvolution（快速卷积）"><a href="#fftconvolution（快速卷积）" class="headerlink" title="fftconvolution（快速卷积）"></a>fftconvolution（快速卷积）</h2><p>虽然卷积的计算方法很简单，但是当<strong>x和h</strong>都很长的时候，卷积计算是非常耗费时间的。直接卷积运算的复杂度为$\mathcal{O}[N^2]$，因此有必要找到比直接计算卷积更快的办法。</p>
<p>举例：如下图所示，如果两个多项式都是有100项的系系数，如果通过相乘系数的方法来展开多项式，需要做10000次乘积计算，随后还需要“沿着对角线合并同类项”【卷积操作】，那么还需要10000次操作，于是直接卷积运算的复杂度为$\mathcal{O}[N^2]$</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/post_images/course/ML/Snipaste_2023-10-21_10-23-28.png" alt="Snipaste_2023-10-21_10-23-28"></p>
<p>如果只考虑多项式的<strong>函数输出值</strong>，只对少数几个输入值进行采样计算，那么简洁运算的执行次数就等于样本数量。对于多项式来说，只需拥有N个函数输出值，就能确定(n-1)次多项式</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/post_images/course/ML/Snipaste_2023-10-21_10-53-18.png" alt="Snipaste_2023-10-21_10-53-18"></p>
<blockquote>
<p>比如，<strong>两个点</strong>（函数输出值）可以<strong>唯一确定一个一次多项式</strong>($a_0+a_1 \times x$)，<strong>三个点</strong>（函数输出值）可以<strong>唯一确定一个二次多项式</strong>($a_0+a_1 \times x +a_2 \times x^2$)，如果知道<strong>N个点</strong>（函数输出值），就可以<strong>唯一确定一个(N-1)次多项式</strong>。</p>
</blockquote>
<p>假设目前有个多项式$h(x)&#x3D;c_0+c_1x^1+c_2x^2+c_3x^3+c_4x^4+c_5x^5+c_6x^6+c_7x^7$，$h(x)$假设是$f(x) \times g(x)$的乘积结果，并且系数$c_i$都是未知量</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/post_images/course/ML/Snipaste_2023-10-21_10-57-07.png" alt="Snipaste_2023-10-21_10-57-07"></p>
<p>假如，现在知道多项式的输出值，比如$h(1), h(2)…… h(x)$（可以通过$f(1) \times g(1)，f(2) \times g(2)……f(x) \times g(x)$求出来），而且提供了 <strong>与未知系数的个数相同数量的方程式</strong>，从原理上来说，这些方程式可以用来还原出来系数值</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/post_images/course/ML/Snipaste_2023-10-21_10-59-01.png" alt="Snipaste_2023-10-21_10-59-01"></p>
<p>例如，现在有A(x)和B(x)两个多项式，而$C(x)&#x3D;A(x) \times B(x)$，那么C(x)将是<strong>4维</strong>（degree 4)需要<strong>5个点才能唯一确定一个四维的多项式</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/post_images/course/ML/Snipaste_2023-10-21_22-07-57.png" alt="Snipaste_2023-10-21_22-07-57"></p>
<p>所以，需要<strong>分别在A(x)和B(x)上取各自取5个点</strong>，将这5个点对应的函数值$A(x_i)、B(x_i)$相乘，从而得到$C(x_i), i \in {(0,4)}$，如下图所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/post_images/course/ML/Snipaste_2023-10-21_22-13-26.png" alt="Snipaste_2023-10-21_22-13-26"></p>
<p>上面这小部分，讲述的是将通过A(x)和B(x)相乘(Mulitiply)得到C(x)，然后，这只是”快速卷积”中的一小步，如下图所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/post_images/course/ML/Snipaste_2023-10-21_22-16-06.png" alt="快速卷积-相乘子部分"></p>
<p>然后，让我们看下<strong>宏观图（big piture）</strong>，快速卷积的大致流程如下</p>
<ol>
<li>拥有两个多项式A(x)和B(x)</li>
<li>将Coeff转成Value，这部分就是FFT</li>
<li>对A(x)和B(x)使用相乘(Multiplay)操作得到C(x)的Value</li>
<li>将C(x)从Value转成Coeff，从而得到具体的C(x)函数</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/post_images/course/ML/Snipaste_2023-10-21_22-16-47.png" alt="快速卷积-宏观图"></p>
<hr>
<p><strong>时域的卷积等于频域的乘积</strong>这个定理，因此要<strong>计算时域的卷积</strong>，可以将<strong>时域信号转换为频域信号</strong>，<strong>进行乘积运算之后再将结果转换为时域信号</strong>，实现<strong>快速卷积</strong>。</p>
<p>经过优化的FFT其运算的复杂度为$\mathcal{O}[NlogN]$，显然通过FFT计算卷积要比直接计算快速得多。</p>
<p>不过由于FFT运算假设其所计算的信号为周期信号，因此通过FFT计算出的结果实际上是两个信号的循环卷积，而不是线性卷积。<br>使用numpy的fft来计算卷积：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">h = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">X = np.fft.rfft(x)</span><br><span class="line">H = np.fft.rfft(h)</span><br><span class="line">y = np.fft.irfft(X*H)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;fft计算卷积结果为:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fft计算卷积结果为:</span><br><span class="line">[66. 68. 66. 60.]</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>可以看到，将x和h变换到频域相乘，然后变换回时域的结果与循环卷积的结果一致。<br>如果需要使用FFT计算线性卷积，就需要对信号进行补零扩展，使得其长度长于线性卷积结果的长度。<br>对x和h进行补零，然后再进行fft：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">h = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">X = np.fft.rfft(x,n=<span class="number">7</span>)</span><br><span class="line">H = np.fft.rfft(h,n=<span class="number">7</span>)</span><br><span class="line">y = np.fft.irfft(X*H,n=<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;fft计算卷积结果为:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fft计算卷积结果为:</span><br><span class="line">[ 5. 16. 34. 60. 61. 52. 32.]</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>可以看到，结果与线性卷积结果一致</p>
<h2 id="FFT算法"><a href="#FFT算法" class="headerlink" title="FFT算法"></a>FFT算法</h2><p>快速傅立叶变换（FFT）是信号处理和数据分析中最重要的算法之一，很多人只是调用现成的库如FFTW，但为了知其所以然，加深对算法的理解，我们有必要搞懂FFT算法是怎么计算的，这里不讨论傅里叶变换的理论和推导，只讨论实际工程中怎样计算，由于python代码的可读性以及计算的方便性，使用python代码展示FFT计算过程</p>
<h2 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h2><p>傅里叶变换FT（fourier transform）用于将时域信号x(t)和频域信号X(f)之间变换，公式如下所示：</p>
<p>$\hat{f}\left(\xi\right)&#x3D;\int_{-\infty}^{\infty}f(x)e^{-2\pi ix\xi}dx\quad\xi\text{ 为任意实数}$</p>
<p>很多时候，这里的$\hat{f}\left(\xi\right)$会写成 $F(w)$或$F(f)$ 表示<strong>角速度</strong>或者<strong>频率</strong>，当然后面的公式的量纲也需要对应的修改；后面的自变量 x大多数时候都是写成t表示时间。当然，他们表示的都是同一个东西</p>
<h3 id="联想链条"><a href="#联想链条" class="headerlink" title="联想链条"></a>联想链条</h3><p>既然是为了【理解】和【记忆】，那么我们还是需要定义一个<strong>联想链条</strong>：</p>
<blockquote>
<p>傅立叶变换 ➜ 分解声音的过程</p>
</blockquote>
<p>建议使用分解声音这个例子来理解傅立叶变换，非常好用</p>
<h3 id="声音的表示"><a href="#声音的表示" class="headerlink" title="声音的表示"></a>声音的表示</h3><p>我们是如何记录声音的呢？如果你测量的是扬声器旁的<strong>气压</strong>，那么它会是一个<strong>随时间</strong>以正弦函数形态不断震荡的图像。</p>
<p>一个标准音 A（下图<strong>黄色</strong>），它的频率是440Hz，表示<strong>每秒钟振动440次</strong></p>
<p>标准音 A 低一些的 D（下图<strong>紫红</strong>），它的频率是294Hz，表示<strong>每秒钟振动294次</strong>，振动的慢一些。</p>
<p>如果这两个音同时发出，产生的<strong>气压随时间曲线</strong>怎么决定呢？如下动图，其实就是<strong>把所有时间点的振幅加起来</strong>，下图中最上层的一条曲线</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picx.zhimg.com/50/v2-1c1febf3700194b2ac8d6aef485a7f9d_720w.webp?source=2c26e567" alt="动图"></p>
<p>那么如果给你随意一段<strong>随时间变化的气压曲线</strong>，你如何找到这些<strong>原有的组成音符</strong>呢？这就是我们的目的，参考下面的动图，感觉有点像是<strong>把一盘混好的原料分成组成它的单独的颜色</strong>，感觉不那么容易吧？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/post_images/course/ML/Snipaste_2023-10-21_22-29-45.png" alt="Snipaste_2023-10-21_22-29-45"></p>
<p>下面就需要一步一步把这件事情做出来</p>
<h3 id="可视化方法"><a href="#可视化方法" class="headerlink" title="可视化方法"></a>可视化方法</h3><p>首先，假设我们有一个<strong>每秒钟振动3次</strong>的声音信号（440Hz实在太快啦），它的图像如下（Intensity为强度，可以同理成气压），并且，<strong>我们只关注前面的4.5秒</strong>（即图像中画出来的部分）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picx.zhimg.com/v2-51f47c67e91773e5313eee0ef32d38a0_r.jpg?source=2c26e567" alt="img"></p>
<h3 id="绕圈记录法：同一事物的不同角度"><a href="#绕圈记录法：同一事物的不同角度" class="headerlink" title="绕圈记录法：同一事物的不同角度"></a>绕圈记录法：同一事物的不同角度</h3><p>千万不要眨眼！下面是<strong>最关键的一步</strong>，是【看到】傅立叶变换的核心部分，如下面动图所示</p>
<video src="https://vdn6.vzuu.com/SD/b5907b9e-239e-11eb-b202-ea37c03d7100.mp4?pkey=AAWb0j_EPCTGeQK3KaFEISCAFzpSMs0BvZVT7ccS93AueehdnJZhkEga1tAuxM6Idn2yXo4P3RGHI8_UeO-NFIeB&c=avc.0.0&f=mp4&pu=078babd7&bu=078babd7&expiration=1697905557&v=ks6" />



<ul>
<li>首先把黄色曲线缠绕到一个圆上，大小就是原本信号的振幅</li>
<li>圆周围的图像由<strong>白色的箭头</strong>绘制而成，速度可变，上图中的白色箭头移动速度是<strong>每秒钟转过白色虚线半圈</strong>（这个速度是对于下面的圆形图像来说，每秒钟在<strong>白色虚线圆形图像中</strong>转半圈），对应上面的则是<strong>虚线表示一圈</strong>走到的位置，0.5拍子&#x2F;秒。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/post_images/course/ML/Snipaste_2023-10-21_22-37-43.png" alt="一秒内转完白色虚线圆形的半圈"></p>
<blockquote>
<p>注意看，在上面的坐标轴，<strong>白色虚线</strong>画在<strong>Time&#x3D;2秒</strong>的位置，表示：下面的<strong>白色虚线圆形图像</strong>中，<strong>转完一圈完成需要2秒</strong></p>
</blockquote>
<ul>
<li>此时，有<strong>两个频率</strong>在起作用，一个是<strong>信号的频率</strong>：3次震荡&#x2F;秒，另一个是图像<strong>缠绕中心圆（白色虚线圆形）</strong>的频率，为0.5圈&#x2F;秒。第二个频率可以自由改变，相当于一个<strong>变量</strong>，下面的动图直观的展现了<strong>缠绕速度变化时（上面的白色虚线）的可视化表现</strong></li>
</ul>
<video src="https://vdn6.vzuu.com/SD/28b7cdec-234b-11eb-865d-32690a56e4fd.mp4?pkey=AAXPaunj35HsGVUo26i5WZiYMsMIY9XCKG4shHRFduMv14UvKi3aJ4O_-nwTIXnfuAMUT5Cm_Mt4GvK_cwEilFw7&c=avc.0.0&f=mp4&pu=078babd7&bu=078babd7&expiration=1697905558&v=ks6" />



<p>从最开始的下面的<strong>白色虚线圆形</strong>0.79圈&#x2F;秒（注意这里的速度是指<strong>绕白色虚线单位圆的【白色箭头】的滑动速度</strong>）一直变化到1.55圈&#x2F;秒，到最后的恰好<strong>让缠绕中心圆的频率3圈&#x2F;秒</strong>，和<strong>信号的频率3拍&#x2F;秒</strong>相同，此时会出现一个<strong>非常稳定的图像</strong>，我们可以理解成：<strong>同步。</strong>这个绕圈图像<strong>记录</strong>了原信号的<strong>幅值变化</strong>并且<strong>每一圈都相同</strong>（周期性）</p>
<blockquote>
<p>在这个特殊的情况下，当坐标轴上面的<strong>白色实线箭头到达高峰</strong>时，下面的<strong>白色实线箭头</strong>会<code>同步</code>地达到<strong>黄色的最右端</strong></p>
<p>而当坐标轴上面的<strong>白色实线箭头到达波谷</strong>时，下面的<strong>白色实线箭头</strong>会<code>同步</code>地达到<strong>黄色的最左端</strong>，如下图所示</p>
<p>其实，我们只是把一个水平的轴缠绕到一个单位圆上，并用另一个速度的<strong>记录标尺</strong>（白色箭头）来画图。想当于<strong>从另一个角度（维度）</strong>来看我们的信号</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/post_images/course/ML/Snipaste_2023-10-21_22-50-07.png" alt="Snipaste_2023-10-21_22-50-07"></p>
<hr>
<h3 id="质心记录法：新维度的特征提取"><a href="#质心记录法：新维度的特征提取" class="headerlink" title="质心记录法：新维度的特征提取"></a>质心记录法：新维度的特征提取</h3><p>虽然新图像挺好看的，但是现在感觉并没法从中看出什么。也不尽然，我们直观的发现，当白色箭头记录的速度在某些特定的值时，画出来的图形非常稳定，形态清晰。那如何表现这个特征呢？</p>
<p>从两个角度来思考</p>
<p>（1）自变量是什么？（输入特征）</p>
<p>输入是一个<strong>可变化</strong>的转圈速度，既然可变，不妨把它看作<strong>自变量</strong>，即$f(x)$中的$x$</p>
<p>（2）输出（新的圆圈图）有什么特征？（输出特征）</p>
<p>观察到，当<strong>图像很混沌（没有规律，混乱的）</strong>时候，图像基本关于原点对称；稳定时，其实是“头重脚轻”的。描述“头重脚轻”最好的方法当然是用【质心】（它描述了物体的空间分布特征） ，下面的动图直观展现了质心特征对图像特征的描述能力（<strong>红色点为质心</strong>）</p>
<video src="https://vdn6.vzuu.com/SD/e9a6398e-231f-11eb-b88e-0a2263636e9f.mp4?pkey=AAXJkyyHLx4OGWDNkqa2vekuCrmGcE5Q_Mhr-wMROUMy7iwXF83FNMZvi0xF_8byxu0-jf3B_7zihoe3QpVVhBem&c=avc.0.0&f=mp4&pu=078babd7&bu=078babd7&expiration=1697905561&v=ks6" />




<p>考虑到质心其实是一个二维坐标，这里为了简洁和直观，取<strong>质心的横坐标</strong>来表示质心的特征</p>
<p>那么新图像的横坐标和纵坐标表示什么如下所示：</p>
<p>【输入（横坐标）】➜【进行采样的（白色箭头）的绕圈速度】</p>
<p>【输出（纵坐标）】➜【圆圈图的质心位置的<strong>横坐标</strong>】</p>
<p>按照上面的说明来记录绘出图像，记录每个缠绕频率（速度）对应的质心位置，参看下列动图，随着图像的绘制到3圈&#x2F;秒这个位置的时候，是不是<strong>感到似曾相识</strong>呢？</p>
<video src="https://vdn6.vzuu.com/SD/6b4abb48-2372-11eb-ab18-9aee720f1b41.mp4?pkey=AAXEjAj43xOPZA1metMaBiFUgjus7Q4wkQ9lPA1VTaUqH7YlUsnEz8IMVUgW4tTsObzChHCqWgFSX_Uzd__D61Ms&c=avc.0.0&f=mp4&pu=078babd7&bu=078babd7&expiration=1697905563&v=ks6" />





<p>补充一点，在横坐标等于<strong>零点处</strong>有一个很大的值，只是因为原来的图像没有关于横轴对称，有一个偏移量，直观参看下面动图，如果把偏移量去除，其实就变成了个$cos(x)$函数</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picx.zhimg.com/50/v2-c2630207d9b8a0fce8ec7c92007b29d0_720w.webp?source=2c26e567"></p>
<blockquote>
<p><strong>关注点是当频率为3时的凸起</strong>，当<strong>缠绕频率和信号频率相等时，就出现了一个尖峰</strong>，这个图是“<strong>近似傅里叶变换</strong>”</p>
<p>当缠绕频率和信号频率相等时，“质心”会离坐标轴中心很远</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/post_images/course/ML/Snipaste_2023-10-21_23-12-47.png" alt="缠绕频率和信号频率相等"></p>
<p>我们可以看到，新图像的横坐标写的是【频率 Frequency】，即缠绕圆圈的记录速度，所以强烈建议看到<strong>频率，想起速度</strong>，并且抽象为<strong>围着圆圈跑的速度</strong>（个人感受，对理解【频率】的概念有助益）</p>
<p>好！有了这个工具，先把它应用到两个声音的组合图像中看看效果：（这是我最喜欢的一张动图）</p>
<video src="https://vdn6.vzuu.com/SD/89332ef4-2342-11eb-b297-e24453d337b5.mp4?pkey=AAW3Z_CvCBtl--yGgJquj_mvuac5NhvuOuZ_5VjmFEaki5kTyNZmaHYHBI39gUvCiBKYZCoDnJaa4owkUSukYDmd&c=avc.0.0&f=mp4&pu=078babd7&bu=078babd7&expiration=1697907201&v=ks6" />



<blockquote>
<p>对于将2Hz和3Hz组成在一起的声音，当缠绕频率和信号频率都等于<strong>2转&#x2F;秒</strong>时，<strong>右下角的图出现了一个峰值</strong>，并且质心处于x轴并离原心最远，而且左下角的图片变得不是那么“混乱”，以上的几个“特征”都说明了当<strong>缠绕频率&#x3D;信号频率&#x3D;2转&#x2F;秒</strong>时的特殊性</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/post_images/course/ML/Snipaste_2023-10-21_23-15-11.png" alt="缠绕频率=信号频率=2转/秒"></p>
<blockquote>
<p>同理，当<strong>缠绕频率&#x3D;信号频率&#x3D;3转&#x2F;秒</strong>时，也发生了相似的特征</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/post_images/course/ML/Snipaste_2023-10-21_23-18-36.png" alt="缠绕频率=信号频率=3转/秒"></p>
<p>什么？还是没看清上面的振动图像如何变成圆圈图的？看下面的动图，<strong>缠绕圆圈速度为2圈&#x2F;秒的白色箭头</strong>将时间信息映射到圆圈图中的的可视化。再次重复，白色箭头以<strong>一定的速度</strong>（频率，一秒几圈）在上图中<strong>向右横移</strong>，同时，在下面的单位圆内被转换成类似钟表指针移动的圆圈运动，并<strong>记录振幅</strong>，画出图像【左下角的图中，<strong>白色箭头实际上是沿着“绿色”线逆时针地移动</strong>，如果把白色箭头抽像出来，它还是按着白色虚线进行旋转的】</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic1.zhimg.com/50/v2-bbf9cacfc943f9ac6b05ebc192905ff5_720w.webp?source=2c26e567" alt="动图封面"></p>
<p>BTW，图形的一部分有点像动画EVA中某个使徒的脸，带给人一种诡异的仪式感。数学之令人敬畏，可能在这一刻熠熠生辉，刺的人睁不开眼</p>
<hr>
<h2 id="公式表示"><a href="#公式表示" class="headerlink" title="公式表示"></a><strong>公式表示</strong></h2><p>大家也发现了，我们已经通过这样一个<strong>缠绕机器</strong>完成了<strong>时域到频域的转换</strong>，总得来说，参看下面的动图</p>
<blockquote>
<p>在下面这个图中，</p>
<p>一种是先将2Hz和3Hz频率转成对应的“近似傅里叶变换”图，再将两个“近似傅里叶变换”图叠加起来</p>
<p>另一种是，先将2Hz和3Hz频率叠加起来，再转成换“近似傅里叶变换”图</p>
<p>这两种在最终得到的“近似傅里叶变换”图都是一样的</p>
<p>这就为我们的“分离”工作带来的最重要的工具，因为我们发现了“可分离”的工具</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picx.zhimg.com/50/v2-307faf1301150b3fb856eeae114805c7_720w.webp?source=2c26e567" alt="动图封面"></p>
<p>这是一种【近傅立叶变换】，为什么是【近】，后面会提到。先考虑，那如何<strong>数学语言</strong>表达这个【转圈记录机制（工具 or 机器）】呢？</p>
<h3 id="第一步：旋转的表示"><a href="#第一步：旋转的表示" class="headerlink" title="第一步：旋转的表示"></a>第一步：旋转的表示</h3><p>如下面的动图所示，在这个工具中，非常关键的就是<strong>转圈</strong>，即表达旋转这种运动，根据第一大部分，这个桥梁，就是<strong>复平面</strong>，其背后的原理是<strong>幂函数</strong>结合<strong>泰勒公式</strong></p>
<video src="https://vdn6.vzuu.com/SD/70d754a6-235c-11eb-9be2-0ed2be95198e.mp4?pkey=AAUG4YGKA9JvIPR4DGgrh7qgP6IbCHaxGopg0Do9i7ZpZItsVRppnE3yM5xZeSTUwQlf92NHPP2UKkCJY136CS_V&c=avc.0.0&f=mp4&pu=078babd7&bu=078babd7&expiration=1697909285&v=ks6" />





<p>著名的欧拉公式说明，在复平面(comples plane)，$e^{ni}$表示，从右边开始，沿着半径为1的单位圆“逆时针”<strong>走到</strong><code>n个单位长度</code>的<strong>点</strong>上</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/post_images/course/ML/Snipaste_2023-10-22_00-10-29.png" alt="Snipaste_2023-10-22_00-10-29"></p>
<p>更进一步，幂函数中，以$e$为底的函数有着特殊的性质，如下面动图所示，$\pi$单位的 $e^{6.28i}$就表示一个单位圆的360°旋转，则$e^{2\pi it}$表示的就是<strong>一秒钟一圈</strong>的旋转方程(<strong>因为对于单位圆来说，$2\pi$就是一圈的长度</strong>），但旋转的速度感觉有点太快了，所以加一个$f$频率，从而控制<strong>旋转的速度</strong>不那么快，图中$f$是$\frac{1}{10}$，合起来表示<strong>一秒钟十分之一圈</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picx.zhimg.com/50/v2-53f33b1d753670fba11cba8c3bfe90c3_720w.webp?source=2c26e567"></p>
<h3 id="第二步：缠绕的表示"><a href="#第二步：缠绕的表示" class="headerlink" title="第二步：缠绕的表示"></a>第二步：缠绕的表示</h3><p>首先，依据下面的动图所示，在傅立叶变换中，我们<strong>规定</strong>旋转是顺时针的（规定只是为了统一标准，并且有时候也会考虑<strong>书写简洁</strong>和<strong>方便计算</strong>），所以先加一个负号。假设原来的函数是$g(t)$ ，将两者的<strong>幅值相乘</strong>就能得到缠绕图像，$g(t)e^{-2\pi ift}$ ，可以说是相当机智了！</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pica.zhimg.com/50/v2-5991b04df2f376b3c8edbbba6cc190fd_720w.webp?source=2c26e567"></p>
<h3 id="第三步：质心的表示"><a href="#第三步：质心的表示" class="headerlink" title="第三步：质心的表示"></a>第三步：质心的表示</h3><p>那如何表示质心这一概念呢？粗略想一下感觉挺难的，但是看起来很难的问题，有一种解决问题的途径是【演绎推理】，先从<strong>简单的特例出发</strong>，推广到<strong>一般</strong>，最后<strong>证明正确性</strong>即可</p>
<p>考虑如何求一个正方形的质心位置，我们只需在边框上取n个等<strong>距离分布的点</strong>，并且算这几个点的位置的平均值。那么推广到一般情况，也使用类似的采样点的方式解决，如下面动图所示（紫红色的点即采样点），得到 $\frac{1}{N} \sum_{k&#x3D;1}^{N} g(t_k) e^{-2\pi i f t_k}$</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picx.zhimg.com/50/v2-ec8d1ea8d3311e14223cafbb0bd03745_720w.jpg?source=2c26e567"></p>
<p>随着采样点的增加，需要使用<strong>积分</strong>来求解这个问题，如下面动图所示，得到</p>
<p>$\frac{1}{t_2-t_1} \int_{t_1}^{t_2} g(t) e^{-2\pi i f t_k}$</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picx.zhimg.com/50/v2-0fffdbbc3ed7c8cfce1692eaddab1bd6_720w.webp?source=2c26e567"></p>
<h3 id="最终步：整理积分限和系数"><a href="#最终步：整理积分限和系数" class="headerlink" title="最终步：整理积分限和系数"></a><strong>最终步：整理积分限和系数</strong></h3><p>看到常数项系数$\frac{1}{t_2-t_1}$，如果忽略表达倍数关系的系数，对应的含义也会发生变化，不再是质心，而是<strong>信号存在的时间越久</strong>，位置是质心位置乘以一个倍数，它的值<strong>就越大</strong>。参看下面的动图，持续时长为3秒，那么新的位置就是原来质心位置的三倍；为6秒，就是原来的6倍</p>
<video src="https://vdn.vzuu.com/SD/43c7170a-2323-11eb-918a-b687078c411a.mp4?disable_local_cache=1&bu=078babd7&c=avc.0.0&f=mp4&expiration=1697907039&auth_key=1697907039-0-0-cde653060621a6bda9bbec7f4a209cfc&v=ali&pu=078babd7" />



<p>而去掉系数的几何直观动图变为（<strong>红色箭头</strong>为去掉系数后的长度表示），最本质的区别是：可以使得最后绘制的图像<strong>更集中在</strong>对应的频率的附近，或者说在对应的频率位置的值更大</p>
<video src="https://vdn6.vzuu.com/SD/b19cc96a-231d-11eb-98a4-3a21be7a59c3.mp4?pkey=AAWTdDgcQAvus9f2ChGgi2PMFjv8qxgC0JnWZ3EcqKw2V4ITjzxdjQotcYJialWAPooARb5pyWXQFqDROPPT0eHN&c=avc.0.0&f=mp4&pu=078babd7&bu=078babd7&expiration=1697910749&v=ks6" />


<p>继续考虑上下限。我们知道，一般傅立叶变换公式的上下限是正负无穷，那它的几何直观是什么呢？参看下面动图，其实就是看看信号持续时间无穷大是什么样子的</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picx.zhimg.com/50/v2-420d0d38700f4c69bb4bda98830647a1_720w.webp?source=2c26e567"></p>
<p>说实话，这个动图解答了我大学时代的一个疑惑，音乐文件不都是有时间长度的嘛，我就一直不懂，凭什么对负无穷到正无穷做傅立叶变换？原来真实情况是，从<strong>负无穷到0</strong>，<strong>音乐结尾到正无穷</strong>，就像上面的动图，其实都<strong>没有振动幅值（电信号幅值）与之对应</strong>，再结合缠绕圆圈的思想：原来，从<strong>音乐开始到结束</strong>做傅立叶变换和<strong>从负无穷到正无穷</strong>做傅立叶变换，是特么的一回事啊！（吐槽完毕）</p>
<p>$\mathrm{X(f)&#x3D;\int_{-\infty}^\infty x(t)e^{-j2\pi ft}dt&#x3D;\int_{-\infty}^\infty X(f)e^{j2\pi ft}df}$</p>
<h3 id="离散傅里叶变换"><a href="#离散傅里叶变换" class="headerlink" title="离散傅里叶变换"></a>离散傅里叶变换</h3><p>由于计算机只能处理有限长的离散信号，因此必须建立对应的<strong>离散傅里叶变换DFT</strong>（Discrete Fourier Transform）：</p>
<p>$\mathrm{X_k<del>&#x3D;</del>\sum_{n&#x3D;0}^{N-1}x_n~\cdot e^{-i2\pi k\frac nN}}$</p>
<p>如果我们定义一个矩阵M</p>
<p>$\mathrm{M_{kn}~&#x3D;e^{-i2\pi k\frac nN}}$</p>
<p>则很明显DFT的公式只是一个简单的线性变换：</p>
<p>$X&#x3D;x \times M$</p>
<p>因此简单的使用矩阵乘法就能计算出DFT的结果，我们可以很容易的写出DFT的python代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">DFT</span>(<span class="params">x</span>):</span><br><span class="line">    N = <span class="built_in">len</span>(x)</span><br><span class="line">    k,n = np.meshgrid(np.arange(N),np.arange(N))</span><br><span class="line">    W = np.exp(-<span class="number">1j</span>*<span class="number">2</span>*np.pi*k*n/N)   </span><br><span class="line">    <span class="keyword">return</span> np.dot(x,W)</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p>我们以2048点DFT为例，与numpy中内置的FFT做对比，看看速度相差多少</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x=np.random.random(<span class="number">2048</span>)</span><br><span class="line">X=np.fft.fft(x)</span><br><span class="line">X=DFT(x)</span><br><span class="line"><span class="number">123</span></span><br><span class="line">compute <span class="number">2048</span> points dft using np.fft cost: <span class="number">0.001677</span> ms</span><br><span class="line">compute <span class="number">2048</span> points dft using DFT cost: <span class="number">0.321912</span> ms</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>可以看到，速度相差了差不多2000倍，对于每个值$X(k)$的计算需要N个复数乘法(4N个乘法和2N个加法)和N-1个复数加法(2N-2个加法),因此DFT的总计算量需要$N^2$个复数乘法和$N^2-N$个复数加法，复杂度是$\mathcal{O}[N^2]$ ，是不利于计算机进行实时信号处理的，因此为了优化DFT的计算量，便有了相关FFT算法，下面介绍快速傅里叶变换算法，对于快速傅里叶逆变换其优化方式非常相似，因此不做介绍</p>
<h3 id="快速傅里叶变换"><a href="#快速傅里叶变换" class="headerlink" title="快速傅里叶变换"></a>快速傅里叶变换</h3><p>Cooley-Tukey快速傅里叶算法是常见的FFT算法，其思想是利用了DFT变换中的对称性和周期性来简化计算</p>
<p>首先我们定义</p>
<p>$\mathrm{W_N}&#x3D;\mathrm{e}^{-\mathrm{i}\frac{2\pi}N}$</p>
<p>$W_N$满足下面的定义</p>
<p>周期性:$W_N^{k+N} &#x3D; W_N^kWNk+N&#x3D;WNk$</p>
<p>对称性:$W_N^{k+\frac {N}{2}} &#x3D; -W_N^k$</p>
<p>若m是N的约数：$W_N^{mkn}&#x3D;W_{\frac{n}{m}}^{kn}$</p>
<p>我们只需几行代码就可验证上述特性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Wn</span>(<span class="params">k,N</span>):</span><br><span class="line">        <span class="keyword">return</span> np.exp(-<span class="number">1j</span>*<span class="number">2</span>*np.pi*k/N)</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>定义如下一些变量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">N = <span class="number">8</span></span><br><span class="line">k = <span class="number">3</span></span><br><span class="line">m = <span class="number">2</span></span><br><span class="line">n = <span class="number">2</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>验证周期性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.allclose(Wn(k,N),-Wn(k+N,,N)))</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>验证对称性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.allclose(Wn(k,N),-Wn(k+N//<span class="number">2</span>,,N)))</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>验证可约性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.allclose(Wn(m*k*n,N),Wn(k*n,N//m)))</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>





<h4 id="基2-FFT"><a href="#基2-FFT" class="headerlink" title="基2 FFT"></a>基2 FFT</h4><p>根据上面的对称性，我们可以将DFT计算分为两个较小的部分</p>
<p>$\begin{aligned}<br>\mathrm{X_k<del>&#x3D;</del>\sum_{n&#x3D;0}^{N-1}x_n<del>\cdot W_{N}^{kn}} \<br>&amp;\mathrm{</del>&#x3D;<del>\sum_{m&#x3D;0}</del>x_{2m}<del>\cdot W_{N}^{2mk}</del>+\sum_{m&#x3D;0}^{N&#x2F;2-1}<del>x_{2m+1}</del>\cdot W_{N}^{(2m+1)k}} \<br>&amp;\mathrm{&#x3D;\sum_{m&#x3D;0}^{N&#x2F;2-1}x_{2m}\cdot W_{\frac N2}^{km}+W_{N}^{k}\sum_{m&#x3D;0}^{N&#x2F;2-1}x_{2m+1}\cdot W_{\frac N2}^{km}} \<br>&amp;&#x3D;\mathrm{F}_1\left(\mathrm{k}\right)+\mathrm{W}_\mathrm{N}^\mathrm{k}\mathrm{~F}_2\left(\mathrm{k}\right)<br>\end{aligned}$</p>
<p>这样一个N点变换就分解为了两个N&#x2F;2点变换，这里F 1 ( k ) F_1(k)F1(k)和F 2 ( k ) F_2(k)F2(k)分别是序列x中的奇数号和偶数号序列的N &#x2F; 2 N&#x2F;2N&#x2F;2点DFT变换，根据以上公式我们也能很快写出python代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">R2FFT</span>(<span class="params">x</span>):</span><br><span class="line">   N = <span class="built_in">len</span>(x)</span><br><span class="line">   N2 = N // <span class="number">2</span></span><br><span class="line">   k,n = np.meshgrid(np.arange(N2),np.arange(N2))</span><br><span class="line">   W = np.exp(-<span class="number">1j</span>*<span class="number">2</span>*np.pi*k*n/N2)</span><br><span class="line">   G = np.exp(-<span class="number">2j</span> * np.pi * np.arange(N2) / N)</span><br><span class="line">   X_even = np.dot(x[::<span class="number">2</span>],W)</span><br><span class="line">   X_odd = G*np.dot(x[<span class="number">1</span>::<span class="number">2</span>],W)</span><br><span class="line">   <span class="keyword">return</span> np.concatenate([X_even+X_odd,X_even-X_odd])</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>

<p>同样计算2048点DFT，速度如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compute 2048 points dft using R2FFT cost: 0.081140 ms</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>对于N &#x3D; 2 r N&#x3D;2^rN&#x3D;2r,很显然两个N&#x2F;2点的DFT变换还可以继续分解下去，分解为4个N&#x2F;4的更短的序列，N&#x2F;4的序列还可以将序列继续分解下去，直到分解为N&#x2F;2个2点的DFT变换，2点的DFT变换只需要复数加法和减法就能实现，复数乘法计算量减小至( N &#x2F; 2 ) l o g N (N&#x2F;2)logN(N&#x2F;2)logN,复数加法计算量减小至N l o g N NlogNNlogN，算法复杂度为O [ N l o g N ] \mathcal{O}[NlogN]O[NlogN]，大大减少了DFT的计算量，这就是<strong>Cooley-Tukey快速傅里叶变换</strong>的基本原理，我们将一个DFT变换分解为两个较小的DFT变换，即基2FFT，我们可以通过递归来实现该算法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">RecursiveR2FFT</span>(<span class="params">x</span>):</span><br><span class="line">    N = x.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> N &lt;= <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> [x[<span class="number">0</span>]+x[<span class="number">1</span>],x[<span class="number">0</span>]-x[<span class="number">1</span>]]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        X_even = RecursiveR2FFT(x[::<span class="number">2</span>])</span><br><span class="line">        X_odd = RecursiveR2FFT(x[<span class="number">1</span>::<span class="number">2</span>])</span><br><span class="line">        factor = np.exp(-<span class="number">2j</span> * np.pi * np.arange(N//<span class="number">2</span>) / N)</span><br><span class="line">        <span class="keyword">return</span> np.concatenate([X_even + factor * X_odd,</span><br><span class="line">                               X_even - factor * X_odd])</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>

<p>计算2048点DFT速度如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compute 2048 points dft using RecursiveR2FFT cost: 0.081140 ms</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>相比前面的版本速度并没有提升,是因为python的递归版本并不高效,并且没有进行并行化的计算,因此,通过观察基2fft的规律我们可以将递归调用的向量乘法转换为并行计算的矩阵乘法以删除递归调用以及并行计算，python代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">NonRecursiveR2FFT</span>(<span class="params">x</span>):</span><br><span class="line">    L = <span class="built_in">len</span>(x)</span><br><span class="line">    N_base = <span class="number">2</span></span><br><span class="line">    base = L//N_base</span><br><span class="line">    X = np.reshape(x,(-<span class="number">1</span>,base))</span><br><span class="line">    X = np.vstack([X[<span class="number">0</span>]+X[<span class="number">1</span>],X[<span class="number">0</span>]-X[<span class="number">1</span>]]).T</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(np.log2(base))):</span><br><span class="line">        N = X.shape[<span class="number">1</span>]</span><br><span class="line">        W = np.exp(-<span class="number">1j</span> * np.pi * np.arange(N) / N)</span><br><span class="line">        X_even = X[:X.shape[<span class="number">0</span>]//<span class="number">2</span>]</span><br><span class="line">        X_odd = W*X[X.shape[<span class="number">0</span>]//<span class="number">2</span>:]</span><br><span class="line">        X = np.concatenate([X_even+X_odd,X_even-X_odd],axis=-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> X.ravel()</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>

<p>计算2048点DFT速度如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compute 2048 points dft using NonRecursiveR2FFT cost: 0.000327 ms</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>可以看到,速度又提高了一个数量级，相比numpy的fft只差了1倍</p>
<h4 id="基4FFT"><a href="#基4FFT" class="headerlink" title="基4FFT"></a>基4FFT</h4><p>当DFT点数N为4的幂时，我们当然可以使用基2FFT算法进行计算，但对于这种情况使用基4FFT算法更为高效，基4FFT的原理与基2FFT类似，只不过是将N点DFT序列拆分成4个N&#x2F;4的子序列：</p>
<p>$\begin{aligned}\mathrm{X_k&#x3D;\sum_{n&#x3D;0}^{N-1}x_n\cdot W_N^{kn}} \ &#x3D; W_N^0F_0\left(k\right)+W_N^kF_1\left(k\right)+W_N^{2k}F_2\left(k\right)+W_N^{3k}F_3\left(k\right) \end{aligned}$</p>
<p>在这里直接给出非递归的基4FFT代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">NonRecursiveR4FFT</span>(<span class="params">x</span>):</span><br><span class="line">    L = <span class="built_in">len</span>(x)</span><br><span class="line">    N_base = <span class="number">2</span></span><br><span class="line">    base = L//N_base</span><br><span class="line">    X = np.reshape(x,(-<span class="number">1</span>,base))</span><br><span class="line">    X = np.vstack([X[<span class="number">0</span>]+X[<span class="number">1</span>],X[<span class="number">0</span>]-X[<span class="number">1</span>]]).T</span><br><span class="line">    butterfly_matrix = np.array([[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,-<span class="number">1j</span>,-<span class="number">1</span>,<span class="number">1j</span>],[<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1j</span>,-<span class="number">1</span>,-<span class="number">1j</span>]])</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(np.log(base)/np.log(<span class="number">4</span>))):</span><br><span class="line">        N4 = X.shape[<span class="number">1</span>]</span><br><span class="line">        N = N4*<span class="number">4</span></span><br><span class="line">        G = np.exp(-<span class="number">2j</span> * np.pi * (np.arange(N4).reshape(<span class="number">1</span>,-<span class="number">1</span>)*np.arange(<span class="number">4</span>).reshape(-<span class="number">1</span>,<span class="number">1</span>)) / N)</span><br><span class="line">        X = G*X.reshape((<span class="number">4</span>,-<span class="number">1</span>,N4)).transpose([<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>])</span><br><span class="line">        X = np.dot(butterfly_matrix,X).transpose([<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>]).reshape((-<span class="number">1</span>,N))</span><br><span class="line">    <span class="keyword">return</span> X.ravel()</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>

<p>注意，由于N &#x3D; 2048 &#x3D; 2 ⋅ 4 5 N&#x3D;2048&#x3D;2\cdot 4^5N&#x3D;2048&#x3D;2⋅45,因此我们最后分成了1024个2点FFT，如果N NN是4的幂例如N&#x3D;1024,那么最后会得到2个512点的结果，并不满足基4FFT的条件，那么我们可以将这2个512点序列按照基2FFT原理进行计算，最终得到1024个FFT点的计算结果，这实际上是一个混合了基2FFt和基4FFT的混合基FFT算法。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://blog.lthero.cn">lthero</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.lthero.cn/2023/10/20/what-is-a-convolution/">https://blog.lthero.cn/2023/10/20/what-is-a-convolution/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.lthero.cn" target="_blank">lthero</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/10/13/ssh-remote-connect/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/webPic/background/wallhaven-l3z192.jpg" onerror="onerror=null;src='https://cdn.lthero.cn/webPic/background/wallhaven-rdekew.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">ssh-remote-connect</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/webPic/logo/lthero_avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">lthero</div><div class="author-info__description">喜欢折腾|喜欢尝试各种炫酷玩意儿|      Hacking the world</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">136</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">66</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">54</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lthero-big"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/lthero-big" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:ltherowlh@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">感谢github托管|hexo--butterfly主题提供支持</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%B7%E7%A7%AF"><span class="toc-number">1.</span> <span class="toc-text">卷积</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%B7%E7%A7%AF%E6%B1%82%E8%A7%A3"><span class="toc-number">2.</span> <span class="toc-text">卷积求解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fftconvolution%EF%BC%88%E5%BF%AB%E9%80%9F%E5%8D%B7%E7%A7%AF%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">fftconvolution（快速卷积）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FFT%E7%AE%97%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">FFT算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2"><span class="toc-number">5.</span> <span class="toc-text">傅里叶变换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E6%83%B3%E9%93%BE%E6%9D%A1"><span class="toc-number">5.1.</span> <span class="toc-text">联想链条</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E9%9F%B3%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">5.2.</span> <span class="toc-text">声音的表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%A7%86%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-number">5.3.</span> <span class="toc-text">可视化方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%95%E5%9C%88%E8%AE%B0%E5%BD%95%E6%B3%95%EF%BC%9A%E5%90%8C%E4%B8%80%E4%BA%8B%E7%89%A9%E7%9A%84%E4%B8%8D%E5%90%8C%E8%A7%92%E5%BA%A6"><span class="toc-number">5.4.</span> <span class="toc-text">绕圈记录法：同一事物的不同角度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%A8%E5%BF%83%E8%AE%B0%E5%BD%95%E6%B3%95%EF%BC%9A%E6%96%B0%E7%BB%B4%E5%BA%A6%E7%9A%84%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96"><span class="toc-number">5.5.</span> <span class="toc-text">质心记录法：新维度的特征提取</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AC%E5%BC%8F%E8%A1%A8%E7%A4%BA"><span class="toc-number">6.</span> <span class="toc-text">公式表示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E6%97%8B%E8%BD%AC%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">6.1.</span> <span class="toc-text">第一步：旋转的表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E7%BC%A0%E7%BB%95%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">6.2.</span> <span class="toc-text">第二步：缠绕的表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E8%B4%A8%E5%BF%83%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">6.3.</span> <span class="toc-text">第三步：质心的表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E6%AD%A5%EF%BC%9A%E6%95%B4%E7%90%86%E7%A7%AF%E5%88%86%E9%99%90%E5%92%8C%E7%B3%BB%E6%95%B0"><span class="toc-number">6.4.</span> <span class="toc-text">最终步：整理积分限和系数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A6%BB%E6%95%A3%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2"><span class="toc-number">6.5.</span> <span class="toc-text">离散傅里叶变换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2"><span class="toc-number">6.6.</span> <span class="toc-text">快速傅里叶变换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA2-FFT"><span class="toc-number">6.6.1.</span> <span class="toc-text">基2 FFT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA4FFT"><span class="toc-number">6.6.2.</span> <span class="toc-text">基4FFT</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/10/20/what-is-a-convolution/" title="what_is_a_convolution"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/webPic/background/wallhaven-285e6x.png" onerror="this.onerror=null;this.src='https://cdn.lthero.cn/webPic/background/wallhaven-rdekew.jpg'" alt="what_is_a_convolution"/></a><div class="content"><a class="title" href="/2023/10/20/what-is-a-convolution/" title="what_is_a_convolution">what_is_a_convolution</a><time datetime="2023-10-20T05:43:45.000Z" title="发表于 2023-10-20 13:43:45">2023-10-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/13/ssh-remote-connect/" title="ssh-remote-connect"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/webPic/background/wallhaven-l3z192.jpg" onerror="this.onerror=null;this.src='https://cdn.lthero.cn/webPic/background/wallhaven-rdekew.jpg'" alt="ssh-remote-connect"/></a><div class="content"><a class="title" href="/2023/10/13/ssh-remote-connect/" title="ssh-remote-connect">ssh-remote-connect</a><time datetime="2023-10-13T10:11:02.000Z" title="发表于 2023-10-13 18:11:02">2023-10-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/04/HowToUseChatGPT/" title="如何更优雅地使用ChatGPT"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/webPic/background/wallhaven-z8qldy.jpg" onerror="this.onerror=null;this.src='https://cdn.lthero.cn/webPic/background/wallhaven-rdekew.jpg'" alt="如何更优雅地使用ChatGPT"/></a><div class="content"><a class="title" href="/2023/10/04/HowToUseChatGPT/" title="如何更优雅地使用ChatGPT">如何更优雅地使用ChatGPT</a><time datetime="2023-10-04T10:08:45.000Z" title="发表于 2023-10-04 18:08:45">2023-10-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/19/MSc-InformationSecurity-1/" title="【研究生课】信息安全技术笔记一"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/webPic/background/wallhaven-z8qldy.jpg" onerror="this.onerror=null;this.src='https://cdn.lthero.cn/webPic/background/wallhaven-rdekew.jpg'" alt="【研究生课】信息安全技术笔记一"/></a><div class="content"><a class="title" href="/2023/09/19/MSc-InformationSecurity-1/" title="【研究生课】信息安全技术笔记一">【研究生课】信息安全技术笔记一</a><time datetime="2023-09-19T07:22:51.000Z" title="发表于 2023-09-19 15:22:51">2023-09-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/15/openwrt-unlockSchoolNetwork/" title="【openwrt】克隆Mac突破校园网"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/webPic/background/wallhaven-wy2ewp.png" onerror="this.onerror=null;this.src='https://cdn.lthero.cn/webPic/background/wallhaven-rdekew.jpg'" alt="【openwrt】克隆Mac突破校园网"/></a><div class="content"><a class="title" href="/2023/09/15/openwrt-unlockSchoolNetwork/" title="【openwrt】克隆Mac突破校园网">【openwrt】克隆Mac突破校园网</a><time datetime="2023-09-15T15:31:30.000Z" title="发表于 2023-09-15 23:31:30">2023-09-15</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By lthero</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="framework-info"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">浙ICP备2021022809号-1</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://ltherocn2.oss-cn-beijing.aliyuncs.com/cdn/js/fancybox.umd.js"></script><script src="https://ltherocn2.oss-cn-beijing.aliyuncs.com/cdn/js/instantpage.min.js" type="module"></script><script src="https://ltherocn2.oss-cn-beijing.aliyuncs.com/cdn/js/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadWaline () {
  function insertCSS () {
    const link = document.createElement("link")
    link.rel = "stylesheet"
    link.href = "https://ltherocn2.oss-cn-beijing.aliyuncs.com/cdn/css/waline.css"
    document.head.appendChild(link)
  }

  function initWaline () {
    const waline = Waline.init(Object.assign({
      el: '#waline-wrap',
      serverURL: 'vercel-psi-seven.vercel.app',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: false,
    }, null))
  }

  if (typeof Waline === 'function') initWaline()
  else {
    insertCSS()
    getScript('https://ltherocn2.oss-cn-beijing.aliyuncs.com/cdn/js/waline.js').then(initWaline)
  }
}

if ('Waline' === 'Waline' || !true) {
  if (true) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script></div><script src="https://ltherocn2.oss-cn-beijing.aliyuncs.com/cdn/js/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>