<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>AlgorithmPractice | lthero</title><meta name="keywords" content="技术&amp;生活"><meta name="author" content="lthero"><meta name="copyright" content="lthero"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="杭电OJ100道 2024 c语言合法标识符  There are two ways to accept all chars including space  use char array, but you need to set the MaxLength for limit the length of buffer use string, it’s more convenient.  and">
<meta property="og:type" content="article">
<meta property="og:title" content="AlgorithmPractice">
<meta property="og:url" content="https://blog.lthero.cn/2023/03/29/AlgorithmPractice/index.html">
<meta property="og:site_name" content="lthero">
<meta property="og:description" content="杭电OJ100道 2024 c语言合法标识符  There are two ways to accept all chars including space  use char array, but you need to set the MaxLength for limit the length of buffer use string, it’s more convenient.  and">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.lthero.cn/webPic/background/rd3pjw.jpg">
<meta property="article:published_time" content="2023-03-29T11:27:59.000Z">
<meta property="article:modified_time" content="2023-03-30T12:26:37.909Z">
<meta property="article:author" content="lthero">
<meta property="article:tag" content="技术&amp;生活">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.lthero.cn/webPic/background/rd3pjw.jpg"><link rel="shortcut icon" href="https://cdn.lthero.cn/webPic/logo/lthero_logo.png"><link rel="canonical" href="https://blog.lthero.cn/2023/03/29/AlgorithmPractice/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="iNo3p5pDMQW3QRCjgVQ_A-4vbPCQipgCC1evSSmk8p8"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":90,"position":"top","messagePrev":"这篇文章距离他上一次更新已经过去了……我算算啊……好像是","messageNext":"天吧，不知道是否还有效啊!"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'AlgorithmPractice',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-30 20:26:37'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/mycss/lthero-css.css"><!-- Google tag (gtag.js) --><script async src="https://www.googletagmanager.com/gtag/js?id=G-3YWJFC5QWY"></script><script>  window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}   gtag('js', new Date()); gtag('config', 'G-3YWJFC5QWY'); </script><!-- hexo injector head_end start --><script> let HEXO_MMEDIA_DATA = { js: [], css: [], aplayerData: [], metingData: [], artPlayerData: [], dplayerData: []}; </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="lthero" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/webPic/logo/lthero_avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">214</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">117</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">69</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/arxiv/"><i class="fa-fw fas fa-newspaper"></i><span> arxiv</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.lthero.cn/webPic/background/rd3pjw.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">lthero</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/arxiv/"><i class="fa-fw fas fa-newspaper"></i><span> arxiv</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">AlgorithmPractice</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-29T11:27:59.000Z" title="发表于 2023-03-29 19:27:59">2023-03-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-30T12:26:37.909Z" title="更新于 2023-03-30 20:26:37">2023-03-30</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">19.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>118分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="AlgorithmPractice"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="杭电oj100道">杭电OJ100道</h1>
<h2 id="2024-c语言合法标识符">2024 c语言合法标识符</h2>
<blockquote>
<p>There are two ways to accept all chars including space</p>
<ol>
<li>use char array, but you need to set the MaxLength for limit the length of buffer</li>
<li>use string, it’s more convenient.</li>
</ol>
<p>and there are two diff ways to get the length of str</p>
<ol>
<li>using &lt; cstring &gt; like: remember to <code>#include &lt;cstring&gt;</code> then use <code>strlen(str)</code> to get the length you wanted.</li>
<li>if you use string, then you can just use the function <code>length()</code> like: <code>str.length()</code>, it will return the length  of the string.</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//use char array</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_LENGTH = <span class="number">100</span>;</span><br><span class="line"><span class="type">char</span> str[MAX_LENGTH];</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Enter a string: &quot;</span>;</span><br><span class="line">cin.<span class="built_in">getline</span>(str, MAX_LENGTH);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;You entered: &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//or use string</span></span><br><span class="line">string s;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Enter a string: &quot;</span>;</span><br><span class="line"><span class="built_in">getline</span>(cin,s);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;You entered: &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Use cctype to judge whether a char is num or alpha</p>
<p>there are three useful fun:</p>
<ol>
<li>isalpha() //check if the char is alpha , both upper and lower</li>
<li>isdigit()</li>
<li>isalnum() //check if the char is alpha , both upper and lower or num</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValidIdentifier</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="comment">//check if the first char is alpha or _</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">isalpha</span>(s[<span class="number">0</span>])&amp;&amp;s[<span class="number">0</span>]!=<span class="string">&#x27;_&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> len=s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="comment">//check the rest of the chars is a alpha , num or _</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">isalnum</span>(s[i]) &amp;&amp; s[i]!=<span class="string">&#x27;_&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Or, you can use you own way to judge it.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> f=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> len=buffer.<span class="built_in">length</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">     <span class="comment">//check if the first letter is a char or _</span></span><br><span class="line">     <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp; (buffer[i]&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;buffer[i]&lt;=<span class="string">&#x27;z&#x27;</span>||buffer[i]&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;buffer[i]&lt;=<span class="string">&#x27;Z&#x27;</span>||buffer[i]==<span class="string">&#x27;_&#x27;</span>))&#123;</span><br><span class="line">         f=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(buffer[i]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;buffer[i]&lt;=<span class="string">&#x27;9&#x27;</span>||buffer[i]&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;buffer[i]&lt;=<span class="string">&#x27;z&#x27;</span>||buffer[i]&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;buffer[i]&lt;=<span class="string">&#x27;Z&#x27;</span>||buffer[i]==<span class="string">&#x27;_&#x27;</span>)&#123;</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span>&#123;</span><br><span class="line">         f=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValidIdentifier</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="comment">//check if the first char is alpha or _</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">isalpha</span>(s[<span class="number">0</span>])&amp;&amp;s[<span class="number">0</span>]!=<span class="string">&#x27;_&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> len=s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="comment">//check the rest of the chars is a alpha , num or _</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">isalnum</span>(s[i]) &amp;&amp; s[i]!=<span class="string">&#x27;_&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    string buffer;</span><br><span class="line">    <span class="comment">//ignore the space</span></span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n,cin.<span class="built_in">ignore</span>())&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="built_in">getline</span>(cin, buffer);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isValidIdentifier</span>(buffer))&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;no&quot;</span>&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2026-将每个单词首字符变成大写">2026 将每个单词首字符变成大写</h2>
<blockquote>
<p><strong>Use sstream</strong></p>
<p>there are some examples to use sstream</p>
</blockquote>
<h3 id="converting-a-string-to-other-types-of-data">Converting a string to other types of data</h3>
<blockquote>
<ol>
<li>We define a string variable <code>str</code> to receive data from input.</li>
<li>Then we create a stringstream object <code>ss</code>, and pass the str into the object.</li>
<li>Finally, we use the <code>&gt;&gt;</code> operator of the <code>ss</code> object to convert the data in the string to the specified data type and store it in the corresponding variable.</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;123 4.56 true&quot;</span>;</span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(str)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">double</span> dbl;</span><br><span class="line">    <span class="type">bool</span> flag;</span><br><span class="line">    </span><br><span class="line">    ss &gt;&gt; num &gt;&gt; dbl &gt;&gt; flag;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; num &lt;&lt; endl; <span class="comment">// 输出: 123</span></span><br><span class="line">    cout &lt;&lt; dbl &lt;&lt; endl; <span class="comment">// 输出: 4.56</span></span><br><span class="line">    cout &lt;&lt; flag &lt;&lt; endl; <span class="comment">// 输出: 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="converting-other-types-of-data-to-a-string">Converting other types of data to a string</h3>
<blockquote>
<ol>
<li>we first define three variables <code>num</code>, <code>dbl</code>, and <code>flag</code>, which are assigned integer, double-precision floating-point, and boolean data, respectively.</li>
<li>We then create a stringstream object <code>ss</code> and use the <code>&lt;&lt;</code> operator of the <code>ss</code> object to convert these data to a string and store it in the <code>ss</code> object.</li>
<li>Finally, we use the <code>str()</code> function of the <code>ss</code> object to convert the data in <code>ss</code> to a string and store it in the variable <code>str</code>, which is then outputted.</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">123</span>;</span><br><span class="line">    <span class="type">double</span> dbl = <span class="number">4.56</span>;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    stringstream ss;</span><br><span class="line">    ss &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; dbl &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; flag;</span><br><span class="line">    string str = ss.<span class="built_in">str</span>();</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl; <span class="comment">// 输出: 123 4.56 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Here is the problems’ resolution</p>
<ol>
<li>We define a string variable <code>str</code> to receive data from input, then create a stringstream object <code>ss</code> and pass <code>str</code> into it.</li>
<li>We split <code>ss</code> into words by space</li>
<li>Convert the first letter into upper and prinf out the result.</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="built_in">getline</span>(cin,str);</span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(str)</span></span>;</span><br><span class="line">    string word;</span><br><span class="line">    <span class="keyword">while</span> (ss &gt;&gt; word) &#123;</span><br><span class="line">        word[<span class="number">0</span>]=<span class="built_in">toupper</span>(word[<span class="number">0</span>]);</span><br><span class="line">        cout &lt;&lt; word &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>However , if we forget to use toupper, then we can converse the letter into upper one by one, like this.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (str[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">            str[i] = str[i] - <span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Here is another resolution that we find a letter which is next to a space, then convert it into upper</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">isalpha</span>(t[i]) &amp;&amp; t[i<span class="number">-1</span>] == <span class="string">&#x27; &#x27;</span>) ? <span class="built_in">toupper</span>(t[i]) : t[i]);</span><br></pre></td></tr></table></figure>
<h3 id="toupper">toupper</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">toupper</span>(str[<span class="number">1</span>])&lt;&lt;endl; <span class="comment">// get 65</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">char</span>(<span class="built_in">toupper</span>(str[<span class="number">0</span>])) &lt;&lt; endl; <span class="comment">// 输出: A</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="tolower">tolower</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tolower returns a int variable, the &quot;ch&quot; will convert it into a char variable</span></span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    ch = <span class="built_in">tolower</span>(ch);</span><br><span class="line">    cout &lt;&lt; ch &lt;&lt; endl; <span class="comment">// 输出: a</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    string str = <span class="string">&quot;AAA&quot;</span>;</span><br><span class="line">    <span class="comment">//if we cout tolower(str[0]) directly , we will get 97</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">char</span>(<span class="built_in">tolower</span>(str[<span class="number">0</span>])) &lt;&lt; endl; <span class="comment">// 输出: a</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="isupper">isupper</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="built_in">isupper</span>(ch);</span><br><span class="line">    cout &lt;&lt; flag &lt;&lt; endl; <span class="comment">// 输出: 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="isalpha">isalpha</h3>
<blockquote>
<p>To judge if a character is a alpha</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> flag = <span class="built_in">isalpha</span>(ch);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; flag &lt;&lt; endl; <span class="comment">// 输出: 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="isdigit">isdigit</h3>
<blockquote>
<p>To judge if a character is a digit</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> flag = <span class="built_in">isdigit</span>(ch);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; flag &lt;&lt; endl; <span class="comment">// 输出: 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="isalnum">isalnum</h3>
<blockquote>
<p>To judge whether a character is a <strong>letter</strong> or a <strong>digit</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> flag = <span class="built_in">isalnum</span>(ch);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; flag &lt;&lt; endl; <span class="comment">// 输出: 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="isspace">isspace</h3>
<blockquote>
<p>To judge if a character is space</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> flag = <span class="built_in">isspace</span>(ch);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; flag &lt;&lt; endl; <span class="comment">// 输出: 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2027-统计元音">2027 统计元音</h2>
<p>count vowels</p>
<blockquote>
<p>As usual,</p>
<ol>
<li>first we define a char array named <code>vowels</code> as {a,e,i,o,u}, and create a int array named <code>arr</code> to record results.</li>
<li>we define a string valiable <code>sentence</code> to receive data from input</li>
<li>use <code>switch</code> to judge every character in the sentence, remember to use <code>tolower</code> to get a lower char</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> vowels[<span class="number">5</span>]=&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;u&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Count the number of every vowels in a sentence</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param sentence </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">countVowels</span><span class="params">(string sentence)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len=sentence.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="comment">//remember to get a lower letter</span></span><br><span class="line">        <span class="keyword">switch</span> (<span class="built_in">tolower</span>(sentence[i]))</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">            arr[<span class="number">0</span>]++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">            arr[<span class="number">1</span>]++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">            arr[<span class="number">2</span>]++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">            arr[<span class="number">3</span>]++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>:</span><br><span class="line">            arr[<span class="number">4</span>]++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        cout&lt;&lt;vowels[i]&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;arr[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string sentence;</span><br><span class="line">    <span class="comment">//remember to ignore the first space after you input the number</span></span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n,cin.<span class="built_in">ignore</span>())&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">getline</span>(cin,sentence);</span><br><span class="line">            <span class="built_in">countVowels</span>(sentence);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2028-最小公倍数">2028 *最小公倍数</h2>
<p>Lowest Common Multiple</p>
<blockquote>
<p>Before we solve this problem, we need to learn some new things</p>
<ol>
<li>Greatest Common Divisor(最大公约数) 【GCD】</li>
<li>Lowest Common Multiple(最小公倍数) 【LCM】</li>
</ol>
<p>You can use the GCD (Greatest Common Divisor) to find the LCM (Lowest Common Multiple) of two numbers using the following formula:</p>
<ol>
<li>LCM(a, b) = (a * b) / GCD(a, b)</li>
</ol>
</blockquote>
<p>So, we need to find GCD before we find LCM, here is an example to get gcd.</p>
<blockquote>
<p>Find the GCD of 12 and 18:</p>
<ol>
<li>Divide the larger number by the smaller number and find the remainder. <code>18 / 12 = 1 remainder 6</code></li>
<li>Divide the smaller number by the remainder and find the new remainder. <code>12 / 6 = 2 remainder 0</code></li>
<li>The GCD is the <code>remainder</code> of the last division, which is <code>6</code>.</li>
</ol>
</blockquote>
<p>Here are codes to get GCD, and there are two approaches.</p>
<ol>
<li>recursion</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>iteration</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> remainder=a%b;</span><br><span class="line">	<span class="keyword">while</span>(remainder)&#123;</span><br><span class="line">		a=b;</span><br><span class="line">		b=remainder;</span><br><span class="line">		remainder=a%b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> remainder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Here is the complete code</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Get the GCD object</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param a </span></span><br><span class="line"><span class="comment"> * @param b </span></span><br><span class="line"><span class="comment"> * @return int </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GCD</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="type">int</span> remainder=a%b;</span><br><span class="line">    <span class="keyword">while</span>(remainder)&#123;</span><br><span class="line">        a=b;</span><br><span class="line">        b=remainder;</span><br><span class="line">        remainder=a%b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Get the LCM object</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param a </span></span><br><span class="line"><span class="comment"> * @param b </span></span><br><span class="line"><span class="comment"> * @return int </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCM</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a*b/<span class="built_in">GCD</span>(a,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Get the LCM of a series of numbers</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return int </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n, n!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> *arr=<span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">        <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;arr[i];</span><br><span class="line">            res=<span class="built_in">LCM</span>(res,arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2029-回文串判断">2029 回文串判断</h2>
<p>Judge whether a string is a palidrome</p>
<blockquote>
<p>Here’s a trick , if the string is a palidrom, then the loop won’t break , then <code>i</code> will equals to <code>len/2</code> as <code>i==len/2</code></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Judge whether a string is a palindrome</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param str </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">JudgePalindromes</span><span class="params">(string str)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len=str.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> f=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i]!=str[len-i<span class="number">-1</span>])&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Trick: if the loop is not broken, then i==len/2</span></span><br><span class="line">    cout&lt;&lt;((i==len/<span class="number">2</span>)?<span class="string">&quot;yes&quot;</span>:<span class="string">&quot;no&quot;</span>)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n,cin.<span class="built_in">ignore</span>(<span class="number">1</span>,<span class="string">&#x27;\n&#x27;</span>))&#123;</span><br><span class="line">        string str;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="built_in">getline</span>(cin,str);</span><br><span class="line">            <span class="built_in">JudgePalindromes</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2031-r进制转换">2031 *R进制转换</h2>
<p>input a decimal number and convert it into an R-ary number</p>
<blockquote>
<p>To convert a decimal number into an R-ary number, you need to follow these steps:</p>
<ol>
<li>Divide the decimal number by the <code>radix (R)</code> and note down the <code>remainder</code>.</li>
<li>Divide the <code>quotient</code> obtained in step 1 by R and note down the <code>remainder</code>.</li>
<li>Repeat step 2 until the <code>quotient</code> becomes zero.</li>
<li>The <code>remainders</code> obtained in step 1, 2, and 3, when read in <code>reverse</code> order, form the R-ary representation of the decimal number.</li>
</ol>
</blockquote>
<p>Let’s take an example to understand this process. Suppose we want to convert the decimal number 37 into a binary number (R = 2).</p>
<blockquote>
<ol>
<li>Divide 37 by 2. The quotient is 18 and the remainder is <code>1</code>. Note down the remainder.</li>
<li>Divide 18 by 2. The quotient is 9 and the remainder is <code>0</code>. Note down the remainder.</li>
<li>Divide 9 by 2. The quotient is 4 and the remainder is <code>1</code>. Note down the remainder.</li>
<li>Divide 4 by 2. The quotient is 2 and the remainder is <code>0</code>. Note down the remainder.</li>
<li>Divide 2 by 2. The quotient is 1 and the remainder is <code>0</code>. Note down the remainder.</li>
<li>Divide 1 by 2. The quotient is 0 and the remainder is <code>1</code>. Note down the remainder.</li>
</ol>
</blockquote>
<p>Reading the remainders in reverse order, we get 100101, which is the binary representation of the decimal number 37.</p>
<p>convert the decimal number 37 into a hexadecimal (R=16) number.</p>
<blockquote>
<p>To convert 37 into a hexadecimal number, we can follow the same process as explained earlier, but this time we will divide the decimal number by 16 instead of 2.</p>
<p>Here are the steps:</p>
<ol>
<li>Divide 37 by 16. The quotient is 2 and the remainder is <code>5</code>. Note down the remainder.</li>
<li>Divide 2 by 16. The quotient is 0 and the remainder is <code>2</code>. Note down the remainder.</li>
</ol>
</blockquote>
<p>Reading the remainders in reverse order, we get 25, which is the hexadecimal representation of the decimal number 37.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Convert</span><span class="params">(<span class="type">int</span> num,<span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">    stringstream ss;</span><br><span class="line">    <span class="type">int</span> quotient=num/R;</span><br><span class="line">    <span class="comment">//if num%R &gt; 9 which means it&#x27;s an alpha not a digit</span></span><br><span class="line">    <span class="comment">//remember to convert a num into an char variable</span></span><br><span class="line">    ss&lt;&lt;<span class="built_in">char</span>((num%R&gt;<span class="number">9</span>)?(num%R<span class="number">-10</span>+<span class="string">&#x27;A&#x27;</span>):(num%R+<span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">    <span class="keyword">while</span>(quotient)&#123;</span><br><span class="line">        num=quotient;</span><br><span class="line">        quotient=num/R;</span><br><span class="line">        ss&lt;&lt;<span class="built_in">char</span>((num%R&gt;<span class="number">9</span>)?(num%R<span class="number">-10</span>+<span class="string">&#x27;A&#x27;</span>):(num%R+<span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//reverse the remainders to get the right answer.</span></span><br><span class="line">    string str=ss.<span class="built_in">str</span>();</span><br><span class="line">    <span class="built_in">reverse</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>());</span><br><span class="line">    cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,R;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;R)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;-&quot;</span>;</span><br><span class="line">            n=-n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Convert</span>(n,R);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2032-杨辉三角">2032 杨辉三角</h2>
<p>YangHuiTriangle</p>
<blockquote>
<p>The rules as following</p>
<p>f(i, i) = f(i, 1) = 1		(i &gt; 0)</p>
<p>f(i, j) = f(i-1, j) + f(i-1, j-1)	(j &lt; i)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Output the YangHui Triangle</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param n </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">outputTriangle</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> *arr=<span class="keyword">new</span> <span class="type">int</span>[n*(n+<span class="number">1</span>)/<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n*(n+<span class="number">1</span>)/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        arr[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="comment">//arr(i, j) = arr(i-1, j) + arr(i-1, j-1), but we can compress the space to one dimension array</span></span><br><span class="line">            <span class="comment">//get each row&#x27;s elements by adding the previous row&#x27;s elements</span></span><br><span class="line">            arr[j]+=arr[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//output the elements of each row</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            cout&lt;&lt;arr[j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        <span class="built_in">outputTriangle</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2034-集合问题a-b">2034 集合问题A-B</h2>
<p>Find the elemetns in A but not in B, both A and B is a ascent set.</p>
<blockquote>
<p>We can use “two pointers” to solve this problem, here is the details</p>
<ol>
<li>We define an int array to receive numbers from input</li>
<li>Define curA initialized as 0 as the begining of set A and curB initialized as 0 as the begining of set B, they are two pointers start from different index</li>
<li>if <code>arr[curA]==arr[curB]</code>, it means both set A and set B has this number</li>
<li>if <code>arr[curA]&gt;arr[curB]</code>, not sure whether B has the same number, so just skip arr[curB]</li>
<li>if <code>arr[curA]&lt;arr[curB]</code>,it means the arr[curA] is only in set A but not in set B</li>
<li>if setA has some numbers left, we just output them directly</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Find the elemetns in A but not in</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param arr </span></span><br><span class="line"><span class="comment"> * @param n </span></span><br><span class="line"><span class="comment"> * @param m </span></span><br><span class="line"><span class="comment"> * @return int </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> *arr,<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> curA=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> curB=n;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;curA&lt;n&amp;&amp;curB&lt;m+n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[curA]==arr[curB])&#123;</span><br><span class="line">            curA++;</span><br><span class="line">            curB++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[curA]&gt;arr[curB])&#123;</span><br><span class="line">            curB++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;arr[curA]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            f=<span class="number">1</span>;</span><br><span class="line">            curA++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//if setA has some numbers left, we just output them</span></span><br><span class="line">    <span class="keyword">while</span>(curA&lt;n)&#123;</span><br><span class="line">        cout&lt;&lt;arr[curA]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        f=<span class="number">1</span>;</span><br><span class="line">        curA++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f==<span class="number">0</span>)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;NULL&quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m,n!=<span class="number">0</span>&amp;&amp;m!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> *arr=<span class="keyword">new</span> <span class="type">int</span>[n+m];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m+n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">foo</span>(arr,n,m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="two-pointers">two pointers</h3>
<h4 id="porblema">PorblemA</h4>
<p>Given a set named arr of positive decimal numbers that is sorted in ascending order and a positive integer M, the task is to find every pair of numbers in the set whose sum equals M</p>
<blockquote>
<p>Here is the solution</p>
<ol>
<li>Define two pointers <code>i</code> and <code>j</code>, where <code>i</code> initialized as <code>0</code> and <code>j</code> initialized as <code>len-1</code>, len is the length of the set.</li>
<li>i will shift to len-1, and j will shift to 0 until <code>i&gt;=j</code></li>
<li>if <code>arr [i]+arr [j]==M</code>, it means that we find one of the answer ,then just <code>output</code> it.</li>
<li>if <code>arr [i]+arr [j]&gt;M</code>, it means that we need to <strong>decrease</strong> the sum of left part, the real answer will show in [i,j-1],</li>
<li>if <code>arr [i]+arr [j]&lt;M</code>, it means that we need to <strong>increase</strong> the sum of left part, the real answer will show in [i+1,j]</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//remember that the array is sorted in ascending order.</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Find every pair of number in the set whose sum equals to M</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param arr </span></span><br><span class="line"><span class="comment"> * @param n </span></span><br><span class="line"><span class="comment"> * @param M </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> *arr,<span class="type">int</span> n,<span class="type">int</span> M)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j=n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]+arr[j]==M)&#123;</span><br><span class="line">            cout&lt;&lt;arr [i]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;arr [j]&lt;&lt;endl;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[i]+arr[j]&gt;M)&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        <span class="type">int</span> *arr=<span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> M;</span><br><span class="line">        cin&gt;&gt;M;</span><br><span class="line">        <span class="built_in">foo</span>(arr,n,M);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="merge">Merge</h3>
<p>Given two sets which are sorted by ascdenting order, the task it to merge them into a new set which needs to be in ascdenting order and print out the result.</p>
<blockquote>
<p>We can also use the two pointer to solve this problem.</p>
<ol>
<li>We create two arraies named arrA adn arrB to receive numbers from input, lenA and lenB are the length of array ,respectively.</li>
<li>Define two pointer i and j ,both of them are initialized as 0</li>
<li>While <code>i&lt;lenA</code> and <code>j&lt;lenB</code>, we need to judge these cases</li>
<li>if <code>arrA[i]&lt;arr[B]</code>,it means we need to push arrA[i] into the new array, and <code>i++</code></li>
<li>if <code>arrA[i]&gt;=arr[B]</code>,it means we need to push arrB[j] into the new array, and <code>j++</code></li>
<li>then remember to push the left number into the new array if arrA or arrB has some numbers left</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Merge two sorted array into one sorted array</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param arrA </span></span><br><span class="line"><span class="comment"> * @param arrB </span></span><br><span class="line"><span class="comment"> * @param lenA </span></span><br><span class="line"><span class="comment"> * @param lenB </span></span><br><span class="line"><span class="comment"> * @return int* </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">merge</span><span class="params">(<span class="type">int</span> *arrA,<span class="type">int</span> *arrB,<span class="type">int</span> lenA,<span class="type">int</span> lenB)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,cur=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> *arrC=<span class="keyword">new</span> <span class="type">int</span>[lenA+lenB];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;lenA&amp;&amp;j&lt;lenB)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arrA[i]&lt;arrB[j])&#123;</span><br><span class="line">            arrC[cur++]=arrA[i++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            arrC[cur++]=arrB[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;lenA)&#123;</span><br><span class="line">        arrC[cur++]=arrA[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;lenB)&#123;</span><br><span class="line">        arrC[cur++]=arrB[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrC;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m,n!=<span class="number">0</span>&amp;&amp;m!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> *arrA=<span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">        <span class="type">int</span> *arrB=<span class="keyword">new</span> <span class="type">int</span>[m];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;arrA[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            cin&gt;&gt;arrB[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> *arrC=<span class="built_in">merge</span>(arrA,arrB,n,m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n+m;i++)&#123;</span><br><span class="line">            cout&lt;&lt;arrC[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2035-集合问题a-b">2035 集合问题A^B</h2>
<p>Find the integer represented by the <strong>last three digits</strong> of A^B.</p>
<p>Explanation: A^B means “A to the power of B”</p>
<p>Here is a more powful fomula</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">        1	    n = 0 </span><br><span class="line">m^n = 	(m^k)^2	n = 2k </span><br><span class="line">        m·m^(2k)n = 2k + 1 </span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">recursion</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    the pow() function does return a double type floating-point number.</span></span><br><span class="line"><span class="comment">    However, it is possible to cast or convert it to a long long type integer, which can then be assigned to the result variable. </span></span><br><span class="line"><span class="comment">    Before doing the conversion, it&#x27;s important to round the pow() function&#x27;s result to the nearest integer to ensure accuracy and correctness.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> half=<span class="built_in">pow</span>(n,m/<span class="number">2</span>);</span><br><span class="line">    half = ((half % <span class="number">1000</span>) + <span class="number">1000</span>) % <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">if</span>(m%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> (half*half)%<span class="number">1000</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">return</span> (half*half*n)%<span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">iteration</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> mp=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        mp=(mp*n)%<span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;mp&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m,n!=<span class="number">0</span>&amp;&amp;m!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">iteration</span>(n,m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2036-计算多边形面积">2036 计算多边形面积</h2>
<p>Calculate the area of polygon</p>
<blockquote>
<p>The formula as following</p>
<p>S = 0.5 * ( (x0<em>y1-x1</em>y0) + (x1<em>y2-x2</em>y1) + …+ (xn-1<em>yn-xn</em>yn-1) + (xn<em>y0-x0</em>yn) )</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Calculate the area of polygon</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param n </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AreaOfPolygon</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="type">int</span> x0,y0;</span><br><span class="line">    <span class="type">int</span> x1,y1;</span><br><span class="line">    cin&gt;&gt;x0&gt;&gt;y0;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    x=x0;</span><br><span class="line">    y=y0;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;x1&gt;&gt;y1;</span><br><span class="line">        sum+=x*y1-x1*y;</span><br><span class="line">        x=x1;</span><br><span class="line">        y=y1;</span><br><span class="line">    &#125;</span><br><span class="line">    sum+=x*y0-x0*y;</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">1</span>)&lt;&lt;<span class="built_in">abs</span>(sum)*<span class="number">1.0</span>/<span class="number">2</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n,n!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">AreaOfPolygon</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2037-贪心算法-独立区间">2037 *贪心算法|独立区间</h2>
<p>indenpendent intervals</p>
<blockquote>
<p>If you have 24 hours to watch different TV shows , and ther are many shows which can be seen as a interval, it is best to start with the latest one to ensure that it is the last show you watch.If there are two shows that start at the same time, you should definitely pick the shorter one in order to watch as many shows as possible.</p>
<p>So, here’s the rule to reorder these shows.</p>
<ol>
<li>Sort the intervals(shows) in descending order by their start time.【To ensure that it is the last show you watch】</li>
<li>If two intervals have the same start time, sort them in ascending order by their end time.【To pick the shorter one】</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line">    <span class="type">int</span> mark;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief First sort by left endpoint from largest to smallest, if the left endpoints are the same, sort by right endpoints from smallest to largest</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param a </span></span><br><span class="line"><span class="comment"> * @param b </span></span><br><span class="line"><span class="comment"> * @return true </span></span><br><span class="line"><span class="comment"> * @return false </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.start!=b.start)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.start&gt;b.start;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.end&lt;b.end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Find out every independent interval</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param tv </span></span><br><span class="line"><span class="comment"> * @param n </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(node *tv,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(tv,tv+n,cmp);</span><br><span class="line">    <span class="comment">//count : the numbers of independent intervals we have choose, the first interval is independent</span></span><br><span class="line">    <span class="type">int</span> count=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> lastLeft=tv[<span class="number">0</span>].start;</span><br><span class="line">    tv[<span class="number">0</span>].mark=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//i starts from 1 because we have already choose the first interval</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="comment">//if the next interval&#x27;s right endpoint is smaller than or equals to the LastLeft, it means that this interval is independent.</span></span><br><span class="line">        <span class="keyword">if</span>(lastLeft&gt;=tv[i].end)&#123;</span><br><span class="line">            count+=<span class="number">1</span>;</span><br><span class="line">            lastLeft=tv[i].start;</span><br><span class="line">            tv[i].mark=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tv[i].mark==<span class="number">1</span>)&#123;</span><br><span class="line">            cout&lt;&lt;tv[i].start&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;tv[i].end&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n,n!=<span class="number">0</span>)&#123;</span><br><span class="line">        node *tv=<span class="keyword">new</span> node[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;tv[i].start&gt;&gt;tv[i].end;</span><br><span class="line">            tv[i].mark=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">foo</span>(tv,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2040-亲和数">2040 亲和数</h2>
<p>Two numbers are affine if either of them is the sum of the proper divisors of the other.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Judge whether a number is affinity number</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param x </span></span><br><span class="line"><span class="comment"> * @param y </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=x/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x%i==<span class="number">0</span>)&#123;</span><br><span class="line">            sum1+=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum1==y)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n,n!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="type">int</span> x,y;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            <span class="built_in">foo</span>(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2041-斐波那契">2041 *斐波那契</h2>
<p>There is a staircase with M levels. At the beginning, you are on the first level. If you can only step up one or two levels at a time, how many ways are there to get to the Mth level?</p>
<blockquote>
<p>To reach second level,you can take one stop from first level.</p>
<p>To reach third level, you can take two steps directly from first level or you can take one step from second level.</p>
<p>To reach nth level , you can take one step from n-1th level or you can take two steps from n-2th level.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Fibonacci sequence by recursion</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param n </span></span><br><span class="line"><span class="comment"> * @return int </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fbRecursion</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>|n==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">fbRecursion</span>(n<span class="number">-1</span>)+<span class="built_in">fbRecursion</span>(n<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Fibonacci sequence by iteration</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param x </span></span><br><span class="line"><span class="comment"> * @return int </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fbIteration</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> *dp=<span class="keyword">new</span> <span class="type">int</span>[x+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;x;i++)&#123;</span><br><span class="line">        dp[i]=dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[x<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n,n!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            cout&lt;&lt;<span class="built_in">fbIteration</span>(x)&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2043-判断是否为强密码">2043 判断是否为强密码</h2>
<blockquote>
<p>Rules.</p>
<ol>
<li>The length of password should be longer than or equals to 8 but not more than 16.</li>
<li>The characters should come from at least three of the following “character categories”</li>
</ol>
<p>category</p>
<ol>
<li>Uppercase letters A.B.C~z</li>
<li>Lowercase letters a.b.c~z</li>
<li>Numbers 0.1.2~9</li>
<li>Special characters. ~,!,@,#,$,%,^;</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief judge if the string is a legal password</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param s </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">judgeIsLegal</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len=s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">if</span>(len&gt;<span class="number">16</span>||len&lt;<span class="number">8</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> countUp=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> countLow=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> countDig=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> countSpec=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isupper</span>(s[i]))&#123;</span><br><span class="line">            countUp=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">islower</span>(s[i]))&#123;</span><br><span class="line">            countLow=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isdigit</span>(s[i]))&#123;</span><br><span class="line">            countDig=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            countSpec=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(countDig+countLow+countSpec+countUp&gt;=<span class="number">3</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n,n!=<span class="number">0</span>,cin.<span class="built_in">ignore</span>())&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x&lt;n;x++)&#123;</span><br><span class="line">            <span class="built_in">getline</span>(cin,s);</span><br><span class="line">            <span class="built_in">judgeIsLegal</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2044-斐波那契2">2044 斐波那契2</h2>
<p>There is a trained bee that can only crawl to the adjacent hive on the right, and cannot crawl in the opposite direction. Please program to calculate the number of possible routes for bees to climb from hive a to hive b.<br>
Among them, the structure of the hive is as follows.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20210515225125628.png#pic_center" alt="Pic"></p>
<blockquote>
<p>To reach hive n, you can crawl from hive n-1 or hive n-2, it’s the same one like 2041.</p>
<p>For example, to reach hive 5 , you can crawl from hive 3 or hive 4</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Fibonacci sequence by recursion</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param x </span></span><br><span class="line"><span class="comment"> * @return long long </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">fbRecursion</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>|x==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">fbRecursion</span>(x<span class="number">-1</span>)+<span class="built_in">fbRecursion</span>(x<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Fibonacci sequence by recursion</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param x </span></span><br><span class="line"><span class="comment"> * @return long long </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">fbIteration</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> *dp=<span class="keyword">new</span> <span class="type">int</span>[x+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;x;i++)&#123;</span><br><span class="line">        dp[i]=dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[x<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n,n!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">fbIteration</span>(b-a)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2045-rpg问题-斐波那契3">2045 RPG问题|斐波那契3</h2>
<p>There are n squares arranged in a row, and each square can be painted with one of three colors: Red, Pink, or Green. Any two adjacent squares cannot have the same color, and the first and last squares cannot have the same color. Find the total number of ways to color all the squares under these constraints.</p>
<blockquote>
<ol>
<li>one square:3</li>
<li>two squares: C(3,1)*C(2,1)=6</li>
<li>three squares: C(3,1)*C(2,1)*C(1,1)=6</li>
<li>four squares:  there are two different situations
<ol>
<li>We set F(4) initiaized as 0, <code>F(4)=0</code></li>
<li>If the first square is same as the third square :negative_squared_cross_mark::black_large_square::negative_squared_cross_mark:,then there are <code>two color</code> for the forth square.
<ol>
<li>:negative_squared_cross_mark::black_large_square::negative_squared_cross_mark::black_large_square:or :negative_squared_cross_mark::black_large_square::negative_squared_cross_mark::white_large_square:</li>
<li>F(4)+=F(2)*2 【Because the third square must be same as the first one, it can’t chose other color】</li>
</ol>
</li>
<li>If the first square is different from the third square :negative_squared_cross_mark::black_large_square::white_large_square:, then <code>only one color</code> for the forth square cuz two adjacent squares cannot have the same color and the first and last squares cannot have the same color
<ol>
<li>:negative_squared_cross_mark::black_large_square::white_large_square::black_large_square:</li>
<li>F(4)+=F(3)*1</li>
</ol>
</li>
<li><code>F(4)=F(3)*1 + F(2)*2</code></li>
</ol>
</li>
<li>N squares:<code>F(n)=F(n-1)+F(n-2)*2</code>;</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief RPG problem</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param n </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RPGsolution</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> *dp=<span class="keyword">new</span> <span class="type">int</span>[n+<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">3</span>;</span><br><span class="line">    dp[<span class="number">1</span>]=<span class="number">6</span>;</span><br><span class="line">    dp[<span class="number">2</span>]=<span class="number">6</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;n;i++)&#123;</span><br><span class="line">        dp[i]=dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>]*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[n<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n,n!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">RPGsolution</span>(n);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2046-骨牌铺方格-斐波那契4">2046 骨牌铺方格|斐波那契4</h2>
<p>In a 2×n rectangular grid, where n is an integer, find the total number of ways to completely cover the grid using 1×2 dominoes.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20191001142317783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAzODA4OQ==,size_16,color_FFFFFF,t_70" alt=""></p>
<blockquote>
<p>To cover Nth dominos over the grid, we can add <code>one vertical dominoe</code> at the end of the arrangement of <code>(N-1)th</code> dominos.</p>
<p>Or we can also add <code>two horizonal dominos</code> at the end of the arrangement of <code>(N-2)th</code> , We can’t add a vertical one otherwise it will be the same as the first case.</p>
<p>So F(n)=F(n-1)+F(n-2)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Pave the square</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param n </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PaveSquare</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> *dp=<span class="keyword">new</span> <span class="type">int</span>[n+<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">    dp[<span class="number">3</span>]=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">4</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dp[i]=dp[i<span class="number">-2</span>]+dp[i<span class="number">-1</span>]*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[n]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n,n!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">PaveSquare</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2047-字符串eof的排列组合-斐波那契5">2047 字符串EOF的排列组合|斐波那契5</h2>
<p>The task is to generate a string of length n consisting of only three characters “E”, “O”, and “F” (which may have only <strong>one or two</strong> of these characters, but cannot have any other characters). It is <strong>forbidden</strong> to have <strong>adjacent</strong> “O” characters in the string.</p>
<blockquote>
<ol>
<li>We define a two-dimentional array dp
<ol>
<li><strong>dp[n][1]</strong> represents the string ending with <strong>“E” or &quot;F</strong>&quot;</li>
<li><strong>dp[n][0]</strong> represents the string ending with <strong>&quot;O&quot;</strong></li>
</ol>
</li>
<li>If the former legal string ending with “E” or “F” or “O”, then we can <code>add &quot;E&quot; or &quot;F&quot;</code>
<ol>
<li>dp[n][1]=2*(dp[n-1][1]+dp[n-1][0])</li>
</ol>
</li>
<li>If the former legal string ending with “E” or “F” but not “O”, then we can <code>add &quot;O&quot;</code>
<ol>
<li>dp[n][0]=dp[n][1]</li>
</ol>
</li>
</ol>
<p>We initialize the <code>dp[0][0]</code> as <strong>1</strong> which represents “O”</p>
<p>and initialize <code>dp[0][1]</code> as <strong>2</strong> which represents “E” or “F”</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param n </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> **dp=<span class="keyword">new</span> <span class="type">int</span> *[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        dp[i]=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//dp[i][0] represents the number of legal strings ending with &quot;O&quot;</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//dp[i][1] represents the number of legal strings ending with &quot;E&quot; or &quot;F&quot;</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="comment">//We can add &quot;O&quot; to the end of the old legal string, so the number of new strings is the same as the number of strings of length i-1.</span></span><br><span class="line">        dp[i][<span class="number">0</span>]=dp[i<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//We can add &quot;E&quot; or &quot;F&quot; to the end of the old legal string</span></span><br><span class="line">        dp[i][<span class="number">1</span>]=(dp[i<span class="number">-1</span>][<span class="number">0</span>]+dp[i<span class="number">-1</span>][<span class="number">1</span>])*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[n<span class="number">-1</span>][<span class="number">0</span>]+dp[n<span class="number">-1</span>][<span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n,n!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">foo</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2048-错排问题1">2048 *错排问题1</h2>
<p>All permutations of N tickets may naturally be Ann = N! permutations<br>
The problem now is that there are several ways to arrange N tickets wrongly.</p>
<blockquote>
<ol>
<li>let’s consider that if none of the previous N-1 people took their own tickets, that is, the previous N-1 people met the wrong order, and now another person comes, and he has his own ticket in his hand.<br>
As long as he <strong>exchanges</strong> his ticket with <strong>any one of the other N-1 people</strong>, he can satisfy the wrong arrangement of N people. At this time, there are <code>N-1</code> ways.
<ol>
<li>F(n)+=(n-1)*F(n-1)</li>
</ol>
</li>
<li>In addition, we can consider the case where the first N-1 people do not satisfy the derangement, but the Nth person exchanges their ticket with one of the previous people and exactly satisfies the derangement.This situation occurs when among the original N-1 people, N-2 people satisfy the derangement and only one person holds their own ticket, and the Nth person happens to exchange with that person, which satisfies the derangement. Because in the first N-1 people, each person has a chance to hold their own ticket. Therefore, <strong>there are N-1 possibilities</strong> for the exchange.Because among the top N-1 people, everyone has a chance to hold their own ticket. So there are <code>N-1</code> possible exchanges.
<ol>
<li>F(n)+=(n-1)*F(n-2)</li>
</ol>
</li>
<li>Even though the formula is F(N)=(n-1)*(F(n-2)+F(n-1)), but the (n-1)'s meaning is different</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief the derangement function uses the recursive formula to calculate the number of derangements of N elements</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param n </span></span><br><span class="line"><span class="comment"> * @return int </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">derangement</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (n<span class="number">-1</span>) * (<span class="built_in">derangement</span>(n<span class="number">-1</span>) + <span class="built_in">derangement</span>(n<span class="number">-2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fooRecursion</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//sum is n!</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        sum*=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//res is the number of derangements of n elements</span></span><br><span class="line">    <span class="type">int</span> res=<span class="built_in">derangement</span>(n);</span><br><span class="line">    cout &lt;&lt; res*<span class="number">1.0</span>/sum&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief the fooIteration function uses the iterative formula to calculate the number of derangements of N elements</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param n </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fooIteration</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">21</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">2</span>,<span class="number">1</span>&#125;,&#123;<span class="number">6</span>,<span class="number">2</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">4</span>;i&lt;=<span class="number">20</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//dp[i][0] is the number of permutations of n elements</span></span><br><span class="line">        dp[i][<span class="number">0</span>]=i*dp[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//dp[i][1] is the number of derangements of n elements</span></span><br><span class="line">        dp[i][<span class="number">1</span>]=(i<span class="number">-1</span>)*(dp[i<span class="number">-1</span>][<span class="number">1</span>]+dp[i<span class="number">-2</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[n][<span class="number">1</span>]*<span class="number">1.0</span>/dp[n][<span class="number">0</span>]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n,n!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fooIteration</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2049-错排问题2">2049 错排问题2</h2>
<p>Here is the explanation of the derangement problem for selecting M people from N people.</p>
<p>To solve the derangement problem for selecting M people from N people, we can use a similar approach as the regular derangement problem.</p>
<blockquote>
<p>Firstly, the number of ways to select M people from N people is given by the formula C(N,M) = N! / (M! * (N-M)!), which is a known quantity.</p>
<p>Next, we consider the derangement problem for these M people, where each person is not in their original position.</p>
<p>Let D(M) be the number of derangements for M people, then we can use the following recurrence relation:</p>
<p><code>D(M) = (M-1) * [D(M-1) + D(M-2)]</code></p>
<p>Here, D(M-1) represents the number of derangements for M-1 people, where the Mth person cannot be in the Mth position, and D(M-2) represents the number of derangements for M-2 people, where the Mth person cannot be in the (M-1)th position. Since the Mth person cannot be in the Mth position, there are M-1 choices.</p>
<p>The initial conditions are D(1) = 0 and D(2) = 1, since there is no derangement problem with one person, and there is only one derangement with two people.</p>
<p>Finally, the number of derangements for selecting M people from N people is given by <code>C(N,M) * D(M)</code>.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief the derangement function uses the recursive formula to calculate the number of derangements of N elements and also need to consider C(n,m)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param n </span></span><br><span class="line"><span class="comment"> * @param m </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fooIteration</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">21</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">2</span>,<span class="number">1</span>&#125;,&#123;<span class="number">6</span>,<span class="number">2</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">4</span>;i&lt;<span class="number">21</span>;i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>]=i*dp[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">        dp[i][<span class="number">1</span>]=(i<span class="number">-1</span>)*(dp[i<span class="number">-1</span>][<span class="number">1</span>]+dp[i<span class="number">-2</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[n][<span class="number">0</span>]/(dp[m][<span class="number">0</span>]*dp[n-m][<span class="number">0</span>])*dp[m][<span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n,n!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> a,b;</span><br><span class="line">            cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">            <span class="built_in">fooIteration</span>(a,b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2050-拆线分割平面">2050 拆线分割平面</h2>
<p>Before we start to solve this problem, let’s see another problem</p>
<p><strong>How many pieces will get at most divided by N intersecting straight lines</strong></p>
<blockquote>
<p>When adding the <strong>n-th</strong> straight line, it can <strong>intersect</strong> with the previous n-1 straight lines at most, because if it is parallel to the n-1th straight line, it will not create new regions. Therefore, the n-th straight line can create at most <strong>n-1 new intersection points</strong>.</p>
<p>Meanwhile, the nth straight line divides the plane into <strong>n+1 regions</strong>. Thus, the total number of regions is the sum of the total intersection points created <strong>by the first n-1 straight lines and the new regions created by the n-th straight line</strong>.</p>
<p>Specifically:</p>
<ol>
<li>The total number of intersection points created by the first n-1 straight lines =
<ol>
<li><strong>1 + 2 + 3 + … + (n-1) = n*(n-1)/2</strong></li>
</ol>
</li>
<li>The new regions created by the n-th straight line = <strong>n+1</strong></li>
</ol>
<p>Therefore, the total number of regions is:</p>
<p>(n*(n-1)/2) + (n+1) = (n^2 + n + 2)/2</p>
<p>So, when adding the n-th straight line, the maximum number of regions that the plane can be divided into is <code>(n^2 + n + 2)/2.</code></p>
</blockquote>
<h2 id="2053-开关灯">2053 开关灯</h2>
<p>There are many lamps in a line. All of them are off at first. A  series of operations are carried out on these lamps. On the i-th operation, the  lamps whose numbers are the multiple of i change the condition ( on to off and  off to on ).</p>
<p>Each test case contains only a number n ( 0&lt; n&lt;= 10^5) in a  line.</p>
<p>Output the condition of the n-th lamp after infinity operations ( 0  - off, 1 - on ).</p>
<blockquote>
<p>Take n=16 for an examples, because it’s approximations are 1,2,4,8,16 so the 16th light will be adjusted on the 1st, 2nd, 4th, 8th and 16th operations.There are a total of 5 operations and since it starts as off status, it will end up being on.</p>
<p>The final status of the light depends on it’s <strong>parity</strong> of the number of approximations , if the number of divisors of n is odd, then output 1 , otherwise output 0;</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Check if the number of divisors of n is odd. If it is, output 1; otherwise, output 0.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param n </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">countApporximation</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)</span><br><span class="line">            count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res=count&amp;<span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n,n!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">countApporximation</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>To think further, if we consider n=B*A, we can observe that the number of divisors of n will be <strong>even</strong> if all the <code>B</code> not equals to <code>A</code>, it means the light end up being off.</p>
<p>On other hand, only the number of divisors is <strong>odd</strong> can turn on the light! Therefore, we only need to check  whether the input number is a perfect square number</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  check whether a number is perfect squart number. If it is, return 1,otherwise return 0.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param n </span></span><br><span class="line"><span class="comment"> * @return int </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">checkPerfectSquareNum</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">int</span>(<span class="built_in">sqrt</span>(n))*<span class="built_in">int</span>(<span class="built_in">sqrt</span>(n))==n)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2054-a-b-plus">2054 A=B_Plus</h2>
<p>Give you two numbers A and B, if A is equal to B, you should print  “YES”, or print “NO”.</p>
<blockquote>
<p>Notice that the number is not decimal or double variable, it could be a string variable or a long char type.</p>
<p>So we should deal with it a bit before we compare them</p>
<ol>
<li>Remote redundant zeros befrore the real effctive number, like 00001.2=1.2</li>
<li>Remote redundant zeros at the end of the string, like 1.0010000=1.001</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RemoteZeroBeforeRealNum</span><span class="params">(string &amp;str)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len=str.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//i is initiazlied to 0, i will never change because we only need to check whether the first character is &#x27;0&#x27;.</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            str.<span class="built_in">erase</span>(i,<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//The length of the string is reduced by 1 after deleting a character, </span></span><br><span class="line">            <span class="comment">//and thus the position of the next character needs to be recalculated.</span></span><br><span class="line">            len--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(str[i]==<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        str.<span class="built_in">insert</span>(i,<span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RemoteRedundantZeroAfterPoint</span><span class="params">(string &amp;str)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> pos=str.<span class="built_in">find</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="type">int</span> len=str.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//i is initialized  to len-1, but we need to reduced i by 1 each time after deleting a character.</span></span><br><span class="line">    <span class="keyword">for</span>(i=len<span class="number">-1</span>;i&gt;pos;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            str.<span class="built_in">erase</span>(i,<span class="number">1</span>);</span><br><span class="line">            len--;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//If the last character is &#x27;.&#x27;, delete it.</span></span><br><span class="line">    <span class="keyword">if</span>(i==pos)&#123;</span><br><span class="line">        str.<span class="built_in">erase</span>(i,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CompareTwoStringNum</span><span class="params">(string A,string B)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="built_in">getline</span>(cin,str);</span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(str)</span></span>;</span><br><span class="line">    string A,B;</span><br><span class="line">    ss&gt;&gt;A&gt;&gt;B;</span><br><span class="line">    <span class="built_in">RemoteZeroBeforeRealNum</span>(A);</span><br><span class="line">    <span class="built_in">RemoteZeroBeforeRealNum</span>(B);</span><br><span class="line">    <span class="built_in">RemoteRedundantZeroAfterPoint</span>(A);</span><br><span class="line">    <span class="built_in">RemoteRedundantZeroAfterPoint</span>(B);</span><br><span class="line">    cout&lt;&lt;A&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;B&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span>(A==B)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="string-find">string.find()</h3>
<p>In C++, the string class provides the find function to find the position of a substring in the original string. The find function has multiple overloaded versions, among which the commonly used versions are as follows:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">copy <span class="type">codesize_t</span> <span class="title">find</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>; <span class="comment">// Find the first occurrence of the string &#x27;str&#x27; in the original string, starting the search from position &#x27;pos</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>; <span class="comment">// Find the first occurrence of the char array s in the original string, starting the search from position &#x27;pos</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos, <span class="type">size_t</span> n)</span> <span class="type">const</span></span>; <span class="comment">// Find the first occurrence of first n letter of the string &#x27;str&#x27; in the original string, starting the search from position &#x27;pos</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">char</span> c, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>; <span class="comment">// Find the first occurrence of the char c in the original string, starting the search from position &#x27;pos</span></span><br></pre></td></tr></table></figure>
<p>The return value of all four versions above is of type size_t, which indicates the starting position of the found substring in the original string (if not found, it returns string::npos, which is -1).</p>
<h2 id="2055-aeasyproblem">2055 AEasyProblem</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief If a is uppercase, b will add the ASCII value of a minus 65 plus 1;</span></span><br><span class="line"><span class="comment"> * If a is lowercase , b will substract the Ascii value of a minus 97 plus 1.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param a </span></span><br><span class="line"><span class="comment"> * @param b </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">char</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isupper</span>(a))&#123;</span><br><span class="line">        b=b+a-<span class="string">&#x27;A&#x27;</span>+<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        b=b+(a-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>)*(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n,n!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">char</span> a;</span><br><span class="line">            <span class="type">int</span> b;</span><br><span class="line">            cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">            <span class="built_in">foo</span>(a,b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2056-计算重合部分的矩阵面积">2056 计算重合部分的矩阵面积</h2>
<p>Calculate the area of the intersection of two rectangles.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://media.geeksforgeeks.org/wp-content/uploads/Area_Of_Intersecting_Two_Rectangles-300x294.png" alt="pic"></p>
<blockquote>
<p>We consider the intersection is a rectangle (sure it is).Therefore, we require the coordinates of two points on the diagonals of the rectangle.</p>
<p>Then we get the formula as following.</p>
<p>X=max(x1,x3)=max(2,3)=3</p>
<p>Y=max(y1,y3)=max(1,2)=2</p>
<p>X’=min(x2,x4)=min(5,5)=5</p>
<p>Y’=min(y2,y4)=min(5,7)=5</p>
<p>(X,Y)=<strong>(3,2)</strong>  (X’,Y’)=<strong>(5,5)</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Calculate the area of the intersection of two rectangles.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param x </span></span><br><span class="line"><span class="comment"> * @param y </span></span><br><span class="line"><span class="comment"> * @return double </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">calculateArea</span><span class="params">(<span class="type">double</span> *x,<span class="type">double</span> *y)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> x1,y1,x2,y2;</span><br><span class="line">    x1=<span class="built_in">max</span>(x[<span class="number">0</span>],x[<span class="number">2</span>]);</span><br><span class="line">    y1=<span class="built_in">max</span>(y[<span class="number">0</span>],y[<span class="number">2</span>]);</span><br><span class="line">    x2=<span class="built_in">min</span>(x[<span class="number">1</span>],x[<span class="number">3</span>]);</span><br><span class="line">    y2=<span class="built_in">min</span>(y[<span class="number">1</span>],y[<span class="number">3</span>]);</span><br><span class="line">    <span class="type">double</span> s=(x2-x1)*(y2-y1);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">double</span> x[<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">double</span> y[<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            cin&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">2</span>)&lt;&lt;<span class="built_in">calculateArea</span>(x,y)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2058-找到连续子段和为m">2058 *找到连续子段和为M</h2>
<p>Given a sequence 1,2,3,…N, the task is to calculate all the  possible sub-sequences that the sum of the sub-sequence is M</p>
<blockquote>
<ol>
<li>Define two pointers as <code>start</code> and <code>end</code> ,initiazlied as <strong>0</strong> and <strong>1</strong> respectively, and define an array range from 1 to n;</li>
<li>We create a decimal variable sum initialized as dp[0];</li>
<li>While <code>end</code> lower than <code>n</code>, excute the loop until end equals to n;</li>
<li>if sum&lt;m, then <code>sum+=dp[end]</code>, and move end to next num , <code>end++</code></li>
<li>if sum=m, output the result and remember to move end to the next num to search next sub-sequence , <code>sum+=dp[end]</code></li>
<li>if sum&gt;m, <code>sum-=dp[start]</code>, meve start to next num , <code>start++</code></li>
</ol>
</blockquote>
<p>For example, Let’s consider N=20, M=10. dp[20] from 1 to 20, sum=1, start=0, end=1;</p>
<blockquote>
<p>20 10<br>
sum&lt;M: excute: sum+2 end 1<br>
sum 3 start 0 end 2<br>
sum&lt;M: excute: sum+3 end 2<br>
sum 6 start 0 end 3<br>
sum&lt;M: excute: sum+4 end 3<br>
sum 10 start 0 end 4<br>
[1,4]<br>
sum=M: sum 15 start 0 end 5<br>
sum&gt;M: excute: sum-1<br>
sum 14 start 1 end 5<br>
sum&gt;M: excute: sum-2<br>
sum 12 start 2 end 5<br>
sum&gt;M: excute: sum-3<br>
sum 9 start 3 end 5<br>
sum&lt;M: excute: sum+6 end 5<br>
sum 15 start 3 end 6<br>
sum&gt;M: excute: sum-4<br>
sum 11 start 4 end 6<br>
sum&gt;M: excute: sum-5<br>
sum 6 start 5 end 6<br>
sum&lt;M: excute: sum+7 end 6<br>
sum 13 start 5 end 7<br>
sum&gt;M: excute: sum-6<br>
sum 7 start 6 end 7<br>
sum&lt;M: excute: sum+8 end 7<br>
sum 15 start 6 end 8<br>
sum&gt;M: excute: sum-7<br>
sum 8 start 7 end 8<br>
sum&lt;M: excute: sum+9 end 8<br>
sum 17 start 7 end 9<br>
sum&gt;M: excute: sum-8<br>
sum 9 start 8 end 9<br>
sum&lt;M: excute: sum+10 end 9<br>
sum 19 start 8 end 10<br>
sum&gt;M: excute: sum-9<br>
sum 10 start 9 end 10<br>
[10,10]<br>
sum=M: sum 21 start 9 end 11<br>
sum&gt;M: excute: sum-10<br>
sum 11 start 10 end 11<br>
sum&gt;M: excute: sum-11<br>
sum 0 start 11 end 11</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Find all possible sub-sequences whose sum is m.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param n </span></span><br><span class="line"><span class="comment"> * @param m </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FindSubarray</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> *dp=<span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        dp[i]=i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sum=dp[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//Two pointers</span></span><br><span class="line">    <span class="type">int</span> start=<span class="number">0</span>,end=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//if dp[start]&gt;m stop searching.</span></span><br><span class="line">    <span class="keyword">while</span>(end&lt;n&amp;&amp;dp[start]&lt;=m)&#123;</span><br><span class="line">        <span class="keyword">while</span>(sum&lt;m)&#123;</span><br><span class="line">            sum+=dp[end++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum==m)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;[&quot;</span>&lt;&lt;dp[start]&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;dp[end<span class="number">-1</span>]&lt;&lt;<span class="string">&quot;]&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="comment">//Start to search the next subarray.</span></span><br><span class="line">            sum+=dp[end++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//sum&gt;m, start to move the start pointer, and sum will be smaller, until sum</span></span><br><span class="line">        <span class="keyword">while</span>(sum&gt;m)&#123;</span><br><span class="line">            sum-=dp[start++]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m,n!=<span class="number">0</span>&amp;&amp;m!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">FindSubarray</span>(n,m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2059-动态规划2">2059 *动态规划2</h2>
<p>Look at 2037</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param n </span></span><br><span class="line"><span class="comment"> * @param Distance </span></span><br><span class="line"><span class="comment"> * @param vt2 </span></span><br><span class="line"><span class="comment"> * @param vt1 </span></span><br><span class="line"><span class="comment"> * @param c </span></span><br><span class="line"><span class="comment"> * @param t </span></span><br><span class="line"><span class="comment"> * @param vr </span></span><br><span class="line"><span class="comment"> * @param p </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> Distance, <span class="type">int</span> vt2,<span class="type">int</span> vt1,<span class="type">int</span> c,<span class="type">int</span> t,<span class="type">int</span> vr,<span class="type">int</span> *p)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> *dp=<span class="keyword">new</span> <span class="type">double</span>[n+<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="type">double</span> minT=<span class="number">9999999</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="type">int</span> len=p[i]-p[j];</span><br><span class="line">            <span class="type">double</span> time;</span><br><span class="line">            <span class="comment">//if len is longer than c, it means we need to consider two parts.</span></span><br><span class="line">            <span class="keyword">if</span>(len&gt;c)&#123;</span><br><span class="line">                <span class="comment">//the distance of c will at speed vt1, the rest will at speed vt2</span></span><br><span class="line">                time=<span class="number">1.0</span>*(len-c)/vt2+<span class="number">1.0</span>*c/vt1;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                time=<span class="number">1.0</span>*c/vt1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//part of dp</span></span><br><span class="line">            time+=dp[j];</span><br><span class="line">            <span class="comment">//Plus the time of charging</span></span><br><span class="line">            <span class="keyword">if</span>(j)</span><br><span class="line">                time+=t;</span><br><span class="line">            <span class="keyword">if</span>(minT&gt;time)</span><br><span class="line">                minT=time;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i]=minT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Distance*<span class="number">1.0</span>/vr&gt;dp[n+<span class="number">1</span>])</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Good job,rabbit!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;What a pity rabbit!&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> Distance;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;Distance,Distance!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> n,c,t,vr,vt1,vt2;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;c&gt;&gt;t&gt;&gt;vr&gt;&gt;vt1&gt;&gt;vt2;</span><br><span class="line">        <span class="type">int</span> *p=<span class="keyword">new</span> <span class="type">int</span>[n+<span class="number">2</span>];</span><br><span class="line">        p[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        p[n+<span class="number">1</span>]=Distance;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;p[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">foo</span>(n,Distance,vt2,vt1,c,t,vr,p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="leecode">LEECODE</h1>
<h2 id="二分查找">二分查找</h2>
<h3 id="704-二分查找">704. 二分查找</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search/">https://leetcode.cn/problems/binary-search/</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">                right=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="35-搜索插入位置">35. 搜索插入位置</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-insert-position/">https://leetcode.cn/problems/search-insert-position/</a></p>
<p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
<p>Please use an algorithm with time complexity O(log n).</p>
<p>Input: nums = [1,3,5,6], target = 5<br>
Output: 2</p>
<p>Input:: nums = [1,3,5,6], target = 2<br>
Output: 1</p>
<p>Input:: nums = [1,3,5,6], target = 7<br>
Output: 4</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//35. 搜索插入位置</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param nums </span></span><br><span class="line"><span class="comment"> * @param target </span></span><br><span class="line"><span class="comment"> * @return int </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(target&gt;nums[right])&#123;</span><br><span class="line">            <span class="keyword">return</span> right+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;nums[<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">   		<span class="comment">//Find the first element that is greater than or equal to target.</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=target)&#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">int</span> target=<span class="number">5</span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">searchInsert</span>(nums,target)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="278-第一个错误的版本">278. 第一个错误的版本</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/first-bad-version/">https://leetcode.cn/problems/first-bad-version/</a></p>
<p>You are a product manager and you are currently leading a team to develop a new product. Unfortunately, the latest version of your product failed quality testing. Since each version is developed based on the previous version, all versions after the wrong version are wrong.</p>
<p>Suppose you have n versions [1, 2, …, n] and you want to find the first wrong version that causes all subsequent versions to fail.</p>
<p>You can call the bool isBadVersion(version) interface to determine whether the version number version has an error in the unit test. Implement a function to find the first wrong version. You should minimize the number of calls to the API.</p>
<p>Input：n = 5, bad = 4<br>
Output：4<br>
Elaboration：<br>
Call isBadVersion(3) -&gt; false<br>
Call isBadVersion(5) -&gt; true<br>
Call  isBadVersion(4) -&gt; true<br>
Therefore，4 is the first bad version。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Fake function</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isBadVersion</span><span class="params">(<span class="type">int</span> version)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">1</span>,right=n;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="comment">//Find the first element that is greater than or equals to the target.</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="comment">//avoid overflow</span></span><br><span class="line">        mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isBadVersion</span>(mid)==<span class="literal">true</span>)&#123;</span><br><span class="line">            right=mid;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">5</span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">firstBadVersion</span>(n)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双指针">双指针</h2>
<h3 id="977-有序数组的平方">977. 有序数组的平方</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/squares-of-a-sorted-array/">https://leetcode.cn/problems/squares-of-a-sorted-array/</a></p>
<p>Given an integer array nums sorted in <strong>non-decreasing</strong> order, return an array of the squares of each number sorted in non-decreasing order.</p>
<p>Input: nums = [-4,-1,0,3,10]<br>
Output: [0,1,9,16,100]<br>
Explanation: After squaring, the array becomes [16,1,0,9,100].<br>
After sorting, it becomes [0,1,9,16,100].</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Given an array of integers A sorted in non-decreasing order, return an array of the squares of each number, also in sorted non-decreasing order.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param nums </span></span><br><span class="line"><span class="comment"> * @return vector&lt;int&gt; </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> piv=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(piv=<span class="number">0</span>;piv&lt;len;piv++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[piv]&gt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> p1=piv<span class="number">-1</span>,p2=piv;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;temp;</span><br><span class="line">    <span class="keyword">while</span>(p1&gt;=<span class="number">0</span>&amp;&amp;p2&lt;len)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[p1]*nums[p1]&lt;nums[p2]*nums[p2])&#123;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(nums[p1]*nums[p1]);</span><br><span class="line">            p1--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(nums[p2]*nums[p2]);</span><br><span class="line">            p2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p1&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        temp.<span class="built_in">push_back</span>(nums[p1]*nums[p1]);</span><br><span class="line">        p1--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p2&lt;len)&#123;</span><br><span class="line">        temp.<span class="built_in">push_back</span>(nums[p2]*nums[p2]);</span><br><span class="line">        p2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="189-轮转数组">189.轮转数组</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-array/">https://leetcode.cn/problems/rotate-array/</a></p>
<p>Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.</p>
<p>Example 1:</p>
<p>Input: nums = [1,2,3,4,5,6,7], k = 3<br>
Output: [5,6,7,1,2,3,4]<br>
Explanation:<br>
rotate 1 steps to the right: [7,1,2,3,4,5,6]<br>
rotate 2 steps to the right: [6,7,1,2,3,4,5]<br>
rotate 3 steps to the right: [5,6,7,1,2,3,4]<br>
Example 2:</p>
<p>Input: nums = [-1,-100,3,99], k = 2<br>
Output: [3,99,-1,-100]<br>
Explanation:<br>
rotate 1 steps to the right: [99,-1,-100,3]<br>
rotate 2 steps to the right: [3,99,-1,-100]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Given an array, rotate the array to the right by k steps, where k is non-negative.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param nums </span></span><br><span class="line"><span class="comment"> * @param start </span></span><br><span class="line"><span class="comment"> * @param end </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reversePart</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="comment">//Two pointers</span></span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="type">int</span> temp=nums[start];</span><br><span class="line">        nums[start]=nums[end];</span><br><span class="line">        nums[end]=temp;</span><br><span class="line">        start += <span class="number">1</span>;</span><br><span class="line">        end -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line">    k%=len;</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reversePart</span>(nums,<span class="number">0</span>,len<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">reversePart</span>(nums,<span class="number">0</span>,k<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">reversePart</span>(nums,k,len<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="283-移动零">283. 移动零</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/move-zeroes/">https://leetcode.cn/problems/move-zeroes/</a></p>
<p>Given an integer array nums, move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p>
<p>Note that you must do this in-place without making a copy of the array.</p>
<p>Example 1:</p>
<p>Input: nums = [0,1,0,3,12]<br>
Output: [1,3,12,0,0]<br>
Example 2:</p>
<p>Input: nums = [0]<br>
Output: [0]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pointZero,pointNahZero;</span><br><span class="line">    pointZero=pointNahZero=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">//pointZero will only point to zero, pointNahZero will only point a positive num.</span></span><br><span class="line">    <span class="keyword">while</span>(pointNahZero&lt;len)&#123;</span><br><span class="line">        <span class="comment">//When the two pointers point the same number, it will exchange too, then the pointZero will move to next number.</span></span><br><span class="line">        <span class="keyword">if</span>(nums[pointNahZero])&#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[pointNahZero],nums[pointZero]);</span><br><span class="line">            pointZero++;</span><br><span class="line">        &#125;</span><br><span class="line">        pointNahZero++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="167-两数之和-ii-输入有序数组">167. 两数之和 II - 输入有序数组</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/</a></p>
<p>Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 &lt;= index1 &lt; index2 &lt;= numbers.length.</p>
<p>Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.</p>
<p>The tests are generated such that there is exactly one solution. You may not use the same element twice.</p>
<p>Your solution must use only constant extra space.</p>
<p>Example 1:</p>
<p>Input: numbers = [2,7,11,15], target = 9<br>
Output: [1,2]<br>
Explanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2].<br>
Example 2:</p>
<p>Input: numbers = [2,3,4], target = 6<br>
Output: [1,3]<br>
Explanation: The sum of 2 and 4 is 6. Therefore index1 = 1, index2 = 3. We return [1, 3].</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param nums </span></span><br><span class="line"><span class="comment"> * @param target </span></span><br><span class="line"><span class="comment"> * @return vector&lt;int&gt; </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;ans;</span><br><span class="line">    <span class="comment">// Find the element that is equals to the target</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        sum=nums[left]+nums[right];</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;target)&#123;</span><br><span class="line">            right-=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;target)&#123;</span><br><span class="line">            left+=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(left+<span class="number">1</span>);</span><br><span class="line">            ans.<span class="built_in">push_back</span>(right+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="344-反转字符串">344. 反转字符串</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string/">https://leetcode.cn/problems/reverse-string/</a></p>
<p>Write a function that reverses a string. The input string is given as an array of characters s.</p>
<p>You must do this by modifying the input array in-place with O(1) extra memory.</p>
<p>Example 1:</p>
<p>Input: s = [“h”,“e”,“l”,“l”,“o”]<br>
Output: [“o”,“l”,“l”,“e”,“h”]<br>
Example 2:</p>
<p>Input: s = [“H”,“a”,“n”,“n”,“a”,“h”]<br>
Output: [“h”,“a”,“n”,“n”,“a”,“H”]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[left],s[right]);</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="557-反转字符串中的单词-iii">557. 反转字符串中的单词 III</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-words-in-a-string-iii/">https://leetcode.cn/problems/reverse-words-in-a-string-iii/</a></p>
<p>Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.</p>
<p>Example 1:</p>
<p>Input: s = “Let’s take LeetCode contest”<br>
Output: “s’teL ekat edoCteeL tsetnoc”<br>
Example 2:</p>
<p>Input: s = “God Ding”<br>
Output: “doG gniD”</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Given an input string, reverse the string word by word.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param s </span></span><br><span class="line"><span class="comment"> * @return string </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len=s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> start=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> end=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(end&lt;len)&#123;</span><br><span class="line">        <span class="keyword">while</span>(s[end]!=<span class="string">&#x27; &#x27;</span>&amp;&amp;end&lt;len)&#123;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> interEnd=end<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//Reverse the word</span></span><br><span class="line">        <span class="keyword">while</span>(start&lt;interEnd)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[start],s[interEnd]);</span><br><span class="line">            start++;</span><br><span class="line">            interEnd--;</span><br><span class="line">        &#125;</span><br><span class="line">        start=end+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//Skip the space</span></span><br><span class="line">        end++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="built_in">getline</span>(cin,s);</span><br><span class="line">    cout&lt;&lt;<span class="built_in">reverseWords</span>(s)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="876-链表的中间结点">876. 链表的中间结点</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/middle-of-the-linked-list/">https://leetcode.cn/problems/middle-of-the-linked-list/</a></p>
<p>Given the head of a singly linked list, return the middle node of the linked list.</p>
<p>If there are two middle nodes, return the second middle node.</p>
<p>Example 1:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/07/23/lc-midlist1.jpg" alt=""></p>
<p>Input: head = [1,2,3,4,5]<br>
Output: [3,4,5]<br>
Explanation: The middle node of the list is node 3.</p>
<p>Example 2:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/07/23/lc-midlist2.jpg" alt="https://assets.leetcode.com/uploads/2021/07/23/lc-midlist2.jpg"></p>
<p>Input: head = [1,2,3,4,5,6]<br>
Output: [4,5,6]<br>
Explanation: Since the list has two middle nodes with values 3 and 4, we return the second one.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode *fast,*slow;</span><br><span class="line">    fast=slow=head;</span><br><span class="line">    <span class="keyword">while</span>(fast-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        slow=slow-&gt;next;</span><br><span class="line">        fast=fast-&gt;next;</span><br><span class="line">        <span class="comment">//Skip one more node.</span></span><br><span class="line">        <span class="keyword">if</span>(fast-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="19-删除链表的倒数第-n-个结点">19. 删除链表的倒数第 N 个结点</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">https://leetcode.cn/problems/remove-nth-node-from-end-of-list/</a></p>
<p>Given the head of a linked list, remove the nth node from the end of the list and return its head.</p>
<p>Example 1:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt=""></p>
<p>Input: head = [1,2,3,4,5], n = 2<br>
Output: [1,2,3,5]<br>
Example 2:</p>
<p>Input: head = [1], n = 1<br>
Output: []<br>
Example 3:</p>
<p>Input: head = [1,2], n = 1<br>
Output: [1]</p>
<blockquote>
<ol>
<li>Define a node <code>fast, slow and dummy</code>, <code>fast</code> is initialized by head , <code>slow</code> and <code>dummy</code> will be initialized by the node before head, which is a <code>fake head</code> and don’t load any data .</li>
<li>The node fast will move to next node for n times to make sure the <code>fast</code> is n-nodes ahead of <code>slow</code></li>
<li>Then let fast and slow move to their respective next node together 【fast=fast-&gt;next;slow=slow-&gt;next;】</li>
<li>Skip the node that should be deleted. 【slow-&gt;next=slow-&gt;next-&gt;next;】</li>
<li>return <code>dummy's next node. </code>【To make sure we are able to delete the head node】</li>
</ol>
<p>You have to consider the situation that the node-head is the n-th one like <code>[1], n=1</code> which will return <code>[]</code>, that’s reason why we return <code>dummy's next node</code> instead of returning head directly, otherwise, we will get <code>[1]</code> instead of <code>[]</code></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *fast,*slow,*dummy;</span><br><span class="line">        dummy=slow=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        fast=head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow-&gt;next=slow-&gt;next-&gt;next;</span><br><span class="line">        </span><br><span class="line">        ListNode *ans=dummy-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummy;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3-无重复字符的最长子串">3. 无重复字符的最长子串</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">https://leetcode.cn/problems/longest-substring-without-repeating-characters/</a></p>
<p>Given a string s, find the length of the longest substring without repeating characters.</p>
<p>Example 1:</p>
<p>Input: s = “abcabcbb”<br>
Output: 3<br>
Explanation: The answer is “abc”, with the length of 3.<br>
Example 2:</p>
<p>Input: s = “bbbbb”<br>
Output: 1<br>
Explanation: The answer is “b”, with the length of 1.<br>
Example 3:</p>
<p>Input: s = “pwwkew”<br>
Output: 3<br>
Explanation: The answer is “wke”, with the length of 3.<br>
Notice that the answer must be a substring, “pwke” is a subsequence and not a substring.</p>
<blockquote>
<p>Let’s take the string in Example 1: abcabcbb<br>
Take <strong>abcabcbb</strong> as an example, find the longest substring starting from each character and not containing repeated characters, then the longest string among them is the answer. For the string in Example 1, we list these results, where the selected characters and the longest string are indicated in brackets:</p>
<p>Start with<br>
(a)bcabcbb End with (abc)abcbb<br>
Start with<br>
a(b)cabcbb End with a(bca)bcbb<br>
Start with<br>
ab©abcbb End with ab(cab)cbb<br>
Start with<br>
abc(a)bcbb End with abc(abc)bb</p>
</blockquote>
<h4 id="solution">Solution</h4>
<blockquote>
<p>In this solution, the purpose of <code>hash[d]--</code> is to decrease the occurrence of the character pointed by the left pointer in the hash table by 1, indicating that <strong>the character is no longer in the current window</strong>. In the sliding window, as the left pointer moves one position each time, the character it points to needs to be removed from the current window.</p>
<p>For example, in the string <code>&quot;abcbac&quot;</code>, when the left pointer points to the second character “b”, the occurrences of characters “a” and “b” are recorded in the hash table, and the occurrence of character “b” is 2, indicating that there are duplicate characters in the current window. Therefore, the left pointer needs to move to the right, <strong>removing the first “b” from the window</strong>. At this point, the operation <code>hash['b']--</code> is performed, decreasing the occurrence of character “b” by 1. The value corresponding to the element with the key “b” in the hash table becomes 1, indicating that the current window contains only one character “b”.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="type">int</span> len=s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> start,end;</span><br><span class="line">        start=end=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(end&lt;len)&#123;</span><br><span class="line">            <span class="comment">//Record new char;</span></span><br><span class="line">            hash[s[end]]++;</span><br><span class="line">            <span class="comment">//If the new char is redunant then remove the leftest char.</span></span><br><span class="line">            <span class="keyword">while</span>(hash[s[end]]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                hash[s[start]]--;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//Counting the length of the str</span></span><br><span class="line">            res=res&lt;(end-start+<span class="number">1</span>)?(end-start+<span class="number">1</span>):res;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="567-字符串的排列">567. 字符串的排列</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutation-in-string/">https://leetcode.cn/problems/permutation-in-string/</a></p>
<p>Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.</p>
<p>In other words, return true if one of s1’s permutations is the substring of s2.</p>
<p>Example 1:</p>
<p>Input: s1 = “ab”, s2 = “eidbaooo”<br>
Output: true<br>
Explanation: s2 contains one permutation of s1 (“ba”).<br>
Example 2:</p>
<p>Input: s1 = “ab”, s2 = “eidboaoo”<br>
Output: false</p>
<blockquote>
<ol>
<li>We create map&lt;char,int&gt; <code>need</code> to record the count of letter appears in <code>s1</code>, and create map&lt;char,int&gt; <code>window</code> to record the count of letter appears in the <code>sliding window</code></li>
<li>Start to search each letter(as variable <code>ch</code>) in <code>s2</code>, if the letter is in s1(judge by need.count()), then we should update the table <code>window</code>, and add one in <code>window[ch]</code>. If <code>window[ch]</code> is equals to <code>need[ch]</code> ,then we need to inhance the <strong>possibility</strong> of success by adding one in <code>valid</code>.</li>
<li>If the length of the sliding window is greater than the length of <code>s1</code>, we need to deal with result and remove some illegal letter from the window.</li>
<li>If <code>valid</code> is equals to <code>need.size()</code>, which means we successfully match all letters from <code>s1</code> in <code>s2</code>.</li>
<li>If not, then we need to remove some illegal letters if they are in <code>s1</code> too, we need to reduce <code>valid</code> by one if <code>window[d]==need[d]</code> , for example: If we consider <strong>s2=eidbxaaoo</strong> , <strong>s1=abb</strong>, there is a “x” between “b” and “aa” so we need to remove “b” from the window table, cuz it’s <strong>100% illegal</strong>.</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkInclusion</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;need,window;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch:s1)&#123;</span><br><span class="line">            need[ch]+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> end=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len=s2.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> valid=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(end&lt;len)&#123;</span><br><span class="line">            <span class="type">char</span> ch=s2[end++];</span><br><span class="line">            <span class="comment">//Enter the if-condition until the ch is in the s1.</span></span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(ch))&#123;</span><br><span class="line">                <span class="comment">//The window table used to record the count of the letter in s2</span></span><br><span class="line">                window[ch]++;</span><br><span class="line">                <span class="comment">//if the counts is the same, it means it&#x27;s a one of the s1.</span></span><br><span class="line">                <span class="keyword">if</span>(window[ch]==need[ch])</span><br><span class="line">                    valid++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//If</span></span><br><span class="line">            <span class="keyword">while</span>((end-start)&gt;=s1.<span class="built_in">length</span>())&#123;</span><br><span class="line">                <span class="comment">//Need.size may not equals to s1.size()</span></span><br><span class="line">                <span class="keyword">if</span>(valid==need.<span class="built_in">size</span>())</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                <span class="type">char</span> d=s2[start++];</span><br><span class="line">                <span class="keyword">if</span>(need.<span class="built_in">count</span>(d))&#123;</span><br><span class="line">                    <span class="comment">//s2=eidbxaaoo , s1=abb, there is a &quot;x&quot; between &quot;b&quot; and &quot;aa&quot; so we need to remove &quot;b&quot; from the window table, it&#x27;s 100% illegal.</span></span><br><span class="line">                    <span class="keyword">if</span>(window[d]==need[d])&#123;</span><br><span class="line">                        valid--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//Remote the letter from the slid window</span></span><br><span class="line">                    window[d]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="深度-广度遍历">深度/广度遍历</h2>
<h3 id="733-图像渲染">733. 图像渲染</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/flood-fill/">https://leetcode.cn/problems/flood-fill/</a></p>
<p>An image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image.</p>
<p>You are also given three integers sr, sc, and color. You should perform a flood fill on the image starting from the pixel image[sr][sc].</p>
<p>To perform a flood fill, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with color.</p>
<p>Return the modified image after performing the flood fill.</p>
<p>Input: image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, color = 2<br>
Output: [[2,2,2],[2,2,0],[2,0,1]]<br>
Explanation: From the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color.<br>
Note the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/06/01/flood1-grid.jpg" alt=""></p>
<h4 id="board">Board</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">floodFill</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; image, <span class="type">int</span> sr, <span class="type">int</span> sc, <span class="type">int</span> color) &#123;</span><br><span class="line">    <span class="type">int</span> m=image.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> n=image[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">//Four directions</span></span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dy[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//Record the currentColor</span></span><br><span class="line">    <span class="type">int</span> currentColor=image[sr][sc];</span><br><span class="line">    <span class="keyword">if</span>(image[sr][sc]==color)&#123;</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Create a queue variable and push &lt;sr,sc&gt; into it.</span></span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; que;</span><br><span class="line">    <span class="comment">//PUSH AND PAINT</span></span><br><span class="line">    que.<span class="built_in">emplace</span>(sr,sc);</span><br><span class="line">    image[sr][sc]=color;</span><br><span class="line">    <span class="comment">//Classic BFS code</span></span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="comment">//Pop out the head from queue.</span></span><br><span class="line">        <span class="type">int</span> x=que.<span class="built_in">front</span>().first;</span><br><span class="line">        <span class="type">int</span> y=que.<span class="built_in">front</span>().second;</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">//Search four directions.</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> nx=x+dx[i];</span><br><span class="line">            <span class="type">int</span> ny=y+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(nx&gt;=<span class="number">0</span>&amp;&amp;nx&lt;m&amp;&amp;ny&gt;=<span class="number">0</span>&amp;&amp;ny&lt;n&amp;&amp;image[nx][ny]==currentColor)&#123;</span><br><span class="line">                que.<span class="built_in">emplace</span>(nx,ny);</span><br><span class="line">                image[nx][ny]=color;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="deep">Deep</h4>
<blockquote>
<p>As you can see, there almost no difference between dfs and bfs codes using queue and stack respectively, but the logic is a bit different.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">floodFill</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; image, <span class="type">int</span> sr, <span class="type">int</span> sc, <span class="type">int</span> color) &#123;</span><br><span class="line">        <span class="type">int</span> m=image.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n=image[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//Four directions</span></span><br><span class="line">        <span class="type">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> dy[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">//Record the currentColor</span></span><br><span class="line">        <span class="type">int</span> currentColor=image[sr][sc];</span><br><span class="line">        <span class="keyword">if</span>(image[sr][sc]==color)&#123;</span><br><span class="line">            <span class="keyword">return</span> image;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Create a stack variable and push &lt;sr,sc&gt; into it.</span></span><br><span class="line">        stack&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; sta;</span><br><span class="line">        <span class="comment">//PUSH AND PAINT</span></span><br><span class="line">        sta.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(sr,sc));</span><br><span class="line">        image[sr][sc]=color;</span><br><span class="line">        <span class="comment">//Class DFS code</span></span><br><span class="line">        <span class="keyword">while</span>(!sta.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="comment">//Pop out the top from stack.</span></span><br><span class="line">            <span class="type">int</span> x=sta.<span class="built_in">top</span>().first;</span><br><span class="line">            <span class="type">int</span> y=sta.<span class="built_in">top</span>().second;</span><br><span class="line">            sta.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">//Search four directions.</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">                <span class="type">int</span> nx=x+dx[i];</span><br><span class="line">                <span class="type">int</span> ny=y+dy[i];</span><br><span class="line">                <span class="keyword">if</span>(nx&gt;=<span class="number">0</span>&amp;&amp;nx&lt;m&amp;&amp;ny&gt;=<span class="number">0</span>&amp;&amp;ny&lt;n&amp;&amp;image[nx][ny]==currentColor)&#123;</span><br><span class="line">                    sta.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(nx,ny));</span><br><span class="line">                    image[nx][ny]=color;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="695-岛屿的最大面积">695. 岛屿的最大面积</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/max-area-of-island/">https://leetcode.cn/problems/max-area-of-island/</a></p>
<p>You are given an m x n binary matrix grid. An island is a group of 1’s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</p>
<p>The area of an island is the number of cells with a value 1 in the island.</p>
<p>Return the maximum area of an island in grid. If there is no island, return 0.</p>
<p>Example 1:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg" alt=""></p>
<p>Input: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]<br>
Output: 6<br>
Explanation: The answer is not 11, because the island must be connected 4-directionally.<br>
Example 2:</p>
<p>Input: grid = [[0,0,0,0,0,0,0,0]]<br>
Output: 0</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Given a non-empty 2D array grid of 0&#x27;s and 1&#x27;s, an island is a group of 1&#x27;s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param grid </span></span><br><span class="line"><span class="comment"> * @return int </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m=grid.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> n=grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> dy[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>||n==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//If i,j is searched then skip it when see it next time.</span></span><br><span class="line">    <span class="type">int</span> **mark=<span class="keyword">new</span> <span class="type">int</span>*[m];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        mark[i]=<span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            mark[i][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Define a que to do BFS</span></span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; que;</span><br><span class="line">    <span class="type">int</span> MaxSum=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//Start from every point</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="comment">//If the point is land and haven&#x27;t been searched.</span></span><br><span class="line">            <span class="keyword">if</span>(grid[i][j]!=<span class="number">0</span>&amp;&amp;mark[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">int</span> sum=<span class="number">1</span>;</span><br><span class="line">                que.<span class="built_in">emplace</span>(i,j);</span><br><span class="line">                mark[i][j]=<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//Classic BFS code</span></span><br><span class="line">                <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    <span class="type">int</span> x=que.<span class="built_in">front</span>().first;</span><br><span class="line">                    <span class="type">int</span> y=que.<span class="built_in">front</span>().second;</span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;<span class="number">4</span>;t++)&#123;</span><br><span class="line">                        <span class="type">int</span> nx=x+dx[t];</span><br><span class="line">                        <span class="type">int</span> ny=y+dy[t];</span><br><span class="line">                        <span class="keyword">if</span>(nx&lt;m&amp;&amp;ny&lt;n&amp;&amp;nx&gt;=<span class="number">0</span>&amp;&amp;ny&gt;=<span class="number">0</span>&amp;&amp;grid[nx][ny]!=<span class="number">0</span>&amp;&amp;mark[nx][ny]==<span class="number">0</span>)&#123;</span><br><span class="line">                            sum++;</span><br><span class="line">                            que.<span class="built_in">emplace</span>(nx,ny);</span><br><span class="line">                            mark[nx][ny]=<span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                MaxSum=MaxSum&lt;sum?sum:MaxSum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MaxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="617-合并二叉树">617. 合并二叉树</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-binary-trees/">https://leetcode.cn/problems/merge-two-binary-trees/</a></p>
<h4 id="bfs">BFS</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root2==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode *merge=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(root1-&gt;val+root2-&gt;val);</span><br><span class="line">        merge-&gt;left=<span class="built_in">mergeTrees</span>(root1-&gt;left,root2-&gt;left);</span><br><span class="line">        merge-&gt;right=<span class="built_in">mergeTrees</span>(root1-&gt;right,root2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> merge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="dfs">DFS</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode&gt; que2;</span><br><span class="line">        queue&lt;TreeNode&gt; que1;</span><br><span class="line">        queue&lt;TreeNode&gt; que3;</span><br><span class="line">        que1.<span class="built_in">emplace</span>(root1);</span><br><span class="line">        que2.<span class="built_in">emplace</span>(root2);</span><br><span class="line">        <span class="keyword">while</span>(!que1.<span class="built_in">empty</span>()&amp;&amp;!que2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode p2=que2.<span class="built_in">front</span>();</span><br><span class="line">            TreeNode p1=que1.<span class="built_in">front</span>();</span><br><span class="line">            que2.<span class="built_in">pop</span>();</span><br><span class="line">            que1.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(p1!=<span class="literal">NULL</span>&amp;&amp;p2!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                que3.<span class="built_in">emplace</span>(<span class="built_in">TreeNode</span>(p1-&gt;val+p2-&gt;val));</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p1==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                que3.<span class="built_in">emplace</span>(p2);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p2==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                que3.<span class="built_in">emplace</span>(p1);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                que3.<span class="built_in">emplace</span>(<span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!que1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode p=que1.<span class="built_in">front</span>();</span><br><span class="line">            que1.<span class="built_in">pop</span>();</span><br><span class="line">            que3.<span class="built_in">emplace</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!que2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode p=que2.<span class="built_in">front</span>();</span><br><span class="line">            que2.<span class="built_in">pop</span>();</span><br><span class="line">            que3.<span class="built_in">emplace</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode p3=que3.<span class="built_in">front</span>();</span><br><span class="line">        que3.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que3.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                p3-&gt;left=que3.<span class="built_in">front</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p3-&gt;right=que3.<span class="built_in">front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            que3.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="dfs">DFS</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == null) &#123;</span><br><span class="line">            <span class="keyword">return</span> t2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t2 == null) &#123;</span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode merged = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(t1.val + t2.val);</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="built_in">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue1 = <span class="keyword">new</span> <span class="built_in">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue2 = <span class="keyword">new</span> <span class="built_in">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        queue.<span class="built_in">offer</span>(merged);</span><br><span class="line">        queue1.<span class="built_in">offer</span>(t1);</span><br><span class="line">        queue2.<span class="built_in">offer</span>(t2);</span><br><span class="line">        <span class="keyword">while</span> (!queue1.<span class="built_in">isEmpty</span>() &amp;&amp; !queue2.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            TreeNode node = queue.<span class="built_in">poll</span>(), node1 = queue1.<span class="built_in">poll</span>(), node2 = queue2.<span class="built_in">poll</span>();</span><br><span class="line">            TreeNode left1 = node1.left, left2 = node2.left, right1 = node1.right, right2 = node2.right;</span><br><span class="line">            <span class="keyword">if</span> (left1 != null || left2 != null) &#123;</span><br><span class="line">                <span class="keyword">if</span> (left1 != null &amp;&amp; left2 != null) &#123;</span><br><span class="line">                    TreeNode left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(left1.val + left2.val);</span><br><span class="line">                    node.left = left;</span><br><span class="line">                    queue.<span class="built_in">offer</span>(left);</span><br><span class="line">                    queue1.<span class="built_in">offer</span>(left1);</span><br><span class="line">                    queue2.<span class="built_in">offer</span>(left2);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left1 != null) &#123;</span><br><span class="line">                    node.left = left1;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left2 != null) &#123;</span><br><span class="line">                    node.left = left2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right1 != null || right2 != null) &#123;</span><br><span class="line">                <span class="keyword">if</span> (right1 != null &amp;&amp; right2 != null) &#123;</span><br><span class="line">                    TreeNode right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(right1.val + right2.val);</span><br><span class="line">                    node.right = right;</span><br><span class="line">                    queue.<span class="built_in">offer</span>(right);</span><br><span class="line">                    queue1.<span class="built_in">offer</span>(right1);</span><br><span class="line">                    queue2.<span class="built_in">offer</span>(right2);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right1 != null) &#123;</span><br><span class="line">                    node.right = right1;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node.right = right2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> merged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="542-01-矩阵">542. 01 矩阵</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/01-matrix/">https://leetcode.cn/problems/01-matrix/</a></p>
<p>Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell.</p>
<p>The distance between two adjacent cells is 1.</p>
<p>Example 1:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/04/24/01-1-grid.jpg" alt=""></p>
<p>Input: mat = [[0,0,0],[0,1,0],[0,0,0]]<br>
Output: [[0,0,0],[0,1,0],[0,0,0]]</p>
<p>Example 2:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/04/24/01-2-grid.jpg" alt=""></p>
<p>Input: mat = [[0,0,0],[0,1,0],[1,1,1]]<br>
Output: [[0,0,0],[0,1,0],[1,2,1]]</p>
<blockquote>
<p>Start From Zero To One！！！！！</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">updateMatrix</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; mat) &#123;</span><br><span class="line">        <span class="type">int</span> n,m;</span><br><span class="line">        <span class="type">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> dy[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        n=mat.<span class="built_in">size</span>();</span><br><span class="line">        m=mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//Define a distance and initialized as INFINITE_MAX;</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">distance</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m,INT_MAX));</span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; que;</span><br><span class="line">        <span class="comment">//Add up all Zero point into a queue, and set the distance as 0 for every Zero point.</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mat[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">emplace</span>(<span class="built_in">make_pair</span>(i,j));</span><br><span class="line">                    distance[i][j]=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//BFS</span></span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="comment">//Start from Zero point to One point</span></span><br><span class="line">            <span class="type">int</span> x=que.<span class="built_in">front</span>().first;</span><br><span class="line">            <span class="type">int</span> y=que.<span class="built_in">front</span>().second;</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">                <span class="type">int</span> nx=x+dx[i];</span><br><span class="line">                <span class="type">int</span> ny=y+dy[i];</span><br><span class="line">                <span class="comment">//Update every One point according to Zero point.</span></span><br><span class="line">                <span class="keyword">if</span>(nx&gt;=<span class="number">0</span>&amp;&amp;nx&lt;n&amp;&amp;ny&gt;=<span class="number">0</span>&amp;&amp;ny&lt;m)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(distance[nx][ny]&gt;distance[x][y]+<span class="number">1</span>)&#123;</span><br><span class="line">                        distance[nx][ny]=distance[x][y]+<span class="number">1</span>;</span><br><span class="line">                        que.<span class="built_in">emplace</span>(<span class="built_in">make_pair</span>(nx,ny));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> distance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="994-腐烂的橘子">994. 腐烂的橘子</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotting-oranges/">https://leetcode.cn/problems/rotting-oranges/</a></p>
<p>You are given an m x n grid where each cell can have one of three values:</p>
<p>0 representing an empty cell,<br>
1 representing a fresh orange, or<br>
2 representing a rotten orange.<br>
Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.</p>
<p>Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.</p>
<p>Example 1:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/oranges.png" alt=""></p>
<p>Input: grid = [[2,1,1],[1,1,0],[0,1,1]]<br>
Output: 4<br>
Example 2:</p>
<p>Input: grid = [[2,1,1],[0,1,1],[1,0,1]]<br>
Output: -1<br>
Explanation: The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.<br>
Example 3:</p>
<p>Input: grid = [[0,2]]<br>
Output: 0<br>
Explanation: Since there are already no fresh oranges at minute 0, the answer is just 0.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//Multiple starting sources problem</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">orangesRotting</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n,m;</span><br><span class="line">        n=grid.<span class="built_in">size</span>();</span><br><span class="line">        m=grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> dy[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">//Define a queue to record starting sources</span></span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; que;</span><br><span class="line">        <span class="type">int</span> freshCount=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="comment">//if grid==2, it&#x27;s a source</span></span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">2</span>)&#123;</span><br><span class="line">                    que.<span class="built_in">emplace</span>(<span class="built_in">make_pair</span>(i,j));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//Record the count of fresh oranges</span></span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    freshCount++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//If there are no any of fresh one, return 0;</span></span><br><span class="line">        <span class="keyword">if</span>(freshCount==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Record the maxstep to fresh oranges;</span></span><br><span class="line">        <span class="type">int</span> TheMax=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//BFS</span></span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> x=que.<span class="built_in">front</span>().first;</span><br><span class="line">            <span class="type">int</span> y=que.<span class="built_in">front</span>().second;</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">                <span class="type">int</span> nx=x+dx[i];</span><br><span class="line">                <span class="type">int</span> ny=y+dy[i];</span><br><span class="line">                <span class="keyword">if</span>(nx&gt;=<span class="number">0</span>&amp;&amp;nx&lt;n&amp;&amp;ny&gt;=<span class="number">0</span>&amp;&amp;ny&lt;m)&#123;</span><br><span class="line">                    <span class="comment">//If reach to a fresh orange, then trans it into rotten one.</span></span><br><span class="line">                    <span class="keyword">if</span>(grid[nx][ny]==<span class="number">1</span>)&#123;</span><br><span class="line">                        freshCount--;</span><br><span class="line">                        <span class="comment">//Increase one step.</span></span><br><span class="line">                        grid[nx][ny]=grid[x][y]+<span class="number">1</span>;</span><br><span class="line">                        <span class="comment">//Update the maxstep to fresh oranges;</span></span><br><span class="line">                        TheMax=TheMax&lt;grid[nx][ny]?grid[nx][ny]:TheMax;</span><br><span class="line">                        <span class="comment">//add a new rotten one into queue.</span></span><br><span class="line">                        que.<span class="built_in">emplace</span>(<span class="built_in">make_pair</span>(nx,ny));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//If there still have any of fresh oranges , return -1;</span></span><br><span class="line">        <span class="keyword">if</span>(freshCount)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> TheMax<span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="递归-回溯">递归/回溯</h2>
<h3 id="21-合并两个有序链表">21. 合并两个有序链表</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-sorted-lists/">https://leetcode.cn/problems/merge-two-sorted-lists/</a></p>
<p>You are given the heads of two sorted linked lists list1 and list2.</p>
<p>Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.</p>
<p>Return the head of the merged linked list.</p>
<p>Example 1:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt=""></p>
<p>Input: list1 = [1,2,4], list2 = [1,3,4]<br>
Output: [1,1,2,3,4,4]<br>
Example 2:</p>
<p>Input: list1 = [], list2 = []<br>
Output: []<br>
Example 3:</p>
<p>Input: list1 = [], list2 = [0]<br>
Output: [0]</p>
<h4 id="iteration">Iteration</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Make a fake head</span></span><br><span class="line">        ListNode* res=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//the p is used to add new nodes to res</span></span><br><span class="line">        ListNode* p=res;</span><br><span class="line">        <span class="keyword">while</span>(list1!=<span class="literal">nullptr</span>&amp;&amp;list2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list1-&gt;val&lt;=list2-&gt;val)&#123;</span><br><span class="line">                p-&gt;next=list1;</span><br><span class="line">                list1=list1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p-&gt;next=list2;</span><br><span class="line">                list2=list2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list1!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            p-&gt;next=list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            p-&gt;next=list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="recursion">Recursion</h4>
<blockquote>
<p>We can find the miner one and merge it with the rest of elements and the rules as following.</p>
<ol>
<li>list1[0]+merge(list1[1:],list2)   list1[0]&lt;list2[0]</li>
<li>list2[0]+merge(list1,list2[1:])   list1[0]&gt;=list2[0]</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list2==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list1-&gt;val&lt;=list2-&gt;val)&#123;</span><br><span class="line">            list1-&gt;next=<span class="built_in">mergeTwoLists</span>(list1-&gt;next,list2);</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            list2-&gt;next=<span class="built_in">mergeTwoLists</span>(list1,list2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="206-反转链表">206.反转链表</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/">https://leetcode.cn/problems/reverse-linked-list/</a></p>
<p>Given the head of a singly linked list, reverse the list, and return the reversed list.</p>
<p>Example 1:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt=""></p>
<p>Input: head = [1,2,3,4,5]<br>
Output: [5,4,3,2,1]</p>
<h4 id="iteration">Iteration</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//preHead is a fake head used to reorder the link.</span></span><br><span class="line">        ListNode*preHead =<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//res keep still which always point to the first element of preHead.</span></span><br><span class="line">        ListNode*res=preHead;</span><br><span class="line">        preHead-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">        ListNode*p=head;</span><br><span class="line">        <span class="comment">//r is used to back up the p-&gt;next for p to recover to p-&gt;next</span></span><br><span class="line">        ListNode*r;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="comment">//back up</span></span><br><span class="line">            r=p-&gt;next;</span><br><span class="line">            p-&gt;next=preHead-&gt;next;</span><br><span class="line">            <span class="comment">//add p to preHead&#x27;s next one</span></span><br><span class="line">            preHead-&gt;next=p;</span><br><span class="line">            <span class="comment">//recovery</span></span><br><span class="line">            p=r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="77-组合">77.组合</h3>
<p>Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].</p>
<p>You may return the answer in any order.</p>
<p>Example 1:</p>
<p>Input: n = 4, k = 2<br>
Output: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]<br>
Explanation: There are 4 choose 2 = 6 total combinations.<br>
Note that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.<br>
Example 2:</p>
<p>Input: n = 1, k = 1<br>
Output: [[1]]<br>
Explanation: There is 1 choose 1 = 1 total combination.</p>
<p>Backtrack with pruning</p>
<blockquote>
<p><code>path.size()</code> means the count of elements have been selected by us</p>
<p><code>(n-i+1)</code> is the count of rest of elements</p>
<p>we need to insure that the <code>path.size()</code> plus <code>(n-i+1)</code> is more than <code>K</code>, otherwise , we can’t meet the condition.</p>
<p>For each loop, i should start at <code>index</code> to avoid add the numbers that have been used.</p>
<p>For each next backtracking , the <code>index</code> will start at <code>(i+1)</code> to make sure there is no duplicate situation like (1,2) and (2,1) cuz we <strong>consider them as the same tuple.</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="comment">//Receive result.</span></span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>()==k)&#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Classic backtracking code</span></span><br><span class="line">        <span class="comment">//path.size() means the count of elements have been selected by us, (n-i+1) is the count of rest of elements, we need to insure that the path.size plus the count of the rest of elements is more than K,otherwise , we can&#x27;t meet the condition.</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=index;(path.<span class="built_in">size</span>()+n-i+<span class="number">1</span>)&gt;=k;i++)&#123;</span><br><span class="line">            <span class="comment">//Add new node</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="comment">//Search for the rest of them. index will start at (i+1)</span></span><br><span class="line">            <span class="built_in">backtracking</span>(n,k,i+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//Pop out one num</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(n,k,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="216-组合总和-iii">216. 组合总和 III</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iii/">https://leetcode.cn/problems/combination-sum-iii/</a></p>
<p>Find all valid combinations of k numbers that sum up to n such that the following conditions are true:</p>
<p>Only numbers 1 through 9 are used.<br>
Each number is used at most once.<br>
Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.</p>
<p>Example 1:</p>
<p>Input: k = 3, n = 7<br>
Output: [[1,2,4]]<br>
Explanation:<br>
1 + 2 + 4 = 7<br>
There are no other valid combinations.<br>
Example 2:</p>
<p>Input: k = 3, n = 9<br>
Output: [[1,2,6],[1,3,5],[2,3,4]]<br>
Explanation:<br>
1 + 2 + 6 = 9<br>
1 + 3 + 5 = 9<br>
2 + 3 + 4 = 9<br>
There are no other valid combinations.<br>
Example 3:</p>
<p>Input: k = 4, n = 1<br>
Output: []<br>
Explanation: There are no valid combinations.<br>
Using 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 &gt; 1, there are no valid combination.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> n,<span class="type">int</span> index,<span class="type">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="comment">//if sum&gt;n return directly</span></span><br><span class="line">        <span class="keyword">if</span>(sum&gt;n)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>()==k)&#123;</span><br><span class="line">            <span class="comment">//Meet the condition</span></span><br><span class="line">            <span class="keyword">if</span>(n==sum)&#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//9 means nums selected from 1 to 9</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=index;(path.<span class="built_in">size</span>()+<span class="number">9</span>-i+<span class="number">1</span>)&gt;=k;i++)&#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(i);</span><br><span class="line">            sum+=i;</span><br><span class="line">            <span class="comment">//start at i+1</span></span><br><span class="line">            <span class="built_in">backtracking</span>(k,n,i+<span class="number">1</span>,sum);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            sum-=i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(k,n,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="动态规划">动态规划</h2>
<h3 id="70-爬楼梯">70. 爬楼梯</h3>
<p>Source:<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">https://leetcode.cn/problems/climbing-stairs/</a></p>
<p>Solution:<a target="_blank" rel="noopener" href="https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF.html#%E6%80%9D%E8%B7%AF">https://programmercarl.com/0070.爬楼梯.html#思路</a></p>
<p>You are climbing a staircase. It takes n steps to reach the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
<p>Example 1:</p>
<p>Input: n = 2<br>
Output: 2<br>
Explanation: There are two ways to climb to the top.</p>
<ol>
<li>1 step + 1 step</li>
<li>2 steps<br>
Example 2:</li>
</ol>
<p>Input: n = 3<br>
Output: 3<br>
Explanation: There are three ways to climb to the top.</p>
<ol>
<li>1 step + 1 step + 1 step</li>
<li>1 step + 2 steps</li>
<li>2 steps + 1 step</li>
</ol>
<blockquote>
<ol>
<li>Define a array dp, <code>dp[i]</code> means the <strong>ways</strong> to climb to the <code>i</code> level</li>
<li>To reach to i level , we can climb from <code>i-1</code> or <code>i-2</code>, so the <strong>ways</strong> to <code>i</code> level equals to the <strong>ways</strong> to <code>i-1</code> plus the ways to <code>i-2</code>. <code>dp[i]=dp[i-1]+dp[i-2]</code></li>
<li>dp[0]=0, dp[1]=1, dp[2]=2</li>
<li>because the <code>i</code> level dependent on <code>i-1</code> and <code>i-2</code> , so we <strong>traverse from front to rear</strong></li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief This is a utility function to calculate the number of ways to climb stairs</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param dp </span></span><br><span class="line"><span class="comment">     * @param n </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">utility</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;dp,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i]=dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">utility</span>(dp,n);</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Solution s;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line">    cout&lt;&lt;s.<span class="built_in">climbStairs</span>(x)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="746-使用最小花费爬楼梯">746. 使用最小花费爬楼梯</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-cost-climbing-stairs/">https://leetcode.cn/problems/min-cost-climbing-stairs/</a></p>
<p>You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps.</p>
<p>You can either start from the step with index 0, or the step with index 1.</p>
<p>Return the minimum cost to reach the top of the floor.</p>
<p>Example 1:</p>
<p>Input: cost = [10,15,20]<br>
Output: 15<br>
Explanation: You will start at index 1.</p>
<ul>
<li>Pay 15 and climb two steps to reach the top.<br>
The total cost is 15.<br>
Example 2:</li>
</ul>
<p>Input: cost = [1,100,1,1,1,100,1,1,100,1]<br>
Output: 6<br>
Explanation: You will start at index 0.</p>
<ul>
<li>Pay 1 and climb two steps to reach index 2.</li>
<li>Pay 1 and climb two steps to reach index 4.</li>
<li>Pay 1 and climb two steps to reach index 6.</li>
<li>Pay 1 and climb one step to reach index 7.</li>
<li>Pay 1 and climb two steps to reach index 9.</li>
<li>Pay 1 and climb one step to reach the top.<br>
The total cost is 6.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">utility</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;cost,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="comment">//dp means the minimum cost to reach the ith level</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">//cost menns the cost to climb from ith level to ith+1 level or ith+2 level</span></span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//Why i end with n, not n-1? Because we need to calculate the cost of the Top level</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>]+cost[i<span class="number">-1</span>],dp[i<span class="number">-2</span>]+cost[i<span class="number">-2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=cost.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">utility</span>(cost,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Solution s;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; cost=&#123;<span class="number">10</span>,<span class="number">15</span>,<span class="number">20</span>&#125;;</span><br><span class="line">    cout&lt;&lt;s.<span class="built_in">minCostClimbingStairs</span>(cost)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="62-不同路径">62. 不同路径</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/">https://leetcode.cn/problems/unique-paths/</a></p>
<p>There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.</p>
<p>Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.</p>
<p>The test cases are generated so that the answer will be less than or equal to 2 * 109.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" alt=""></p>
<p>Example 1:</p>
<p>Input: m = 3, n = 7<br>
Output: 28<br>
Example 2:</p>
<p>Input: m = 3, n = 2<br>
Output: 3<br>
Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:</p>
<ol>
<li>Right -&gt; Down -&gt; Down</li>
<li>Down -&gt; Down -&gt; Right</li>
<li>Down -&gt; Right -&gt; Down</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//This is a utility function to calculate the number of unique paths</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">utility</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="comment">//dp means the ways to reach the x,y grid.</span></span><br><span class="line">        <span class="comment">//The first row and the first column are all 1</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n,<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">//This is a compressed version of the DP solution.</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="comment">//uncompressed version:dp[j][i]=dp[j-1][i]+dp[j][i-1];</span></span><br><span class="line">                dp[i]=dp[i]+dp[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">utility</span>(m,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Solution s;</span><br><span class="line">    <span class="type">int</span> m,n;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    cout&lt;&lt;s.<span class="built_in">uniquePaths</span>(m,n)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="63-不同路径-ii">63. 不同路径 II</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths-ii/">https://leetcode.cn/problems/unique-paths-ii/</a></p>
<p>You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.</p>
<p>An obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle.</p>
<p>Return the number of possible unique paths that the robot can take to reach the bottom-right corner.</p>
<p>The testcases are generated so that the answer will be less than or equal to 2 * 109.</p>
<blockquote>
<p>When we initialize the first row and col at <code>dp</code>, we should stop initialize the rest of elements in the row or col when we meet a obstacle.</p>
<p>And when we transerve the grid, if there’s a obstacle in [i][j], then we should set dp[i][j] as zero.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">utility</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; obstacleGrid,<span class="type">int</span> m,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[m<span class="number">-1</span>][n<span class="number">-1</span>]==<span class="number">1</span>||obstacleGrid[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">//Trick: when we initialize the first row and col, if we meet obstacle we should stop initialize the rest of elements in the row or col</span></span><br><span class="line">        <span class="comment">//And this is the biggest difference between normal one</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n&amp;&amp;obstacleGrid[<span class="number">0</span>][i]!=<span class="number">1</span>;i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m&amp;&amp;obstacleGrid[i][<span class="number">0</span>]!=<span class="number">1</span>;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j]!=<span class="number">1</span>)&#123;</span><br><span class="line">                    dp[i][j]=dp[i][j<span class="number">-1</span>]+dp[i<span class="number">-1</span>][j];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//if there is a obstacle then we set dp[i][j] as zero it means we can&#x27;t pass here.</span></span><br><span class="line">                    dp[i][j]=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">utility</span>(obstacleGrid,obstacleGrid.<span class="built_in">size</span>(),obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Solution s;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; obstacleGrid=&#123;&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    cout&lt;&lt;s.<span class="built_in">uniquePathsWithObstacles</span>(obstacleGrid)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="0-1背包">0-1背包</h3>
<blockquote>
<p><code>dp[i][j]</code> means the <strong>biggest value</strong> that we select a <strong>any count</strong> of items from <code>item_0</code> to <code>item_i</code> and put them into a package whose capacity is <code>j</code></p>
<p>if we don’t select item_i, then the maximum value of this package is <code>dp[i-1][j]</code></p>
<p>if we do select item_i, then the maximum value of this package is <code>value[i]+dp[i-1][j-weight[i]]</code>, which means we  reserve some space(<code>weight[i]</code>) for <code>item_i</code> and we will find the <strong>biggest value</strong>(<code>dp[i-1][j-weight[i]]</code>) in such a condition , then we add the value of <code>item_i</code> with that value</p>
<p>In a short,</p>
<p>If we don’t select item_i, <code>dp[i][j]=dp[i-1][j]</code></p>
<p>If we select item_i, <code>dp[i][j]=dp[i-1][j-weight[i]]+value[i]</code></p>
<p>Then we should select the maximum one of the two value <code>max( dp[i-1][j],dp[i-1][j-weight[i]]+value[i] )</code>, it’s bit of long.</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th>Weight</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Item1</td>
<td>1</td>
<td>15</td>
</tr>
<tr>
<td>Item2</td>
<td>3</td>
<td>20</td>
</tr>
<tr>
<td>Item3</td>
<td>4</td>
<td>30</td>
</tr>
</tbody>
</table>
<p>DP</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>Item1</td>
<td>0</td>
<td>15</td>
<td>15</td>
<td>15</td>
<td>15</td>
<td>15</td>
</tr>
<tr>
<td>Item2</td>
<td>0</td>
<td>15</td>
<td>15</td>
<td>20</td>
<td>35</td>
<td>35</td>
</tr>
<tr>
<td>Item3</td>
<td>0</td>
<td>15</td>
<td>15</td>
<td>20</td>
<td>35</td>
<td>45</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Traverse items first ,however we also can traverse capacity first</span></span><br><span class="line"><span class="comment">// i start from 1 beacuse we have set dp[0][] we can skip item_1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;items;i++)&#123;</span><br><span class="line">    <span class="comment">//j means the j capacity </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;cap;j++)&#123;</span><br><span class="line">        <span class="comment">//if j&gt;=weight[i] which means the package can afford the item_i</span></span><br><span class="line">        <span class="keyword">if</span>(j&gt;=weight[i])&#123;</span><br><span class="line">            <span class="comment">//then we need to decide whether we should add item_i into package.</span></span><br><span class="line">            dp[i][j]=<span class="built_in">max</span>( dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-weight[i]]+value[i] );</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>We also can compress dp into one-dimension</p>
<p><code>dp[j]=max(dp[j],dp[j-weight[i]]+value[i])</code></p>
<p><code>dp[j]</code> is still mean the maximum value in <code>j</code> capacity, i means the item_i</p>
<p>Here’s the code,</p>
<ol>
<li>
<p>why we <strong>traverse from rear to front</strong>?</p>
<p>Once we traverse in positive order, the <strong>item_1</strong> will be added multiple times!</p>
<p>For example：<strong>Item_1</strong> :weight[0] = 1，[0] = 15</p>
<p>If we consider traverse in positive order, here’s the result.</p>
<p>dp[1] = dp[1 - weight[0]] + value[0] = 15</p>
<p>dp[2] = dp[2 - weight[0]] + value[0] = 30</p>
<p>dp[2] will get 30 which means we put <strong>item_1</strong> twice!!!</p>
</li>
<li>
<p>how to initiazlie the dp</p>
<p>we should initialize <code>dp</code> with <strong>all zero</strong> , if we set <code>dp</code> as other positive number like 10000, the initiazlied num will cover the new number we calculated in the future. <code>dp[j]</code> - 10000 may will always bigger than <code>dp[j-weight[i]]+value[i]</code> - other new number</p>
</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDP</span><span class="params">(vector&lt;<span class="type">int</span>&gt; dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;dp.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            cout&lt;&lt;dp[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_1_wei_bag_problem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; weight = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; value = &#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="type">int</span> items=<span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> bagWeight = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Initialize dp as all zero , one dimensional array with &quot;cap&quot; elements</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(bagWeight+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;items;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=bagWeight;j&gt;=weight[i];j--)&#123;</span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j],dp[j-weight[i]]+value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printDP</span>(dp);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test_1_wei_bag_problem</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="416-分割等和子集">416. 分割等和子集</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-equal-subset-sum/">https://leetcode.cn/problems/partition-equal-subset-sum/</a></p>
<p>Given an integer array nums, return true if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or false otherwise.</p>
<p>Example 1:</p>
<p>Input: nums = [1,5,11,5]<br>
Output: true<br>
Explanation: The array can be partitioned as [1, 5, 5] and [11].<br>
Example 2:</p>
<p>Input: nums = [1,2,3,5]<br>
Output: false<br>
Explanation: The array cannot be partitioned into equal sum subsets.</p>
<blockquote>
<p>This problem is a bit of special: <strong>weight[i]=value[i]</strong></p>
<ol>
<li>First , we should calculate the sum of array, if sum%2==1, which means it can’t split to two sub-arrays.</li>
<li>If not, the we set variable <code>target</code>=sum/2</li>
<li>Define a array dp, <code>dp[j]</code> means <strong>the maximum value</strong> in <strong>j</strong> capacity.</li>
<li>If <code>dp[j]==target</code> we can fill up the <strong>j</strong> capacity with some numbers whose sum is also <strong>j</strong> ,that means we can get two sub-arrays.
<ol>
<li>For example, Input: nums = [1,5,11,5], we consider <code>dp[11]==target=11</code> as [1,5,5]=target=11 when we grap three number into package with <strong>11</strong> capacity and their sum is also <strong>11</strong>.It’s a bit of puzzying, but it’s true.</li>
</ol>
</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printDP</span><span class="params">(vector&lt;<span class="type">int</span>&gt; dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;dp.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            cout&lt;&lt;dp[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">utility</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> sum,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> target=sum/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//n equals to capacity</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(target+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=target;j&gt;=nums[i];j--)&#123;</span><br><span class="line">                <span class="comment">//The first nums[i] is the weight[i], and the latter one is value[i]</span></span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j],dp[j-nums[i]]+nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// printDP(dp);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target]==target?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">utility</span>(nums,sum,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Solution s;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    cout&lt;&lt;s.<span class="built_in">canPartition</span>(nums)&lt;&lt;endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://blog.lthero.cn">lthero</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.lthero.cn/2023/03/29/AlgorithmPractice/">https://blog.lthero.cn/2023/03/29/AlgorithmPractice/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.lthero.cn" target="_blank">lthero</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/08/UnlockNetcloudMusic/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/webPic/background/wallhaven-3z8qjd.png" onerror="onerror=null;src='https://cdn.lthero.cn/webPic/background/wallhaven-rdekew.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">网易云解锁灰色歌曲</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/12/CreateChatbotWithOpenai/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/webPic/background/wallhaven-wy2ewp.png" onerror="onerror=null;src='https://cdn.lthero.cn/webPic/background/wallhaven-rdekew.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">基于openAI创建自己的chatbot</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/webPic/logo/lthero_avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">lthero</div><div class="author-info__description">喜欢折腾|喜欢尝试各种炫酷玩意儿|      Hacking the world</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">214</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">117</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">69</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lthero-big"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/lthero-big" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:ltherowlh@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">感谢github托管|hexo--butterfly主题提供支持</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%AD%E7%94%B5oj100%E9%81%93"><span class="toc-number">1.</span> <span class="toc-text">杭电OJ100道</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2024-c%E8%AF%AD%E8%A8%80%E5%90%88%E6%B3%95%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">1.1.</span> <span class="toc-text">2024 c语言合法标识符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2026-%E5%B0%86%E6%AF%8F%E4%B8%AA%E5%8D%95%E8%AF%8D%E9%A6%96%E5%AD%97%E7%AC%A6%E5%8F%98%E6%88%90%E5%A4%A7%E5%86%99"><span class="toc-number">1.2.</span> <span class="toc-text">2026 将每个单词首字符变成大写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#converting-a-string-to-other-types-of-data"><span class="toc-number">1.2.1.</span> <span class="toc-text">Converting a string to other types of data</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#converting-other-types-of-data-to-a-string"><span class="toc-number">1.2.2.</span> <span class="toc-text">Converting other types of data to a string</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#toupper"><span class="toc-number">1.2.3.</span> <span class="toc-text">toupper</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tolower"><span class="toc-number">1.2.4.</span> <span class="toc-text">tolower</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#isupper"><span class="toc-number">1.2.5.</span> <span class="toc-text">isupper</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#isalpha"><span class="toc-number">1.2.6.</span> <span class="toc-text">isalpha</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#isdigit"><span class="toc-number">1.2.7.</span> <span class="toc-text">isdigit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#isalnum"><span class="toc-number">1.2.8.</span> <span class="toc-text">isalnum</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#isspace"><span class="toc-number">1.2.9.</span> <span class="toc-text">isspace</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2027-%E7%BB%9F%E8%AE%A1%E5%85%83%E9%9F%B3"><span class="toc-number">1.3.</span> <span class="toc-text">2027 统计元音</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2028-%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0"><span class="toc-number">1.4.</span> <span class="toc-text">2028 *最小公倍数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2029-%E5%9B%9E%E6%96%87%E4%B8%B2%E5%88%A4%E6%96%AD"><span class="toc-number">1.5.</span> <span class="toc-text">2029 回文串判断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2031-r%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.6.</span> <span class="toc-text">2031 *R进制转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2032-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92"><span class="toc-number">1.7.</span> <span class="toc-text">2032 杨辉三角</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2034-%E9%9B%86%E5%90%88%E9%97%AE%E9%A2%98a-b"><span class="toc-number">1.8.</span> <span class="toc-text">2034 集合问题A-B</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#two-pointers"><span class="toc-number">1.8.1.</span> <span class="toc-text">two pointers</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#porblema"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">PorblemA</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#merge"><span class="toc-number">1.8.2.</span> <span class="toc-text">Merge</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2035-%E9%9B%86%E5%90%88%E9%97%AE%E9%A2%98a-b"><span class="toc-number">1.9.</span> <span class="toc-text">2035 集合问题A^B</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2036-%E8%AE%A1%E7%AE%97%E5%A4%9A%E8%BE%B9%E5%BD%A2%E9%9D%A2%E7%A7%AF"><span class="toc-number">1.10.</span> <span class="toc-text">2036 计算多边形面积</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2037-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E7%8B%AC%E7%AB%8B%E5%8C%BA%E9%97%B4"><span class="toc-number">1.11.</span> <span class="toc-text">2037 *贪心算法|独立区间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2040-%E4%BA%B2%E5%92%8C%E6%95%B0"><span class="toc-number">1.12.</span> <span class="toc-text">2040 亲和数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2041-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91"><span class="toc-number">1.13.</span> <span class="toc-text">2041 *斐波那契</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2043-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E5%BC%BA%E5%AF%86%E7%A0%81"><span class="toc-number">1.14.</span> <span class="toc-text">2043 判断是否为强密码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2044-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%912"><span class="toc-number">1.15.</span> <span class="toc-text">2044 斐波那契2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2045-rpg%E9%97%AE%E9%A2%98-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%913"><span class="toc-number">1.16.</span> <span class="toc-text">2045 RPG问题|斐波那契3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2046-%E9%AA%A8%E7%89%8C%E9%93%BA%E6%96%B9%E6%A0%BC-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%914"><span class="toc-number">1.17.</span> <span class="toc-text">2046 骨牌铺方格|斐波那契4</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2047-%E5%AD%97%E7%AC%A6%E4%B8%B2eof%E7%9A%84%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%915"><span class="toc-number">1.18.</span> <span class="toc-text">2047 字符串EOF的排列组合|斐波那契5</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2048-%E9%94%99%E6%8E%92%E9%97%AE%E9%A2%981"><span class="toc-number">1.19.</span> <span class="toc-text">2048 *错排问题1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2049-%E9%94%99%E6%8E%92%E9%97%AE%E9%A2%982"><span class="toc-number">1.20.</span> <span class="toc-text">2049 错排问题2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2050-%E6%8B%86%E7%BA%BF%E5%88%86%E5%89%B2%E5%B9%B3%E9%9D%A2"><span class="toc-number">1.21.</span> <span class="toc-text">2050 拆线分割平面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2053-%E5%BC%80%E5%85%B3%E7%81%AF"><span class="toc-number">1.22.</span> <span class="toc-text">2053 开关灯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2054-a-b-plus"><span class="toc-number">1.23.</span> <span class="toc-text">2054 A&#x3D;B_Plus</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#string-find"><span class="toc-number">1.23.1.</span> <span class="toc-text">string.find()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2055-aeasyproblem"><span class="toc-number">1.24.</span> <span class="toc-text">2055 AEasyProblem</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2056-%E8%AE%A1%E7%AE%97%E9%87%8D%E5%90%88%E9%83%A8%E5%88%86%E7%9A%84%E7%9F%A9%E9%98%B5%E9%9D%A2%E7%A7%AF"><span class="toc-number">1.25.</span> <span class="toc-text">2056 计算重合部分的矩阵面积</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2058-%E6%89%BE%E5%88%B0%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%AE%B5%E5%92%8C%E4%B8%BAm"><span class="toc-number">1.26.</span> <span class="toc-text">2058 *找到连续子段和为M</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2059-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922"><span class="toc-number">1.27.</span> <span class="toc-text">2059 *动态规划2</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leecode"><span class="toc-number">2.</span> <span class="toc-text">LEECODE</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">2.1.</span> <span class="toc-text">二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">2.1.1.</span> <span class="toc-text">704. 二分查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE"><span class="toc-number">2.1.2.</span> <span class="toc-text">35. 搜索插入位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#278-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC"><span class="toc-number">2.1.3.</span> <span class="toc-text">278. 第一个错误的版本</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">2.2.</span> <span class="toc-text">双指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9"><span class="toc-number">2.2.1.</span> <span class="toc-text">977. 有序数组的平方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#189-%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="toc-number">2.2.2.</span> <span class="toc-text">189.轮转数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#283-%E7%A7%BB%E5%8A%A8%E9%9B%B6"><span class="toc-number">2.2.3.</span> <span class="toc-text">283. 移动零</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-ii-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-number">2.2.4.</span> <span class="toc-text">167. 两数之和 II - 输入有序数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.2.5.</span> <span class="toc-text">344. 反转字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#557-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D-iii"><span class="toc-number">2.2.6.</span> <span class="toc-text">557. 反转字符串中的单词 III</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#876-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9"><span class="toc-number">2.2.7.</span> <span class="toc-text">876. 链表的中间结点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-n-%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="toc-number">2.2.8.</span> <span class="toc-text">19. 删除链表的倒数第 N 个结点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="toc-number">2.2.9.</span> <span class="toc-text">3. 无重复字符的最长子串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#solution"><span class="toc-number">2.2.9.1.</span> <span class="toc-text">Solution</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#567-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97"><span class="toc-number">2.2.10.</span> <span class="toc-text">567. 字符串的排列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6-%E5%B9%BF%E5%BA%A6%E9%81%8D%E5%8E%86"><span class="toc-number">2.3.</span> <span class="toc-text">深度&#x2F;广度遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#733-%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93"><span class="toc-number">2.3.1.</span> <span class="toc-text">733. 图像渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#board"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">Board</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deep"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">Deep</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#695-%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF"><span class="toc-number">2.3.2.</span> <span class="toc-text">695. 岛屿的最大面积</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.3.3.</span> <span class="toc-text">617. 合并二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#bfs"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">BFS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dfs"><span class="toc-number">2.3.3.2.</span> <span class="toc-text">DFS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dfs"><span class="toc-number">2.3.3.3.</span> <span class="toc-text">DFS</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#542-01-%E7%9F%A9%E9%98%B5"><span class="toc-number">2.3.4.</span> <span class="toc-text">542. 01 矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#994-%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90"><span class="toc-number">2.3.5.</span> <span class="toc-text">994. 腐烂的橘子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92-%E5%9B%9E%E6%BA%AF"><span class="toc-number">2.4.</span> <span class="toc-text">递归&#x2F;回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">2.4.1.</span> <span class="toc-text">21. 合并两个有序链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#iteration"><span class="toc-number">2.4.1.1.</span> <span class="toc-text">Iteration</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#recursion"><span class="toc-number">2.4.1.2.</span> <span class="toc-text">Recursion</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">2.4.2.</span> <span class="toc-text">206.反转链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#iteration"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">Iteration</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#77-%E7%BB%84%E5%90%88"><span class="toc-number">2.4.3.</span> <span class="toc-text">77.组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-iii"><span class="toc-number">2.4.4.</span> <span class="toc-text">216. 组合总和 III</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">2.5.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#70-%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-number">2.5.1.</span> <span class="toc-text">70. 爬楼梯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-number">2.5.2.</span> <span class="toc-text">746. 使用最小花费爬楼梯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="toc-number">2.5.3.</span> <span class="toc-text">62. 不同路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-ii"><span class="toc-number">2.5.4.</span> <span class="toc-text">63. 不同路径 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-1%E8%83%8C%E5%8C%85"><span class="toc-number">2.5.5.</span> <span class="toc-text">0-1背包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="toc-number">2.5.6.</span> <span class="toc-text">416. 分割等和子集</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/07/13/LeetCodeCampsDay18/" title="LeetCodeCampsDay18"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/webPic/background/wallhaven-l3z192.jpg" onerror="this.onerror=null;this.src='https://cdn.lthero.cn/webPic/background/wallhaven-rdekew.jpg'" alt="LeetCodeCampsDay18"/></a><div class="content"><a class="title" href="/2025/07/13/LeetCodeCampsDay18/" title="LeetCodeCampsDay18">LeetCodeCampsDay18</a><time datetime="2025-07-13T02:51:24.000Z" title="发表于 2025-07-13 10:51:24">2025-07-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/11/LeetCodeCampsDay17/" title="LeetCodeCampsDay17二叉树part05"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/webPic/background/3_Jewel_4k.jpg" onerror="this.onerror=null;this.src='https://cdn.lthero.cn/webPic/background/wallhaven-rdekew.jpg'" alt="LeetCodeCampsDay17二叉树part05"/></a><div class="content"><a class="title" href="/2025/07/11/LeetCodeCampsDay17/" title="LeetCodeCampsDay17二叉树part05">LeetCodeCampsDay17二叉树part05</a><time datetime="2025-07-11T10:57:14.000Z" title="发表于 2025-07-11 18:57:14">2025-07-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/10/AutoRegressionToDiffusion/" title="从AutoRegression到Diffusion"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/webPic/background/RD2.jpg" onerror="this.onerror=null;this.src='https://cdn.lthero.cn/webPic/background/wallhaven-rdekew.jpg'" alt="从AutoRegression到Diffusion"/></a><div class="content"><a class="title" href="/2025/07/10/AutoRegressionToDiffusion/" title="从AutoRegression到Diffusion">从AutoRegression到Diffusion</a><time datetime="2025-07-10T15:44:54.000Z" title="发表于 2025-07-10 23:44:54">2025-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/10/Transformer-03-LayerNorm/" title="Transformer-03-LayerNorm"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/webPic/background/wallhaven-73y539.png" onerror="this.onerror=null;this.src='https://cdn.lthero.cn/webPic/background/wallhaven-rdekew.jpg'" alt="Transformer-03-LayerNorm"/></a><div class="content"><a class="title" href="/2025/07/10/Transformer-03-LayerNorm/" title="Transformer-03-LayerNorm">Transformer-03-LayerNorm</a><time datetime="2025-07-10T15:15:21.000Z" title="发表于 2025-07-10 23:15:21">2025-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/10/LeetCodeCampsDay16/" title="LeetCodeCampsDay16"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.lthero.cn/webPic/background/wallhaven-6oe337.png" onerror="this.onerror=null;this.src='https://cdn.lthero.cn/webPic/background/wallhaven-rdekew.jpg'" alt="LeetCodeCampsDay16"/></a><div class="content"><a class="title" href="/2025/07/10/LeetCodeCampsDay16/" title="LeetCodeCampsDay16">LeetCodeCampsDay16</a><time datetime="2025-07-10T11:13:28.000Z" title="发表于 2025-07-10 19:13:28">2025-07-10</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By lthero</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="framework-info"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">浙ICP备2021022809号-1</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadWaline () {
  function insertCSS () {
    const link = document.createElement("link")
    link.rel = "stylesheet"
    link.href = "https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.css"
    document.head.appendChild(link)
  }

  function initWaline () {
    const waline = Waline.init(Object.assign({
      el: '#waline-wrap',
      serverURL: 'ltheroblogwaline-comments-ltherobigs-projects.vercel.app',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: false,
    }, null))
  }

  if (typeof Waline === 'function') initWaline()
  else {
    insertCSS()
    getScript('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.js').then(initWaline)
  }
}

if ('Waline' === 'Waline' || !true) {
  if (true) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script src="/assets/mmedia/mmedia-loader.js"></script><!-- hexo injector body_end end --></body></html>